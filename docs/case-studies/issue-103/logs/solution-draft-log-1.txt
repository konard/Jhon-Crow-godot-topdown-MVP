Solution draft log for https://github.com/Jhon-Crow/godot-topdown-MVP/pull/104

# Solve.mjs Log - 2026-01-18T02:48:11.432Z

[2026-01-18T02:48:11.432Z] [INFO] üìÅ Log file: /home/hive/solve-2026-01-18T02-48-11-431Z.log
[2026-01-18T02:48:11.434Z] [INFO]    (All output will be logged here)
[2026-01-18T02:48:12.060Z] [INFO] 
[2026-01-18T02:48:12.061Z] [INFO] üöÄ solve v1.4.0
[2026-01-18T02:48:12.061Z] [INFO] üîß Raw command executed:
[2026-01-18T02:48:12.062Z] [INFO]    /home/hive/.nvm/versions/node/v20.19.6/bin/node /home/hive/.bun/bin/solve https://github.com/Jhon-Crow/godot-topdown-MVP/issues/103 --model opus --attach-logs --verbose --no-tool-check --auto-resume-on-limit-reset --tokens-budget-stats
[2026-01-18T02:48:12.062Z] [INFO] 
[2026-01-18T02:48:12.076Z] [INFO] 
[2026-01-18T02:48:12.077Z] [WARNING] ‚ö†Ô∏è  SECURITY WARNING: --attach-logs is ENABLED
[2026-01-18T02:48:12.077Z] [INFO] 
[2026-01-18T02:48:12.078Z] [INFO]    This option will upload the complete solution draft log file to the Pull Request.
[2026-01-18T02:48:12.078Z] [INFO]    The log may contain sensitive information such as:
[2026-01-18T02:48:12.078Z] [INFO]    ‚Ä¢ API keys, tokens, or secrets
[2026-01-18T02:48:12.078Z] [INFO]    ‚Ä¢ File paths and directory structures
[2026-01-18T02:48:12.079Z] [INFO]    ‚Ä¢ Command outputs and error messages
[2026-01-18T02:48:12.079Z] [INFO]    ‚Ä¢ Internal system information
[2026-01-18T02:48:12.079Z] [INFO] 
[2026-01-18T02:48:12.079Z] [INFO]    ‚ö†Ô∏è  DO NOT use this option with public repositories or if the log
[2026-01-18T02:48:12.079Z] [INFO]        might contain sensitive data that should not be shared publicly.
[2026-01-18T02:48:12.079Z] [INFO] 
[2026-01-18T02:48:12.079Z] [INFO]    Continuing in 5 seconds... (Press Ctrl+C to abort)
[2026-01-18T02:48:12.080Z] [INFO] 
[2026-01-18T02:48:17.086Z] [INFO] 
[2026-01-18T02:48:17.110Z] [INFO] üíæ Disk space check: 54621MB available (2048MB required) ‚úÖ
[2026-01-18T02:48:17.112Z] [INFO] üß† Memory check: 11013MB available, swap: 4095MB (0MB used), total: 15108MB (256MB required) ‚úÖ
[2026-01-18T02:48:17.129Z] [INFO] ‚è© Skipping tool connection validation (dry-run mode or skip-tool-connection-check enabled)
[2026-01-18T02:48:17.129Z] [INFO] ‚è© Skipping GitHub authentication check (dry-run mode or skip-tool-connection-check enabled)
[2026-01-18T02:48:17.130Z] [INFO] üìã URL validation:
[2026-01-18T02:48:17.130Z] [INFO]    Input URL: https://github.com/Jhon-Crow/godot-topdown-MVP/issues/103
[2026-01-18T02:48:17.130Z] [INFO]    Is Issue URL: true
[2026-01-18T02:48:17.130Z] [INFO]    Is PR URL: false
[2026-01-18T02:48:17.130Z] [INFO] üîç Checking repository access for auto-fork...
[2026-01-18T02:48:17.747Z] [INFO]    Repository visibility: public
[2026-01-18T02:48:17.747Z] [INFO] ‚úÖ Auto-fork: No write access detected, enabling fork mode
[2026-01-18T02:48:17.748Z] [INFO] ‚úÖ Repository access check: Skipped (fork mode enabled)
[2026-01-18T02:48:18.087Z] [INFO]    Repository visibility: public
[2026-01-18T02:48:18.087Z] [INFO]    Auto-cleanup default: false (repository is public)
[2026-01-18T02:48:18.088Z] [INFO] üîç Auto-continue enabled: Checking for existing PRs for issue #103...
[2026-01-18T02:48:18.719Z] [INFO] üîç Fork mode: Checking for existing branches in konard/Jhon-Crow-godot-topdown-MVP...
[2026-01-18T02:48:19.559Z] [INFO] üìã Found 2 existing PR(s) linked to issue #103
[2026-01-18T02:48:19.559Z] [INFO]   PR #68: created 127h ago (OPEN, ready)
[2026-01-18T02:48:19.560Z] [INFO]   PR #68: Branch 'issue-59-ec67c5cf9228' doesn't match expected pattern 'issue-103-*' - skipping
[2026-01-18T02:48:19.560Z] [INFO]   PR #65: created 128h ago (OPEN, draft)
[2026-01-18T02:48:19.560Z] [INFO]   PR #65: Branch 'issue-64-6db5a4a1532f' doesn't match expected pattern 'issue-103-*' - skipping
[2026-01-18T02:48:19.560Z] [INFO] ‚è≠Ô∏è  No suitable PRs found (missing CLAUDE.md/.gitkeep or older than 24h) - creating new PR as usual
[2026-01-18T02:48:19.561Z] [INFO] üìù Issue mode: Working with issue #103
[2026-01-18T02:48:19.561Z] [INFO] 
Creating temporary directory: /tmp/gh-issue-solver-1768704499561
[2026-01-18T02:48:19.563Z] [INFO] 
üç¥ Fork mode:                ENABLED
[2026-01-18T02:48:19.564Z] [INFO]  Checking fork status...   

[2026-01-18T02:48:19.830Z] [INFO] üîç Detecting fork conflicts... 
[2026-01-18T02:48:20.946Z] [INFO] ‚úÖ No fork conflict:         Safe to proceed
[2026-01-18T02:48:21.522Z] [INFO] ‚úÖ Fork exists:              konard/Jhon-Crow-godot-topdown-MVP
[2026-01-18T02:48:21.523Z] [INFO] üîç Validating fork parent... 
[2026-01-18T02:48:21.884Z] [INFO] ‚úÖ Fork parent validated:    Jhon-Crow/godot-topdown-MVP
[2026-01-18T02:48:21.887Z] [INFO] 
üì• Cloning repository:       konard/Jhon-Crow-godot-topdown-MVP
[2026-01-18T02:48:23.331Z] [INFO] ‚úÖ Cloned to:                /tmp/gh-issue-solver-1768704499561
[2026-01-18T02:48:23.367Z] [INFO] üîó Setting upstream:         Jhon-Crow/godot-topdown-MVP
[2026-01-18T02:48:23.404Z] [INFO] ‚ÑπÔ∏è Upstream exists:          Using existing upstream remote
[2026-01-18T02:48:23.404Z] [INFO] üîÑ Fetching upstream...      
[2026-01-18T02:48:23.703Z] [INFO] ‚úÖ Upstream fetched:         Successfully
[2026-01-18T02:48:23.704Z] [INFO] üîÑ Syncing default branch... 
[2026-01-18T02:48:24.055Z] [INFO] ‚ÑπÔ∏è Default branch:           main
[2026-01-18T02:48:24.169Z] [INFO] ‚úÖ Default branch synced:    with upstream/main
[2026-01-18T02:48:24.169Z] [INFO] üîÑ Pushing to fork:          main branch
[2026-01-18T02:48:24.941Z] [INFO] ‚úÖ Fork updated:             Default branch pushed to fork
[2026-01-18T02:48:25.073Z] [INFO] 
üìå Default branch:           main
[2026-01-18T02:48:25.154Z] [INFO] 
üåø Creating branch:          issue-103-a8cadd220202 from main (default)
[2026-01-18T02:48:25.193Z] [INFO] üîç Verifying:                Branch creation...
[2026-01-18T02:48:25.229Z] [INFO] ‚úÖ Branch created:           issue-103-a8cadd220202
[2026-01-18T02:48:25.230Z] [INFO] ‚úÖ Current branch:           issue-103-a8cadd220202
[2026-01-18T02:48:25.230Z] [INFO]    Branch operation: Create new branch
[2026-01-18T02:48:25.230Z] [INFO]    Branch verification: Matches expected
[2026-01-18T02:48:25.233Z] [INFO] 
üöÄ Auto PR creation:         ENABLED
[2026-01-18T02:48:25.234Z] [INFO]      Creating:               Initial commit and draft PR...
[2026-01-18T02:48:25.234Z] [INFO] 
[2026-01-18T02:48:25.273Z] [INFO]    Using CLAUDE.md mode (--claude-file=true, --gitkeep-file=false, --auto-gitkeep-file=true)
[2026-01-18T02:48:25.274Z] [INFO] üìù Creating:                 CLAUDE.md with task details
[2026-01-18T02:48:25.275Z] [INFO]    Issue URL from argv['issue-url']: https://github.com/Jhon-Crow/godot-topdown-MVP/issues/103
[2026-01-18T02:48:25.275Z] [INFO]    Issue URL from argv._[0]: undefined
[2026-01-18T02:48:25.275Z] [INFO]    Final issue URL: https://github.com/Jhon-Crow/godot-topdown-MVP/issues/103
[2026-01-18T02:48:25.276Z] [INFO] ‚úÖ File created:             CLAUDE.md
[2026-01-18T02:48:25.276Z] [INFO] üì¶ Adding file:              To git staging
[2026-01-18T02:48:25.351Z] [INFO]    Git status after add: A  CLAUDE.md
[2026-01-18T02:48:25.351Z] [INFO] üìù Creating commit:          With CLAUDE.md file
[2026-01-18T02:48:25.397Z] [INFO] ‚úÖ Commit created:           Successfully with CLAUDE.md
[2026-01-18T02:48:25.398Z] [INFO]    Commit output: [issue-103-a8cadd220202 5904996] Initial commit with task details
 1 file changed, 7 insertions(+)
 create mode 100644 CLAUDE.md
[2026-01-18T02:48:25.430Z] [INFO]    Commit hash: 5904996...
[2026-01-18T02:48:25.472Z] [INFO]    Latest commit: 5904996 Initial commit with task details
[2026-01-18T02:48:25.511Z] [INFO]    Git status: clean
[2026-01-18T02:48:25.544Z] [INFO]    Remotes: origin	https://github.com/konard/Jhon-Crow-godot-topdown-MVP.git (fetch)
[2026-01-18T02:48:25.577Z] [INFO]    Branch info: * issue-103-a8cadd220202 5904996 [origin/main: ahead 1] Initial commit with task details
  main                   9e7af85 [origin/main] Merge pull request #102 from konard/issue-100-12a42823264e
[2026-01-18T02:48:25.577Z] [INFO] üì§ Pushing branch:           To remote repository...
[2026-01-18T02:48:25.578Z] [INFO]    Push command: git push -u origin issue-103-a8cadd220202
[2026-01-18T02:48:26.363Z] [INFO]    Push exit code: 0
[2026-01-18T02:48:26.364Z] [INFO]    Push output: remote: 
remote: Create a pull request for 'issue-103-a8cadd220202' on GitHub by visiting:        
remote:      https://github.com/konard/Jhon-Crow-godot-topdown-MVP/pull/new/issue-103-a8cadd220202        
remote: 
To https://github.com/konard/Jhon-Crow-godot-topdown-MVP.git
 * [new branch]      issue-103-a8cadd220202 -> issue-103-a8cadd220202
branch 'issue-103-a8cadd220202' set up to track 'origin/issue-103-a8cadd220202'.
[2026-01-18T02:48:26.365Z] [INFO] ‚úÖ Branch pushed:            Successfully to remote
[2026-01-18T02:48:26.366Z] [INFO]    Push output: remote: 
remote: Create a pull request for 'issue-103-a8cadd220202' on GitHub by visiting:        
remote:      https://github.com/konard/Jhon-Crow-godot-topdown-MVP/pull/new/issue-103-a8cadd220202        
remote: 
To https://github.com/konard/Jhon-Crow-godot-topdown-MVP.git
 * [new branch]      issue-103-a8cadd220202 -> issue-103-a8cadd220202
branch 'issue-103-a8cadd220202' set up to track 'origin/issue-103-a8cadd220202'.
[2026-01-18T02:48:26.366Z] [INFO]    Waiting for GitHub to sync...
[2026-01-18T02:48:28.850Z] [INFO]    Compare API check: 1 commit(s) ahead of main
[2026-01-18T02:48:28.851Z] [INFO]    GitHub compare API ready: 1 commit(s) found
[2026-01-18T02:48:29.250Z] [INFO]    Branch verified on GitHub: issue-103-a8cadd220202
[2026-01-18T02:48:29.739Z] [INFO]    Remote commit SHA: 5904996...
[2026-01-18T02:48:29.739Z] [INFO] üìã Getting issue:            Title from GitHub...
[2026-01-18T02:48:30.088Z] [INFO]    Issue title: "—É–ª—É—á—à–∏—Ç—å —Å–∏—Å—Ç–µ–º—É –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è"
[2026-01-18T02:48:30.089Z] [INFO] üë§ Getting user:             Current GitHub account...
[2026-01-18T02:48:30.415Z] [INFO]    Current user: konard
[2026-01-18T02:48:30.832Z] [INFO]    User is not a collaborator (will skip assignment)
[2026-01-18T02:48:30.833Z] [INFO]    User is not a collaborator (will skip assignment)
[2026-01-18T02:48:30.834Z] [INFO] üîÑ Fetching:                 Latest main branch...
[2026-01-18T02:48:31.165Z] [INFO] ‚úÖ Base updated:             Fetched latest main
[2026-01-18T02:48:31.166Z] [INFO] üîç Checking:                 Commits between branches...
[2026-01-18T02:48:31.202Z] [INFO]    Commits ahead of origin/main: 1
[2026-01-18T02:48:31.203Z] [INFO] ‚úÖ Commits found:            1 commit(s) ahead
[2026-01-18T02:48:31.203Z] [INFO] üîÄ Creating PR:              Draft pull request...
[2026-01-18T02:48:31.203Z] [INFO] üéØ Target branch:            main (default)
[2026-01-18T02:48:31.203Z] [INFO]    PR Title: [WIP] —É–ª—É—á—à–∏—Ç—å —Å–∏—Å—Ç–µ–º—É –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è
[2026-01-18T02:48:31.204Z] [INFO]    Base branch: main
[2026-01-18T02:48:31.204Z] [INFO]    Head branch: issue-103-a8cadd220202
[2026-01-18T02:48:31.204Z] [INFO]    Assignee: konard
[2026-01-18T02:48:31.204Z] [INFO]    PR Body:
## ü§ñ AI-Powered Solution Draft

This pull request is being automatically generated to solve issue Jhon-Crow/godot-topdown-MVP#103.

### üìã Issue Reference
Fixes Jhon-Crow/godot-topdown-MVP#103

### üöß Status
**Work in Progress** - The AI assistant is currently analyzing and implementing the solution draft.

### üìù Implementation Details
_Details will be added as the solution draft is developed..._

---
*This PR was created automatically by the AI issue solver*
[2026-01-18T02:48:31.206Z] [INFO]    Command: cd "/tmp/gh-issue-solver-1768704499561" && gh pr create --draft --title "$(cat '/tmp/pr-title-1768704511205.txt')" --body-file "/tmp/pr-body-1768704511205.md" --base main --head konard:issue-103-a8cadd220202 --repo Jhon-Crow/godot-topdown-MVP
[2026-01-18T02:48:32.541Z] [INFO] üîç Verifying:                PR creation...
[2026-01-18T02:48:32.863Z] [INFO] ‚úÖ Verification:             PR exists on GitHub
[2026-01-18T02:48:32.863Z] [INFO] ‚úÖ PR created:               #104
[2026-01-18T02:48:32.864Z] [INFO] üìç PR URL:                   https://github.com/Jhon-Crow/godot-topdown-MVP/pull/104
[2026-01-18T02:48:32.864Z] [INFO] ‚ÑπÔ∏è Note:                     Could not assign (no permission)
[2026-01-18T02:48:32.864Z] [INFO] üîó Linking:                  Issue #103 to PR #104...
[2026-01-18T02:48:33.218Z] [INFO]    Issue node ID: I_kwDOQ35BQ87kD7EJ
[2026-01-18T02:48:33.585Z] [INFO]    PR node ID: PR_kwDOQ35BQ8691cDp
[2026-01-18T02:48:33.946Z] [INFO] 
[2026-01-18T02:48:33.947Z] [WARNING] ‚ö†Ô∏è ISSUE LINK MISSING:       PR not linked to issue
[2026-01-18T02:48:33.948Z] [INFO] 
[2026-01-18T02:48:33.948Z] [WARNING]    The PR was created from a fork but wasn't linked to the issue.
[2026-01-18T02:48:33.948Z] [WARNING]    Expected: "Fixes Jhon-Crow/godot-topdown-MVP#103" in PR body
[2026-01-18T02:48:33.948Z] [INFO] 
[2026-01-18T02:48:33.948Z] [WARNING]    To fix manually:
[2026-01-18T02:48:33.949Z] [WARNING]    1. Edit the PR description at: https://github.com/Jhon-Crow/godot-topdown-MVP/pull/104
[2026-01-18T02:48:33.949Z] [WARNING]    2. Add this line: Fixes Jhon-Crow/godot-topdown-MVP#103
[2026-01-18T02:48:33.949Z] [INFO] 
[2026-01-18T02:48:34.219Z] [INFO]   üë§ Current user:           konard
[2026-01-18T02:48:34.220Z] [INFO] 
üìä Comment counting conditions:
[2026-01-18T02:48:34.220Z] [INFO]    prNumber: 104
[2026-01-18T02:48:34.220Z] [INFO]    branchName: issue-103-a8cadd220202
[2026-01-18T02:48:34.220Z] [INFO]    isContinueMode: false
[2026-01-18T02:48:34.220Z] [INFO]    Will count comments: true
[2026-01-18T02:48:34.221Z] [INFO] üí¨ Counting comments:        Checking for new comments since last commit...
[2026-01-18T02:48:34.221Z] [INFO]    PR #104 on branch: issue-103-a8cadd220202
[2026-01-18T02:48:34.221Z] [INFO]    Owner/Repo: Jhon-Crow/godot-topdown-MVP
[2026-01-18T02:48:34.626Z] [INFO]   üìÖ Last commit time (from API): 2026-01-18T02:48:25.000Z
[2026-01-18T02:48:35.545Z] [INFO]   üí¨ New PR comments:        0
[2026-01-18T02:48:35.545Z] [INFO]   üí¨ New PR review comments: 0
[2026-01-18T02:48:35.546Z] [INFO]   üí¨ New issue comments:     0
[2026-01-18T02:48:35.546Z] [INFO]    Total new comments: 0
[2026-01-18T02:48:35.546Z] [INFO]    Comment lines to add: No (saving tokens)
[2026-01-18T02:48:35.547Z] [INFO]    PR review comments fetched: 0
[2026-01-18T02:48:35.547Z] [INFO]    PR conversation comments fetched: 0
[2026-01-18T02:48:35.547Z] [INFO]    Total PR comments checked: 0
[2026-01-18T02:48:38.057Z] [INFO]    Feedback info will be added to prompt:
[2026-01-18T02:48:38.057Z] [INFO]      - Pull request description was edited after last commit
[2026-01-18T02:48:38.058Z] [INFO] üìÖ Getting timestamps:       From GitHub servers...
[2026-01-18T02:48:38.454Z] [INFO]   üìù Issue updated:          2026-01-18T02:44:40.000Z
[2026-01-18T02:48:38.922Z] [INFO]   üí¨ Comments:               None found
[2026-01-18T02:48:39.591Z] [INFO]   üîÄ Recent PR:              2026-01-18T02:48:32.000Z
[2026-01-18T02:48:39.591Z] [INFO] 
‚úÖ Reference time:           2026-01-18T02:48:32.000Z
[2026-01-18T02:48:39.592Z] [INFO] 
üîç Checking for uncommitted changes to include as feedback...
[2026-01-18T02:48:39.630Z] [INFO] ‚úÖ No uncommitted changes found
[2026-01-18T02:48:39.977Z] [INFO] üì¶ Fork workflows detected:  https://github.com/konard/Jhon-Crow-godot-topdown-MVP/actions?query=branch%3Aissue-103-a8cadd220202
[2026-01-18T02:48:41.969Z] [INFO] üé≠ Playwright MCP detected - enabling browser automation hints
[2026-01-18T02:48:41.974Z] [INFO] 
üìù Final prompt structure:
[2026-01-18T02:48:41.975Z] [INFO]    Characters: 529
[2026-01-18T02:48:41.975Z] [INFO]    System prompt characters: 11916
[2026-01-18T02:48:41.976Z] [INFO]    Feedback info: Included
[2026-01-18T02:48:41.977Z] [INFO] 
ü§ñ Executing Claude:         OPUS
[2026-01-18T02:48:41.978Z] [INFO]    Model: opus
[2026-01-18T02:48:41.978Z] [INFO]    Working directory: /tmp/gh-issue-solver-1768704499561
[2026-01-18T02:48:41.978Z] [INFO]    Branch: issue-103-a8cadd220202
[2026-01-18T02:48:41.978Z] [INFO]    Prompt length: 529 chars
[2026-01-18T02:48:41.979Z] [INFO]    System prompt length: 11916 chars
[2026-01-18T02:48:41.979Z] [INFO]    Feedback info included: Yes (1 lines)
[2026-01-18T02:48:42.020Z] [INFO] üìà System resources before execution:
[2026-01-18T02:48:42.020Z] [INFO]    Memory: MemFree:        10447896 kB
[2026-01-18T02:48:42.020Z] [INFO]    Load: 0.37 0.10 0.10 1/275 142353
[2026-01-18T02:48:42.021Z] [INFO] 
üìù Raw command:              
[2026-01-18T02:48:42.021Z] [INFO] (cd "/tmp/gh-issue-solver-1768704499561" && claude --output-format stream-json --verbose --dangerously-skip-permissions --model claude-opus-4-5-20251101 -p "Issue to solve: https://github.com/Jhon-Crow/godot-topdown-MVP/issues/103
Your prepared branch: issue-103-a8cadd220202
Your prepared working directory: /tmp/gh-issue-solver-1768704499561
Your prepared Pull Request: https://github.com/Jhon-Crow/godot-topdown-MVP/pull/104
Your forked repository: konard/Jhon-Crow-godot-topdown-MVP
Original repository (upstream): Jhon-Crow/godot-topdown-MVP
GitHub Actions on your fork: https://github.com/konard/Jhon-Crow-godot-topdown-MVP/actions?query=branch%3Aissue-103-a8cadd220202

Proceed.
" --append-system-prompt "You are an AI issue solver. You prefer to find the root cause of each and every issue. When you talk, you prefer to speak with facts which you have double-checked yourself or cite sources that provide evidence, like quote actual code or give references to documents or pages found on the internet. You are polite and patient, and prefer to assume good intent, trying your best to be helpful. If you are unsure or have assumptions, you prefer to test them yourself or ask questions to clarify requirements.
General guidelines.
   - When you execute commands, always save their logs to files for easier reading if the output becomes large.
   - When running commands, do not set a timeout yourself ‚Äî let them run as long as needed (default timeout - 2 minutes is more than enough), and once they finish, review the logs in the file.
   - When running sudo commands (especially package installations like apt-get, yum, npm install, etc.), always run them in the background to avoid timeout issues and permission errors when the process needs to be killed. Use the run_in_background parameter or append & to the command.
   - When CI is failing or user reports failures, consider adding a detailed investigation protocol to your todo list with these steps:
      Step 1: List recent runs with timestamps using: gh run list --repo Jhon-Crow/godot-topdown-MVP --branch issue-103-a8cadd220202 --limit 5 --json databaseId,conclusion,createdAt,headSha
      Step 2: Verify runs are after the latest commit by checking timestamps and SHA
      Step 3: For each non-passing run, download logs to preserve them: gh run view {run-id} --repo Jhon-Crow/godot-topdown-MVP --log > ci-logs/{workflow}-{run-id}.log
      Step 4: Read each downloaded log file using Read tool to understand the actual failures
      Step 5: Report findings with specific errors and line numbers from logs
      This detailed investigation is especially helpful when user mentions CI failures, asks to investigate logs, you see non-passing status, or when finalizing a PR.
      Note: If user says \"failing\" but tools show \"passing\", this might indicate stale data - consider downloading fresh logs and checking timestamps to resolve the discrepancy.
   - When a code or log file has more than 1500 lines, read it in chunks of 1500 lines.
   - When facing a complex problem, do as much tracing as possible and turn on all verbose modes.
   - When you create debug, test, or example/experiment scripts for fixing, always keep them in an examples and/or experiments folders so you can reuse them later.
   - When testing your assumptions, use the experiment scripts, and add it to experiments folder.
   - When your experiments can show real world use case of the software, add it to examples folder.
   - When you face something extremely hard, use divide and conquer ‚Äî it always helps.

Initial research.
   - When you start, make sure you create detailed plan for yourself and follow your todo list step by step, make sure that as many points from these guidelines are added to your todo list to keep track of everything that can help you solve the issue with highest possible quality.
   - When user mentions CI failures or asks to investigate logs, consider adding these todos to track the investigation: (1) List recent CI runs with timestamps, (2) Download logs from failed runs to ci-logs/ directory, (3) Analyze error messages and identify root cause, (4) Implement fix, (5) Verify fix resolves the specific errors found in logs.
   - When you read issue, read all details and comments thoroughly.
   - When you see screenshots or images in issue descriptions, pull request descriptions, comments, or discussions, use WebFetch tool (or fetch tool) to download the image first, then use Read tool to view and analyze it. IMPORTANT: Before reading downloaded images with the Read tool, verify the file is a valid image (not HTML). Use a CLI tool like 'file' command to check the actual file format. Reading corrupted or non-image files (like GitHub's HTML 404 pages saved as .png) can cause \"Could not process image\" errors and may crash the AI solver process. If the file command shows \"HTML\" or \"text\", the download failed and you should retry or skip the image.
   - When you need issue details, use gh issue view https://github.com/Jhon-Crow/godot-topdown-MVP/issues/103.
   - When you need related code, use gh search code --owner Jhon-Crow [keywords].
   - When you need repo context, read files in your working directory.
   - When you study related work, study the most recent related pull requests.
   - When issue is not defined enough, write a comment to ask clarifying questions.
   - When accessing GitHub Gists (especially private ones), use gh gist view command instead of direct URL fetching to ensure proper authentication.
   - When you are fixing a bug, please make sure you first find the actual root cause, do as many experiments as needed.
   - When you are fixing a bug and code does not have enough tracing/logs, add them and make sure they stay in the code, but are switched off by default.
   - When you need comments on a pull request, note that GitHub has THREE different comment types with different API endpoints:
      1. PR review comments (inline code comments): gh api repos/Jhon-Crow/godot-topdown-MVP/pulls/104/comments --paginate
      2. PR conversation comments (general discussion): gh api repos/Jhon-Crow/godot-topdown-MVP/issues/104/comments --paginate
      3. PR reviews (approve/request changes): gh api repos/Jhon-Crow/godot-topdown-MVP/pulls/104/reviews --paginate
      IMPORTANT: The command \"gh pr view --json comments\" ONLY returns conversation comments and misses review comments!
   - When you need latest comments on issue, use gh api repos/Jhon-Crow/godot-topdown-MVP/issues/103/comments --paginate.

Solution development and testing.
   - When issue is solvable, implement code with tests.
   - When implementing features, search for similar existing implementations in the codebase and use them as examples instead of implementing everything from scratch.
   - When coding, each atomic step that can be useful by itself should be commited to the pull request's branch, meaning if work will be interrupted by any reason parts of solution will still be kept intact and safe in pull request.
   - When you test:
      start from testing of small functions using separate scripts;
      write unit tests with mocks for easy and quick start.
   - When you test integrations, use existing framework.
   - When you test solution draft, include automated checks in pr.
   - When issue is unclear, write comment on issue asking questions.
   - When you encounter any problems that you unable to solve yourself (any human feedback or help), write a comment to the pull request asking for help.
   - When you need human help, use gh pr comment 104 --body \"your message\" to comment on existing PR.

Preparing pull request.
   - When you code, follow contributing guidelines.
   - When you commit, write clear message.
   - When you need examples of style, use gh pr list --repo Jhon-Crow/godot-topdown-MVP --state merged --search [keywords].
   - When you open pr, describe solution draft and include tests.
   - When there is a package with version and GitHub Actions workflows for automatic release, update the version (or other necessary release trigger) in your pull request to prepare for next release.
   - When you update existing pr 104, use gh pr edit to modify title and description.
   - When you are about to commit or push code, ALWAYS run local CI checks first if they are available in contributing guidelines (like ruff check, mypy, eslint, etc.) to catch errors before pushing.
   - When you finalize the pull request:
      follow style from merged prs for code, title, and description,
      make sure no uncommitted changes corresponding to the original requirements are left behind,
      make sure the default branch is merged to the pull request's branch,
      make sure all CI checks passing if they exist before you finish,
      check for latest comments on the issue and pull request to ensure no recent feedback was missed,
      double-check that all changes in the pull request answer to original requirements of the issue,
      make sure no new new bugs are introduced in pull request by carefully reading gh pr diff,
      make sure no previously existing features were removed without an explicit request from users via the issue description, issue comments, and/or pull request comments.
   - When you finish implementation, use gh pr ready 104.

Workflow and collaboration.
   - When you check branch, verify with git branch --show-current.
   - When you push, push only to branch issue-103-a8cadd220202.
   - When you finish, create a pull request from branch issue-103-a8cadd220202. (Note: PR 104 already exists, update it instead)
   - When you organize workflow, use pull requests instead of direct merges to default branch (main or master).
   - When you manage commits, preserve commit history for later analysis.
   - When you contribute, keep repository history forward-moving with regular commits, pushes, and reverts if needed.
   - When you face conflict that you cannot resolve yourself, ask for help.
   - When you collaborate, respect branch protections by working only on issue-103-a8cadd220202.
   - When you mention result, include pull request url or comment url.
   - When you need to create pr, remember pr 104 already exists for this branch.

Self review.
   - When you check your solution draft, run all tests locally.
   - When you check your solution draft, verify git status shows a clean working tree with no uncommitted changes.
   - When you compare with repo style, use gh pr diff [number].
   - When you finalize, confirm code, tests, and description are consistent.

GitHub CLI command patterns.
   - IMPORTANT: Always use --paginate flag when fetching lists from GitHub API to ensure all results are returned (GitHub returns max 30 per page by default).
   - When listing PR review comments (inline code comments), use gh api repos/OWNER/REPO/pulls/NUMBER/comments --paginate.
   - When listing PR conversation comments, use gh api repos/OWNER/REPO/issues/NUMBER/comments --paginate.
   - When listing PR reviews, use gh api repos/OWNER/REPO/pulls/NUMBER/reviews --paginate.
   - When listing issue comments, use gh api repos/OWNER/REPO/issues/NUMBER/comments --paginate.
   - When adding PR comment, use gh pr comment NUMBER --body \"text\" --repo OWNER/REPO.
   - When adding issue comment, use gh issue comment NUMBER --body \"text\" --repo OWNER/REPO.
   - When viewing PR details, use gh pr view NUMBER --repo OWNER/REPO.
   - When filtering with jq, use gh api repos/\${owner}/\${repo}/pulls/\${prNumber}/comments --paginate --jq 'reverse | .[0:5]'.

Playwright MCP usage (browser automation via mcp__playwright__* tools).
   - When you develop frontend web applications (HTML, CSS, JavaScript, React, Vue, Angular, etc.), use Playwright MCP tools to test the UI in a real browser.
   - When WebFetch tool fails to retrieve expected content (e.g., returns empty content, JavaScript-rendered pages, or login-protected pages), use Playwright MCP tools (browser_navigate, browser_snapshot) as a fallback for web browsing.
   - When you need to interact with dynamic web pages that require JavaScript execution, use Playwright MCP tools.
   - When you need to visually verify how a web page looks or take screenshots, use browser_take_screenshot from Playwright MCP.
   - When you need to fill forms, click buttons, or perform user interactions on web pages, use Playwright MCP tools (browser_click, browser_type, browser_fill_form).
   - When you need to test responsive design or different viewport sizes, use browser_resize from Playwright MCP.
   - When you finish using the browser, always close it with browser_close to free resources." | jq -c .)
[2026-01-18T02:48:42.021Z] [INFO] 
[2026-01-18T02:48:42.021Z] [INFO] üìã User prompt:
[2026-01-18T02:48:42.022Z] [INFO] ---BEGIN USER PROMPT---
[2026-01-18T02:48:42.022Z] [INFO] Issue to solve: https://github.com/Jhon-Crow/godot-topdown-MVP/issues/103
Your prepared branch: issue-103-a8cadd220202
Your prepared working directory: /tmp/gh-issue-solver-1768704499561
Your prepared Pull Request: https://github.com/Jhon-Crow/godot-topdown-MVP/pull/104
Your forked repository: konard/Jhon-Crow-godot-topdown-MVP
Original repository (upstream): Jhon-Crow/godot-topdown-MVP
GitHub Actions on your fork: https://github.com/konard/Jhon-Crow-godot-topdown-MVP/actions?query=branch%3Aissue-103-a8cadd220202

Proceed.

[2026-01-18T02:48:42.023Z] [INFO] ---END USER PROMPT---
[2026-01-18T02:48:42.023Z] [INFO] 
[2026-01-18T02:48:42.023Z] [INFO] üìã System prompt:
[2026-01-18T02:48:42.023Z] [INFO] ---BEGIN SYSTEM PROMPT---
[2026-01-18T02:48:42.023Z] [INFO] You are an AI issue solver. You prefer to find the root cause of each and every issue. When you talk, you prefer to speak with facts which you have double-checked yourself or cite sources that provide evidence, like quote actual code or give references to documents or pages found on the internet. You are polite and patient, and prefer to assume good intent, trying your best to be helpful. If you are unsure or have assumptions, you prefer to test them yourself or ask questions to clarify requirements.
General guidelines.
   - When you execute commands, always save their logs to files for easier reading if the output becomes large.
   - When running commands, do not set a timeout yourself ‚Äî let them run as long as needed (default timeout - 2 minutes is more than enough), and once they finish, review the logs in the file.
   - When running sudo commands (especially package installations like apt-get, yum, npm install, etc.), always run them in the background to avoid timeout issues and permission errors when the process needs to be killed. Use the run_in_background parameter or append & to the command.
   - When CI is failing or user reports failures, consider adding a detailed investigation protocol to your todo list with these steps:
      Step 1: List recent runs with timestamps using: gh run list --repo Jhon-Crow/godot-topdown-MVP --branch issue-103-a8cadd220202 --limit 5 --json databaseId,conclusion,createdAt,headSha
      Step 2: Verify runs are after the latest commit by checking timestamps and SHA
      Step 3: For each non-passing run, download logs to preserve them: gh run view {run-id} --repo Jhon-Crow/godot-topdown-MVP --log > ci-logs/{workflow}-{run-id}.log
      Step 4: Read each downloaded log file using Read tool to understand the actual failures
      Step 5: Report findings with specific errors and line numbers from logs
      This detailed investigation is especially helpful when user mentions CI failures, asks to investigate logs, you see non-passing status, or when finalizing a PR.
      Note: If user says "failing" but tools show "passing", this might indicate stale data - consider downloading fresh logs and checking timestamps to resolve the discrepancy.
   - When a code or log file has more than 1500 lines, read it in chunks of 1500 lines.
   - When facing a complex problem, do as much tracing as possible and turn on all verbose modes.
   - When you create debug, test, or example/experiment scripts for fixing, always keep them in an examples and/or experiments folders so you can reuse them later.
   - When testing your assumptions, use the experiment scripts, and add it to experiments folder.
   - When your experiments can show real world use case of the software, add it to examples folder.
   - When you face something extremely hard, use divide and conquer ‚Äî it always helps.

Initial research.
   - When you start, make sure you create detailed plan for yourself and follow your todo list step by step, make sure that as many points from these guidelines are added to your todo list to keep track of everything that can help you solve the issue with highest possible quality.
   - When user mentions CI failures or asks to investigate logs, consider adding these todos to track the investigation: (1) List recent CI runs with timestamps, (2) Download logs from failed runs to ci-logs/ directory, (3) Analyze error messages and identify root cause, (4) Implement fix, (5) Verify fix resolves the specific errors found in logs.
   - When you read issue, read all details and comments thoroughly.
   - When you see screenshots or images in issue descriptions, pull request descriptions, comments, or discussions, use WebFetch tool (or fetch tool) to download the image first, then use Read tool to view and analyze it. IMPORTANT: Before reading downloaded images with the Read tool, verify the file is a valid image (not HTML). Use a CLI tool like 'file' command to check the actual file format. Reading corrupted or non-image files (like GitHub's HTML 404 pages saved as .png) can cause "Could not process image" errors and may crash the AI solver process. If the file command shows "HTML" or "text", the download failed and you should retry or skip the image.
   - When you need issue details, use gh issue view https://github.com/Jhon-Crow/godot-topdown-MVP/issues/103.
   - When you need related code, use gh search code --owner Jhon-Crow [keywords].
   - When you need repo context, read files in your working directory.
   - When you study related work, study the most recent related pull requests.
   - When issue is not defined enough, write a comment to ask clarifying questions.
   - When accessing GitHub Gists (especially private ones), use gh gist view command instead of direct URL fetching to ensure proper authentication.
   - When you are fixing a bug, please make sure you first find the actual root cause, do as many experiments as needed.
   - When you are fixing a bug and code does not have enough tracing/logs, add them and make sure they stay in the code, but are switched off by default.
   - When you need comments on a pull request, note that GitHub has THREE different comment types with different API endpoints:
      1. PR review comments (inline code comments): gh api repos/Jhon-Crow/godot-topdown-MVP/pulls/104/comments --paginate
      2. PR conversation comments (general discussion): gh api repos/Jhon-Crow/godot-topdown-MVP/issues/104/comments --paginate
      3. PR reviews (approve/request changes): gh api repos/Jhon-Crow/godot-topdown-MVP/pulls/104/reviews --paginate
      IMPORTANT: The command "gh pr view --json comments" ONLY returns conversation comments and misses review comments!
   - When you need latest comments on issue, use gh api repos/Jhon-Crow/godot-topdown-MVP/issues/103/comments --paginate.

Solution development and testing.
   - When issue is solvable, implement code with tests.
   - When implementing features, search for similar existing implementations in the codebase and use them as examples instead of implementing everything from scratch.
   - When coding, each atomic step that can be useful by itself should be commited to the pull request's branch, meaning if work will be interrupted by any reason parts of solution will still be kept intact and safe in pull request.
   - When you test:
      start from testing of small functions using separate scripts;
      write unit tests with mocks for easy and quick start.
   - When you test integrations, use existing framework.
   - When you test solution draft, include automated checks in pr.
   - When issue is unclear, write comment on issue asking questions.
   - When you encounter any problems that you unable to solve yourself (any human feedback or help), write a comment to the pull request asking for help.
   - When you need human help, use gh pr comment 104 --body "your message" to comment on existing PR.

Preparing pull request.
   - When you code, follow contributing guidelines.
   - When you commit, write clear message.
   - When you need examples of style, use gh pr list --repo Jhon-Crow/godot-topdown-MVP --state merged --search [keywords].
   - When you open pr, describe solution draft and include tests.
   - When there is a package with version and GitHub Actions workflows for automatic release, update the version (or other necessary release trigger) in your pull request to prepare for next release.
   - When you update existing pr 104, use gh pr edit to modify title and description.
   - When you are about to commit or push code, ALWAYS run local CI checks first if they are available in contributing guidelines (like ruff check, mypy, eslint, etc.) to catch errors before pushing.
   - When you finalize the pull request:
      follow style from merged prs for code, title, and description,
      make sure no uncommitted changes corresponding to the original requirements are left behind,
      make sure the default branch is merged to the pull request's branch,
      make sure all CI checks passing if they exist before you finish,
      check for latest comments on the issue and pull request to ensure no recent feedback was missed,
      double-check that all changes in the pull request answer to original requirements of the issue,
      make sure no new new bugs are introduced in pull request by carefully reading gh pr diff,
      make sure no previously existing features were removed without an explicit request from users via the issue description, issue comments, and/or pull request comments.
   - When you finish implementation, use gh pr ready 104.

Workflow and collaboration.
   - When you check branch, verify with git branch --show-current.
   - When you push, push only to branch issue-103-a8cadd220202.
   - When you finish, create a pull request from branch issue-103-a8cadd220202. (Note: PR 104 already exists, update it instead)
   - When you organize workflow, use pull requests instead of direct merges to default branch (main or master).
   - When you manage commits, preserve commit history for later analysis.
   - When you contribute, keep repository history forward-moving with regular commits, pushes, and reverts if needed.
   - When you face conflict that you cannot resolve yourself, ask for help.
   - When you collaborate, respect branch protections by working only on issue-103-a8cadd220202.
   - When you mention result, include pull request url or comment url.
   - When you need to create pr, remember pr 104 already exists for this branch.

Self review.
   - When you check your solution draft, run all tests locally.
   - When you check your solution draft, verify git status shows a clean working tree with no uncommitted changes.
   - When you compare with repo style, use gh pr diff [number].
   - When you finalize, confirm code, tests, and description are consistent.

GitHub CLI command patterns.
   - IMPORTANT: Always use --paginate flag when fetching lists from GitHub API to ensure all results are returned (GitHub returns max 30 per page by default).
   - When listing PR review comments (inline code comments), use gh api repos/OWNER/REPO/pulls/NUMBER/comments --paginate.
   - When listing PR conversation comments, use gh api repos/OWNER/REPO/issues/NUMBER/comments --paginate.
   - When listing PR reviews, use gh api repos/OWNER/REPO/pulls/NUMBER/reviews --paginate.
   - When listing issue comments, use gh api repos/OWNER/REPO/issues/NUMBER/comments --paginate.
   - When adding PR comment, use gh pr comment NUMBER --body "text" --repo OWNER/REPO.
   - When adding issue comment, use gh issue comment NUMBER --body "text" --repo OWNER/REPO.
   - When viewing PR details, use gh pr view NUMBER --repo OWNER/REPO.
   - When filtering with jq, use gh api repos/${owner}/${repo}/pulls/${prNumber}/comments --paginate --jq 'reverse | .[0:5]'.

Playwright MCP usage (browser automation via mcp__playwright__* tools).
   - When you develop frontend web applications (HTML, CSS, JavaScript, React, Vue, Angular, etc.), use Playwright MCP tools to test the UI in a real browser.
   - When WebFetch tool fails to retrieve expected content (e.g., returns empty content, JavaScript-rendered pages, or login-protected pages), use Playwright MCP tools (browser_navigate, browser_snapshot) as a fallback for web browsing.
   - When you need to interact with dynamic web pages that require JavaScript execution, use Playwright MCP tools.
   - When you need to visually verify how a web page looks or take screenshots, use browser_take_screenshot from Playwright MCP.
   - When you need to fill forms, click buttons, or perform user interactions on web pages, use Playwright MCP tools (browser_click, browser_type, browser_fill_form).
   - When you need to test responsive design or different viewport sizes, use browser_resize from Playwright MCP.
   - When you finish using the browser, always close it with browser_close to free resources.
[2026-01-18T02:48:42.024Z] [INFO] ---END SYSTEM PROMPT---
[2026-01-18T02:48:42.024Z] [INFO] 
[2026-01-18T02:48:42.024Z] [INFO] üìä CLAUDE_CODE_MAX_OUTPUT_TOKENS: 64000
[2026-01-18T02:48:42.024Z] [INFO] üìã Command details:          
[2026-01-18T02:48:42.025Z] [INFO]   üìÇ Working directory:      /tmp/gh-issue-solver-1768704499561
[2026-01-18T02:48:42.025Z] [INFO]   üåø Branch:                 issue-103-a8cadd220202
[2026-01-18T02:48:42.025Z] [INFO]   ü§ñ Model:                  Claude OPUS
[2026-01-18T02:48:42.025Z] [INFO]   üç¥ Fork:                   konard/Jhon-Crow-godot-topdown-MVP
[2026-01-18T02:48:42.025Z] [INFO] 
‚ñ∂Ô∏è Streaming output:         

[2026-01-18T02:48:44.250Z] [INFO] {
  "type": "system",
  "subtype": "init",
  "cwd": "/tmp/gh-issue-solver-1768704499561",
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "tools": [
    "Task",
    "TaskOutput",
    "Bash",
    "Glob",
    "Grep",
    "ExitPlanMode",
    "Read",
    "Edit",
    "Write",
    "NotebookEdit",
    "WebFetch",
    "TodoWrite",
    "WebSearch",
    "KillShell",
    "AskUserQuestion",
    "Skill",
    "EnterPlanMode",
    "MCPSearch",
    "mcp__playwright__browser_close",
    "mcp__playwright__browser_resize",
    "mcp__playwright__browser_console_messages",
    "mcp__playwright__browser_handle_dialog",
    "mcp__playwright__browser_evaluate",
    "mcp__playwright__browser_file_upload",
    "mcp__playwright__browser_fill_form",
    "mcp__playwright__browser_install",
    "mcp__playwright__browser_press_key",
    "mcp__playwright__browser_type",
    "mcp__playwright__browser_navigate",
    "mcp__playwright__browser_navigate_back",
    "mcp__playwright__browser_network_requests",
    "mcp__playwright__browser_run_code",
    "mcp__playwright__browser_take_screenshot",
    "mcp__playwright__browser_snapshot",
    "mcp__playwright__browser_click",
    "mcp__playwright__browser_drag",
    "mcp__playwright__browser_hover",
    "mcp__playwright__browser_select_option",
    "mcp__playwright__browser_tabs",
    "mcp__playwright__browser_wait_for"
  ],
  "mcp_servers": [
    {
      "name": "playwright",
      "status": "connected"
    }
  ],
  "model": "claude-opus-4-5-20251101",
  "permissionMode": "bypassPermissions",
  "slash_commands": [
    "compact",
    "context",
    "cost",
    "init",
    "pr-comments",
    "release-notes",
    "review",
    "security-review"
  ],
  "apiKeySource": "none",
  "claude_code_version": "2.1.9",
  "output_style": "default",
  "agents": [
    "Bash",
    "general-purpose",
    "statusline-setup",
    "Explore",
    "Plan"
  ],
  "skills": [],
  "plugins": [],
  "uuid": "b345c332-7fda-4b03-8ad9-7c7f8f4a9950"
}
[2026-01-18T02:48:44.251Z] [INFO] üìå Session ID: 797fbac8-f5e6-4339-8fd2-77453410db49
[2026-01-18T02:48:44.252Z] [INFO] üìÅ Log renamed to: /home/hive/797fbac8-f5e6-4339-8fd2-77453410db49.log
[2026-01-18T02:48:47.220Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01F9C1kL6cPf6Nbds4mEv9we",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01KMCsUtUwfm8S7NipRhMbfe",
        "name": "Bash",
        "input": {
          "command": "gh issue view https://github.com/Jhon-Crow/godot-topdown-MVP/issues/103",
          "description": "View issue details"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 2,
      "cache_creation_input_tokens": 11567,
      "cache_read_input_tokens": 13914,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 11567,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "1fcf0771-4bba-40e2-aca9-83fe6f82753f"
}
[2026-01-18T02:48:47.954Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01F9C1kL6cPf6Nbds4mEv9we",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01P8tbfNYtYBYmihK8QTfeXq",
        "name": "Bash",
        "input": {
          "command": "gh api repos/Jhon-Crow/godot-topdown-MVP/issues/103/comments --paginate",
          "description": "Get issue comments"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 2,
      "cache_creation_input_tokens": 11567,
      "cache_read_input_tokens": 13914,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 11567,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "40f610b7-c4f3-430a-be3a-18567deb6aaa"
}
[2026-01-18T02:48:48.610Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01F9C1kL6cPf6Nbds4mEv9we",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01V6D31iCsPorNPm2Kd5b4e7",
        "name": "Bash",
        "input": {
          "command": "gh pr view 104 --repo Jhon-Crow/godot-topdown-MVP",
          "description": "View existing PR details"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 2,
      "cache_creation_input_tokens": 11567,
      "cache_read_input_tokens": 13914,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 11567,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "f28f1f55-a657-4901-aa79-578b841574b7"
}
[2026-01-18T02:48:50.347Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01KMCsUtUwfm8S7NipRhMbfe",
        "type": "tool_result",
        "content": "title:\t—É–ª—É—á—à–∏—Ç—å —Å–∏—Å—Ç–µ–º—É –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è\nstate:\tOPEN\nauthor:\tJhon-Crow\nlabels:\t\ncomments:\t0\nassignees:\t\nprojects:\t\nmilestone:\t\nnumber:\t103\n--\n–ø–æ—Å–ª–µ –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è –∏–≥—Ä–æ–∫–∞ –∏–∑ –ø–æ–ª—è –∑—Ä–µ–Ω–∏—è –≤—Ä–∞–≥–∞ –æ–Ω –¥–æ–ª–∂–µ–Ω —Å—á–∏—Ç–∞—Ç—å –Ω–µ–±–æ–ª—å—à—É—é –Ω–µ–≤–∏–¥–∏–º—É—é –∑–æ–Ω—É, –≤ –∫–æ—Ç–æ—Ä–æ–π —Å–∫—Ä—ã–ª—Å—è –∏–≥—Ä–æ–∫ - –∑–æ–Ω–æ–π –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞. –≤—Ä–∞–≥ –¥–æ–ª–∂–µ–Ω —Å—Ç—Ä–æ–∏—Ç—å –ø–æ–ª–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç –¥–æ —ç—Ç–æ–π –∑–æ–Ω—ã –∏ –∑–∞—Ç–µ–º –æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å –µ—ë.\n–∑–∞ –≤—Å–µ–º–∏ —É–∫—Ä—ã—Ç–∏—è–º–∏ –∏ –≤ —É–≥–ª–∞—Ö –∫–æ–º–Ω–∞—Ç –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–≤–∏–¥–∏–º—ã–µ —Ç–æ—á–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤—Ä–∞–≥ –¥–æ–ª–∂–µ–Ω –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–µ–∂–¥–µ, —á–µ–º –¥–≤–∏–≥–∞—Ç—å—Å—è –¥–∞–ª—å—à–µ, –µ—Å–ª–∏ —ç—Ç–∏ —Ç–æ—á–∫–∏ –≤ –∑–æ–Ω–µ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞. –∫–æ–≥–¥–∞ –≤—Å–µ —Ç–æ—á–∫–∏ —É –∑–æ–Ω–µ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞ –ø—Ä–æ–≤–µ—Ä–µ–Ω—ã - –∑–æ–Ω–∞ —Å—á–∏—Ç–∞–µ—Ç—Å—è –∑–æ–Ω–æ–π –±–µ–∑ –∏–≥—Ä–æ–∫–∞.\n–ø—Ä–∏ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–∏ —Å –∏–≥—Ä–æ–∫–æ–º –∑–æ–Ω—ã –æ–±–Ω—É–ª—è—é—Ç—Å—è.\n\n—Ä–∞—Å—à–∏—Ä—å –∏–º–µ—é—â–µ–µ—Å—è –ø–æ–≤–µ–¥–µ–Ω–∏–µ ai –∏ —Å–∏—Å—Ç–µ–º—É GOAP.\n—Å–æ—Ö—Ä–∞–Ω–∏ –≤–µ—Å—å –∏–º–µ—é—â–∏–π—Å—è –≤ exe —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª.\n\nPlease download all logs and data related about the issue to this repository, make sure we compile that data to `./docs/case-studies/issue-{id}` folder, and use it to do deep case study analysis (also make sure to search online for additional facts and data), in which we will reconstruct timeline/sequence of events, find root causes of the problem, and propose possible solutions.",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "bac12834-973d-489e-a7d7-bea8cbe57e33",
  "tool_use_result": {
    "stdout": "title:\t—É–ª—É—á—à–∏—Ç—å —Å–∏—Å—Ç–µ–º—É –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è\nstate:\tOPEN\nauthor:\tJhon-Crow\nlabels:\t\ncomments:\t0\nassignees:\t\nprojects:\t\nmilestone:\t\nnumber:\t103\n--\n–ø–æ—Å–ª–µ –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è –∏–≥—Ä–æ–∫–∞ –∏–∑ –ø–æ–ª—è –∑—Ä–µ–Ω–∏—è –≤—Ä–∞–≥–∞ –æ–Ω –¥–æ–ª–∂–µ–Ω —Å—á–∏—Ç–∞—Ç—å –Ω–µ–±–æ–ª—å—à—É—é –Ω–µ–≤–∏–¥–∏–º—É—é –∑–æ–Ω—É, –≤ –∫–æ—Ç–æ—Ä–æ–π —Å–∫—Ä—ã–ª—Å—è –∏–≥—Ä–æ–∫ - –∑–æ–Ω–æ–π –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞. –≤—Ä–∞–≥ –¥–æ–ª–∂–µ–Ω —Å—Ç—Ä–æ–∏—Ç—å –ø–æ–ª–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç –¥–æ —ç—Ç–æ–π –∑–æ–Ω—ã –∏ –∑–∞—Ç–µ–º –æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å –µ—ë.\n–∑–∞ –≤—Å–µ–º–∏ —É–∫—Ä—ã—Ç–∏—è–º–∏ –∏ –≤ —É–≥–ª–∞—Ö –∫–æ–º–Ω–∞—Ç –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–≤–∏–¥–∏–º—ã–µ —Ç–æ—á–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤—Ä–∞–≥ –¥–æ–ª–∂–µ–Ω –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–µ–∂–¥–µ, —á–µ–º –¥–≤–∏–≥–∞—Ç—å—Å—è –¥–∞–ª—å—à–µ, –µ—Å–ª–∏ —ç—Ç–∏ —Ç–æ—á–∫–∏ –≤ –∑–æ–Ω–µ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞. –∫–æ–≥–¥–∞ –≤—Å–µ —Ç–æ—á–∫–∏ —É –∑–æ–Ω–µ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞ –ø—Ä–æ–≤–µ—Ä–µ–Ω—ã - –∑–æ–Ω–∞ —Å—á–∏—Ç–∞–µ—Ç—Å—è –∑–æ–Ω–æ–π –±–µ–∑ –∏–≥—Ä–æ–∫–∞.\n–ø—Ä–∏ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–∏ —Å –∏–≥—Ä–æ–∫–æ–º –∑–æ–Ω—ã –æ–±–Ω—É–ª—è—é—Ç—Å—è.\n\n—Ä–∞—Å—à–∏—Ä—å –∏–º–µ—é—â–µ–µ—Å—è –ø–æ–≤–µ–¥–µ–Ω–∏–µ ai –∏ —Å–∏—Å—Ç–µ–º—É GOAP.\n—Å–æ—Ö—Ä–∞–Ω–∏ –≤–µ—Å—å –∏–º–µ—é—â–∏–π—Å—è –≤ exe —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª.\n\nPlease download all logs and data related about the issue to this repository, make sure we compile that data to `./docs/case-studies/issue-{id}` folder, and use it to do deep case study analysis (also make sure to search online for additional facts and data), in which we will reconstruct timeline/sequence of events, find root causes of the problem, and propose possible solutions.",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-01-18T02:48:51.862Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01P8tbfNYtYBYmihK8QTfeXq",
        "type": "tool_result",
        "content": "[]",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "77443abc-5321-4eb9-a261-12ed13c3ff2e",
  "tool_use_result": {
    "stdout": "[]",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-01-18T02:48:54.263Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01V6D31iCsPorNPm2Kd5b4e7",
        "type": "tool_result",
        "content": "title:\t[WIP] —É–ª—É—á—à–∏—Ç—å —Å–∏—Å—Ç–µ–º—É –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è\nstate:\tDRAFT\nauthor:\tkonard\nlabels:\t\nassignees:\t\nreviewers:\t\nprojects:\t\nmilestone:\t\nnumber:\t104\nurl:\thttps://github.com/Jhon-Crow/godot-topdown-MVP/pull/104\nadditions:\t7\ndeletions:\t0\nauto-merge:\tdisabled\n--\n## ü§ñ AI-Powered Solution Draft\n\nThis pull request is being automatically generated to solve issue Jhon-Crow/godot-topdown-MVP#103.\n\n### üìã Issue Reference\nFixes Jhon-Crow/godot-topdown-MVP#103\n\n### üöß Status\n**Work in Progress** - The AI assistant is currently analyzing and implementing the solution draft.\n\n### üìù Implementation Details\n_Details will be added as the solution draft is developed..._\n\n---\n*This PR was created automatically by the AI issue solver*",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "9b5a0ceb-9bd7-4758-83bb-bb46bb0e5598",
  "tool_use_result": {
    "stdout": "title:\t[WIP] —É–ª—É—á—à–∏—Ç—å —Å–∏—Å—Ç–µ–º—É –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è\nstate:\tDRAFT\nauthor:\tkonard\nlabels:\t\nassignees:\t\nreviewers:\t\nprojects:\t\nmilestone:\t\nnumber:\t104\nurl:\thttps://github.com/Jhon-Crow/godot-topdown-MVP/pull/104\nadditions:\t7\ndeletions:\t0\nauto-merge:\tdisabled\n--\n## ü§ñ AI-Powered Solution Draft\n\nThis pull request is being automatically generated to solve issue Jhon-Crow/godot-topdown-MVP#103.\n\n### üìã Issue Reference\nFixes Jhon-Crow/godot-topdown-MVP#103\n\n### üöß Status\n**Work in Progress** - The AI assistant is currently analyzing and implementing the solution draft.\n\n### üìù Implementation Details\n_Details will be added as the solution draft is developed..._\n\n---\n*This PR was created automatically by the AI issue solver*",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-01-18T02:48:56.851Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01TS8gPLRHhVVo66LUCvVBeT",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Let me explore the codebase to understand the existing AI and GOAP system, and then create a comprehensive case study."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 959,
      "cache_read_input_tokens": 25481,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 959,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "225d1201-4732-4cf9-8e13-35e02d2d25cf"
}
[2026-01-18T02:48:57.222Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01TS8gPLRHhVVo66LUCvVBeT",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01MMDoWxLvJc55MNR8a9QPK5",
        "name": "Glob",
        "input": {
          "pattern": "**/*"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 959,
      "cache_read_input_tokens": 25481,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 959,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "badf63ca-400d-49a3-8990-08929de9fed3"
}
[2026-01-18T02:48:57.865Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01TS8gPLRHhVVo66LUCvVBeT",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01Kn8VMgiugaXMgvHMGLU5cG",
        "name": "Bash",
        "input": {
          "command": "ls -la /tmp/gh-issue-solver-1768704499561",
          "description": "List files in working directory"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 959,
      "cache_read_input_tokens": 25481,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 959,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "78303b11-843d-4f76-acff-de3283085040"
}
[2026-01-18T02:48:57.929Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01MMDoWxLvJc55MNR8a9QPK5",
        "type": "tool_result",
        "content": "/tmp/gh-issue-solver-1768704499561/.git/info/exclude\n/tmp/gh-issue-solver-1768704499561/.git/hooks/prepare-commit-msg.sample\n/tmp/gh-issue-solver-1768704499561/.git/hooks/pre-rebase.sample\n/tmp/gh-issue-solver-1768704499561/.git/hooks/pre-merge-commit.sample\n/tmp/gh-issue-solver-1768704499561/.git/hooks/push-to-checkout.sample\n/tmp/gh-issue-solver-1768704499561/.git/hooks/pre-applypatch.sample\n/tmp/gh-issue-solver-1768704499561/.git/hooks/fsmonitor-watchman.sample\n/tmp/gh-issue-solver-1768704499561/.git/hooks/pre-push.sample\n/tmp/gh-issue-solver-1768704499561/.git/hooks/sendemail-validate.sample\n/tmp/gh-issue-solver-1768704499561/.git/hooks/applypatch-msg.sample\n/tmp/gh-issue-solver-1768704499561/.git/hooks/pre-commit.sample\n/tmp/gh-issue-solver-1768704499561/.git/hooks/commit-msg.sample\n/tmp/gh-issue-solver-1768704499561/.git/hooks/post-update.sample\n/tmp/gh-issue-solver-1768704499561/.git/hooks/update.sample\n/tmp/gh-issue-solver-1768704499561/.git/hooks/pre-receive.sample\n/tmp/gh-issue-solver-1768704499561/.git/description\n/tmp/gh-issue-solver-1768704499561/.git/objects/pack/pack-0deeaa688c1c170587bf786cd0670e1308c9d80a.pack\n/tmp/gh-issue-solver-1768704499561/.git/objects/pack/pack-0deeaa688c1c170587bf786cd0670e1308c9d80a.idx\n/tmp/gh-issue-solver-1768704499561/.git/objects/pack/pack-0deeaa688c1c170587bf786cd0670e1308c9d80a.rev\n/tmp/gh-issue-solver-1768704499561/.git/refs/remotes/origin/HEAD\n/tmp/gh-issue-solver-1768704499561/.git/logs/refs/remotes/origin/HEAD\n/tmp/gh-issue-solver-1768704499561/.git/packed-refs\n/tmp/gh-issue-solver-1768704499561/.gitignore\n/tmp/gh-issue-solver-1768704499561/GodotTopDownTemplate.csproj\n/tmp/gh-issue-solver-1768704499561/LICENSE\n/tmp/gh-issue-solver-1768704499561/GodotTopDownTemplate.sln\n/tmp/gh-issue-solver-1768704499561/.github/workflows/build-windows.yml\n/tmp/gh-issue-solver-1768704499561/Scripts/Components/HealthComponent.cs\n/tmp/gh-issue-solver-1768704499561/Scripts/Characters/Player.cs\n/tmp/gh-issue-solver-1768704499561/Scripts/Data/BulletData.cs\n/tmp/gh-issue-solver-1768704499561/Scripts/AbstractClasses/BaseCharacter.cs\n/tmp/gh-issue-solver-1768704499561/Scripts/AbstractClasses/BaseWeapon.cs\n/tmp/gh-issue-solver-1768704499561/README_RU.md\n/tmp/gh-issue-solver-1768704499561/README.md\n/tmp/gh-issue-solver-1768704499561/Scripts/Interfaces/IDamageable.cs\n/tmp/gh-issue-solver-1768704499561/Scripts/Projectiles/Bullet.cs\n/tmp/gh-issue-solver-1768704499561/Scripts/Data/WeaponData.cs\n/tmp/gh-issue-solver-1768704499561/Scripts/Objects/Enemy.cs\n/tmp/gh-issue-solver-1768704499561/Scripts/Weapons/AssaultRifle.cs\n/tmp/gh-issue-solver-1768704499561/assets/audio/.gitkeep\n/tmp/gh-issue-solver-1768704499561/addons/.gitkeep\n/tmp/gh-issue-solver-1768704499561/assets/audio/m16  –¥–≤–∞ –≤—ã—Å—Ç—Ä–µ–ª–∞ –ø–æ–¥—Ä—è–¥ 2.wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/m16 1.wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/m16 2.wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/m16 3.wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/m16 –¥–≤–∞ –≤—ã—Å—Ç—Ä–µ–ª–∞ –ø–æ–¥—Ä—è–¥.wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/–≤–∑–≤–æ–¥ –∑–∞—Ç–≤–æ—Ä–∞ m16 1.wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/–≤–∑–≤–æ–¥ –∑–∞—Ç–≤–æ—Ä–∞ m16 2.wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/–≤–∑–≤–æ–¥ –∑–∞—Ç–≤–æ—Ä–∞ m16 3.wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/–≤–∑–≤–æ–¥ –∑–∞—Ç–≤–æ—Ä–∞ m16 4.wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/–∑–≤—É–∫ –ø–æ–ø–∞–¥–∞–Ω–∏—è –Ω–µ —Å–º–µ—Ä—Ç–µ–ª—å–Ω–æ–≥–æ –ø–æ–ø–∞–¥–∞–Ω–∏—è.wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/–∑–≤—É–∫ —Å–º–µ—Ä—Ç–µ–ª—å–Ω–æ–≥–æ –ø–æ–ø–∞–¥–∞–Ω–∏—è.wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/–≤–∑–≤–æ–¥ –∑–∞—Ç–≤–æ—Ä–∞ –ø–∏—Å—Ç–æ–ª–µ—Ç–∞.wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/–∏–≥—Ä–æ–∫ –≤—Å—Ç–∞–≤–∏–ª –º–∞–≥–∞–∑–∏–Ω (–≤—Ç–æ—Ä–∞—è —Ñ–∞–∑–∞ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∏).wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/–∏–≥—Ä–æ–∫ –¥–æ—Å—Ç–∞–ª –º–∞–≥–∞–∑–∏–Ω (–ø–µ—Ä–≤–∞—è —Ñ–∞–∑–∞ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∏).wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/–∏–≥—Ä–æ–∫ –∏–∑–º–µ–Ω–∏–ª —Ä–µ–∂–∏–º —Å—Ç—Ä–µ–ª—å–±—ã (–Ω–∞–∂–∞–ª b).wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/–∫–æ–Ω—á–∏–ª–∏—Å—å –ø–∞—Ç—Ä–æ–Ω—ã –≤ –ø–∏—Å—Ç–æ–ª–µ—Ç–µ.wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/–ø–∞–¥–∞–µ—Ç –≥–∏–ª—å–∑–∞ –∞–≤—Ç–æ–º–∞—Ç–∞.wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/–ø–∞–¥–∞–µ—Ç –≥–∏–ª—å–∑–∞ –ø–∏—Å—Ç–æ–ª–µ—Ç–∞.wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/–ø–æ–ª–Ω–∞—è –∑–∞—Ä—è–¥–∫–∞ m16.wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/–ø–æ–ø–∞–¥–∞–Ω–∏–µ –ø—É–ª–∏ –≤ —É–∫—Ä—ã—Ç–∏–µ —Ä—è–¥–æ–º —Å –∏–≥—Ä–æ–∫–æ–º.wav\n/tmp/gh-issue-solver-1768704499561/assets/fonts/.gitkeep\n/tmp/gh-issue-solver-1768704499561/assets/sprites/.gitkeep\n/tmp/gh-issue-solver-1768704499561/assets/audio/–ø—É–ª—è –ø—Ä–æ–ª–µ—Ç–µ–ª–∞ —Ä—è–¥–æ–º —Å –∏–≥—Ä–æ–∫–æ–º.wav\n/tmp/gh-issue-solver-1768704499561/assets/audio/–ø—É–ª—è –ø–æ–ø–∞–ª–∞ –≤ —Å—Ç–µ–Ω—É –∏–ª–∏ —É–∫—Ä—ã—Ç–∏–µ (—Å–¥–µ–ª–∞—Ç—å –ø–æ —Ç–∏—à–µ).wav\n/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-10/README.md\n/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-78/README.md\n/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-41/README.md\n/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-88/analysis.md\n/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-42/README.md\n/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-94/README.md\n/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-46/README.md\n/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-91/README.md\n/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-55/README.md\n/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-62/README.md\n/tmp/gh-issue-solver-1768704499561/export_presets.cfg\n/tmp/gh-issue-solver-1768704499561/icon.svg\n/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-94/user-logs/game_log_20260118_045534.txt\n/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-94/ci-logs/latest-build.log\n/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-94/ci-logs/build-21103908270.log\n/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-94/ci-logs/build-21104089330.log\n/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-94/ci-logs/build-21104116910.log\n/tmp/gh-issue-solver-1768704499561/experiments/test_wall_shooting_fix.gd\n/tmp/gh-issue-solver-1768704499561/resources/weapons/AssaultRifleData.tres\n/tmp/gh-issue-solver-1768704499561/scenes/levels/TestTier.tscn\n/tmp/gh-issue-solver-1768704499561/scenes/levels/csharp/TestTier.tscn\n/tmp/gh-issue-solver-1768704499561/scenes/levels/BuildingLevel.tscn\n/tmp/gh-issue-solver-1768704499561/scenes/ui/.gitkeep\n/tmp/gh-issue-solver-1768704499561/scenes/characters/csharp/Player.tscn\n/tmp/gh-issue-solver-1768704499561/scenes/characters/Player.tscn\n/tmp/gh-issue-solver-1768704499561/scenes/main/Main.tscn\n/tmp/gh-issue-solver-1768704499561/scenes/objects/Enemy.tscn\n/tmp/gh-issue-solver-1768704499561/scenes/objects/Target.tscn\n/tmp/gh-issue-solver-1768704499561/scenes/objects/csharp/Enemy.tscn\n/tmp/gh-issue-solver-1768704499561/scenes/objects/csharp/Target.tscn\n/tmp/gh-issue-solver-1768704499561/scenes/projectiles/Bullet.tscn\n/tmp/gh-issue-solver-1768704499561/scenes/projectiles/csharp/Bullet.tscn\n/tmp/gh-issue-solver-1768704499561/scripts/ai/enemy_actions.gd\n/tmp/gh-issue-solver-1768704499561/scripts/ai/goap_planner.gd\n/tmp/gh-issue-solver-1768704499561/scripts/ai/goap_action.gd\n(Results are truncated. Consider using a more specific path or pattern.)"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "8e10a7d5-5e28-4b18-8b06-81a056049715",
  "tool_use_result": {
    "filenames": [
      "/tmp/gh-issue-solver-1768704499561/.git/info/exclude",
      "/tmp/gh-issue-solver-1768704499561/.git/hooks/prepare-commit-msg.sample",
      "/tmp/gh-issue-solver-1768704499561/.git/hooks/pre-rebase.sample",
      "/tmp/gh-issue-solver-1768704499561/.git/hooks/pre-merge-commit.sample",
      "/tmp/gh-issue-solver-1768704499561/.git/hooks/push-to-checkout.sample",
      "/tmp/gh-issue-solver-1768704499561/.git/hooks/pre-applypatch.sample",
      "/tmp/gh-issue-solver-1768704499561/.git/hooks/fsmonitor-watchman.sample",
      "/tmp/gh-issue-solver-1768704499561/.git/hooks/pre-push.sample",
      "/tmp/gh-issue-solver-1768704499561/.git/hooks/sendemail-validate.sample",
      "/tmp/gh-issue-solver-1768704499561/.git/hooks/applypatch-msg.sample",
      "/tmp/gh-issue-solver-1768704499561/.git/hooks/pre-commit.sample",
      "/tmp/gh-issue-solver-1768704499561/.git/hooks/commit-msg.sample",
      "/tmp/gh-issue-solver-1768704499561/.git/hooks/post-update.sample",
      "/tmp/gh-issue-solver-1768704499561/.git/hooks/update.sample",
      "/tmp/gh-issue-solver-1768704499561/.git/hooks/pre-receive.sample",
      "/tmp/gh-issue-solver-1768704499561/.git/description",
      "/tmp/gh-issue-solver-1768704499561/.git/objects/pack/pack-0deeaa688c1c170587bf786cd0670e1308c9d80a.pack",
      "/tmp/gh-issue-solver-1768704499561/.git/objects/pack/pack-0deeaa688c1c170587bf786cd0670e1308c9d80a.idx",
      "/tmp/gh-issue-solver-1768704499561/.git/objects/pack/pack-0deeaa688c1c170587bf786cd0670e1308c9d80a.rev",
      "/tmp/gh-issue-solver-1768704499561/.git/refs/remotes/origin/HEAD",
      "/tmp/gh-issue-solver-1768704499561/.git/logs/refs/remotes/origin/HEAD",
      "/tmp/gh-issue-solver-1768704499561/.git/packed-refs",
      "/tmp/gh-issue-solver-1768704499561/.gitignore",
      "/tmp/gh-issue-solver-1768704499561/GodotTopDownTemplate.csproj",
      "/tmp/gh-issue-solver-1768704499561/LICENSE",
      "/tmp/gh-issue-solver-1768704499561/GodotTopDownTemplate.sln",
      "/tmp/gh-issue-solver-1768704499561/.github/workflows/build-windows.yml",
      "/tmp/gh-issue-solver-1768704499561/Scripts/Components/HealthComponent.cs",
      "/tmp/gh-issue-solver-1768704499561/Scripts/Characters/Player.cs",
      "/tmp/gh-issue-solver-1768704499561/Scripts/Data/BulletData.cs",
      "/tmp/gh-issue-solver-1768704499561/Scripts/AbstractClasses/BaseCharacter.cs",
      "/tmp/gh-issue-solver-1768704499561/Scripts/AbstractClasses/BaseWeapon.cs",
      "/tmp/gh-issue-solver-1768704499561/README_RU.md",
      "/tmp/gh-issue-solver-1768704499561/README.md",
      "/tmp/gh-issue-solver-1768704499561/Scripts/Interfaces/IDamageable.cs",
      "/tmp/gh-issue-solver-1768704499561/Scripts/Projectiles/Bullet.cs",
      "/tmp/gh-issue-solver-1768704499561/Scripts/Data/WeaponData.cs",
      "/tmp/gh-issue-solver-1768704499561/Scripts/Objects/Enemy.cs",
      "/tmp/gh-issue-solver-1768704499561/Scripts/Weapons/AssaultRifle.cs",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/.gitkeep",
      "/tmp/gh-issue-solver-1768704499561/addons/.gitkeep",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/m16  –¥–≤–∞ –≤—ã—Å—Ç—Ä–µ–ª–∞ –ø–æ–¥—Ä—è–¥ 2.wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/m16 1.wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/m16 2.wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/m16 3.wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/m16 –¥–≤–∞ –≤—ã—Å—Ç—Ä–µ–ª–∞ –ø–æ–¥—Ä—è–¥.wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/–≤–∑–≤–æ–¥ –∑–∞—Ç–≤–æ—Ä–∞ m16 1.wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/–≤–∑–≤–æ–¥ –∑–∞—Ç–≤–æ—Ä–∞ m16 2.wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/–≤–∑–≤–æ–¥ –∑–∞—Ç–≤–æ—Ä–∞ m16 3.wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/–≤–∑–≤–æ–¥ –∑–∞—Ç–≤–æ—Ä–∞ m16 4.wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/–∑–≤—É–∫ –ø–æ–ø–∞–¥–∞–Ω–∏—è –Ω–µ —Å–º–µ—Ä—Ç–µ–ª—å–Ω–æ–≥–æ –ø–æ–ø–∞–¥–∞–Ω–∏—è.wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/–∑–≤—É–∫ —Å–º–µ—Ä—Ç–µ–ª—å–Ω–æ–≥–æ –ø–æ–ø–∞–¥–∞–Ω–∏—è.wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/–≤–∑–≤–æ–¥ –∑–∞—Ç–≤–æ—Ä–∞ –ø–∏—Å—Ç–æ–ª–µ—Ç–∞.wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/–∏–≥—Ä–æ–∫ –≤—Å—Ç–∞–≤–∏–ª –º–∞–≥–∞–∑–∏–Ω (–≤—Ç–æ—Ä–∞—è —Ñ–∞–∑–∞ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∏).wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/–∏–≥—Ä–æ–∫ –¥–æ—Å—Ç–∞–ª –º–∞–≥–∞–∑–∏–Ω (–ø–µ—Ä–≤–∞—è —Ñ–∞–∑–∞ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∏).wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/–∏–≥—Ä–æ–∫ –∏–∑–º–µ–Ω–∏–ª —Ä–µ–∂–∏–º —Å—Ç—Ä–µ–ª—å–±—ã (–Ω–∞–∂–∞–ª b).wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/–∫–æ–Ω—á–∏–ª–∏—Å—å –ø–∞—Ç—Ä–æ–Ω—ã –≤ –ø–∏—Å—Ç–æ–ª–µ—Ç–µ.wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/–ø–∞–¥–∞–µ—Ç –≥–∏–ª—å–∑–∞ –∞–≤—Ç–æ–º–∞—Ç–∞.wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/–ø–∞–¥–∞–µ—Ç –≥–∏–ª—å–∑–∞ –ø–∏—Å—Ç–æ–ª–µ—Ç–∞.wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/–ø–æ–ª–Ω–∞—è –∑–∞—Ä—è–¥–∫–∞ m16.wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/–ø–æ–ø–∞–¥–∞–Ω–∏–µ –ø—É–ª–∏ –≤ —É–∫—Ä—ã—Ç–∏–µ —Ä—è–¥–æ–º —Å –∏–≥—Ä–æ–∫–æ–º.wav",
      "/tmp/gh-issue-solver-1768704499561/assets/fonts/.gitkeep",
      "/tmp/gh-issue-solver-1768704499561/assets/sprites/.gitkeep",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/–ø—É–ª—è –ø—Ä–æ–ª–µ—Ç–µ–ª–∞ —Ä—è–¥–æ–º —Å –∏–≥—Ä–æ–∫–æ–º.wav",
      "/tmp/gh-issue-solver-1768704499561/assets/audio/–ø—É–ª—è –ø–æ–ø–∞–ª–∞ –≤ —Å—Ç–µ–Ω—É –∏–ª–∏ —É–∫—Ä—ã—Ç–∏–µ (—Å–¥–µ–ª–∞—Ç—å –ø–æ —Ç–∏—à–µ).wav",
      "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-10/README.md",
      "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-78/README.md",
      "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-41/README.md",
      "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-88/analysis.md",
      "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-42/README.md",
      "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-94/README.md",
      "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-46/README.md",
      "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-91/README.md",
      "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-55/README.md",
      "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-62/README.md",
      "/tmp/gh-issue-solver-1768704499561/export_presets.cfg",
      "/tmp/gh-issue-solver-1768704499561/icon.svg",
      "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-94/user-logs/game_log_20260118_045534.txt",
      "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-94/ci-logs/latest-build.log",
      "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-94/ci-logs/build-21103908270.log",
      "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-94/ci-logs/build-21104089330.log",
      "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-94/ci-logs/build-21104116910.log",
      "/tmp/gh-issue-solver-1768704499561/experiments/test_wall_shooting_fix.gd",
      "/tmp/gh-issue-solver-1768704499561/resources/weapons/AssaultRifleData.tres",
      "/tmp/gh-issue-solver-1768704499561/scenes/levels/TestTier.tscn",
      "/tmp/gh-issue-solver-1768704499561/scenes/levels/csharp/TestTier.tscn",
      "/tmp/gh-issue-solver-1768704499561/scenes/levels/BuildingLevel.tscn",
      "/tmp/gh-issue-solver-1768704499561/scenes/ui/.gitkeep",
      "/tmp/gh-issue-solver-1768704499561/scenes/characters/csharp/Player.tscn",
      "/tmp/gh-issue-solver-1768704499561/scenes/characters/Player.tscn",
      "/tmp/gh-issue-solver-1768704499561/scenes/main/Main.tscn",
      "/tmp/gh-issue-solver-1768704499561/scenes/objects/Enemy.tscn",
      "/tmp/gh-issue-solver-1768704499561/scenes/objects/Target.tscn",
      "/tmp/gh-issue-solver-1768704499561/scenes/objects/csharp/Enemy.tscn",
      "/tmp/gh-issue-solver-1768704499561/scenes/objects/csharp/Target.tscn",
      "/tmp/gh-issue-solver-1768704499561/scenes/projectiles/Bullet.tscn",
      "/tmp/gh-issue-solver-1768704499561/scenes/projectiles/csharp/Bullet.tscn",
      "/tmp/gh-issue-solver-1768704499561/scripts/ai/enemy_actions.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/ai/goap_planner.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/ai/goap_action.gd"
    ],
    "durationMs": 20,
    "numFiles": 100,
    "truncated": true
  }
}
[2026-01-18T02:48:57.975Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01Kn8VMgiugaXMgvHMGLU5cG",
        "type": "tool_result",
        "content": "total 436\ndrwxrwxr-x 13 hive hive   4096 Jan 18 03:48 .\ndrwxrwxrwt 44 root root 274432 Jan 18 03:48 ..\ndrwxrwxr-x  8 hive hive   4096 Jan 18 03:48 .git\ndrwxrwxr-x  3 hive hive   4096 Jan 18 03:48 .github\n-rw-rw-r--  1 hive hive    483 Jan 18 03:48 .gitignore\n-rw-rw-r--  1 hive hive    425 Jan 18 03:48 .gutconfig.json\n-rw-rw-r--  1 hive hive    316 Jan 18 03:48 CLAUDE.md\n-rw-rw-r--  1 hive hive    508 Jan 18 03:48 GodotTopDownTemplate.csproj\n-rw-rw-r--  1 hive hive   1075 Jan 18 03:48 GodotTopDownTemplate.sln\n-rw-rw-r--  1 hive hive   1211 Jan 18 03:48 LICENSE\n-rw-rw-r--  1 hive hive  18032 Jan 18 03:48 README.md\n-rw-rw-r--  1 hive hive  57322 Jan 18 03:48 README_RU.md\ndrwxrwxr-x 10 hive hive   4096 Jan 18 03:48 Scripts\ndrwxrwxr-x  3 hive hive   4096 Jan 18 03:48 addons\ndrwxrwxr-x  5 hive hive   4096 Jan 18 03:48 assets\ndrwxrwxr-x  3 hive hive   4096 Jan 18 03:48 docs\ndrwxrwxr-x  2 hive hive   4096 Jan 18 03:48 experiments\n-rw-rw-r--  1 hive hive   2420 Jan 18 03:48 export_presets.cfg\n-rw-rw-r--  1 hive hive    264 Jan 18 03:48 icon.svg\n-rw-rw-r--  1 hive hive   5962 Jan 18 03:48 project.godot\ndrwxrwxr-x  3 hive hive   4096 Jan 18 03:48 resources\ndrwxrwxr-x  9 hive hive   4096 Jan 18 03:48 scenes\ndrwxrwxr-x 11 hive hive   4096 Jan 18 03:48 scripts\ndrwxrwxr-x  4 hive hive   4096 Jan 18 03:48 tests",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "4fa5f78d-5efe-4048-8f2e-2e7b477221fc",
  "tool_use_result": {
    "stdout": "total 436\ndrwxrwxr-x 13 hive hive   4096 Jan 18 03:48 .\ndrwxrwxrwt 44 root root 274432 Jan 18 03:48 ..\ndrwxrwxr-x  8 hive hive   4096 Jan 18 03:48 .git\ndrwxrwxr-x  3 hive hive   4096 Jan 18 03:48 .github\n-rw-rw-r--  1 hive hive    483 Jan 18 03:48 .gitignore\n-rw-rw-r--  1 hive hive    425 Jan 18 03:48 .gutconfig.json\n-rw-rw-r--  1 hive hive    316 Jan 18 03:48 CLAUDE.md\n-rw-rw-r--  1 hive hive    508 Jan 18 03:48 GodotTopDownTemplate.csproj\n-rw-rw-r--  1 hive hive   1075 Jan 18 03:48 GodotTopDownTemplate.sln\n-rw-rw-r--  1 hive hive   1211 Jan 18 03:48 LICENSE\n-rw-rw-r--  1 hive hive  18032 Jan 18 03:48 README.md\n-rw-rw-r--  1 hive hive  57322 Jan 18 03:48 README_RU.md\ndrwxrwxr-x 10 hive hive   4096 Jan 18 03:48 Scripts\ndrwxrwxr-x  3 hive hive   4096 Jan 18 03:48 addons\ndrwxrwxr-x  5 hive hive   4096 Jan 18 03:48 assets\ndrwxrwxr-x  3 hive hive   4096 Jan 18 03:48 docs\ndrwxrwxr-x  2 hive hive   4096 Jan 18 03:48 experiments\n-rw-rw-r--  1 hive hive   2420 Jan 18 03:48 export_presets.cfg\n-rw-rw-r--  1 hive hive    264 Jan 18 03:48 icon.svg\n-rw-rw-r--  1 hive hive   5962 Jan 18 03:48 project.godot\ndrwxrwxr-x  3 hive hive   4096 Jan 18 03:48 resources\ndrwxrwxr-x  9 hive hive   4096 Jan 18 03:48 scenes\ndrwxrwxr-x 11 hive hive   4096 Jan 18 03:48 scripts\ndrwxrwxr-x  4 hive hive   4096 Jan 18 03:48 tests",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-01-18T02:49:00.325Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01CR9ertJP6uTopr4wmgXBMf",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me explore the AI and GOAP system in detail."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 3868,
      "cache_read_input_tokens": 26440,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 3868,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 4,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "45dbf068-42ee-430b-9e47-e9b7f1cb75fe"
}
[2026-01-18T02:49:00.703Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01CR9ertJP6uTopr4wmgXBMf",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01QoSwXrc2Xgps7qLRv4WSGp",
        "name": "Glob",
        "input": {
          "pattern": "scripts/**/*.gd"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 3868,
      "cache_read_input_tokens": 26440,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 3868,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 4,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "ebf681b7-9883-43c5-aeaf-dd8ea8f4d03f"
}
[2026-01-18T02:49:00.977Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01CR9ertJP6uTopr4wmgXBMf",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01MhnP4L1TPnLyW9E4NGUG7c",
        "name": "Glob",
        "input": {
          "pattern": "Scripts/**/*.cs"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 3868,
      "cache_read_input_tokens": 26440,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 3868,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 4,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "39512445-3253-44c5-a82b-e2f71310995d"
}
[2026-01-18T02:49:01.046Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01MhnP4L1TPnLyW9E4NGUG7c",
        "type": "tool_result",
        "content": "/tmp/gh-issue-solver-1768704499561/Scripts/Components/HealthComponent.cs\n/tmp/gh-issue-solver-1768704499561/Scripts/Characters/Player.cs\n/tmp/gh-issue-solver-1768704499561/Scripts/Data/BulletData.cs\n/tmp/gh-issue-solver-1768704499561/Scripts/AbstractClasses/BaseCharacter.cs\n/tmp/gh-issue-solver-1768704499561/Scripts/AbstractClasses/BaseWeapon.cs\n/tmp/gh-issue-solver-1768704499561/Scripts/Interfaces/IDamageable.cs\n/tmp/gh-issue-solver-1768704499561/Scripts/Projectiles/Bullet.cs\n/tmp/gh-issue-solver-1768704499561/Scripts/Data/WeaponData.cs\n/tmp/gh-issue-solver-1768704499561/Scripts/Objects/Enemy.cs\n/tmp/gh-issue-solver-1768704499561/Scripts/Weapons/AssaultRifle.cs"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "e481b4ea-f4f8-47a4-a752-f6bdcdea597c",
  "tool_use_result": {
    "filenames": [
      "/tmp/gh-issue-solver-1768704499561/Scripts/Components/HealthComponent.cs",
      "/tmp/gh-issue-solver-1768704499561/Scripts/Characters/Player.cs",
      "/tmp/gh-issue-solver-1768704499561/Scripts/Data/BulletData.cs",
      "/tmp/gh-issue-solver-1768704499561/Scripts/AbstractClasses/BaseCharacter.cs",
      "/tmp/gh-issue-solver-1768704499561/Scripts/AbstractClasses/BaseWeapon.cs",
      "/tmp/gh-issue-solver-1768704499561/Scripts/Interfaces/IDamageable.cs",
      "/tmp/gh-issue-solver-1768704499561/Scripts/Projectiles/Bullet.cs",
      "/tmp/gh-issue-solver-1768704499561/Scripts/Data/WeaponData.cs",
      "/tmp/gh-issue-solver-1768704499561/Scripts/Objects/Enemy.cs",
      "/tmp/gh-issue-solver-1768704499561/Scripts/Weapons/AssaultRifle.cs"
    ],
    "durationMs": 17,
    "numFiles": 10,
    "truncated": false
  }
}
[2026-01-18T02:49:01.058Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01QoSwXrc2Xgps7qLRv4WSGp",
        "type": "tool_result",
        "content": "/tmp/gh-issue-solver-1768704499561/scripts/ai/enemy_actions.gd\n/tmp/gh-issue-solver-1768704499561/scripts/ai/goap_planner.gd\n/tmp/gh-issue-solver-1768704499561/scripts/ai/goap_action.gd\n/tmp/gh-issue-solver-1768704499561/scripts/autoload/hit_effects_manager.gd\n/tmp/gh-issue-solver-1768704499561/scripts/autoload/game_manager.gd\n/tmp/gh-issue-solver-1768704499561/scripts/autoload/file_logger.gd\n/tmp/gh-issue-solver-1768704499561/scripts/autoload/audio_manager.gd\n/tmp/gh-issue-solver-1768704499561/scripts/autoload/input_settings.gd\n/tmp/gh-issue-solver-1768704499561/scripts/characters/player.gd\n/tmp/gh-issue-solver-1768704499561/scripts/levels/test_tier.gd\n/tmp/gh-issue-solver-1768704499561/scripts/levels/building_level.gd\n/tmp/gh-issue-solver-1768704499561/scripts/main.gd\n/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd\n/tmp/gh-issue-solver-1768704499561/scripts/objects/target.gd\n/tmp/gh-issue-solver-1768704499561/scripts/objects/hit_area.gd\n/tmp/gh-issue-solver-1768704499561/scripts/ui/controls_menu.gd\n/tmp/gh-issue-solver-1768704499561/scripts/ui/pause_menu.gd\n/tmp/gh-issue-solver-1768704499561/scripts/projectiles/bullet.gd"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "38a05f06-9e9b-499a-9df3-026fbf545631",
  "tool_use_result": {
    "filenames": [
      "/tmp/gh-issue-solver-1768704499561/scripts/ai/enemy_actions.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/ai/goap_planner.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/ai/goap_action.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/autoload/hit_effects_manager.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/autoload/game_manager.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/autoload/file_logger.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/autoload/audio_manager.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/autoload/input_settings.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/characters/player.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/levels/test_tier.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/levels/building_level.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/main.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/objects/target.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/objects/hit_area.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/ui/controls_menu.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/ui/pause_menu.gd",
      "/tmp/gh-issue-solver-1768704499561/scripts/projectiles/bullet.gd"
    ],
    "durationMs": 29,
    "numFiles": 18,
    "truncated": false
  }
}
[2026-01-18T02:49:03.524Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_011yR5jgs6Zx4ZjVwVYm8uQD",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Let me read the AI-related files and the enemy script to understand the current GOAP system."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 287,
      "cache_creation_input_tokens": 605,
      "cache_read_input_tokens": 30308,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 605,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 3,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "dde8bb33-0678-457d-857b-a623fd4d1286"
}
[2026-01-18T02:49:04.064Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_011yR5jgs6Zx4ZjVwVYm8uQD",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_016UgSKr5p3VRaKFEfzwu2ZK",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/ai/goap_planner.gd"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 287,
      "cache_creation_input_tokens": 605,
      "cache_read_input_tokens": 30308,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 605,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 3,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "5c08b9ab-3423-4811-913a-9a710b63da37"
}
[2026-01-18T02:49:04.497Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_011yR5jgs6Zx4ZjVwVYm8uQD",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01GrnXiSv7JntcAGVejTL5LL",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/ai/goap_action.gd"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 287,
      "cache_creation_input_tokens": 605,
      "cache_read_input_tokens": 30308,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 605,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 3,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "353a46a7-ef62-4fac-a85f-5732523cde6e"
}
[2026-01-18T02:49:04.915Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_011yR5jgs6Zx4ZjVwVYm8uQD",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01X2aVHTC2qj4RNTzmSykgmA",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/ai/enemy_actions.gd"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 287,
      "cache_creation_input_tokens": 605,
      "cache_read_input_tokens": 30308,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 605,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 3,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "07bf7eb5-4a35-4bf9-b2e5-1da6524a2d1d"
}
[2026-01-18T02:49:05.374Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_011yR5jgs6Zx4ZjVwVYm8uQD",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01GnnhscudK7dFbAqyJWLwiZ",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 287,
      "cache_creation_input_tokens": 605,
      "cache_read_input_tokens": 30308,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 605,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 3,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "0a4ec551-d91b-435f-ac91-d5afe9224bba"
}
[2026-01-18T02:49:05.438Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_016UgSKr5p3VRaKFEfzwu2ZK",
        "type": "tool_result",
        "content": "     1‚Üíclass_name GOAPPlanner\n     2‚Üíextends RefCounted\n     3‚Üí## GOAP (Goal Oriented Action Planning) planner.\n     4‚Üí##\n     5‚Üí## This planner uses A* search to find the optimal sequence of actions\n     6‚Üí## to achieve a goal from the current world state.\n     7‚Üí##\n     8‚Üí## Usage:\n     9‚Üí##   var planner = GOAPPlanner.new()\n    10‚Üí##   planner.add_action(some_action)\n    11‚Üí##   var plan = planner.plan(current_state, goal_state)\n    12‚Üí##   if plan.size() > 0:\n    13‚Üí##       execute_plan(plan)\n    14‚Üí\n    15‚Üí## Available actions for planning.\n    16‚Üívar _actions: Array[GOAPAction] = []\n    17‚Üí\n    18‚Üí## Maximum planning depth to prevent infinite loops.\n    19‚Üívar max_depth: int = 10\n    20‚Üí\n    21‚Üí## Enable debug logging.\n    22‚Üívar debug_logging: bool = false\n    23‚Üí\n    24‚Üí\n    25‚Üí## Add an action to the planner's available actions.\n    26‚Üífunc add_action(action: GOAPAction) -> void:\n    27‚Üí\t_actions.append(action)\n    28‚Üí\n    29‚Üí\n    30‚Üí## Remove an action from the planner.\n    31‚Üífunc remove_action(action: GOAPAction) -> void:\n    32‚Üí\t_actions.erase(action)\n    33‚Üí\n    34‚Üí\n    35‚Üí## Clear all actions.\n    36‚Üífunc clear_actions() -> void:\n    37‚Üí\t_actions.clear()\n    38‚Üí\n    39‚Üí\n    40‚Üí## Plan a sequence of actions to achieve the goal from the current state.\n    41‚Üí## Returns an array of GOAPAction, or empty array if no plan found.\n    42‚Üífunc plan(current_state: Dictionary, goal: Dictionary, agent: Node = null) -> Array[GOAPAction]:\n    43‚Üí\t_log(\"Planning from state: %s to goal: %s\" % [current_state, goal])\n    44‚Üí\n    45‚Üí\t# Check if goal is already satisfied\n    46‚Üí\tif _is_goal_satisfied(current_state, goal):\n    47‚Üí\t\t_log(\"Goal already satisfied!\")\n    48‚Üí\t\treturn []\n    49‚Üí\n    50‚Üí\t# A* search for optimal plan\n    51‚Üí\tvar open_set: Array = []  # Array of PlanNode\n    52‚Üí\tvar closed_set: Dictionary = {}  # state_hash -> best_cost\n    53‚Üí\n    54‚Üí\t# Start node\n    55‚Üí\tvar start_node := PlanNode.new(current_state, [], 0.0)\n    56‚Üí\tstart_node.heuristic = _estimate_cost(current_state, goal)\n    57‚Üí\topen_set.append(start_node)\n    58‚Üí\n    59‚Üí\tvar iterations := 0\n    60‚Üí\tvar max_iterations := 1000  # Prevent infinite loops\n    61‚Üí\n    62‚Üí\twhile not open_set.is_empty() and iterations < max_iterations:\n    63‚Üí\t\titerations += 1\n    64‚Üí\n    65‚Üí\t\t# Get node with lowest f-score (cost + heuristic)\n    66‚Üí\t\topen_set.sort_custom(func(a, b): return (a.cost + a.heuristic) < (b.cost + b.heuristic))\n    67‚Üí\t\tvar current: PlanNode = open_set.pop_front()\n    68‚Üí\n    69‚Üí\t\t# Check if we reached the goal\n    70‚Üí\t\tif _is_goal_satisfied(current.state, goal):\n    71‚Üí\t\t\t_log(\"Plan found in %d iterations: %s\" % [iterations, current.actions])\n    72‚Üí\t\t\treturn current.actions\n    73‚Üí\n    74‚Üí\t\t# Skip if we've seen this state with lower cost\n    75‚Üí\t\tvar state_hash := _hash_state(current.state)\n    76‚Üí\t\tif closed_set.has(state_hash) and closed_set[state_hash] <= current.cost:\n    77‚Üí\t\t\tcontinue\n    78‚Üí\t\tclosed_set[state_hash] = current.cost\n    79‚Üí\n    80‚Üí\t\t# Check depth limit\n    81‚Üí\t\tif current.actions.size() >= max_depth:\n    82‚Üí\t\t\tcontinue\n    83‚Üí\n    84‚Üí\t\t# Expand node with all valid actions\n    85‚Üí\t\tfor action in _actions:\n    86‚Üí\t\t\tif action.is_valid(current.state):\n    87‚Üí\t\t\t\tvar new_state := action.get_result_state(current.state)\n    88‚Üí\t\t\t\tvar action_cost := action.get_cost(agent, current.state) if agent else action.cost\n    89‚Üí\t\t\t\tvar new_cost := current.cost + action_cost\n    90‚Üí\n    91‚Üí\t\t\t\t# Create new plan with this action\n    92‚Üí\t\t\t\tvar new_actions: Array[GOAPAction] = current.actions.duplicate()\n    93‚Üí\t\t\t\tnew_actions.append(action)\n    94‚Üí\n    95‚Üí\t\t\t\tvar new_node := PlanNode.new(new_state, new_actions, new_cost)\n    96‚Üí\t\t\t\tnew_node.heuristic = _estimate_cost(new_state, goal)\n    97‚Üí\n    98‚Üí\t\t\t\topen_set.append(new_node)\n    99‚Üí\n   100‚Üí\t_log(\"No plan found after %d iterations\" % iterations)\n   101‚Üí\treturn []\n   102‚Üí\n   103‚Üí\n   104‚Üí## Check if all goal conditions are satisfied in the current state.\n   105‚Üífunc _is_goal_satisfied(state: Dictionary, goal: Dictionary) -> bool:\n   106‚Üí\tfor key in goal:\n   107‚Üí\t\tif not state.has(key):\n   108‚Üí\t\t\treturn false\n   109‚Üí\t\tif state[key] != goal[key]:\n   110‚Üí\t\t\treturn false\n   111‚Üí\treturn true\n   112‚Üí\n   113‚Üí\n   114‚Üí## Estimate the cost to reach the goal (heuristic for A*).\n   115‚Üí## Returns the number of unsatisfied goal conditions.\n   116‚Üífunc _estimate_cost(state: Dictionary, goal: Dictionary) -> float:\n   117‚Üí\tvar unsatisfied := 0.0\n   118‚Üí\tfor key in goal:\n   119‚Üí\t\tif not state.has(key) or state[key] != goal[key]:\n   120‚Üí\t\t\tunsatisfied += 1.0\n   121‚Üí\treturn unsatisfied\n   122‚Üí\n   123‚Üí\n   124‚Üí## Create a hash string for a state (for closed set lookup).\n   125‚Üífunc _hash_state(state: Dictionary) -> String:\n   126‚Üí\tvar keys := state.keys()\n   127‚Üí\tkeys.sort()\n   128‚Üí\tvar parts: Array[String] = []\n   129‚Üí\tfor key in keys:\n   130‚Üí\t\tparts.append(\"%s=%s\" % [key, state[key]])\n   131‚Üí\treturn \",\".join(parts)\n   132‚Üí\n   133‚Üí\n   134‚Üí## Log a debug message.\n   135‚Üífunc _log(message: String) -> void:\n   136‚Üí\tif debug_logging:\n   137‚Üí\t\tprint(\"[GOAPPlanner] %s\" % message)\n   138‚Üí\n   139‚Üí\n   140‚Üí## Internal class for A* search nodes.\n   141‚Üíclass PlanNode:\n   142‚Üí\tvar state: Dictionary\n   143‚Üí\tvar actions: Array[GOAPAction]\n   144‚Üí\tvar cost: float\n   145‚Üí\tvar heuristic: float\n   146‚Üí\n   147‚Üí\tfunc _init(s: Dictionary, a: Array[GOAPAction], c: float) -> void:\n   148‚Üí\t\tstate = s\n   149‚Üí\t\tactions = a\n   150‚Üí\t\tcost = c\n   151‚Üí\t\theuristic = 0.0\n   152‚Üí\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "32122fb0-8510-4d26-981e-cd128bd47d29",
  "tool_use_result": {
    "type": "text",
    "file": {
      "filePath": "/tmp/gh-issue-solver-1768704499561/scripts/ai/goap_planner.gd",
      "content": "class_name GOAPPlanner\nextends RefCounted\n## GOAP (Goal Oriented Action Planning) planner.\n##\n## This planner uses A* search to find the optimal sequence of actions\n## to achieve a goal from the current world state.\n##\n## Usage:\n##   var planner = GOAPPlanner.new()\n##   planner.add_action(some_action)\n##   var plan = planner.plan(current_state, goal_state)\n##   if plan.size() > 0:\n##       execute_plan(plan)\n\n## Available actions for planning.\nvar _actions: Array[GOAPAction] = []\n\n## Maximum planning depth to prevent infinite loops.\nvar max_depth: int = 10\n\n## Enable debug logging.\nvar debug_logging: bool = false\n\n\n## Add an action to the planner's available actions.\nfunc add_action(action: GOAPAction) -> void:\n\t_actions.append(action)\n\n\n## Remove an action from the planner.\nfunc remove_action(action: GOAPAction) -> void:\n\t_actions.erase(action)\n\n\n## Clear all actions.\nfunc clear_actions() -> void:\n\t_actions.clear()\n\n\n## Plan a sequence of actions to achieve the goal from the current state.\n## Returns an array of GOAPAction, or empty array if no plan found.\nfunc plan(current_state: Dictionary, goal: Dictionary, agent: Node = null) -> Array[GOAPAction]:\n\t_log(\"Planning from state: %s to goal: %s\" % [current_state, goal])\n\n\t# Check if goal is already satisfied\n\tif _is_goal_satisfied(current_state, goal):\n\t\t_log(\"Goal already satisfied!\")\n\t\treturn []\n\n\t# A* search for optimal plan\n\tvar open_set: Array = []  # Array of PlanNode\n\tvar closed_set: Dictionary = {}  # state_hash -> best_cost\n\n\t# Start node\n\tvar start_node := PlanNode.new(current_state, [], 0.0)\n\tstart_node.heuristic = _estimate_cost(current_state, goal)\n\topen_set.append(start_node)\n\n\tvar iterations := 0\n\tvar max_iterations := 1000  # Prevent infinite loops\n\n\twhile not open_set.is_empty() and iterations < max_iterations:\n\t\titerations += 1\n\n\t\t# Get node with lowest f-score (cost + heuristic)\n\t\topen_set.sort_custom(func(a, b): return (a.cost + a.heuristic) < (b.cost + b.heuristic))\n\t\tvar current: PlanNode = open_set.pop_front()\n\n\t\t# Check if we reached the goal\n\t\tif _is_goal_satisfied(current.state, goal):\n\t\t\t_log(\"Plan found in %d iterations: %s\" % [iterations, current.actions])\n\t\t\treturn current.actions\n\n\t\t# Skip if we've seen this state with lower cost\n\t\tvar state_hash := _hash_state(current.state)\n\t\tif closed_set.has(state_hash) and closed_set[state_hash] <= current.cost:\n\t\t\tcontinue\n\t\tclosed_set[state_hash] = current.cost\n\n\t\t# Check depth limit\n\t\tif current.actions.size() >= max_depth:\n\t\t\tcontinue\n\n\t\t# Expand node with all valid actions\n\t\tfor action in _actions:\n\t\t\tif action.is_valid(current.state):\n\t\t\t\tvar new_state := action.get_result_state(current.state)\n\t\t\t\tvar action_cost := action.get_cost(agent, current.state) if agent else action.cost\n\t\t\t\tvar new_cost := current.cost + action_cost\n\n\t\t\t\t# Create new plan with this action\n\t\t\t\tvar new_actions: Array[GOAPAction] = current.actions.duplicate()\n\t\t\t\tnew_actions.append(action)\n\n\t\t\t\tvar new_node := PlanNode.new(new_state, new_actions, new_cost)\n\t\t\t\tnew_node.heuristic = _estimate_cost(new_state, goal)\n\n\t\t\t\topen_set.append(new_node)\n\n\t_log(\"No plan found after %d iterations\" % iterations)\n\treturn []\n\n\n## Check if all goal conditions are satisfied in the current state.\nfunc _is_goal_satisfied(state: Dictionary, goal: Dictionary) -> bool:\n\tfor key in goal:\n\t\tif not state.has(key):\n\t\t\treturn false\n\t\tif state[key] != goal[key]:\n\t\t\treturn false\n\treturn true\n\n\n## Estimate the cost to reach the goal (heuristic for A*).\n## Returns the number of unsatisfied goal conditions.\nfunc _estimate_cost(state: Dictionary, goal: Dictionary) -> float:\n\tvar unsatisfied := 0.0\n\tfor key in goal:\n\t\tif not state.has(key) or state[key] != goal[key]:\n\t\t\tunsatisfied += 1.0\n\treturn unsatisfied\n\n\n## Create a hash string for a state (for closed set lookup).\nfunc _hash_state(state: Dictionary) -> String:\n\tvar keys := state.keys()\n\tkeys.sort()\n\tvar parts: Array[String] = []\n\tfor key in keys:\n\t\tparts.append(\"%s=%s\" % [key, state[key]])\n\treturn \",\".join(parts)\n\n\n## Log a debug message.\nfunc _log(message: String) -> void:\n\tif debug_logging:\n\t\tprint(\"[GOAPPlanner] %s\" % message)\n\n\n## Internal class for A* search nodes.\nclass PlanNode:\n\tvar state: Dictionary\n\tvar actions: Array[GOAPAction]\n\tvar cost: float\n\tvar heuristic: float\n\n\tfunc _init(s: Dictionary, a: Array[GOAPAction], c: float) -> void:\n\t\tstate = s\n\t\tactions = a\n\t\tcost = c\n\t\theuristic = 0.0\n",
      "numLines": 152,
      "startLine": 1,
      "totalLines": 152
    }
  }
}
[2026-01-18T02:49:05.449Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01GrnXiSv7JntcAGVejTL5LL",
        "type": "tool_result",
        "content": "     1‚Üíclass_name GOAPAction\n     2‚Üíextends RefCounted\n     3‚Üí## Base class for GOAP (Goal Oriented Action Planning) actions.\n     4‚Üí##\n     5‚Üí## This is a foundation for implementing goal-oriented AI behavior.\n     6‚Üí## Actions have preconditions (what must be true to execute) and\n     7‚Üí## effects (what becomes true after execution).\n     8‚Üí##\n     9‚Üí## To create a new action, extend this class and override the methods.\n    10‚Üí\n    11‚Üí## Name of this action for debugging.\n    12‚Üívar action_name: String = \"base_action\"\n    13‚Üí\n    14‚Üí## Cost of performing this action (lower is preferred).\n    15‚Üívar cost: float = 1.0\n    16‚Üí\n    17‚Üí## Preconditions required for this action to be valid.\n    18‚Üí## Dictionary of state_key -> required_value pairs.\n    19‚Üívar preconditions: Dictionary = {}\n    20‚Üí\n    21‚Üí## Effects of this action on the world state.\n    22‚Üí## Dictionary of state_key -> new_value pairs.\n    23‚Üívar effects: Dictionary = {}\n    24‚Üí\n    25‚Üí\n    26‚Üífunc _init(name: String = \"base_action\", action_cost: float = 1.0) -> void:\n    27‚Üí\taction_name = name\n    28‚Üí\tcost = action_cost\n    29‚Üí\n    30‚Üí\n    31‚Üí## Check if this action can be executed given the current world state.\n    32‚Üífunc is_valid(world_state: Dictionary) -> bool:\n    33‚Üí\tfor key in preconditions:\n    34‚Üí\t\tif not world_state.has(key):\n    35‚Üí\t\t\treturn false\n    36‚Üí\t\tif world_state[key] != preconditions[key]:\n    37‚Üí\t\t\treturn false\n    38‚Üí\treturn true\n    39‚Üí\n    40‚Üí\n    41‚Üí## Get the resulting world state after applying this action's effects.\n    42‚Üífunc get_result_state(world_state: Dictionary) -> Dictionary:\n    43‚Üí\tvar result := world_state.duplicate()\n    44‚Üí\tfor key in effects:\n    45‚Üí\t\tresult[key] = effects[key]\n    46‚Üí\treturn result\n    47‚Üí\n    48‚Üí\n    49‚Üí## Check if this action can satisfy the given goal.\n    50‚Üí## Returns true if any of the action's effects match a goal condition.\n    51‚Üífunc can_satisfy_goal(goal: Dictionary) -> bool:\n    52‚Üí\tfor key in goal:\n    53‚Üí\t\tif effects.has(key) and effects[key] == goal[key]:\n    54‚Üí\t\t\treturn true\n    55‚Üí\treturn false\n    56‚Üí\n    57‚Üí\n    58‚Üí## Execute the action. Override this in subclasses.\n    59‚Üí## Returns true if action started successfully.\n    60‚Üífunc execute(_agent: Node) -> bool:\n    61‚Üí\treturn true\n    62‚Üí\n    63‚Üí\n    64‚Üí## Check if the action is complete. Override this in subclasses.\n    65‚Üífunc is_complete(_agent: Node) -> bool:\n    66‚Üí\treturn true\n    67‚Üí\n    68‚Üí\n    69‚Üí## Get dynamic cost based on current state. Override for context-sensitive costs.\n    70‚Üífunc get_cost(_agent: Node, _world_state: Dictionary) -> float:\n    71‚Üí\treturn cost\n    72‚Üí\n    73‚Üí\n    74‚Üí## Create a string representation for debugging.\n    75‚Üífunc _to_string() -> String:\n    76‚Üí\treturn \"GOAPAction(%s, cost=%.1f)\" % [action_name, cost]\n    77‚Üí\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "9f8d9d34-1d83-42dc-b8ae-bf51069d068a",
  "tool_use_result": {
    "type": "text",
    "file": {
      "filePath": "/tmp/gh-issue-solver-1768704499561/scripts/ai/goap_action.gd",
      "content": "class_name GOAPAction\nextends RefCounted\n## Base class for GOAP (Goal Oriented Action Planning) actions.\n##\n## This is a foundation for implementing goal-oriented AI behavior.\n## Actions have preconditions (what must be true to execute) and\n## effects (what becomes true after execution).\n##\n## To create a new action, extend this class and override the methods.\n\n## Name of this action for debugging.\nvar action_name: String = \"base_action\"\n\n## Cost of performing this action (lower is preferred).\nvar cost: float = 1.0\n\n## Preconditions required for this action to be valid.\n## Dictionary of state_key -> required_value pairs.\nvar preconditions: Dictionary = {}\n\n## Effects of this action on the world state.\n## Dictionary of state_key -> new_value pairs.\nvar effects: Dictionary = {}\n\n\nfunc _init(name: String = \"base_action\", action_cost: float = 1.0) -> void:\n\taction_name = name\n\tcost = action_cost\n\n\n## Check if this action can be executed given the current world state.\nfunc is_valid(world_state: Dictionary) -> bool:\n\tfor key in preconditions:\n\t\tif not world_state.has(key):\n\t\t\treturn false\n\t\tif world_state[key] != preconditions[key]:\n\t\t\treturn false\n\treturn true\n\n\n## Get the resulting world state after applying this action's effects.\nfunc get_result_state(world_state: Dictionary) -> Dictionary:\n\tvar result := world_state.duplicate()\n\tfor key in effects:\n\t\tresult[key] = effects[key]\n\treturn result\n\n\n## Check if this action can satisfy the given goal.\n## Returns true if any of the action's effects match a goal condition.\nfunc can_satisfy_goal(goal: Dictionary) -> bool:\n\tfor key in goal:\n\t\tif effects.has(key) and effects[key] == goal[key]:\n\t\t\treturn true\n\treturn false\n\n\n## Execute the action. Override this in subclasses.\n## Returns true if action started successfully.\nfunc execute(_agent: Node) -> bool:\n\treturn true\n\n\n## Check if the action is complete. Override this in subclasses.\nfunc is_complete(_agent: Node) -> bool:\n\treturn true\n\n\n## Get dynamic cost based on current state. Override for context-sensitive costs.\nfunc get_cost(_agent: Node, _world_state: Dictionary) -> float:\n\treturn cost\n\n\n## Create a string representation for debugging.\nfunc _to_string() -> String:\n\treturn \"GOAPAction(%s, cost=%.1f)\" % [action_name, cost]\n",
      "numLines": 77,
      "startLine": 1,
      "totalLines": 77
    }
  }
}
[2026-01-18T02:49:05.477Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01X2aVHTC2qj4RNTzmSykgmA",
        "type": "tool_result",
        "content": "     1‚Üíclass_name EnemyActions\n     2‚Üíextends RefCounted\n     3‚Üí## Collection of GOAP actions for enemy AI.\n     4‚Üí##\n     5‚Üí## These actions define what enemies can do to achieve their goals.\n     6‚Üí## Each action has preconditions, effects, and costs that the\n     7‚Üí## GOAP planner uses to find optimal action sequences.\n     8‚Üí\n     9‚Üí\n    10‚Üí## Action to find and move to cover.\n    11‚Üíclass SeekCoverAction extends GOAPAction:\n    12‚Üí\tfunc _init() -> void:\n    13‚Üí\t\tsuper._init(\"seek_cover\", 2.0)\n    14‚Üí\t\tpreconditions = {\n    15‚Üí\t\t\t\"has_cover\": true,\n    16‚Üí\t\t\t\"in_cover\": false\n    17‚Üí\t\t}\n    18‚Üí\t\teffects = {\n    19‚Üí\t\t\t\"in_cover\": true,\n    20‚Üí\t\t\t\"under_fire\": false\n    21‚Üí\t\t}\n    22‚Üí\n    23‚Üí\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n    24‚Üí\t\t# Higher cost if we're actively engaging\n    25‚Üí\t\tif world_state.get(\"player_visible\", false):\n    26‚Üí\t\t\treturn 3.0\n    27‚Üí\t\treturn 2.0\n    28‚Üí\n    29‚Üí\n    30‚Üí## Action to engage the player in combat.\n    31‚Üíclass EngagePlayerAction extends GOAPAction:\n    32‚Üí\tfunc _init() -> void:\n    33‚Üí\t\tsuper._init(\"engage_player\", 1.0)\n    34‚Üí\t\tpreconditions = {\n    35‚Üí\t\t\t\"player_visible\": true\n    36‚Üí\t\t}\n    37‚Üí\t\teffects = {\n    38‚Üí\t\t\t\"player_engaged\": true\n    39‚Üí\t\t}\n    40‚Üí\n    41‚Üí\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n    42‚Üí\t\t# Lower cost if we have advantage (in cover, not under fire)\n    43‚Üí\t\tif world_state.get(\"in_cover\", false):\n    44‚Üí\t\t\treturn 0.5\n    45‚Üí\t\tif world_state.get(\"under_fire\", false):\n    46‚Üí\t\t\treturn 2.0\n    47‚Üí\t\treturn 1.0\n    48‚Üí\n    49‚Üí\n    50‚Üí## Action to flank the player.\n    51‚Üíclass FlankPlayerAction extends GOAPAction:\n    52‚Üí\tfunc _init() -> void:\n    53‚Üí\t\tsuper._init(\"flank_player\", 3.0)\n    54‚Üí\t\tpreconditions = {\n    55‚Üí\t\t\t\"player_visible\": false,\n    56‚Üí\t\t\t\"under_fire\": false\n    57‚Üí\t\t}\n    58‚Üí\t\teffects = {\n    59‚Üí\t\t\t\"at_flank_position\": true,\n    60‚Üí\t\t\t\"player_visible\": true\n    61‚Üí\t\t}\n    62‚Üí\n    63‚Üí\n    64‚Üí## Action to patrol the area.\n    65‚Üíclass PatrolAction extends GOAPAction:\n    66‚Üí\tfunc _init() -> void:\n    67‚Üí\t\tsuper._init(\"patrol\", 1.0)\n    68‚Üí\t\tpreconditions = {\n    69‚Üí\t\t\t\"player_visible\": false,\n    70‚Üí\t\t\t\"under_fire\": false\n    71‚Üí\t\t}\n    72‚Üí\t\teffects = {\n    73‚Üí\t\t\t\"area_patrolled\": true\n    74‚Üí\t\t}\n    75‚Üí\n    76‚Üí\n    77‚Üí## Action to stay suppressed (wait for fire to stop).\n    78‚Üíclass StaySuppressedAction extends GOAPAction:\n    79‚Üí\tfunc _init() -> void:\n    80‚Üí\t\tsuper._init(\"stay_suppressed\", 0.5)\n    81‚Üí\t\tpreconditions = {\n    82‚Üí\t\t\t\"under_fire\": true,\n    83‚Üí\t\t\t\"in_cover\": true\n    84‚Üí\t\t}\n    85‚Üí\t\teffects = {\n    86‚Üí\t\t\t\"waiting_for_safe\": true\n    87‚Üí\t\t}\n    88‚Üí\n    89‚Üí\n    90‚Üí## Action to return fire while suppressed.\n    91‚Üíclass ReturnFireAction extends GOAPAction:\n    92‚Üí\tfunc _init() -> void:\n    93‚Üí\t\tsuper._init(\"return_fire\", 1.5)\n    94‚Üí\t\tpreconditions = {\n    95‚Üí\t\t\t\"player_visible\": true,\n    96‚Üí\t\t\t\"in_cover\": true\n    97‚Üí\t\t}\n    98‚Üí\t\teffects = {\n    99‚Üí\t\t\t\"player_engaged\": true\n   100‚Üí\t\t}\n   101‚Üí\n   102‚Üí\n   103‚Üí## Action to find cover (search for cover positions).\n   104‚Üíclass FindCoverAction extends GOAPAction:\n   105‚Üí\tfunc _init() -> void:\n   106‚Üí\t\tsuper._init(\"find_cover\", 0.5)\n   107‚Üí\t\tpreconditions = {\n   108‚Üí\t\t\t\"has_cover\": false\n   109‚Üí\t\t}\n   110‚Üí\t\teffects = {\n   111‚Üí\t\t\t\"has_cover\": true\n   112‚Üí\t\t}\n   113‚Üí\n   114‚Üí\n   115‚Üí## Action to retreat when health is low.\n   116‚Üíclass RetreatAction extends GOAPAction:\n   117‚Üí\tfunc _init() -> void:\n   118‚Üí\t\tsuper._init(\"retreat\", 4.0)\n   119‚Üí\t\tpreconditions = {\n   120‚Üí\t\t\t\"health_low\": true\n   121‚Üí\t\t}\n   122‚Üí\t\teffects = {\n   123‚Üí\t\t\t\"in_cover\": true,\n   124‚Üí\t\t\t\"retreated\": true\n   125‚Üí\t\t}\n   126‚Üí\n   127‚Üí\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n   128‚Üí\t\t# Very high priority if under fire with low health\n   129‚Üí\t\tif world_state.get(\"under_fire\", false):\n   130‚Üí\t\t\treturn 1.0\n   131‚Üí\t\treturn 4.0\n   132‚Üí\n   133‚Üí\n   134‚Üí## Action to retreat with fire when under suppression (tactical retreat).\n   135‚Üí## Cost varies based on number of hits taken during encounter.\n   136‚Üíclass RetreatWithFireAction extends GOAPAction:\n   137‚Üí\tfunc _init() -> void:\n   138‚Üí\t\tsuper._init(\"retreat_with_fire\", 1.5)\n   139‚Üí\t\tpreconditions = {\n   140‚Üí\t\t\t\"under_fire\": true\n   141‚Üí\t\t}\n   142‚Üí\t\teffects = {\n   143‚Üí\t\t\t\"in_cover\": true,\n   144‚Üí\t\t\t\"is_retreating\": true\n   145‚Üí\t\t}\n   146‚Üí\n   147‚Üí\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n   148‚Üí\t\t# Cost is lower (higher priority) when under fire\n   149‚Üí\t\t# Priority also depends on hits taken\n   150‚Üí\t\tvar hits: int = world_state.get(\"hits_taken\", 0)\n   151‚Üí\t\tif hits == 0:\n   152‚Üí\t\t\t# Full HP - can afford to fight while retreating\n   153‚Üí\t\t\treturn 1.0\n   154‚Üí\t\telif hits == 1:\n   155‚Üí\t\t\t# One hit - quick burst then escape\n   156‚Üí\t\t\treturn 0.8\n   157‚Üí\t\telse:\n   158‚Üí\t\t\t# Multiple hits - just run!\n   159‚Üí\t\t\treturn 0.5\n   160‚Üí\n   161‚Üí\n   162‚Üí## Action to pursue the player by moving cover-to-cover.\n   163‚Üí## Used when enemy is far from player and can't hit them from current position.\n   164‚Üíclass PursuePlayerAction extends GOAPAction:\n   165‚Üí\tfunc _init() -> void:\n   166‚Üí\t\tsuper._init(\"pursue_player\", 2.5)\n   167‚Üí\t\tpreconditions = {\n   168‚Üí\t\t\t\"player_visible\": false,\n   169‚Üí\t\t\t\"player_close\": false\n   170‚Üí\t\t}\n   171‚Üí\t\teffects = {\n   172‚Üí\t\t\t\"is_pursuing\": true,\n   173‚Üí\t\t\t\"player_close\": true\n   174‚Üí\t\t}\n   175‚Üí\n   176‚Üí\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n   177‚Üí\t\t# Lower cost if we can't hit from current position\n   178‚Üí\t\tif not world_state.get(\"can_hit_from_cover\", false):\n   179‚Üí\t\t\treturn 1.5\n   180‚Üí\t\treturn 3.0\n   181‚Üí\n   182‚Üí\n   183‚Üí## Action to initiate coordinated assault when multiple enemies are in combat.\n   184‚Üí## All enemies rush the player simultaneously after a 5 second wait.\n   185‚Üíclass AssaultPlayerAction extends GOAPAction:\n   186‚Üí\tfunc _init() -> void:\n   187‚Üí\t\tsuper._init(\"assault_player\", 1.0)\n   188‚Üí\t\tpreconditions = {\n   189‚Üí\t\t\t\"player_visible\": true\n   190‚Üí\t\t}\n   191‚Üí\t\teffects = {\n   192‚Üí\t\t\t\"is_assaulting\": true,\n   193‚Üí\t\t\t\"player_engaged\": true\n   194‚Üí\t\t}\n   195‚Üí\n   196‚Üí\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n   197‚Üí\t\t# Only low cost if multiple enemies are in combat\n   198‚Üí\t\tvar enemies_count: int = world_state.get(\"enemies_in_combat\", 0)\n   199‚Üí\t\tif enemies_count >= 2:\n   200‚Üí\t\t\treturn 0.5  # High priority for coordinated attack\n   201‚Üí\t\treturn 5.0  # Very high cost if alone (prefer other actions)\n   202‚Üí\n   203‚Üí\n   204‚Üí## Create and return all enemy actions.\n   205‚Üístatic func create_all_actions() -> Array[GOAPAction]:\n   206‚Üí\tvar actions: Array[GOAPAction] = []\n   207‚Üí\tactions.append(SeekCoverAction.new())\n   208‚Üí\tactions.append(EngagePlayerAction.new())\n   209‚Üí\tactions.append(FlankPlayerAction.new())\n   210‚Üí\tactions.append(PatrolAction.new())\n   211‚Üí\tactions.append(StaySuppressedAction.new())\n   212‚Üí\tactions.append(ReturnFireAction.new())\n   213‚Üí\tactions.append(FindCoverAction.new())\n   214‚Üí\tactions.append(RetreatAction.new())\n   215‚Üí\tactions.append(RetreatWithFireAction.new())\n   216‚Üí\tactions.append(PursuePlayerAction.new())\n   217‚Üí\tactions.append(AssaultPlayerAction.new())\n   218‚Üí\treturn actions\n   219‚Üí\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "65ce5208-f00b-4b06-bd8a-41f4e8ec81c2",
  "tool_use_result": {
    "type": "text",
    "file": {
      "filePath": "/tmp/gh-issue-solver-1768704499561/scripts/ai/enemy_actions.gd",
      "content": "class_name EnemyActions\nextends RefCounted\n## Collection of GOAP actions for enemy AI.\n##\n## These actions define what enemies can do to achieve their goals.\n## Each action has preconditions, effects, and costs that the\n## GOAP planner uses to find optimal action sequences.\n\n\n## Action to find and move to cover.\nclass SeekCoverAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"seek_cover\", 2.0)\n\t\tpreconditions = {\n\t\t\t\"has_cover\": true,\n\t\t\t\"in_cover\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"in_cover\": true,\n\t\t\t\"under_fire\": false\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Higher cost if we're actively engaging\n\t\tif world_state.get(\"player_visible\", false):\n\t\t\treturn 3.0\n\t\treturn 2.0\n\n\n## Action to engage the player in combat.\nclass EngagePlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"engage_player\", 1.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"player_engaged\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Lower cost if we have advantage (in cover, not under fire)\n\t\tif world_state.get(\"in_cover\", false):\n\t\t\treturn 0.5\n\t\tif world_state.get(\"under_fire\", false):\n\t\t\treturn 2.0\n\t\treturn 1.0\n\n\n## Action to flank the player.\nclass FlankPlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"flank_player\", 3.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": false,\n\t\t\t\"under_fire\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"at_flank_position\": true,\n\t\t\t\"player_visible\": true\n\t\t}\n\n\n## Action to patrol the area.\nclass PatrolAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"patrol\", 1.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": false,\n\t\t\t\"under_fire\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"area_patrolled\": true\n\t\t}\n\n\n## Action to stay suppressed (wait for fire to stop).\nclass StaySuppressedAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"stay_suppressed\", 0.5)\n\t\tpreconditions = {\n\t\t\t\"under_fire\": true,\n\t\t\t\"in_cover\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"waiting_for_safe\": true\n\t\t}\n\n\n## Action to return fire while suppressed.\nclass ReturnFireAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"return_fire\", 1.5)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": true,\n\t\t\t\"in_cover\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"player_engaged\": true\n\t\t}\n\n\n## Action to find cover (search for cover positions).\nclass FindCoverAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"find_cover\", 0.5)\n\t\tpreconditions = {\n\t\t\t\"has_cover\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"has_cover\": true\n\t\t}\n\n\n## Action to retreat when health is low.\nclass RetreatAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"retreat\", 4.0)\n\t\tpreconditions = {\n\t\t\t\"health_low\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"in_cover\": true,\n\t\t\t\"retreated\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Very high priority if under fire with low health\n\t\tif world_state.get(\"under_fire\", false):\n\t\t\treturn 1.0\n\t\treturn 4.0\n\n\n## Action to retreat with fire when under suppression (tactical retreat).\n## Cost varies based on number of hits taken during encounter.\nclass RetreatWithFireAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"retreat_with_fire\", 1.5)\n\t\tpreconditions = {\n\t\t\t\"under_fire\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"in_cover\": true,\n\t\t\t\"is_retreating\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Cost is lower (higher priority) when under fire\n\t\t# Priority also depends on hits taken\n\t\tvar hits: int = world_state.get(\"hits_taken\", 0)\n\t\tif hits == 0:\n\t\t\t# Full HP - can afford to fight while retreating\n\t\t\treturn 1.0\n\t\telif hits == 1:\n\t\t\t# One hit - quick burst then escape\n\t\t\treturn 0.8\n\t\telse:\n\t\t\t# Multiple hits - just run!\n\t\t\treturn 0.5\n\n\n## Action to pursue the player by moving cover-to-cover.\n## Used when enemy is far from player and can't hit them from current position.\nclass PursuePlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"pursue_player\", 2.5)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": false,\n\t\t\t\"player_close\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"is_pursuing\": true,\n\t\t\t\"player_close\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Lower cost if we can't hit from current position\n\t\tif not world_state.get(\"can_hit_from_cover\", false):\n\t\t\treturn 1.5\n\t\treturn 3.0\n\n\n## Action to initiate coordinated assault when multiple enemies are in combat.\n## All enemies rush the player simultaneously after a 5 second wait.\nclass AssaultPlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"assault_player\", 1.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"is_assaulting\": true,\n\t\t\t\"player_engaged\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Only low cost if multiple enemies are in combat\n\t\tvar enemies_count: int = world_state.get(\"enemies_in_combat\", 0)\n\t\tif enemies_count >= 2:\n\t\t\treturn 0.5  # High priority for coordinated attack\n\t\treturn 5.0  # Very high cost if alone (prefer other actions)\n\n\n## Create and return all enemy actions.\nstatic func create_all_actions() -> Array[GOAPAction]:\n\tvar actions: Array[GOAPAction] = []\n\tactions.append(SeekCoverAction.new())\n\tactions.append(EngagePlayerAction.new())\n\tactions.append(FlankPlayerAction.new())\n\tactions.append(PatrolAction.new())\n\tactions.append(StaySuppressedAction.new())\n\tactions.append(ReturnFireAction.new())\n\tactions.append(FindCoverAction.new())\n\tactions.append(RetreatAction.new())\n\tactions.append(RetreatWithFireAction.new())\n\tactions.append(PursuePlayerAction.new())\n\tactions.append(AssaultPlayerAction.new())\n\treturn actions\n",
      "numLines": 219,
      "startLine": 1,
      "totalLines": 219
    }
  }
}
[2026-01-18T02:49:05.727Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "type": "tool_result",
        "content": "File content (34721 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.",
        "is_error": true,
        "tool_use_id": "toolu_01GnnhscudK7dFbAqyJWLwiZ"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "e5629019-aa12-443f-ba45-60fe3541afbb",
  "tool_use_result": "Error: File content (34721 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."
}
[2026-01-18T02:49:08.647Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_015C6PejmVZX735wuVQDTxrF",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "The enemy.gd file is large. Let me read it in chunks and also create a todo list to track my work."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 6329,
      "cache_read_input_tokens": 30913,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 6329,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "c7f86949-c3a9-4ca7-95bd-25004294b191"
}
[2026-01-18T02:49:13.542Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_015C6PejmVZX735wuVQDTxrF",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01Q33bPQWhEjAxVrrqLvtnVi",
        "name": "TodoWrite",
        "input": {
          "todos": [
            {
              "content": "Read and analyze issue #103 requirements",
              "status": "completed",
              "activeForm": "Reading issue requirements"
            },
            {
              "content": "Explore existing AI/GOAP system architecture",
              "status": "in_progress",
              "activeForm": "Exploring AI/GOAP system architecture"
            },
            {
              "content": "Create case study directory structure",
              "status": "pending",
              "activeForm": "Creating case study directory structure"
            },
            {
              "content": "Research GOAP and AI search patterns online",
              "status": "pending",
              "activeForm": "Researching GOAP and AI search patterns"
            },
            {
              "content": "Document timeline and sequence of events",
              "status": "pending",
              "activeForm": "Documenting timeline and events"
            },
            {
              "content": "Identify root causes and propose solutions",
              "status": "pending",
              "activeForm": "Identifying root causes and solutions"
            },
            {
              "content": "Implement enemy search behavior",
              "status": "pending",
              "activeForm": "Implementing enemy search behavior"
            },
            {
              "content": "Add patrol points for hiding spots",
              "status": "pending",
              "activeForm": "Adding patrol points for hiding spots"
            },
            {
              "content": "Test and verify implementation",
              "status": "pending",
              "activeForm": "Testing implementation"
            },
            {
              "content": "Update PR description and finalize",
              "status": "pending",
              "activeForm": "Updating PR and finalizing"
            }
          ]
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 6329,
      "cache_read_input_tokens": 30913,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 6329,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "0f38bbf4-42d6-4434-a557-ffa74325cda8"
}
[2026-01-18T02:49:14.861Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_015C6PejmVZX735wuVQDTxrF",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01WTQrsp5VMvPHGgKfRRi177",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "offset": 1,
          "limit": 400
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 6329,
      "cache_read_input_tokens": 30913,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 6329,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "dca2f43d-2be6-46a9-9c49-33ff9d9147cc"
}
[2026-01-18T02:49:14.903Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01Q33bPQWhEjAxVrrqLvtnVi",
        "type": "tool_result",
        "content": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "83b5e2bd-d22f-47cd-99ba-563825c54ea5",
  "tool_use_result": {
    "oldTodos": [],
    "newTodos": [
      {
        "content": "Read and analyze issue #103 requirements",
        "status": "completed",
        "activeForm": "Reading issue requirements"
      },
      {
        "content": "Explore existing AI/GOAP system architecture",
        "status": "in_progress",
        "activeForm": "Exploring AI/GOAP system architecture"
      },
      {
        "content": "Create case study directory structure",
        "status": "pending",
        "activeForm": "Creating case study directory structure"
      },
      {
        "content": "Research GOAP and AI search patterns online",
        "status": "pending",
        "activeForm": "Researching GOAP and AI search patterns"
      },
      {
        "content": "Document timeline and sequence of events",
        "status": "pending",
        "activeForm": "Documenting timeline and events"
      },
      {
        "content": "Identify root causes and propose solutions",
        "status": "pending",
        "activeForm": "Identifying root causes and solutions"
      },
      {
        "content": "Implement enemy search behavior",
        "status": "pending",
        "activeForm": "Implementing enemy search behavior"
      },
      {
        "content": "Add patrol points for hiding spots",
        "status": "pending",
        "activeForm": "Adding patrol points for hiding spots"
      },
      {
        "content": "Test and verify implementation",
        "status": "pending",
        "activeForm": "Testing implementation"
      },
      {
        "content": "Update PR description and finalize",
        "status": "pending",
        "activeForm": "Updating PR and finalizing"
      }
    ]
  }
}
[2026-01-18T02:49:14.928Z] [INFO] {"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WTQrsp5VMvPHGgKfRRi177","type":"tool_result","content":"     1‚Üíextends CharacterBody2D\n     2‚Üí## Enemy AI with tactical behaviors including patrol, guard, cover, and flanking.\n     3‚Üí##\n     4‚Üí## Supports multiple behavior modes:\n     5‚Üí## - PATROL: Moves between patrol points\n     6‚Üí## - GUARD: Stands in place watching for the player\n     7‚Üí##\n     8‚Üí## Tactical features:\n     9‚Üí## - Uses cover when under fire (suppression)\n    10‚Üí## - Attempts to flank the player from the sides\n    11‚Üí## - Coordinates with other enemies (optional)\n    12‚Üí## - GOAP foundation for goal-oriented planning\n    13‚Üí\n    14‚Üí## AI States for tactical behavior.\n    15‚Üíenum AIState {\n    16‚Üí\tIDLE,       ## Default idle state (patrol or guard)\n    17‚Üí\tCOMBAT,     ## Actively engaging the player (coming out of cover, shooting 2-3s, returning)\n    18‚Üí\tSEEKING_COVER,  ## Moving to cover position\n    19‚Üí\tIN_COVER,   ## Taking cover from player fire\n    20‚Üí\tFLANKING,   ## Attempting to flank the player\n    21‚Üí\tSUPPRESSED, ## Under fire, staying in cover\n    22‚Üí\tRETREATING, ## Retreating to cover while possibly shooting\n    23‚Üí\tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n    24‚Üí\tASSAULT     ## Coordinated multi-enemy assault (rush player after 5s wait)\n    25‚Üí}\n    26‚Üí\n    27‚Üí## Retreat behavior modes based on damage taken.\n    28‚Üíenum RetreatMode {\n    29‚Üí\tFULL_HP,        ## No damage - retreat backwards while shooting, periodically turn to cover\n    30‚Üí\tONE_HIT,        ## One hit taken - quick burst then retreat without shooting\n    31‚Üí\tMULTIPLE_HITS   ## Multiple hits - quick burst then retreat without shooting (same as ONE_HIT)\n    32‚Üí}\n    33‚Üí\n    34‚Üí## Behavior modes for the enemy.\n    35‚Üíenum BehaviorMode {\n    36‚Üí\tPATROL,  ## Moves between patrol points\n    37‚Üí\tGUARD    ## Stands in one place\n    38‚Üí}\n    39‚Üí\n    40‚Üí## Current behavior mode.\n    41‚Üí@export var behavior_mode: BehaviorMode = BehaviorMode.GUARD\n    42‚Üí\n    43‚Üí## Maximum movement speed in pixels per second.\n    44‚Üí@export var move_speed: float = 220.0\n    45‚Üí\n    46‚Üí## Combat movement speed (faster when flanking/seeking cover).\n    47‚Üí@export var combat_move_speed: float = 320.0\n    48‚Üí\n    49‚Üí## Rotation speed in radians per second for gradual turning.\n    50‚Üí## Default is 15 rad/sec for challenging but fair combat.\n    51‚Üí@export var rotation_speed: float = 15.0\n    52‚Üí\n    53‚Üí## Detection range for spotting the player.\n    54‚Üí## Set to 0 or negative to allow unlimited detection range (line-of-sight only).\n    55‚Üí## This allows enemies to see the player even outside the viewport if no obstacles block view.\n    56‚Üí@export var detection_range: float = 0.0\n    57‚Üí\n    58‚Üí## Time between shots in seconds.\n    59‚Üí## Default matches assault rifle fire rate (10 shots/second = 0.1s cooldown).\n    60‚Üí@export var shoot_cooldown: float = 0.1\n    61‚Üí\n    62‚Üí## Bullet scene to instantiate when shooting.\n    63‚Üí@export var bullet_scene: PackedScene\n    64‚Üí\n    65‚Üí## Offset from enemy center for bullet spawn position.\n    66‚Üí@export var bullet_spawn_offset: float = 30.0\n    67‚Üí\n    68‚Üí## Patrol points as offsets from the initial position.\n    69‚Üí## Only used when behavior_mode is PATROL.\n    70‚Üí@export var patrol_offsets: Array[Vector2] = [Vector2(100, 0), Vector2(-100, 0)]\n    71‚Üí\n    72‚Üí## Wait time at each patrol point in seconds.\n    73‚Üí@export var patrol_wait_time: float = 1.5\n    74‚Üí\n    75‚Üí## Color when at full health.\n    76‚Üí@export var full_health_color: Color = Color(0.9, 0.2, 0.2, 1.0)\n    77‚Üí\n    78‚Üí## Color when at low health (interpolates based on health percentage).\n    79‚Üí@export var low_health_color: Color = Color(0.3, 0.1, 0.1, 1.0)\n    80‚Üí\n    81‚Üí## Color to flash when hit.\n    82‚Üí@export var hit_flash_color: Color = Color(1.0, 1.0, 1.0, 1.0)\n    83‚Üí\n    84‚Üí## Duration of hit flash effect in seconds.\n    85‚Üí@export var hit_flash_duration: float = 0.1\n    86‚Üí\n    87‚Üí## Whether to destroy the enemy after death.\n    88‚Üí@export var destroy_on_death: bool = false\n    89‚Üí\n    90‚Üí## Delay before respawning or destroying (in seconds).\n    91‚Üí@export var respawn_delay: float = 2.0\n    92‚Üí\n    93‚Üí## Minimum random health.\n    94‚Üí@export var min_health: int = 2\n    95‚Üí\n    96‚Üí## Maximum random health.\n    97‚Üí@export var max_health: int = 4\n    98‚Üí\n    99‚Üí## Threat sphere radius - bullets within this radius trigger suppression.\n   100‚Üí@export var threat_sphere_radius: float = 100.0\n   101‚Üí\n   102‚Üí## Time to stay suppressed after bullets leave threat sphere.\n   103‚Üí@export var suppression_cooldown: float = 2.0\n   104‚Üí\n   105‚Üí## Delay (in seconds) before reacting to bullets in the threat sphere.\n   106‚Üí## This prevents instant reactions to nearby gunfire, giving the player more time.\n   107‚Üí@export var threat_reaction_delay: float = 0.2\n   108‚Üí\n   109‚Üí## Flank angle from player's facing direction (radians).\n   110‚Üí@export var flank_angle: float = PI / 3.0  # 60 degrees\n   111‚Üí\n   112‚Üí## Distance to maintain while flanking.\n   113‚Üí@export var flank_distance: float = 200.0\n   114‚Üí\n   115‚Üí## Enable/disable flanking behavior.\n   116‚Üí@export var enable_flanking: bool = true\n   117‚Üí\n   118‚Üí## Enable/disable cover behavior.\n   119‚Üí@export var enable_cover: bool = true\n   120‚Üí\n   121‚Üí## Enable/disable debug logging.\n   122‚Üí@export var debug_logging: bool = false\n   123‚Üí\n   124‚Üí## Enable/disable debug label above enemy showing current AI state.\n   125‚Üí@export var debug_label_enabled: bool = false\n   126‚Üí\n   127‚Üí## Enable/disable friendly fire avoidance (don't shoot if other enemies are in the way).\n   128‚Üí@export var enable_friendly_fire_avoidance: bool = true\n   129‚Üí\n   130‚Üí## Enable/disable lead prediction (shooting ahead of moving targets).\n   131‚Üí@export var enable_lead_prediction: bool = true\n   132‚Üí\n   133‚Üí## Bullet speed for lead prediction calculation.\n   134‚Üí## Should match the actual bullet speed (default is 2500 for assault rifle).\n   135‚Üí@export var bullet_speed: float = 2500.0\n   136‚Üí\n   137‚Üí## Ammunition system - magazine size (bullets per magazine).\n   138‚Üí@export var magazine_size: int = 30\n   139‚Üí\n   140‚Üí## Ammunition system - number of magazines the enemy carries.\n   141‚Üí@export var total_magazines: int = 5\n   142‚Üí\n   143‚Üí## Ammunition system - time to reload in seconds.\n   144‚Üí@export var reload_time: float = 3.0\n   145‚Üí\n   146‚Üí## Delay (in seconds) between spotting player and starting to shoot.\n   147‚Üí## Gives player a brief reaction time when entering enemy line of sight.\n   148‚Üí## This delay \"recharges\" each time the player breaks direct contact with the enemy.\n   149‚Üí@export var detection_delay: float = 0.2\n   150‚Üí\n   151‚Üí## Minimum time (in seconds) the player must be continuously visible before\n   152‚Üí## lead prediction is enabled. This prevents enemies from predicting player\n   153‚Üí## position immediately when they emerge from cover.\n   154‚Üí@export var lead_prediction_delay: float = 0.3\n   155‚Üí\n   156‚Üí## Minimum visibility ratio (0.0 to 1.0) of player body that must be visible\n   157‚Üí## before lead prediction is enabled. At 1.0, the player's entire body must be\n   158‚Üí## visible. At 0.5, at least half of the check points must be visible.\n   159‚Üí## This prevents pre-firing at players who are at cover edges.\n   160‚Üí@export var lead_prediction_visibility_threshold: float = 0.6\n   161‚Üí\n   162‚Üí## Signal emitted when the enemy is hit.\n   163‚Üísignal hit\n   164‚Üí\n   165‚Üí## Signal emitted when the enemy dies.\n   166‚Üísignal died\n   167‚Üí\n   168‚Üí## Signal emitted when AI state changes.\n   169‚Üísignal state_changed(new_state: AIState)\n   170‚Üí\n   171‚Üí## Signal emitted when ammunition changes.\n   172‚Üísignal ammo_changed(current_ammo: int, reserve_ammo: int)\n   173‚Üí\n   174‚Üí## Signal emitted when reloading starts.\n   175‚Üísignal reload_started\n   176‚Üí\n   177‚Üí## Signal emitted when reloading finishes.\n   178‚Üísignal reload_finished\n   179‚Üí\n   180‚Üí## Signal emitted when all ammunition is depleted.\n   181‚Üísignal ammo_depleted\n   182‚Üí\n   183‚Üí## Reference to the sprite for color changes.\n   184‚Üí@onready var _sprite: Sprite2D = $Sprite2D\n   185‚Üí\n   186‚Üí## RayCast2D for line of sight detection.\n   187‚Üí@onready var _raycast: RayCast2D = $RayCast2D\n   188‚Üí\n   189‚Üí## Debug label for showing current AI state above the enemy.\n   190‚Üí@onready var _debug_label: Label = $DebugLabel\n   191‚Üí\n   192‚Üí## Wall detection raycasts for obstacle avoidance (created at runtime).\n   193‚Üívar _wall_raycasts: Array[RayCast2D] = []\n   194‚Üí\n   195‚Üí## Distance to check for walls ahead.\n   196‚Üíconst WALL_CHECK_DISTANCE: float = 40.0\n   197‚Üí\n   198‚Üí## Number of raycasts for wall detection (spread around the enemy).\n   199‚Üíconst WALL_CHECK_COUNT: int = 3\n   200‚Üí\n   201‚Üí## Cover detection raycasts (created at runtime).\n   202‚Üívar _cover_raycasts: Array[RayCast2D] = []\n   203‚Üí\n   204‚Üí## Number of raycasts for cover detection.\n   205‚Üíconst COVER_CHECK_COUNT: int = 16\n   206‚Üí\n   207‚Üí## Distance to check for cover.\n   208‚Üíconst COVER_CHECK_DISTANCE: float = 300.0\n   209‚Üí\n   210‚Üí## Current health of the enemy.\n   211‚Üívar _current_health: int = 0\n   212‚Üí\n   213‚Üí## Maximum health of the enemy (set at spawn).\n   214‚Üívar _max_health: int = 0\n   215‚Üí\n   216‚Üí## Whether the enemy is alive.\n   217‚Üívar _is_alive: bool = true\n   218‚Üí\n   219‚Üí## Reference to the player (found at runtime).\n   220‚Üívar _player: Node2D = null\n   221‚Üí\n   222‚Üí## Time since last shot.\n   223‚Üívar _shoot_timer: float = 0.0\n   224‚Üí\n   225‚Üí## Current ammo in the magazine.\n   226‚Üívar _current_ammo: int = 0\n   227‚Üí\n   228‚Üí## Reserve ammo (ammo in remaining magazines).\n   229‚Üívar _reserve_ammo: int = 0\n   230‚Üí\n   231‚Üí## Whether the enemy is currently reloading.\n   232‚Üívar _is_reloading: bool = false\n   233‚Üí\n   234‚Üí## Timer for reload progress.\n   235‚Üívar _reload_timer: float = 0.0\n   236‚Üí\n   237‚Üí## Patrol state variables.\n   238‚Üívar _patrol_points: Array[Vector2] = []\n   239‚Üívar _current_patrol_index: int = 0\n   240‚Üívar _is_waiting_at_patrol_point: bool = false\n   241‚Üívar _patrol_wait_timer: float = 0.0\n   242‚Üívar _initial_position: Vector2\n   243‚Üí\n   244‚Üí## Whether the enemy can currently see the player.\n   245‚Üívar _can_see_player: bool = false\n   246‚Üí\n   247‚Üí## Current AI state.\n   248‚Üívar _current_state: AIState = AIState.IDLE\n   249‚Üí\n   250‚Üí## Current cover position (if any).\n   251‚Üívar _cover_position: Vector2 = Vector2.ZERO\n   252‚Üí\n   253‚Üí## Is currently in a valid cover position.\n   254‚Üívar _has_valid_cover: bool = false\n   255‚Üí\n   256‚Üí## Timer for suppression cooldown.\n   257‚Üívar _suppression_timer: float = 0.0\n   258‚Üí\n   259‚Üí## Whether enemy is currently under fire (bullets in threat sphere).\n   260‚Üívar _under_fire: bool = false\n   261‚Üí\n   262‚Üí## Flank target position.\n   263‚Üívar _flank_target: Vector2 = Vector2.ZERO\n   264‚Üí\n   265‚Üí## Threat sphere Area2D for detecting nearby bullets.\n   266‚Üívar _threat_sphere: Area2D = null\n   267‚Üí\n   268‚Üí## Bullets currently in threat sphere.\n   269‚Üívar _bullets_in_threat_sphere: Array = []\n   270‚Üí\n   271‚Üí## Timer for threat reaction delay - time since first bullet entered threat sphere.\n   272‚Üívar _threat_reaction_timer: float = 0.0\n   273‚Üí\n   274‚Üí## Whether the threat reaction delay has elapsed (enemy can react to bullets).\n   275‚Üívar _threat_reaction_delay_elapsed: bool = false\n   276‚Üí\n   277‚Üí## Memory of bullets that have passed through the threat sphere recently.\n   278‚Üí## This allows the enemy to react even after fast-moving bullets have exited.\n   279‚Üívar _threat_memory_timer: float = 0.0\n   280‚Üí\n   281‚Üí## Duration to remember that a bullet passed through the threat sphere.\n   282‚Üí## This should be longer than the reaction delay to ensure enemies can complete\n   283‚Üí## their reac
[2026-01-18T02:49:14.935Z] [INFO] tion even after bullets have passed through quickly.\n   284‚Üíconst THREAT_MEMORY_DURATION: float = 0.5\n   285‚Üí\n   286‚Üí## Current retreat mode determined by damage taken.\n   287‚Üívar _retreat_mode: RetreatMode = RetreatMode.FULL_HP\n   288‚Üí\n   289‚Üí## Number of hits taken during the current retreat/combat encounter.\n   290‚Üí## Resets when enemy enters IDLE state or finishes retreating.\n   291‚Üívar _hits_taken_in_encounter: int = 0\n   292‚Üí\n   293‚Üí## Timer for periodic turning to cover during FULL_HP retreat.\n   294‚Üívar _retreat_turn_timer: float = 0.0\n   295‚Üí\n   296‚Üí## Duration to face cover during FULL_HP retreat turn (seconds).\n   297‚Üíconst RETREAT_TURN_DURATION: float = 0.8\n   298‚Üí\n   299‚Üí## Interval between turns toward cover in FULL_HP retreat (seconds).\n   300‚Üíconst RETREAT_TURN_INTERVAL: float = 1.5\n   301‚Üí\n   302‚Üí## Whether currently in the \"turn to cover\" phase of FULL_HP retreat.\n   303‚Üívar _retreat_turning_to_cover: bool = false\n   304‚Üí\n   305‚Üí## Burst fire counter for ONE_HIT retreat mode.\n   306‚Üívar _retreat_burst_remaining: int = 0\n   307‚Üí\n   308‚Üí## Timer for burst fire cooldown in ONE_HIT retreat.\n   309‚Üívar _retreat_burst_timer: float = 0.0\n   310‚Üí\n   311‚Üí## Fast cooldown between burst shots (seconds).\n   312‚Üíconst RETREAT_BURST_COOLDOWN: float = 0.06\n   313‚Üí\n   314‚Üí## Whether burst fire phase is complete in ONE_HIT retreat.\n   315‚Üívar _retreat_burst_complete: bool = false\n   316‚Üí\n   317‚Üí## Accuracy reduction during retreat (multiplier for inaccuracy angle spread).\n   318‚Üíconst RETREAT_INACCURACY_SPREAD: float = 0.15\n   319‚Üí\n   320‚Üí## Arc spread for ONE_HIT burst fire (radians, total spread).\n   321‚Üíconst RETREAT_BURST_ARC: float = 0.4\n   322‚Üí\n   323‚Üí## Current angle offset within burst arc.\n   324‚Üívar _retreat_burst_angle_offset: float = 0.0\n   325‚Üí\n   326‚Üí## Whether enemy is in \"alarm\" mode (was suppressed/retreating and hasn't calmed down).\n   327‚Üí## This persists until the enemy reaches safety in cover or returns to idle.\n   328‚Üívar _in_alarm_mode: bool = false\n   329‚Üí\n   330‚Üí## Whether the enemy needs to fire a cover burst (when leaving cover while in alarm).\n   331‚Üívar _cover_burst_pending: bool = false\n   332‚Üí\n   333‚Üí## --- Combat Cover Cycling (come out, shoot 2-3s, go back) ---\n   334‚Üí## Timer for how long the enemy has been shooting while out of cover.\n   335‚Üívar _combat_shoot_timer: float = 0.0\n   336‚Üí\n   337‚Üí## Duration to shoot while out of cover (2-3 seconds, randomized).\n   338‚Üívar _combat_shoot_duration: float = 2.5\n   339‚Üí\n   340‚Üí## Whether the enemy is currently in the \"exposed shooting\" phase of combat.\n   341‚Üívar _combat_exposed: bool = false\n   342‚Üí\n   343‚Üí## Whether the enemy is in the \"approaching player\" phase of combat.\n   344‚Üí## In this phase, the enemy moves toward the player to get into direct contact.\n   345‚Üívar _combat_approaching: bool = false\n   346‚Üí\n   347‚Üí## Timer for the approach phase of combat.\n   348‚Üívar _combat_approach_timer: float = 0.0\n   349‚Üí\n   350‚Üí## Maximum time to spend approaching player before starting to shoot (seconds).\n   351‚Üíconst COMBAT_APPROACH_MAX_TIME: float = 2.0\n   352‚Üí\n   353‚Üí## Distance at which enemy is considered \"close enough\" to start shooting phase.\n   354‚Üíconst COMBAT_DIRECT_CONTACT_DISTANCE: float = 250.0\n   355‚Üí\n   356‚Üí## --- Pursuit State (cover-to-cover movement) ---\n   357‚Üí## Timer for waiting at cover during pursuit.\n   358‚Üívar _pursuit_cover_wait_timer: float = 0.0\n   359‚Üí\n   360‚Üí## Duration to wait at each cover during pursuit (1-2 seconds, reduced for faster pursuit).\n   361‚Üíconst PURSUIT_COVER_WAIT_DURATION: float = 1.5\n   362‚Üí\n   363‚Üí## Current pursuit target cover position.\n   364‚Üívar _pursuit_next_cover: Vector2 = Vector2.ZERO\n   365‚Üí\n   366‚Üí## Whether the enemy has a valid pursuit cover target.\n   367‚Üívar _has_pursuit_cover: bool = false\n   368‚Üí\n   369‚Üí## --- Flanking State (cover-to-cover movement toward flank target) ---\n   370‚Üí## Timer for waiting at cover during flanking.\n   371‚Üívar _flank_cover_wait_timer: float = 0.0\n   372‚Üí\n   373‚Üí## Duration to wait at each cover during flanking (seconds).\n   374‚Üíconst FLANK_COVER_WAIT_DURATION: float = 0.8\n   375‚Üí\n   376‚Üí## Current flank cover position to move to.\n   377‚Üívar _flank_next_cover: Vector2 = Vector2.ZERO\n   378‚Üí\n   379‚Üí## Whether the enemy has a valid flank cover target.\n   380‚Üívar _has_flank_cover: bool = false\n   381‚Üí\n   382‚Üí## --- Assault State (coordinated multi-enemy rush) ---\n   383‚Üí## Timer for assault wait period (5 seconds before rushing).\n   384‚Üívar _assault_wait_timer: float = 0.0\n   385‚Üí\n   386‚Üí## Duration to wait at cover before assault (5 seconds).\n   387‚Üíconst ASSAULT_WAIT_DURATION: float = 5.0\n   388‚Üí\n   389‚Üí## Whether the assault wait period is complete.\n   390‚Üívar _assault_ready: bool = false\n   391‚Üí\n   392‚Üí## Whether this enemy is currently participating in an assault.\n   393‚Üívar _in_assault: bool = false\n   394‚Üí\n   395‚Üí## Distance threshold for \"close\" vs \"far\" from player.\n   396‚Üí## Used to determine if enemy can engage from current position or needs to pursue.\n   397‚Üíconst CLOSE_COMBAT_DISTANCE: float = 400.0\n   398‚Üí\n   399‚Üí## GOAP world state for goal-oriented planning.\n   400‚Üívar _goap_world_state: Dictionary = {}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"797fbac8-f5e6-4339-8fd2-77453410db49","uuid":"4b6dac1a-4e9e-437d-a7b1-772c98d632fb","tool_use_result":{"type":"text","file":{"filePath":"/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd","content":"extends CharacterBody2D\n## Enemy AI with tactical behaviors including patrol, guard, cover, and flanking.\n##\n## Supports multiple behavior modes:\n## - PATROL: Moves between patrol points\n## - GUARD: Stands in place watching for the player\n##\n## Tactical features:\n## - Uses cover when under fire (suppression)\n## - Attempts to flank the player from the sides\n## - Coordinates with other enemies (optional)\n## - GOAP foundation for goal-oriented planning\n\n## AI States for tactical behavior.\nenum AIState {\n\tIDLE,       ## Default idle state (patrol or guard)\n\tCOMBAT,     ## Actively engaging the player (coming out of cover, shooting 2-3s, returning)\n\tSEEKING_COVER,  ## Moving to cover position\n\tIN_COVER,   ## Taking cover from player fire\n\tFLANKING,   ## Attempting to flank the player\n\tSUPPRESSED, ## Under fire, staying in cover\n\tRETREATING, ## Retreating to cover while possibly shooting\n\tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n\tASSAULT     ## Coordinated multi-enemy assault (rush player after 5s wait)\n}\n\n## Retreat behavior modes based on damage taken.\nenum RetreatMode {\n\tFULL_HP,        ## No damage - retreat backwards while shooting, periodically turn to cover\n\tONE_HIT,        ## One hit taken - quick burst then retreat without shooting\n\tMULTIPLE_HITS   ## Multiple hits - quick burst then retreat without shooting (same as ONE_HIT)\n}\n\n## Behavior modes for the enemy.\nenum BehaviorMode {\n\tPATROL,  ## Moves between patrol points\n\tGUARD    ## Stands in one place\n}\n\n## Current behavior mode.\n@export var behavior_mode: BehaviorMode = BehaviorMode.GUARD\n\n## Maximum movement speed in pixels per second.\n@export var move_speed: float = 220.0\n\n## Combat movement speed (faster when flanking/seeking cover).\n@export var combat_move_speed: float = 320.0\n\n## Rotation speed in radians per second for gradual turning.\n## Default is 15 rad/sec for challenging but fair combat.\n@export var rotation_speed: float = 15.0\n\n## Detection range for spotting the player.\n## Set to 0 or negative to allow unlimited detection range (line-of-sight only).\n## This allows enemies to see the player even outside the viewport if no obstacles block view.\n@export var detection_range: float = 0.0\n\n## Time between shots in seconds.\n## Default matches assault rifle fire rate (10 shots/second = 0.1s cooldown).\n@export var shoot_cooldown: float = 0.1\n\n## Bullet scene to instantiate when shooting.\n@export var bullet_scene: PackedScene\n\n## Offset from enemy center for bullet spawn position.\n@export var bullet_spawn_offset: float = 30.0\n\n## Patrol points as offsets from the initial position.\n## Only used when behavior_mode is PATROL.\n@export var patrol_offsets: Array[Vector2] = [Vector2(100, 0), Vector2(-100, 0)]\n\n## Wait time at each patrol point in seconds.\n@export var patrol_wait_time: float = 1.5\n\n## Color when at full health.\n@export var full_health_color: Color = Color(0.9, 0.2, 0.2, 1.0)\n\n## Color when at low health (interpolates based on health percentage).\n@export var low_health_color: Color = Color(0.3, 0.1, 0.1, 1.0)\n\n## Color to flash when hit.\n@export var hit_flash_color: Color = Color(1.0, 1.0, 1.0, 1.0)\n\n## Duration of hit flash effect in seconds.\n@export var hit_flash_duration: float = 0.1\n\n## Whether to destroy the enemy after death.\n@export var destroy_on_death: bool = false\n\n## Delay before respawning or destroying (in seconds).\n@export var respawn_delay: float = 2.0\n\n## Minimum random health.\n@export var min_health: int = 2\n\n## Maximum random health.\n@export var max_health: int = 4\n\n## Threat sphere radius - bullets within this radius trigger suppression.\n@export var threat_sphere_radius: float = 100.0\n\n## Time to stay suppressed after bullets leave threat sphere.\n@export var suppression_cooldown: float = 2.0\n\n## Delay (in seconds) before reacting to bullets in the threat sphere.\n## This prevents instant reactions to nearby gunfire, giving the player more time.\n@export var threat_reaction_delay: float = 0.2\n\n## Flank angle from player's facing direction (radians).\n@export var flank_angle: float = PI / 3.0  # 60 degrees\n\n## Distance to maintain while flanking.\n@export var flank_distance: float = 200.0\n\n## Enable/disable flanking behavior.\n@export var enable_flanking: bool = true\n\n## Enable/disable cover behavior.\n@export var enable_cover: bool = true\n\n## Enable/disable debug logging.\n@export var debug_logging: bool = false\n\n## Enable/disable debug label above enemy showing current AI state.\n@export var debug_label_enabled: bool = false\n\n## Enable/disable friendly fire avoidance (don't shoot if other enemies are in the way).\n@export var enable_friendly_fire_avoidance: bool = true\n\n## Enable/disable lead prediction (shooting ahead of moving targets).\n@export var enable_lead_prediction: bool = true\n\n## Bullet speed for lead prediction calculation.\n## Should match the actual bullet speed (default is 2500 for assault rifle).\n@export var bullet_speed: float = 2500.0\n\n## Ammunition system - magazine size (bullets per magazine).\n@export var magazine_size: int = 30\n\n## Ammunition system - number of magazines the enemy carries.\n@export var total_magazines: int = 5\n\n## Ammunition system - time to reload in seconds.\n@export var reload_time: float = 3.0\n\n## Delay (in seconds) between spotting player and starting to shoot.\n## Gives player a brief reaction time when entering enemy line of sight.\n## This delay \"recharges\" each time the player breaks direct contact with the enemy.\n@export var detection_delay: float = 0.2\n\n## Minimum time (in seconds) the player must be continuously visible before\n## lead prediction is enabled. This prevents enemies from predicting player\n## position immediately when they emerge from cover.\n@export var lead_prediction_delay: float = 0.3\n\n## Minimum visibility ratio (0.0 to 1.0) of player body that must be visible\n## before lead prediction is enabled. At 1.0, the player's entire body must be\n## visible. At 0.5, at least half of the check points must be visible.\n## This prevents pre-firing at players who are at cover edges.\n@export var lead_prediction_visibility_threshold: float = 0.6\n\n## Signal emitted when the enemy is hit.\nsignal hit\n\n## Signal emitted when the enemy dies.\nsignal died\n\n## Signal emitted when AI state changes.\nsignal state_changed(new_state: AIState)\n\n## Signal emitted when ammunition changes.\nsignal ammo_changed(current_ammo: int, reserve_ammo: int)\n\n## Signal emitted when reloading starts.\nsignal reload_started\n\n## Signal emitted when reloading finishes.\nsignal reload_finished\n\n## Signal emitted when all ammunition is depleted.\nsignal ammo_depleted\n\n## Reference to the sprite for color changes.\n@onready var _sprite: Sprite2D = $Sprite2D\n\n## RayCast2D for line of sight detection.\n@onready var _raycast: RayCast2D = $RayCast2D\n\n## Debug label for showing current AI state above the enemy.\n@onready var _debug_label: Label = $DebugLabel\n\n## Wall detection raycasts for obstacle avoidance (created at runtime).\nvar _wall_raycasts: Array[RayCast2D] = []\n\n## Distance to check for walls ahead.\nconst WALL_CHECK_DISTANCE: float = 40.0\n\n## Number of raycasts for wall detection (spread around the enemy).\nconst WALL_CHECK_COUNT: int = 3\n\n## Cover detection raycasts (created at runtime).\nvar _cover_raycasts: Array[RayCast2D] = []\n\n## Number of raycasts for cover detection.\nconst COVER_CHECK_COUNT: int = 16\n\n## Distance to check for cover.\nconst COVER_CHECK_DISTANCE: float = 300.0\n\n## Current health of the enemy.\nvar _current_health: int = 0\n\n## Maximum health of the enemy (set at spawn).\nvar _max_health: int = 0\n\n## Whether the enemy is alive.\nvar _is_alive: bool = true\n\n## Reference to the player (found at runtime).\nvar _player: Node2D = null\n\n## Time since last shot.\nvar _shoot_timer: float = 0.0\n\n## Current ammo in the magazine.\nvar _current_ammo: int = 0\n\n## Reserve ammo (ammo in remaining magazines).\nvar _reserve_ammo: int = 0\n\n## Whether the enemy is currently reloading.\nvar _is_reloading: bool = false\n\n## Timer for reload progress.\nvar _reload_timer: float = 0.0\n\n## Patrol state variables.\nvar _patrol_points: Array[Vector2] = []\nvar _current_patrol_index: int = 0\nvar _is_waiting_at_patrol_point: bool = false\nvar _patrol_wait_timer: float = 0.0\nvar _initial_position: Vector2\n\n## Whether the enemy can currently see the player.\nvar _can_see_player: bool = false\n\n## Current AI state.\nvar _current_state: AIState = AIState.IDLE\n\n## Current cover position (if any).\nvar _cover_position: Vector2 = Vector2.ZERO\n\n## Is currently in a valid cover position.\nvar _has_valid_cover: bool = false\n\n## Timer for suppression cooldown.\nvar _suppression_timer: float = 0.0\n\n## Whether enemy is currently under fire (bullets in threat sphere).\nvar _under_fire: bool = false\n\n## Flank target position.\nvar _flank_target: Vector2 = Vector2.ZERO\n\n## Threat sphere Area2D for detecting nearby bullets.\nvar _threat_sphere: Area2D = null\n\n## Bullets currently in threat sphere.\nvar _bullets_in_threat_sphere: Array = []\n\n## Timer for threat reaction delay - time since first bullet entered threat sphere.\nvar _threat_reaction_timer: float = 0.0\n\n## Whether the threat reaction delay has elapsed (enemy can react to bullets).\nvar _threat_reaction_delay_elapsed: bool = false\n\n## Memory of bullets that have passed through the threat sphere recently.\n## This allows the enemy to react even after fast-moving bullets have exited.\nvar _threat_memory_timer: float = 0.0\n\n## Duration to remember that a bullet passed through the threat sphere.\n## This should be longer than the reaction delay to ensure enemies can complete\n## their reaction even after bullets have passed through quickly.\nconst THREAT_MEMORY_DURATION: float = 0.5\n\n## Current retreat mode determined by damage taken.\nvar _retreat_mode: RetreatMode = RetreatMode.FULL_HP\n\n## Number of hits taken during the current retreat/combat encounter.\n## Resets when enemy enters IDLE state or finishes retreating.\nvar _hits_taken_in_encounter: int = 0\n\n## Timer for periodic turning to cover during FULL_HP retreat.\nvar _retreat_turn_timer: float = 0.0\n\n## Duration to face cover during FULL_HP retreat turn (seconds).\nconst RETREAT_TURN_DURATION: float = 0.8\n\n## Interval between turns toward cover in FULL_HP retreat (seconds).\nconst RETREAT_TURN_INTERVAL: float = 1.5\n\n## Whether currently in the \"turn to cover\" phase of FULL_HP retreat.\nvar _retreat_turning_to_cover: bool = false\n\n## Burst fire counter for ONE_HIT retreat mode.\nvar _retreat_burst_remaining: int = 0\n\n## Timer for burst fire cooldown in ONE_HIT retreat.\nvar _retreat_burst_timer: float = 0.0\n\n## Fast cooldown between burst shots (seconds).\nconst RETREAT_BURST_COOLDOWN: float = 0.06\n\n## Whether burst fire phase is complete in ONE_HIT retreat.\nvar _retreat_burst_complete: bool = false\n\n## Accuracy reduction during retreat (multiplier for inaccuracy angle spread).\nconst RETREAT_INACCURACY_SPREAD: float = 0.15\n\n## Arc spread for ONE_HIT burst fire (radians, total spread).\nconst RETREAT_BURST_ARC: float = 0.4\n\n## Current angle offset within burst arc.\nvar _retreat_burst_angle_offset: float = 0.0\n\n## Whether enemy is in \"alarm\" mode (was suppressed/retreating and hasn't calmed down).\n## This persists until the enemy reaches safety in cover or returns to idle.\nvar _in_alarm_mode: bool = false\n\n## Whether the enemy needs to fire a cover burst (when leaving cover while in alarm).\nvar _cover_burst_pending: bool = false\n\n## --- Combat Cover Cycling (come out, shoot 2-3s, go back) ---\n## Timer for how long the enemy has been shooting while out of cover.\nvar _combat_shoot_timer: float = 0.0\n\n## Duration to shoot while out of cover (2-3 seconds, randomized).\nvar _combat_shoot_duration: float = 2.5\n\n## Whether the enemy is currently in the \"exposed shooting\" phase of combat.\nvar _combat_exposed: bool = false\n\n## Whether the enemy is in the \"approaching player\" phase of combat.\n## In this phase, the enemy moves toward the player to get into direct contact.\nvar _combat_approaching: bool = false\n\n## Timer for the approach phase of combat.\nvar _combat_approach_timer: float = 0.0\n\n## Maximum time to spend approaching player before starting to shoot (seconds).\nconst COMBAT_APPROACH_MAX_TIME: float = 2.0\n\n## Distance at which enemy is considered \"close enough\" to start shooting phase.\nconst COMBAT_DIRECT_CONTACT_DISTANCE: float = 250.0\n\n## --- Pursuit State (cover-to-cover movement) ---\n## Timer for waiting at cover during pursuit.\nvar _pursuit_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during pursuit (1-2 seconds, reduced for faster pursuit).\nconst PURSUIT_COVER_WAIT_DURATION: float = 1.5\n\n## Current pursuit target cover position.\nvar _pursuit_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid pursuit cover target.\nvar _has_pursuit_cover: bool = false\n\n## --- Flanking State (cover-to-cover movement toward flank target) ---\n## Timer for waiting at cover during flanking.\nvar _flank_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during flanking (seconds).\nconst FLANK_COVER_WAIT_DURATION: float = 0.8\n\n## Current flank cover position to move to.\nvar _flank_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid flank cover target.\nvar _has_flank_cover: bool = false\n\n## --- Assault State (coordinated multi-enemy rush) ---\n## Timer for assault wait period (5 seconds before rushing).\nvar _assault_wait_timer: float = 0.0\n\n## Duration to wait at cover before assault (5 seconds).\nconst ASSAULT_WAIT_DURATION: float = 5.0\n\n## Whether the assault wait period is complete.\nvar _assault_ready: bool = false\n\n## Whether this enemy is currently participating in an assault.\nvar _in_assault: bool = false\n\n## Distance threshold for \"close\" vs \"far\" from player.\n## Used to determine if enemy can engage from current position or needs to pursue.\nconst CLOSE_COMBAT_DISTANCE: float = 400.0\n\n## GOAP world state for goal-oriented planning.\nvar _goap_world_state: Dictionary = {}","numLines":400,"startLine":1,"totalLines":3206}}}
[2026-01-18T02:49:17.593Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_019UtJoHDGwNUh1224rqDD9M",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Let me continue reading the enemy.gd file to understand the current state management and behaviors."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 5917,
      "cache_read_input_tokens": 37242,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 5917,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 3,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "c95adc5e-765c-46db-907d-7e35d2852ac8"
}
[2026-01-18T02:49:18.954Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_019UtJoHDGwNUh1224rqDD9M",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01326xQ3TVtseY3idgZ8j2ps",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "offset": 400,
          "limit": 400
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 5917,
      "cache_read_input_tokens": 37242,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 5917,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 3,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "d51e9423-86a3-4142-abac-9ebec9803097"
}
[2026-01-18T02:49:18.976Z] [INFO] {"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01326xQ3TVtseY3idgZ8j2ps","type":"tool_result","content":"   400‚Üívar _goap_world_state: Dictionary = {}\n   401‚Üí\n   402‚Üí## Detection delay timer - tracks time since entering combat.\n   403‚Üívar _detection_timer: float = 0.0\n   404‚Üí\n   405‚Üí## Whether the detection delay has elapsed.\n   406‚Üívar _detection_delay_elapsed: bool = false\n   407‚Üí\n   408‚Üí## Continuous visibility timer - tracks how long the player has been continuously visible.\n   409‚Üí## Resets when line of sight is lost.\n   410‚Üívar _continuous_visibility_timer: float = 0.0\n   411‚Üí\n   412‚Üí## Current visibility ratio of the player (0.0 to 1.0).\n   413‚Üí## Represents what fraction of the player's body is visible to the enemy.\n   414‚Üí## Used to determine if lead prediction should be enabled.\n   415‚Üívar _player_visibility_ratio: float = 0.0\n   416‚Üí\n   417‚Üí## --- Clear Shot Movement (move out from cover to get clear shot) ---\n   418‚Üí## Target position to move to for getting a clear shot.\n   419‚Üívar _clear_shot_target: Vector2 = Vector2.ZERO\n   420‚Üí\n   421‚Üí## Whether we're currently moving to find a clear shot position.\n   422‚Üívar _seeking_clear_shot: bool = false\n   423‚Üí\n   424‚Üí## Timer for how long we've been trying to find a clear shot.\n   425‚Üívar _clear_shot_timer: float = 0.0\n   426‚Üí\n   427‚Üí## Maximum time to spend finding a clear shot before giving up (seconds).\n   428‚Üíconst CLEAR_SHOT_MAX_TIME: float = 3.0\n   429‚Üí\n   430‚Üí## Distance to move when exiting cover to find a clear shot.\n   431‚Üíconst CLEAR_SHOT_EXIT_DISTANCE: float = 60.0\n   432‚Üí\n   433‚Üí\n   434‚Üí\n   435‚Üífunc _ready() -> void:\n   436‚Üí\t_initial_position = global_position\n   437‚Üí\t_initialize_health()\n   438‚Üí\t_initialize_ammo()\n   439‚Üí\t_update_health_visual()\n   440‚Üí\t_setup_patrol_points()\n   441‚Üí\t_find_player()\n   442‚Üí\t_setup_wall_detection()\n   443‚Üí\t_setup_cover_detection()\n   444‚Üí\t_setup_threat_sphere()\n   445‚Üí\t_initialize_goap_state()\n   446‚Üí\t_connect_debug_mode_signal()\n   447‚Üí\t_update_debug_label()\n   448‚Üí\n   449‚Üí\t# Log that this enemy is ready (use call_deferred to ensure FileLogger is loaded)\n   450‚Üí\tcall_deferred(\"_log_spawn_info\")\n   451‚Üí\n   452‚Üí\t# Preload bullet scene if not set in inspector\n   453‚Üí\tif bullet_scene == null:\n   454‚Üí\t\tbullet_scene = preload(\"res://scenes/projectiles/Bullet.tscn\")\n   455‚Üí\n   456‚Üí\n   457‚Üí## Initialize health with random value between min and max.\n   458‚Üífunc _initialize_health() -> void:\n   459‚Üí\t_max_health = randi_range(min_health, max_health)\n   460‚Üí\t_current_health = _max_health\n   461‚Üí\t_is_alive = true\n   462‚Üí\n   463‚Üí\n   464‚Üí## Initialize ammunition with full magazine and reserve ammo.\n   465‚Üífunc _initialize_ammo() -> void:\n   466‚Üí\t_current_ammo = magazine_size\n   467‚Üí\t# Reserve ammo is (total_magazines - 1) * magazine_size since one magazine is loaded\n   468‚Üí\t_reserve_ammo = (total_magazines - 1) * magazine_size\n   469‚Üí\t_is_reloading = false\n   470‚Üí\t_reload_timer = 0.0\n   471‚Üí\n   472‚Üí\n   473‚Üí## Setup patrol points based on patrol offsets from initial position.\n   474‚Üífunc _setup_patrol_points() -> void:\n   475‚Üí\t_patrol_points.clear()\n   476‚Üí\t_patrol_points.append(_initial_position)\n   477‚Üí\tfor offset in patrol_offsets:\n   478‚Üí\t\t_patrol_points.append(_initial_position + offset)\n   479‚Üí\n   480‚Üí\n   481‚Üí## Setup wall detection raycasts for obstacle avoidance.\n   482‚Üífunc _setup_wall_detection() -> void:\n   483‚Üí\t# Create multiple raycasts spread in front of the enemy\n   484‚Üí\tfor i in range(WALL_CHECK_COUNT):\n   485‚Üí\t\tvar raycast := RayCast2D.new()\n   486‚Üí\t\traycast.enabled = true\n   487‚Üí\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n   488‚Üí\t\traycast.exclude_parent = true\n   489‚Üí\t\tadd_child(raycast)\n   490‚Üí\t\t_wall_raycasts.append(raycast)\n   491‚Üí\n   492‚Üí\n   493‚Üí## Setup cover detection raycasts for finding cover positions.\n   494‚Üífunc _setup_cover_detection() -> void:\n   495‚Üí\tfor i in range(COVER_CHECK_COUNT):\n   496‚Üí\t\tvar raycast := RayCast2D.new()\n   497‚Üí\t\traycast.enabled = true\n   498‚Üí\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n   499‚Üí\t\traycast.exclude_parent = true\n   500‚Üí\t\tadd_child(raycast)\n   501‚Üí\t\t_cover_raycasts.append(raycast)\n   502‚Üí\n   503‚Üí\n   504‚Üí## Setup threat sphere for detecting nearby bullets.\n   505‚Üífunc _setup_threat_sphere() -> void:\n   506‚Üí\t_threat_sphere = Area2D.new()\n   507‚Üí\t_threat_sphere.name = \"ThreatSphere\"\n   508‚Üí\t_threat_sphere.collision_layer = 0\n   509‚Üí\t_threat_sphere.collision_mask = 16  # Detect projectiles (layer 5)\n   510‚Üí\n   511‚Üí\tvar collision_shape := CollisionShape2D.new()\n   512‚Üí\tvar circle_shape := CircleShape2D.new()\n   513‚Üí\tcircle_shape.radius = threat_sphere_radius\n   514‚Üí\tcollision_shape.shape = circle_shape\n   515‚Üí\t_threat_sphere.add_child(collision_shape)\n   516‚Üí\n   517‚Üí\tadd_child(_threat_sphere)\n   518‚Üí\n   519‚Üí\t# Connect signals\n   520‚Üí\t_threat_sphere.area_entered.connect(_on_threat_area_entered)\n   521‚Üí\t_threat_sphere.area_exited.connect(_on_threat_area_exited)\n   522‚Üí\n   523‚Üí\n   524‚Üí## Initialize GOAP world state.\n   525‚Üífunc _initialize_goap_state() -> void:\n   526‚Üí\t_goap_world_state = {\n   527‚Üí\t\t\"player_visible\": false,\n   528‚Üí\t\t\"has_cover\": false,\n   529‚Üí\t\t\"in_cover\": false,\n   530‚Üí\t\t\"under_fire\": false,\n   531‚Üí\t\t\"health_low\": false,\n   532‚Üí\t\t\"can_flank\": false,\n   533‚Üí\t\t\"at_flank_position\": false,\n   534‚Üí\t\t\"is_retreating\": false,\n   535‚Üí\t\t\"hits_taken\": 0,\n   536‚Üí\t\t\"is_pursuing\": false,\n   537‚Üí\t\t\"is_assaulting\": false,\n   538‚Üí\t\t\"can_hit_from_cover\": false,\n   539‚Üí\t\t\"player_close\": false,\n   540‚Üí\t\t\"enemies_in_combat\": 0\n   541‚Üí\t}\n   542‚Üí\n   543‚Üí\n   544‚Üí## Connect to GameManager's debug mode signal for F7 toggle.\n   545‚Üífunc _connect_debug_mode_signal() -> void:\n   546‚Üí\tvar game_manager: Node = get_node_or_null(\"/root/GameManager\")\n   547‚Üí\tif game_manager:\n   548‚Üí\t\t# Connect to debug mode toggle signal\n   549‚Üí\t\tif game_manager.has_signal(\"debug_mode_toggled\"):\n   550‚Üí\t\t\tgame_manager.debug_mode_toggled.connect(_on_debug_mode_toggled)\n   551‚Üí\t\t# Sync with current debug mode state\n   552‚Üí\t\tif game_manager.has_method(\"is_debug_mode_enabled\"):\n   553‚Üí\t\t\tdebug_label_enabled = game_manager.is_debug_mode_enabled()\n   554‚Üí\n   555‚Üí\n   556‚Üí## Called when debug mode is toggled via F7 key.\n   557‚Üífunc _on_debug_mode_toggled(enabled: bool) -> void:\n   558‚Üí\tdebug_label_enabled = enabled\n   559‚Üí\t_update_debug_label()\n   560‚Üí\n   561‚Üí\n   562‚Üí## Find the player node in the scene tree.\n   563‚Üífunc _find_player() -> void:\n   564‚Üí\t# Try to find the player by group first\n   565‚Üí\tvar players := get_tree().get_nodes_in_group(\"player\")\n   566‚Üí\tif players.size() > 0:\n   567‚Üí\t\t_player = players[0]\n   568‚Üí\t\treturn\n   569‚Üí\n   570‚Üí\t# Fallback: search for player by node name or type\n   571‚Üí\tvar root := get_tree().current_scene\n   572‚Üí\tif root:\n   573‚Üí\t\t_player = _find_player_recursive(root)\n   574‚Üí\n   575‚Üí\n   576‚Üí## Recursively search for a player node.\n   577‚Üífunc _find_player_recursive(node: Node) -> Node2D:\n   578‚Üí\tif node.name == \"Player\" and node is Node2D:\n   579‚Üí\t\treturn node\n   580‚Üí\tfor child in node.get_children():\n   581‚Üí\t\tvar result := _find_player_recursive(child)\n   582‚Üí\t\tif result:\n   583‚Üí\t\t\treturn result\n   584‚Üí\treturn null\n   585‚Üí\n   586‚Üí\n   587‚Üífunc _physics_process(delta: float) -> void:\n   588‚Üí\tif not _is_alive:\n   589‚Üí\t\treturn\n   590‚Üí\n   591‚Üí\t# Update shoot cooldown timer\n   592‚Üí\t_shoot_timer += delta\n   593‚Üí\n   594‚Üí\t# Update reload timer\n   595‚Üí\t_update_reload(delta)\n   596‚Üí\n   597‚Üí\t# Check for player visibility and try to find player if not found\n   598‚Üí\tif _player == null:\n   599‚Üí\t\t_find_player()\n   600‚Üí\n   601‚Üí\t_check_player_visibility()\n   602‚Üí\t_update_goap_state()\n   603‚Üí\t_update_suppression(delta)\n   604‚Üí\n   605‚Üí\t# Process AI state machine\n   606‚Üí\t_process_ai_state(delta)\n   607‚Üí\n   608‚Üí\t# Update debug label if enabled\n   609‚Üí\t_update_debug_label()\n   610‚Üí\n   611‚Üí\t# Request redraw for debug visualization\n   612‚Üí\tif debug_label_enabled:\n   613‚Üí\t\tqueue_redraw()\n   614‚Üí\n   615‚Üí\tmove_and_slide()\n   616‚Üí\n   617‚Üí\n   618‚Üí## Update GOAP world state based on current conditions.\n   619‚Üífunc _update_goap_state() -> void:\n   620‚Üí\t_goap_world_state[\"player_visible\"] = _can_see_player\n   621‚Üí\t_goap_world_state[\"under_fire\"] = _under_fire\n   622‚Üí\t_goap_world_state[\"health_low\"] = _get_health_percent() < 0.5\n   623‚Üí\t_goap_world_state[\"in_cover\"] = _current_state == AIState.IN_COVER\n   624‚Üí\t_goap_world_state[\"has_cover\"] = _has_valid_cover\n   625‚Üí\t_goap_world_state[\"is_retreating\"] = _current_state == AIState.RETREATING\n   626‚Üí\t_goap_world_state[\"hits_taken\"] = _hits_taken_in_encounter\n   627‚Üí\t_goap_world_state[\"is_pursuing\"] = _current_state == AIState.PURSUING\n   628‚Üí\t_goap_world_state[\"is_assaulting\"] = _current_state == AIState.ASSAULT\n   629‚Üí\t_goap_world_state[\"player_close\"] = _is_player_close()\n   630‚Üí\t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n   631‚Üí\t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()\n   632‚Üí\n   633‚Üí\n   634‚Üí## Update suppression state.\n   635‚Üífunc _update_suppression(delta: float) -> void:\n   636‚Üí\t# Clean up destroyed bullets from tracking\n   637‚Üí\t_bullets_in_threat_sphere = _bullets_in_threat_sphere.filter(func(b): return is_instance_valid(b))\n   638‚Üí\n   639‚Üí\t# Determine if there's an active threat (bullets in sphere OR recent threat memory)\n   640‚Üí\tvar has_active_threat := not _bullets_in_threat_sphere.is_empty() or _threat_memory_timer > 0.0\n   641‚Üí\n   642‚Üí\tif not has_active_threat:\n   643‚Üí\t\tif _under_fire:\n   644‚Üí\t\t\t_suppression_timer += delta\n   645‚Üí\t\t\tif _suppression_timer >= suppression_cooldown:\n   646‚Üí\t\t\t\t_under_fire = false\n   647‚Üí\t\t\t\t_suppression_timer = 0.0\n   648‚Üí\t\t\t\t_log_debug(\"Suppression ended\")\n   649‚Üí\t\t# Reset threat reaction timer when no bullets are in threat sphere and no threat memory\n   650‚Üí\t\t_threat_reaction_timer = 0.0\n   651‚Üí\t\t_threat_reaction_delay_elapsed = false\n   652‚Üí\telse:\n   653‚Üí\t\t# Decrement threat memory timer if no bullets currently in sphere\n   654‚Üí\t\tif _bullets_in_threat_sphere.is_empty() and _threat_memory_timer > 0.0:\n   655‚Üí\t\t\t_threat_memory_timer -= delta\n   656‚Üí\n   657‚Üí\t\t# Update threat reaction timer\n   658‚Üí\t\tif not _threat_reaction_delay_elapsed:\n   659‚Üí\t\t\t_threat_reaction_timer += delta\n   660‚Üí\t\t\tif _threat_reaction_timer >= threat_reaction_delay:\n   661‚Üí\t\t\t\t_threat_reaction_delay_elapsed = true\n   662‚Üí\t\t\t\t_log_debug(\"Threat reaction delay elapsed, now reacting to bullets\")\n   663‚Üí\n   664‚Üí\t\t# Only set under_fire after the reaction delay has elapsed\n   665‚Üí\t\tif _threat_reaction_delay_elapsed:\n   666‚Üí\t\t\t_under_fire = true\n   667‚Üí\t\t\t_suppression_timer = 0.0\n   668‚Üí\n   669‚Üí\n   670‚Üí## Update reload state.\n   671‚Üífunc _update_reload(delta: float) -> void:\n   672‚Üí\tif not _is_reloading:\n   673‚Üí\t\treturn\n   674‚Üí\n   675‚Üí\t_reload_timer += delta\n   676‚Üí\tif _reload_timer >= reload_time:\n   677‚Üí\t\t_finish_reload()\n   678‚Üí\n   679‚Üí\n   680‚Üí## Start reloading the weapon.\n   681‚Üífunc _start_reload() -> void:\n   682‚Üí\t# Can't reload if already reloading or no reserve ammo\n   683‚Üí\tif _is_reloading or _reserve_ammo <= 0:\n   684‚Üí\t\treturn\n   685‚Üí\n   686‚Üí\t_is_reloading = true\n   687‚Üí\t_reload_timer = 0.0\n   688‚Üí\treload_started.emit()\n   689‚Üí\t_log_debug(\"Reloading... (%d reserve ammo)\" % _reserve_ammo)\n   690‚Üí\n   691‚Üí\n   692‚Üí## Finish the reload process.\n   693‚Üífunc _finish_reload() -> void:\n   694‚Üí\t_is_reloading = false\n   695‚Üí\t_reload_timer = 0.0\n   696‚Üí\n   697‚Üí\t# Calculate how many rounds to load\n   698‚Üí\tvar ammo_needed := magazine_size - _current_ammo\n   699‚Üí\tvar ammo_to_load := mini(ammo_needed, _reserve_ammo)\n   700‚Üí\n   701‚Üí\t_reserve_ammo -= ammo_to_load\n   702‚Üí\t_current_ammo += ammo_to_load\n   703‚Üí\n   704‚Üí\treload_finished.emit()\n   705‚Üí\tammo_changed.emit(_current_ammo, _reserve_ammo)\n   706‚Üí\t_log_debug(\"Reload complete. Magazine: %d/%d, Reserve: %d\" % [_current_ammo, magazine_size, _reserve_ammo])\n   707‚Üí\n   708‚Üí\n   709‚Üí## Check if the enemy can shoot (has ammo and not reloading).\n   710‚Üífunc _can_shoot() -> bool:\n   711‚Üí\t# Can't shoot if reloading\n   712‚Üí\tif _is_reloading:\n   713‚Üí\t\treturn false\n   714‚Üí\n   715‚Üí\t# Can't shoot if no ammo in magazine\n   716‚Üí\tif _current_ammo <= 0:\n   717‚Üí\t\t# Try to start reload if we have reserve ammo\n   718‚Üí\t\tif _reserve_ammo > 0:\n   719‚Üí\t\t\t_start_reload()\n   720‚Üí\t\telse:\n   721‚Üí\t\t\t# No ammo at all - emit depleted signal once\n   722‚Üí\t\t\tif not _goap_world_state.get(\"ammo_depleted\", false):\n   723‚Üí\t\t\t\t_goap_world_state[\"ammo_depleted\"] = true\n   724‚Üí\t\t\t\tammo_depleted.emit()\n   725‚Üí\t\t\t\t_log_debug(\"All ammunition depleted!\")\n   726‚Üí\t\treturn false\n   727‚Üí\n   728‚Üí\treturn true\n   729‚Üí\n   730‚Üí\n   731‚Üí## Process the AI state machine.\n   732‚Üífunc _process_ai_state(delta: float) -> void:\n   733‚Üí\tvar previous_state := _current_state\n   734‚Üí\n   735‚Üí\t# State transitions based on conditions\n   736‚Üí\tmatch _current_state:\n   737‚Üí\t\tAIState.IDLE:\n   738‚Üí\t\t\t_process_idle_state(delta)\n   739‚Üí\t\tAIState.COMBAT:\n   740‚Üí\t\t\t_process_combat_state(delta)\n   741‚Üí\t\tAIState.SEEKING_COVER:\n   742‚Üí\t\t\t_process_seeking_cover_state(delta)\n   743‚Üí\t\tAIState.IN_COVER:\n   744‚Üí\t\t\t_process_in_cover_state(delta)\n   745‚Üí\t\tAIState.FLANKING:\n   746‚Üí\t\t\t_process_flanking_state(delta)\n   747‚Üí\t\tAIState.SUPPRESSED:\n   748‚Üí\t\t\t_process_suppressed_state(delta)\n   749‚Üí\t\tAIState.RETREATING:\n   750‚Üí\t\t\t_process_retreating_state(delta)\n   751‚Üí\t\tAIState.PURSUING:\n   752‚Üí\t\t\t_process_pursuing_state(delta)\n   753‚Üí\t\tAIState.ASSAULT:\n   754‚Üí\t\t\t_process_assault_state(delta)\n   755‚Üí\n   756‚Üí\tif previous_state != _current_state:\n   757‚Üí\t\tstate_changed.emit(_current_state)\n   758‚Üí\t\t_log_debug(\"State changed: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n   759‚Üí\t\t# Also log to file for exported build debugging\n   760‚Üí\t\t_log_to_file(\"State: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n   761‚Üí\n   762‚Üí\n   763‚Üí## Process IDLE state - patrol or guard behavior.\n   764‚Üífunc _process_idle_state(delta: float) -> void:\n   765‚Üí\t# Transition to combat if player is visible\n   766‚Üí\tif _can_see_player and _player:\n   767‚Üí\t\t_transition_to_combat()\n   768‚Üí\t\treturn\n   769‚Üí\n   770‚Üí\t# Execute idle behavior\n   771‚Üí\tmatch behavior_mode:\n   772‚Üí\t\tBehaviorMode.PATROL:\n   773‚Üí\t\t\t_process_patrol(delta)\n   774‚Üí\t\tBehaviorMode.GUARD:\n   775‚Üí\t\t\t_process_guard(delta)\n   776‚Üí\n   777‚Üí\n   778‚Üí## Process COMBAT state - approach player for direct contact, shoot for 2-3 seconds, return to cover.\n   779‚Üí## Implements the combat cycling behavior: exit cover -> exposed shooting -> return to cover.\n   780‚Üí## Phase 0 (seeking clear shot): If bullet spawn blocked, move out from cover to find clear shot.\n   781‚Üí## Phase 1 (approaching): Move toward player to get into direct contact range.\n   782‚Üí## Phase 2 (exposed): Stand and shoot for 2-3 seconds.\n   783‚Üí## Phase 3: Return to cover via SEEKING_COVER state.\n   784‚Üífunc _process_combat_state(delta: float) -> void:\n   785‚Üí\t# Check for suppression - transition to retreating behavior\n   786‚Üí\tif _under_fire and enable_cover:\n   787‚Üí\t\t_combat_exposed = false\n   788‚Üí\t\t_combat_approaching = false\n   789‚Üí\t\t_seeking_clear_shot = false\n   790‚Üí\t\t_transition_to_retreating()\n   791‚Üí\t\treturn\n   792‚Üí\n   793‚Üí\t# Check if multiple enemies are in combat - transition to assault state\n   794‚Üí\tvar enemies_in_combat := _count_enemies_in_combat()\n   795‚Üí\tif enemies_in_combat >= 2:\n   796‚Üí\t\t_log_debug(\"Multiple enemies in combat (%d), transitioning to ASSAULT\" % enemies_in_combat)\n   797‚Üí\t\t_combat_exposed = false\n   798‚Üí\t\t_combat_approaching = false\n   799‚Üí\t\t_seeking_clear_shot = false\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"797fbac8-f5e6-4339-8fd2-77453410db49","uuid":"e009f27a-eacf-4647-8070-a85865b3df84","tool_use_result":{"type":"text","file":{"filePath":"/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd","content":"var _goap_world_state: Dictionary = {}\n\n## Detection delay timer - tracks time since entering combat.\nvar _detection_timer: float = 0.0\n\n## Whether the detection delay has elapsed.\nvar _detection_delay_elapsed: bool = false\n\n## Continuous visibility timer - tracks how long the player has been continuously visible.\n## Resets when line of sight is lost.\nvar _continuous_visibility_timer: float = 0.0\n\n## Current visibility ratio of the player (0.0 to 1.0).\n## Represents what fraction of the player's body is visible to the enemy.\n## Used to determine if lead prediction should be enabled.\nvar _player_visibility_ratio: float = 0.0\n\n## --- Clear Shot Movement (move out from cover to get clear shot) ---\n## Target position to move to for getting a clear shot.\nvar _clear_shot_target: Vector2 = Vector2.ZERO\n\n## Whether we're currently moving to find a clear shot position.\nvar _seeking_clear_shot: bool = false\n\n## Timer for how long we've been trying to find a clear shot.\nvar _clear_shot_timer: float = 0.0\n\n## Maximum time to spend finding a clear shot before giving up (seconds).\nconst CLEAR_SHOT_MAX_TIME: float = 3.0\n\n## Distance to move when exiting cover to find a clear shot.\nconst CLEAR_SHOT_EXIT_DISTANCE: float = 60.0\n\n\n\nfunc _ready() -> void:\n\t_initial_position = global_position\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_setup_patrol_points()\n\t_find_player()\n\t_setup_wall_detection()\n\t_setup_cover_detection()\n\t_setup_threat_sphere()\n\t_initialize_goap_state()\n\t_connect_debug_mode_signal()\n\t_update_debug_label()\n\n\t# Log that this enemy is ready (use call_deferred to ensure FileLogger is loaded)\n\tcall_deferred(\"_log_spawn_info\")\n\n\t# Preload bullet scene if not set in inspector\n\tif bullet_scene == null:\n\t\tbullet_scene = preload(\"res://scenes/projectiles/Bullet.tscn\")\n\n\n## Initialize health with random value between min and max.\nfunc _initialize_health() -> void:\n\t_max_health = randi_range(min_health, max_health)\n\t_current_health = _max_health\n\t_is_alive = true\n\n\n## Initialize ammunition with full magazine and reserve ammo.\nfunc _initialize_ammo() -> void:\n\t_current_ammo = magazine_size\n\t# Reserve ammo is (total_magazines - 1) * magazine_size since one magazine is loaded\n\t_reserve_ammo = (total_magazines - 1) * magazine_size\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\n## Setup patrol points based on patrol offsets from initial position.\nfunc _setup_patrol_points() -> void:\n\t_patrol_points.clear()\n\t_patrol_points.append(_initial_position)\n\tfor offset in patrol_offsets:\n\t\t_patrol_points.append(_initial_position + offset)\n\n\n## Setup wall detection raycasts for obstacle avoidance.\nfunc _setup_wall_detection() -> void:\n\t# Create multiple raycasts spread in front of the enemy\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_wall_raycasts.append(raycast)\n\n\n## Setup cover detection raycasts for finding cover positions.\nfunc _setup_cover_detection() -> void:\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_cover_raycasts.append(raycast)\n\n\n## Setup threat sphere for detecting nearby bullets.\nfunc _setup_threat_sphere() -> void:\n\t_threat_sphere = Area2D.new()\n\t_threat_sphere.name = \"ThreatSphere\"\n\t_threat_sphere.collision_layer = 0\n\t_threat_sphere.collision_mask = 16  # Detect projectiles (layer 5)\n\n\tvar collision_shape := CollisionShape2D.new()\n\tvar circle_shape := CircleShape2D.new()\n\tcircle_shape.radius = threat_sphere_radius\n\tcollision_shape.shape = circle_shape\n\t_threat_sphere.add_child(collision_shape)\n\n\tadd_child(_threat_sphere)\n\n\t# Connect signals\n\t_threat_sphere.area_entered.connect(_on_threat_area_entered)\n\t_threat_sphere.area_exited.connect(_on_threat_area_exited)\n\n\n## Initialize GOAP world state.\nfunc _initialize_goap_state() -> void:\n\t_goap_world_state = {\n\t\t\"player_visible\": false,\n\t\t\"has_cover\": false,\n\t\t\"in_cover\": false,\n\t\t\"under_fire\": false,\n\t\t\"health_low\": false,\n\t\t\"can_flank\": false,\n\t\t\"at_flank_position\": false,\n\t\t\"is_retreating\": false,\n\t\t\"hits_taken\": 0,\n\t\t\"is_pursuing\": false,\n\t\t\"is_assaulting\": false,\n\t\t\"can_hit_from_cover\": false,\n\t\t\"player_close\": false,\n\t\t\"enemies_in_combat\": 0\n\t}\n\n\n## Connect to GameManager's debug mode signal for F7 toggle.\nfunc _connect_debug_mode_signal() -> void:\n\tvar game_manager: Node = get_node_or_null(\"/root/GameManager\")\n\tif game_manager:\n\t\t# Connect to debug mode toggle signal\n\t\tif game_manager.has_signal(\"debug_mode_toggled\"):\n\t\t\tgame_manager.debug_mode_toggled.connect(_on_debug_mode_toggled)\n\t\t# Sync with current debug mode state\n\t\tif game_manager.has_method(\"is_debug_mode_enabled\"):\n\t\t\tdebug_label_enabled = game_manager.is_debug_mode_enabled()\n\n\n## Called when debug mode is toggled via F7 key.\nfunc _on_debug_mode_toggled(enabled: bool) -> void:\n\tdebug_label_enabled = enabled\n\t_update_debug_label()\n\n\n## Find the player node in the scene tree.\nfunc _find_player() -> void:\n\t# Try to find the player by group first\n\tvar players := get_tree().get_nodes_in_group(\"player\")\n\tif players.size() > 0:\n\t\t_player = players[0]\n\t\treturn\n\n\t# Fallback: search for player by node name or type\n\tvar root := get_tree().current_scene\n\tif root:\n\t\t_player = _find_player_recursive(root)\n\n\n## Recursively search for a player node.\nfunc _find_player_recursive(node: Node) -> Node2D:\n\tif node.name == \"Player\" and node is Node2D:\n\t\treturn node\n\tfor child in node.get_children():\n\t\tvar result := _find_player_recursive(child)\n\t\tif result:\n\t\t\treturn result\n\treturn null\n\n\nfunc _physics_process(delta: float) -> void:\n\tif not _is_alive:\n\t\treturn\n\n\t# Update shoot cooldown timer\n\t_shoot_timer += delta\n\n\t# Update reload timer\n\t_update_reload(delta)\n\n\t# Check for player visibility and try to find player if not found\n\tif _player == null:\n\t\t_find_player()\n\n\t_check_player_visibility()\n\t_update_goap_state()\n\t_update_suppression(delta)\n\n\t# Process AI state machine\n\t_process_ai_state(delta)\n\n\t# Update debug label if enabled\n\t_update_debug_label()\n\n\t# Request redraw for debug visualization\n\tif debug_label_enabled:\n\t\tqueue_redraw()\n\n\tmove_and_slide()\n\n\n## Update GOAP world state based on current conditions.\nfunc _update_goap_state() -> void:\n\t_goap_world_state[\"player_visible\"] = _can_see_player\n\t_goap_world_state[\"under_fire\"] = _under_fire\n\t_goap_world_state[\"health_low\"] = _get_health_percent() < 0.5\n\t_goap_world_state[\"in_cover\"] = _current_state == AIState.IN_COVER\n\t_goap_world_state[\"has_cover\"] = _has_valid_cover\n\t_goap_world_state[\"is_retreating\"] = _current_state == AIState.RETREATING\n\t_goap_world_state[\"hits_taken\"] = _hits_taken_in_encounter\n\t_goap_world_state[\"is_pursuing\"] = _current_state == AIState.PURSUING\n\t_goap_world_state[\"is_assaulting\"] = _current_state == AIState.ASSAULT\n\t_goap_world_state[\"player_close\"] = _is_player_close()\n\t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n\t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()\n\n\n## Update suppression state.\nfunc _update_suppression(delta: float) -> void:\n\t# Clean up destroyed bullets from tracking\n\t_bullets_in_threat_sphere = _bullets_in_threat_sphere.filter(func(b): return is_instance_valid(b))\n\n\t# Determine if there's an active threat (bullets in sphere OR recent threat memory)\n\tvar has_active_threat := not _bullets_in_threat_sphere.is_empty() or _threat_memory_timer > 0.0\n\n\tif not has_active_threat:\n\t\tif _under_fire:\n\t\t\t_suppression_timer += delta\n\t\t\tif _suppression_timer >= suppression_cooldown:\n\t\t\t\t_under_fire = false\n\t\t\t\t_suppression_timer = 0.0\n\t\t\t\t_log_debug(\"Suppression ended\")\n\t\t# Reset threat reaction timer when no bullets are in threat sphere and no threat memory\n\t\t_threat_reaction_timer = 0.0\n\t\t_threat_reaction_delay_elapsed = false\n\telse:\n\t\t# Decrement threat memory timer if no bullets currently in sphere\n\t\tif _bullets_in_threat_sphere.is_empty() and _threat_memory_timer > 0.0:\n\t\t\t_threat_memory_timer -= delta\n\n\t\t# Update threat reaction timer\n\t\tif not _threat_reaction_delay_elapsed:\n\t\t\t_threat_reaction_timer += delta\n\t\t\tif _threat_reaction_timer >= threat_reaction_delay:\n\t\t\t\t_threat_reaction_delay_elapsed = true\n\t\t\t\t_log_debug(\"Threat reaction delay elapsed, now reacting to bullets\")\n\n\t\t# Only set under_fire after the reaction de
[2026-01-18T02:49:18.980Z] [INFO] lay has elapsed\n\t\tif _threat_reaction_delay_elapsed:\n\t\t\t_under_fire = true\n\t\t\t_suppression_timer = 0.0\n\n\n## Update reload state.\nfunc _update_reload(delta: float) -> void:\n\tif not _is_reloading:\n\t\treturn\n\n\t_reload_timer += delta\n\tif _reload_timer >= reload_time:\n\t\t_finish_reload()\n\n\n## Start reloading the weapon.\nfunc _start_reload() -> void:\n\t# Can't reload if already reloading or no reserve ammo\n\tif _is_reloading or _reserve_ammo <= 0:\n\t\treturn\n\n\t_is_reloading = true\n\t_reload_timer = 0.0\n\treload_started.emit()\n\t_log_debug(\"Reloading... (%d reserve ammo)\" % _reserve_ammo)\n\n\n## Finish the reload process.\nfunc _finish_reload() -> void:\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\t# Calculate how many rounds to load\n\tvar ammo_needed := magazine_size - _current_ammo\n\tvar ammo_to_load := mini(ammo_needed, _reserve_ammo)\n\n\t_reserve_ammo -= ammo_to_load\n\t_current_ammo += ammo_to_load\n\n\treload_finished.emit()\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\t_log_debug(\"Reload complete. Magazine: %d/%d, Reserve: %d\" % [_current_ammo, magazine_size, _reserve_ammo])\n\n\n## Check if the enemy can shoot (has ammo and not reloading).\nfunc _can_shoot() -> bool:\n\t# Can't shoot if reloading\n\tif _is_reloading:\n\t\treturn false\n\n\t# Can't shoot if no ammo in magazine\n\tif _current_ammo <= 0:\n\t\t# Try to start reload if we have reserve ammo\n\t\tif _reserve_ammo > 0:\n\t\t\t_start_reload()\n\t\telse:\n\t\t\t# No ammo at all - emit depleted signal once\n\t\t\tif not _goap_world_state.get(\"ammo_depleted\", false):\n\t\t\t\t_goap_world_state[\"ammo_depleted\"] = true\n\t\t\t\tammo_depleted.emit()\n\t\t\t\t_log_debug(\"All ammunition depleted!\")\n\t\treturn false\n\n\treturn true\n\n\n## Process the AI state machine.\nfunc _process_ai_state(delta: float) -> void:\n\tvar previous_state := _current_state\n\n\t# State transitions based on conditions\n\tmatch _current_state:\n\t\tAIState.IDLE:\n\t\t\t_process_idle_state(delta)\n\t\tAIState.COMBAT:\n\t\t\t_process_combat_state(delta)\n\t\tAIState.SEEKING_COVER:\n\t\t\t_process_seeking_cover_state(delta)\n\t\tAIState.IN_COVER:\n\t\t\t_process_in_cover_state(delta)\n\t\tAIState.FLANKING:\n\t\t\t_process_flanking_state(delta)\n\t\tAIState.SUPPRESSED:\n\t\t\t_process_suppressed_state(delta)\n\t\tAIState.RETREATING:\n\t\t\t_process_retreating_state(delta)\n\t\tAIState.PURSUING:\n\t\t\t_process_pursuing_state(delta)\n\t\tAIState.ASSAULT:\n\t\t\t_process_assault_state(delta)\n\n\tif previous_state != _current_state:\n\t\tstate_changed.emit(_current_state)\n\t\t_log_debug(\"State changed: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\t\t# Also log to file for exported build debugging\n\t\t_log_to_file(\"State: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\n\n## Process IDLE state - patrol or guard behavior.\nfunc _process_idle_state(delta: float) -> void:\n\t# Transition to combat if player is visible\n\tif _can_see_player and _player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Execute idle behavior\n\tmatch behavior_mode:\n\t\tBehaviorMode.PATROL:\n\t\t\t_process_patrol(delta)\n\t\tBehaviorMode.GUARD:\n\t\t\t_process_guard(delta)\n\n\n## Process COMBAT state - approach player for direct contact, shoot for 2-3 seconds, return to cover.\n## Implements the combat cycling behavior: exit cover -> exposed shooting -> return to cover.\n## Phase 0 (seeking clear shot): If bullet spawn blocked, move out from cover to find clear shot.\n## Phase 1 (approaching): Move toward player to get into direct contact range.\n## Phase 2 (exposed): Stand and shoot for 2-3 seconds.\n## Phase 3: Return to cover via SEEKING_COVER state.\nfunc _process_combat_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies in combat (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false","numLines":400,"startLine":400,"totalLines":3206}}}
[2026-01-18T02:49:21.682Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_0143nbvVajbhyJvPxnici17W",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Let me continue reading to understand more about the AI behavior and what happens when the player escapes from view."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 5576,
      "cache_read_input_tokens": 43159,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 5576,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 3,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "26d305d1-d6e3-44c2-985e-45fc3818bf2d"
}
[2026-01-18T02:49:23.328Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_0143nbvVajbhyJvPxnici17W",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01AfzVMawjmJ6dWdJkrVhKz8",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "offset": 800,
          "limit": 500
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 5576,
      "cache_read_input_tokens": 43159,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 5576,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 3,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "ebd5703e-01ea-4f58-ab73-c525ca20339e"
}
[2026-01-18T02:49:23.361Z] [INFO] {"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AfzVMawjmJ6dWdJkrVhKz8","type":"tool_result","content":"   800‚Üí\t\t_transition_to_assault()\n   801‚Üí\t\treturn\n   802‚Üí\n   803‚Üí\t# If can't see player, pursue them (move cover-to-cover toward player)\n   804‚Üí\tif not _can_see_player:\n   805‚Üí\t\t_combat_exposed = false\n   806‚Üí\t\t_combat_approaching = false\n   807‚Üí\t\t_seeking_clear_shot = false\n   808‚Üí\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to PURSUING\")\n   809‚Üí\t\t_transition_to_pursuing()\n   810‚Üí\t\treturn\n   811‚Üí\n   812‚Üí\t# Update detection delay timer\n   813‚Üí\tif not _detection_delay_elapsed:\n   814‚Üí\t\t_detection_timer += delta\n   815‚Üí\t\tif _detection_timer >= detection_delay:\n   816‚Üí\t\t\t_detection_delay_elapsed = true\n   817‚Üí\n   818‚Üí\t# If we don't have cover, find some first (needed for returning later)\n   819‚Üí\tif not _has_valid_cover and enable_cover:\n   820‚Üí\t\t_find_cover_position()\n   821‚Üí\t\tif _has_valid_cover:\n   822‚Üí\t\t\t_log_debug(\"Found cover at %s for combat cycling\" % _cover_position)\n   823‚Üí\n   824‚Üí\t# Check player distance for approach/exposed phase decisions\n   825‚Üí\tvar distance_to_player := INF\n   826‚Üí\tif _player:\n   827‚Üí\t\tdistance_to_player = global_position.distance_to(_player.global_position)\n   828‚Üí\n   829‚Üí\t# Check if we have a clear shot (no wall blocking bullet spawn)\n   830‚Üí\tvar direction_to_player := Vector2.ZERO\n   831‚Üí\tvar has_clear_shot := true\n   832‚Üí\tif _player:\n   833‚Üí\t\tdirection_to_player = (_player.global_position - global_position).normalized()\n   834‚Üí\t\thas_clear_shot = _is_bullet_spawn_clear(direction_to_player)\n   835‚Üí\n   836‚Üí\t# If already exposed (shooting phase), handle shooting and timer\n   837‚Üí\tif _combat_exposed:\n   838‚Üí\t\t_combat_shoot_timer += delta\n   839‚Üí\n   840‚Üí\t\t# Check if exposure time is complete - go back to cover\n   841‚Üí\t\tif _combat_shoot_timer >= _combat_shoot_duration and _has_valid_cover:\n   842‚Üí\t\t\t_log_debug(\"Combat exposure time complete (%.1fs), returning to cover\" % _combat_shoot_duration)\n   843‚Üí\t\t\t_combat_exposed = false\n   844‚Üí\t\t\t_combat_approaching = false\n   845‚Üí\t\t\t_combat_shoot_timer = 0.0\n   846‚Üí\t\t\t_transition_to_seeking_cover()\n   847‚Üí\t\t\treturn\n   848‚Üí\n   849‚Üí\t\t# Check if we still have a clear shot - if not, move sideways to find one\n   850‚Üí\t\tif _player and not has_clear_shot:\n   851‚Üí\t\t\t# Bullet spawn is blocked - move sideways to find a clear shot position\n   852‚Üí\t\t\tvar sidestep_dir := _find_sidestep_direction_for_clear_shot(direction_to_player)\n   853‚Üí\t\t\tif sidestep_dir != Vector2.ZERO:\n   854‚Üí\t\t\t\tvelocity = sidestep_dir * combat_move_speed * 0.7\n   855‚Üí\t\t\t\trotation = direction_to_player.angle()  # Keep facing player while sidestepping\n   856‚Üí\t\t\t\t_log_debug(\"COMBAT exposed: sidestepping to maintain clear shot\")\n   857‚Üí\t\t\telse:\n   858‚Üí\t\t\t\t# No sidestep works - stay still, the shot might clear up\n   859‚Üí\t\t\t\tvelocity = Vector2.ZERO\n   860‚Üí\t\t\treturn\n   861‚Üí\n   862‚Üí\t\t# In exposed phase with clear shot, stand still and shoot\n   863‚Üí\t\tvelocity = Vector2.ZERO\n   864‚Üí\n   865‚Üí\t\t# Aim and shoot at player (only shoot after detection delay)\n   866‚Üí\t\tif _player:\n   867‚Üí\t\t\t_aim_at_player()\n   868‚Üí\t\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n   869‚Üí\t\t\t\t_shoot()\n   870‚Üí\t\t\t\t_shoot_timer = 0.0\n   871‚Üí\t\treturn\n   872‚Üí\n   873‚Üí\t# --- CLEAR SHOT SEEKING PHASE ---\n   874‚Üí\t# If bullet spawn is blocked and we're not already exposed, we need to move out from cover\n   875‚Üí\tif not has_clear_shot and _player:\n   876‚Üí\t\t# Start seeking clear shot if not already doing so\n   877‚Üí\t\tif not _seeking_clear_shot:\n   878‚Üí\t\t\t_seeking_clear_shot = true\n   879‚Üí\t\t\t_clear_shot_timer = 0.0\n   880‚Üí\t\t\t# Calculate target position: move perpendicular to player direction (around cover edge)\n   881‚Üí\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n   882‚Üí\t\t\t_log_debug(\"COMBAT: bullet spawn blocked, seeking clear shot at %s\" % _clear_shot_target)\n   883‚Üí\n   884‚Üí\t\t_clear_shot_timer += delta\n   885‚Üí\n   886‚Üí\t\t# Check if we've exceeded the max time trying to find a clear shot\n   887‚Üí\t\tif _clear_shot_timer >= CLEAR_SHOT_MAX_TIME:\n   888‚Üí\t\t\t_log_debug(\"COMBAT: clear shot timeout, trying flanking\")\n   889‚Üí\t\t\t_seeking_clear_shot = false\n   890‚Üí\t\t\t_clear_shot_timer = 0.0\n   891‚Üí\t\t\t# Try flanking to get around the obstacle\n   892‚Üí\t\t\tif enable_flanking:\n   893‚Üí\t\t\t\t_transition_to_flanking()\n   894‚Üí\t\t\telse:\n   895‚Üí\t\t\t\t_transition_to_pursuing()\n   896‚Üí\t\t\treturn\n   897‚Üí\n   898‚Üí\t\t# Move toward the clear shot target position\n   899‚Üí\t\tvar distance_to_target := global_position.distance_to(_clear_shot_target)\n   900‚Üí\t\tif distance_to_target > 15.0:\n   901‚Üí\t\t\tvar move_direction := (_clear_shot_target - global_position).normalized()\n   902‚Üí\n   903‚Üí\t\t\t# Apply wall avoidance\n   904‚Üí\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n   905‚Üí\t\t\tif avoidance != Vector2.ZERO:\n   906‚Üí\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n   907‚Üí\n   908‚Üí\t\t\tvelocity = move_direction * combat_move_speed\n   909‚Üí\t\t\trotation = direction_to_player.angle()  # Keep facing player\n   910‚Üí\n   911‚Üí\t\t\t# Check if the new position now has a clear shot\n   912‚Üí\t\t\tif _is_bullet_spawn_clear(direction_to_player):\n   913‚Üí\t\t\t\t_log_debug(\"COMBAT: found clear shot position while moving\")\n   914‚Üí\t\t\t\t_seeking_clear_shot = false\n   915‚Üí\t\t\t\t_clear_shot_timer = 0.0\n   916‚Üí\t\t\t\t# Continue to exposed phase check below\n   917‚Üí\t\t\telse:\n   918‚Üí\t\t\t\treturn  # Keep moving toward target\n   919‚Üí\t\telse:\n   920‚Üí\t\t\t# Reached target but still no clear shot - recalculate target\n   921‚Üí\t\t\t_log_debug(\"COMBAT: reached target but no clear shot, recalculating\")\n   922‚Üí\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n   923‚Üí\t\t\treturn\n   924‚Üí\n   925‚Üí\t# Reset seeking state if we now have a clear shot\n   926‚Üí\tif _seeking_clear_shot and has_clear_shot:\n   927‚Üí\t\t_log_debug(\"COMBAT: clear shot acquired\")\n   928‚Üí\t\t_seeking_clear_shot = false\n   929‚Üí\t\t_clear_shot_timer = 0.0\n   930‚Üí\n   931‚Üí\t# Determine if we should be in approach phase or exposed shooting phase\n   932‚Üí\tvar in_direct_contact := distance_to_player <= COMBAT_DIRECT_CONTACT_DISTANCE\n   933‚Üí\n   934‚Üí\t# Enter exposed phase if we have a clear shot and are either close enough or have approached long enough\n   935‚Üí\tif has_clear_shot and (in_direct_contact or _combat_approach_timer >= COMBAT_APPROACH_MAX_TIME):\n   936‚Üí\t\t# Close enough AND have clear shot - start exposed shooting phase\n   937‚Üí\t\t_combat_exposed = true\n   938‚Üí\t\t_combat_approaching = false\n   939‚Üí\t\t_combat_shoot_timer = 0.0\n   940‚Üí\t\t_combat_approach_timer = 0.0\n   941‚Üí\t\t# Randomize exposure duration between 2-3 seconds\n   942‚Üí\t\t_combat_shoot_duration = randf_range(2.0, 3.0)\n   943‚Üí\t\t_log_debug(\"COMBAT exposed phase started (distance: %.0f), will shoot for %.1fs\" % [distance_to_player, _combat_shoot_duration])\n   944‚Üí\t\treturn\n   945‚Üí\n   946‚Üí\t# Need to approach player - move toward them\n   947‚Üí\tif not _combat_approaching:\n   948‚Üí\t\t_combat_approaching = true\n   949‚Üí\t\t_combat_approach_timer = 0.0\n   950‚Üí\t\t_log_debug(\"COMBAT approach phase started, moving toward player\")\n   951‚Üí\n   952‚Üí\t_combat_approach_timer += delta\n   953‚Üí\n   954‚Üí\t# Move toward player while approaching\n   955‚Üí\tif _player:\n   956‚Üí\t\tvar move_direction := direction_to_player\n   957‚Üí\n   958‚Üí\t\t# Apply wall avoidance\n   959‚Üí\t\tvar avoidance := _check_wall_ahead(move_direction)\n   960‚Üí\t\tif avoidance != Vector2.ZERO:\n   961‚Üí\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n   962‚Üí\n   963‚Üí\t\tvelocity = move_direction * combat_move_speed\n   964‚Üí\t\trotation = direction_to_player.angle()  # Always face player\n   965‚Üí\n   966‚Üí\t\t# Can shoot while approaching (only after detection delay and if have clear shot)\n   967‚Üí\t\tif has_clear_shot and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n   968‚Üí\t\t\t_aim_at_player()\n   969‚Üí\t\t\t_shoot()\n   970‚Üí\t\t\t_shoot_timer = 0.0\n   971‚Üí\n   972‚Üí\n   973‚Üí## Calculate a target position to exit cover and get a clear shot.\n   974‚Üí## Returns a position that should allow the bullet spawn point to be unobstructed.\n   975‚Üífunc _calculate_clear_shot_exit_position(direction_to_player: Vector2) -> Vector2:\n   976‚Üí\t# Calculate perpendicular directions to the player\n   977‚Üí\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n   978‚Üí\n   979‚Üí\t# Try both perpendicular directions and pick the one that's more likely to work\n   980‚Üí\t# Also blend with forward movement toward player to help navigate around cover\n   981‚Üí\tvar best_position := global_position\n   982‚Üí\tvar best_score := -1.0\n   983‚Üí\n   984‚Üí\tfor side_multiplier: float in [1.0, -1.0]:\n   985‚Üí\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n   986‚Üí\t\t# Blend sidestep with forward movement for better cover navigation\n   987‚Üí\t\tvar exit_dir: Vector2 = (sidestep_dir * 0.7 + direction_to_player * 0.3).normalized()\n   988‚Üí\t\tvar test_position: Vector2 = global_position + exit_dir * CLEAR_SHOT_EXIT_DISTANCE\n   989‚Üí\n   990‚Üí\t\t# Score this position based on:\n   991‚Üí\t\t# 1. Does it have a clear path? (no walls in the way)\n   992‚Üí\t\t# 2. Would the bullet spawn be clear from there?\n   993‚Üí\t\tvar score: float = 0.0\n   994‚Üí\n   995‚Üí\t\t# Check if we can move to this position\n   996‚Üí\t\tif _has_clear_path_to(test_position):\n   997‚Üí\t\t\tscore += 1.0\n   998‚Üí\n   999‚Üí\t\t# Check if bullet spawn would be clear from this position\n  1000‚Üí\t\t# This is a rough estimate - we check from the test position toward player\n  1001‚Üí\t\tvar world_2d := get_world_2d()\n  1002‚Üí\t\tif world_2d != null:\n  1003‚Üí\t\t\tvar space_state := world_2d.direct_space_state\n  1004‚Üí\t\t\tif space_state != null:\n  1005‚Üí\t\t\t\tvar check_distance := bullet_spawn_offset + 5.0\n  1006‚Üí\t\t\t\tvar query := PhysicsRayQueryParameters2D.new()\n  1007‚Üí\t\t\t\tquery.from = test_position\n  1008‚Üí\t\t\t\tquery.to = test_position + direction_to_player * check_distance\n  1009‚Üí\t\t\t\tquery.collision_mask = 4  # Only check obstacles\n  1010‚Üí\t\t\t\tquery.exclude = [get_rid()]\n  1011‚Üí\t\t\t\tvar result := space_state.intersect_ray(query)\n  1012‚Üí\t\t\t\tif result.is_empty():\n  1013‚Üí\t\t\t\t\tscore += 2.0  # Higher score for clear bullet spawn\n  1014‚Üí\n  1015‚Üí\t\tif score > best_score:\n  1016‚Üí\t\t\tbest_score = score\n  1017‚Üí\t\t\tbest_position = test_position\n  1018‚Üí\n  1019‚Üí\t# If no good position found, just move forward toward player\n  1020‚Üí\tif best_score < 0.5:\n  1021‚Üí\t\tbest_position = global_position + direction_to_player * CLEAR_SHOT_EXIT_DISTANCE\n  1022‚Üí\n  1023‚Üí\treturn best_position\n  1024‚Üí\n  1025‚Üí\n  1026‚Üí## Process SEEKING_COVER state - moving to cover position.\n  1027‚Üífunc _process_seeking_cover_state(_delta: float) -> void:\n  1028‚Üí\tif not _has_valid_cover:\n  1029‚Üí\t\t# Try to find cover\n  1030‚Üí\t\t_find_cover_position()\n  1031‚Üí\t\tif not _has_valid_cover:\n  1032‚Üí\t\t\t# No cover found, stay in combat\n  1033‚Üí\t\t\t_transition_to_combat()\n  1034‚Üí\t\t\treturn\n  1035‚Üí\n  1036‚Üí\t# Check if we're already hidden from the player (the main goal)\n  1037‚Üí\tif not _is_visible_from_player():\n  1038‚Üí\t\t_transition_to_in_cover()\n  1039‚Üí\t\t_log_debug(\"Hidden from player, entering cover state\")\n  1040‚Üí\t\treturn\n  1041‚Üí\n  1042‚Üí\t# Move towards cover\n  1043‚Üí\tvar direction := (_cover_position - global_position).normalized()\n  1044‚Üí\tvar distance := global_position.distance_to(_cover_position)\n  1045‚Üí\n  1046‚Üí\tif distance < 10.0:\n  1047‚Üí\t\t# Reached the cover position, but still visible - try to find better cover\n  1048‚Üí\t\tif _is_visible_from_player():\n  1049‚Üí\t\t\t_has_valid_cover = false\n  1050‚Üí\t\t\t_find_cover_position()\n  1051‚Üí\t\t\tif not _has_valid_cover:\n  1052‚Üí\t\t\t\t# No better cover found, stay in combat\n  1053‚Üí\t\t\t\t_transition_to_combat()\n  1054‚Üí\t\t\t\treturn\n  1055‚Üí\n  1056‚Üí\t# Apply wall avoidance\n  1057‚Üí\tvar avoidance := _check_wall_ahead(direction)\n  1058‚Üí\tif avoidance != Vector2.ZERO:\n  1059‚Üí\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n  1060‚Üí\n  1061‚Üí\tvelocity = direction * combat_move_speed\n  1062‚Üí\trotation = direction.angle()\n  1063‚Üí\n  1064‚Üí\t# Can still shoot while moving to cover (only after detection delay)\n  1065‚Üí\tif _can_see_player and _player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n  1066‚Üí\t\t_aim_at_player()\n  1067‚Üí\t\t_shoot()\n  1068‚Üí\t\t_shoot_timer = 0.0\n  1069‚Üí\n  1070‚Üí\n  1071‚Üí## Process IN_COVER state - taking cover from enemy fire.\n  1072‚Üí## Decides next action based on:\n  1073‚Üí## 1. If under fire -> suppressed\n  1074‚Üí## 2. If player is close (can exit cover for direct contact) -> COMBAT\n  1075‚Üí## 3. If player is far but can hit from current position -> COMBAT (stay and shoot)\n  1076‚Üí## 4. If player is far and can't hit -> PURSUING (move cover-to-cover)\n  1077‚Üífunc _process_in_cover_state(delta: float) -> void:\n  1078‚Üí\tvelocity = Vector2.ZERO\n  1079‚Üí\n  1080‚Üí\t# If still under fire, stay suppressed\n  1081‚Üí\tif _under_fire:\n  1082‚Üí\t\t_transition_to_suppressed()\n  1083‚Üí\t\treturn\n  1084‚Üí\n  1085‚Üí\t# Check if player has flanked us - if we're now visible from player's position,\n  1086‚Üí\t# we need to find new cover\n  1087‚Üí\tif _is_visible_from_player():\n  1088‚Üí\t\t# If in alarm mode and can see player, fire a burst before escaping\n  1089‚Üí\t\tif _in_alarm_mode and _can_see_player and _player:\n  1090‚Üí\t\t\tif not _cover_burst_pending:\n  1091‚Üí\t\t\t\t# Start the cover burst\n  1092‚Üí\t\t\t\t_cover_burst_pending = true\n  1093‚Üí\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n  1094‚Üí\t\t\t\t_retreat_burst_timer = 0.0\n  1095‚Üí\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n  1096‚Üí\t\t\t\t_log_debug(\"IN_COVER alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n  1097‚Üí\n  1098‚Üí\t\t\t# Fire the burst\n  1099‚Üí\t\t\tif _retreat_burst_remaining > 0:\n  1100‚Üí\t\t\t\t_retreat_burst_timer += delta\n  1101‚Üí\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n  1102‚Üí\t\t\t\t\t_aim_at_player()\n  1103‚Üí\t\t\t\t\t_shoot_burst_shot()\n  1104‚Üí\t\t\t\t\t_retreat_burst_remaining -= 1\n  1105‚Üí\t\t\t\t\t_retreat_burst_timer = 0.0\n  1106‚Üí\t\t\t\t\tif _retreat_burst_remaining > 0:\n  1107‚Üí\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n  1108‚Üí\t\t\t\treturn  # Stay in cover while firing burst\n  1109‚Üí\n  1110‚Üí\t\t# Burst complete or not in alarm mode, seek new cover\n  1111‚Üí\t\t_log_debug(\"Player flanked our cover position, seeking new cover\")\n  1112‚Üí\t\t_has_valid_cover = false  # Invalidate current cover\n  1113‚Üí\t\t_cover_burst_pending = false\n  1114‚Üí\t\t_transition_to_seeking_cover()\n  1115‚Üí\t\treturn\n  1116‚Üí\n  1117‚Üí\t# Check if multiple enemies are in combat - transition to assault state\n  1118‚Üí\tvar enemies_in_combat := _count_enemies_in_combat()\n  1119‚Üí\tif enemies_in_combat >= 2:\n  1120‚Üí\t\t_log_debug(\"Multiple enemies detected (%d), transitioning to ASSAULT\" % enemies_in_combat)\n  1121‚Üí\t\t_transition_to_assault()\n  1122‚Üí\t\treturn\n  1123‚Üí\n  1124‚Üí\t# Decision making based on player distance and visibility\n  1125‚Üí\tif _player:\n  1126‚Üí\t\tvar player_close := _is_player_close()\n  1127‚Üí\t\tvar can_hit := _can_hit_player_from_current_position()\n  1128‚Üí\n  1129‚Üí\t\tif _can_see_player:\n  1130‚Üí\t\t\tif player_close:\n  1131‚Üí\t\t\t\t# Player is close - engage in combat (come out, shoot, go back)\n  1132‚Üí\t\t\t\t_log_debug(\"Player is close, transitioning to COMBAT\")\n  1133‚Üí\t\t\t\t_transition_to_combat()\n  1134‚Üí\t\t\t\treturn\n  1135‚Üí\t\t\telse:\n  1136‚Üí\t\t\t\t# Player is far\n  1137‚Üí\t\t\t\tif can_hit:\n  1138‚Üí\t\t\t\t\t# Can hit from current position - come out and shoot\n  1139‚Üí\t\t\t\t\t# (Don't pursue, just transition to combat which will handle the cycling)\n  1140‚Üí\t\t\t\t\t_log_debug(\"Player is far but can hit from here, transitioning to COMBAT\")\n  1141‚Üí\t\t\t\t\t_transition_to_combat()\n  1142‚Üí\t\t\t\t\treturn\n  1143‚Üí\t\t\t\telse:\n  1144‚Üí\t\t\t\t\t# Can't hit from here - need to pursue (move cover-to-cover)\n  1145‚Üí\t\t\t\t\t_log_debug(\"Player is far and can't hit, transitioning to PURSUING\")\n  1146‚Üí\t\t\t\t\t_transition_to_pursuing()\n  1147‚Üí\t\t\t\t\treturn\n  1148‚Üí\n  1149‚Üí\t# If not under fire and can see player, engage (only shoot after detection delay)\n  1150‚Üí\tif _can_see_player and _player:\n  1151‚Üí\t\t_aim_at_player()\n  1152‚Üí\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n  1153‚Üí\t\t\t_shoot()\n  1154‚Üí\t\t\t_shoot_timer = 0.0\n  1155‚Üí\n  1156‚Üí\t# If player is no longer visible and not under fire, try pursuing\n  1157‚Üí\tif not _can_see_player and not _under_fire:\n  1158‚Üí\t\t_log_debug(\"Lost sight of player from cover, transitioning to PURSUING\")\n  1159‚Üí\t\t_transition_to_pursuing()\n  1160‚Üí\n  1161‚Üí\n  1162‚Üí## Process FLANKING state - attempting to flank the player using cover-to-cover movement.\n  1163‚Üí## Uses intermediate cover positions to navigate around obstacles instead of walking\n  1164‚Üí## directly toward the flank target.\n  1165‚Üífunc _process_flanking_state(delta: float) -> void:\n  1166‚Üí\t# If under fire, retreat with shooting behavior\n  1167‚Üí\tif _under_fire and enable_cover:\n  1168‚Üí\t\t_transition_to_retreating()\n  1169‚Üí\t\treturn\n  1170‚Üí\n  1171‚Üí\t# If can see player, engage in combat\n  1172‚Üí\tif _can_see_player:\n  1173‚Üí\t\t_transition_to_combat()\n  1174‚Üí\t\treturn\n  1175‚Üí\n  1176‚Üí\tif _player == null:\n  1177‚Üí\t\t_transition_to_idle()\n  1178‚Üí\t\treturn\n  1179‚Üí\n  1180‚Üí\t# Recalculate flank pos
[2026-01-18T02:49:23.364Z] [INFO] ition (player may have moved)\n  1181‚Üí\t_calculate_flank_position()\n  1182‚Üí\n  1183‚Üí\tvar distance_to_flank := global_position.distance_to(_flank_target)\n  1184‚Üí\n  1185‚Üí\t# Check if we've reached the flank target\n  1186‚Üí\tif distance_to_flank < 30.0:\n  1187‚Üí\t\t_log_debug(\"Reached flank position, engaging\")\n  1188‚Üí\t\t_transition_to_combat()\n  1189‚Üí\t\treturn\n  1190‚Üí\n  1191‚Üí\t# Check if we have direct line of sight to flank target (no obstacles)\n  1192‚Üí\tif _has_clear_path_to(_flank_target):\n  1193‚Üí\t\t# Direct path is clear - move directly toward flank target\n  1194‚Üí\t\tvar direction := (_flank_target - global_position).normalized()\n  1195‚Üí\t\tvar avoidance := _check_wall_ahead(direction)\n  1196‚Üí\t\tif avoidance != Vector2.ZERO:\n  1197‚Üí\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n  1198‚Üí\t\tvelocity = direction * combat_move_speed\n  1199‚Üí\t\trotation = direction.angle()\n  1200‚Üí\t\t_has_flank_cover = false\n  1201‚Üí\t\treturn\n  1202‚Üí\n  1203‚Üí\t# Path is blocked - use cover-to-cover movement\n  1204‚Üí\n  1205‚Üí\t# If we're at a cover position, wait briefly before moving to next\n  1206‚Üí\tif _has_valid_cover and not _has_flank_cover:\n  1207‚Üí\t\t_flank_cover_wait_timer += delta\n  1208‚Üí\t\tvelocity = Vector2.ZERO\n  1209‚Üí\n  1210‚Üí\t\tif _flank_cover_wait_timer >= FLANK_COVER_WAIT_DURATION:\n  1211‚Üí\t\t\t# Done waiting, find next cover toward flank target\n  1212‚Üí\t\t\t_find_flank_cover_toward_target()\n  1213‚Üí\t\t\tif not _has_flank_cover:\n  1214‚Üí\t\t\t\t_log_debug(\"No flank cover found, attempting direct movement\")\n  1215‚Üí\t\t\t\t# No cover found - try direct movement with enhanced wall avoidance\n  1216‚Üí\t\t\t\tvar direction := (_flank_target - global_position).normalized()\n  1217‚Üí\t\t\t\tvar avoidance := _check_wall_ahead(direction)\n  1218‚Üí\t\t\t\tif avoidance != Vector2.ZERO:\n  1219‚Üí\t\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n  1220‚Üí\t\t\t\tvelocity = direction * combat_move_speed\n  1221‚Üí\t\t\t\trotation = direction.angle()\n  1222‚Üí\t\t\t\t# Invalidate current cover to trigger new search next frame\n  1223‚Üí\t\t\t\t_has_valid_cover = false\n  1224‚Üí\t\treturn\n  1225‚Üí\n  1226‚Üí\t# If we have a flank cover target, move toward it\n  1227‚Üí\tif _has_flank_cover:\n  1228‚Üí\t\tvar direction := (_flank_next_cover - global_position).normalized()\n  1229‚Üí\t\tvar distance := global_position.distance_to(_flank_next_cover)\n  1230‚Üí\n  1231‚Üí\t\t# Check if we've reached the flank cover\n  1232‚Üí\t\tif distance < 15.0:\n  1233‚Üí\t\t\t_log_debug(\"Reached flank cover at distance %.1f\" % distance)\n  1234‚Üí\t\t\t_has_flank_cover = false\n  1235‚Üí\t\t\t_flank_cover_wait_timer = 0.0\n  1236‚Üí\t\t\t_cover_position = _flank_next_cover\n  1237‚Üí\t\t\t_has_valid_cover = true\n  1238‚Üí\t\t\t# Start waiting at this cover\n  1239‚Üí\t\t\treturn\n  1240‚Üí\n  1241‚Üí\t\t# Apply wall avoidance\n  1242‚Üí\t\tvar avoidance := _check_wall_ahead(direction)\n  1243‚Üí\t\tif avoidance != Vector2.ZERO:\n  1244‚Üí\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n  1245‚Üí\n  1246‚Üí\t\tvelocity = direction * combat_move_speed\n  1247‚Üí\t\trotation = direction.angle()\n  1248‚Üí\t\treturn\n  1249‚Üí\n  1250‚Üí\t# No cover and no flank cover target - find initial flank cover\n  1251‚Üí\t_find_flank_cover_toward_target()\n  1252‚Üí\tif not _has_flank_cover:\n  1253‚Üí\t\t# Can't find cover, try direct movement with wall avoidance\n  1254‚Üí\t\tvar direction := (_flank_target - global_position).normalized()\n  1255‚Üí\t\tvar avoidance := _check_wall_ahead(direction)\n  1256‚Üí\t\tif avoidance != Vector2.ZERO:\n  1257‚Üí\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n  1258‚Üí\t\tvelocity = direction * combat_move_speed\n  1259‚Üí\t\trotation = direction.angle()\n  1260‚Üí\n  1261‚Üí\n  1262‚Üí## Process SUPPRESSED state - staying in cover under fire.\n  1263‚Üífunc _process_suppressed_state(delta: float) -> void:\n  1264‚Üí\tvelocity = Vector2.ZERO\n  1265‚Üí\n  1266‚Üí\t# Check if player has flanked us - if we're now visible from player's position,\n  1267‚Üí\t# we need to find new cover even while suppressed\n  1268‚Üí\tif _is_visible_from_player():\n  1269‚Üí\t\t# In suppressed state we're always in alarm mode - fire a burst before escaping if we can see player\n  1270‚Üí\t\tif _can_see_player and _player:\n  1271‚Üí\t\t\tif not _cover_burst_pending:\n  1272‚Üí\t\t\t\t# Start the cover burst\n  1273‚Üí\t\t\t\t_cover_burst_pending = true\n  1274‚Üí\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n  1275‚Üí\t\t\t\t_retreat_burst_timer = 0.0\n  1276‚Üí\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n  1277‚Üí\t\t\t\t_log_debug(\"SUPPRESSED alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n  1278‚Üí\n  1279‚Üí\t\t\t# Fire the burst\n  1280‚Üí\t\t\tif _retreat_burst_remaining > 0:\n  1281‚Üí\t\t\t\t_retreat_burst_timer += delta\n  1282‚Üí\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n  1283‚Üí\t\t\t\t\t_aim_at_player()\n  1284‚Üí\t\t\t\t\t_shoot_burst_shot()\n  1285‚Üí\t\t\t\t\t_retreat_burst_remaining -= 1\n  1286‚Üí\t\t\t\t\t_retreat_burst_timer = 0.0\n  1287‚Üí\t\t\t\t\tif _retreat_burst_remaining > 0:\n  1288‚Üí\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n  1289‚Üí\t\t\t\treturn  # Stay suppressed while firing burst\n  1290‚Üí\n  1291‚Üí\t\t# Burst complete or can't see player, seek new cover\n  1292‚Üí\t\t_log_debug(\"Player flanked our cover position while suppressed, seeking new cover\")\n  1293‚Üí\t\t_has_valid_cover = false  # Invalidate current cover\n  1294‚Üí\t\t_cover_burst_pending = false\n  1295‚Üí\t\t_transition_to_seeking_cover()\n  1296‚Üí\t\treturn\n  1297‚Üí\n  1298‚Üí\t# Can still shoot while suppressed (only after detection delay)\n  1299‚Üí\tif _can_see_player and _player:\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"797fbac8-f5e6-4339-8fd2-77453410db49","uuid":"01eabc54-ff5e-404f-8c21-6e0b15205346","tool_use_result":{"type":"text","file":{"filePath":"/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd","content":"\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can't see player, pursue them (move cover-to-cover toward player)\n\tif not _can_see_player:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\t\treturn\n\n\t# Update detection delay timer\n\tif not _detection_delay_elapsed:\n\t\t_detection_timer += delta\n\t\tif _detection_timer >= detection_delay:\n\t\t\t_detection_delay_elapsed = true\n\n\t# If we don't have cover, find some first (needed for returning later)\n\tif not _has_valid_cover and enable_cover:\n\t\t_find_cover_position()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found cover at %s for combat cycling\" % _cover_position)\n\n\t# Check player distance for approach/exposed phase decisions\n\tvar distance_to_player := INF\n\tif _player:\n\t\tdistance_to_player = global_position.distance_to(_player.global_position)\n\n\t# Check if we have a clear shot (no wall blocking bullet spawn)\n\tvar direction_to_player := Vector2.ZERO\n\tvar has_clear_shot := true\n\tif _player:\n\t\tdirection_to_player = (_player.global_position - global_position).normalized()\n\t\thas_clear_shot = _is_bullet_spawn_clear(direction_to_player)\n\n\t# If already exposed (shooting phase), handle shooting and timer\n\tif _combat_exposed:\n\t\t_combat_shoot_timer += delta\n\n\t\t# Check if exposure time is complete - go back to cover\n\t\tif _combat_shoot_timer >= _combat_shoot_duration and _has_valid_cover:\n\t\t\t_log_debug(\"Combat exposure time complete (%.1fs), returning to cover\" % _combat_shoot_duration)\n\t\t\t_combat_exposed = false\n\t\t\t_combat_approaching = false\n\t\t\t_combat_shoot_timer = 0.0\n\t\t\t_transition_to_seeking_cover()\n\t\t\treturn\n\n\t\t# Check if we still have a clear shot - if not, move sideways to find one\n\t\tif _player and not has_clear_shot:\n\t\t\t# Bullet spawn is blocked - move sideways to find a clear shot position\n\t\t\tvar sidestep_dir := _find_sidestep_direction_for_clear_shot(direction_to_player)\n\t\t\tif sidestep_dir != Vector2.ZERO:\n\t\t\t\tvelocity = sidestep_dir * combat_move_speed * 0.7\n\t\t\t\trotation = direction_to_player.angle()  # Keep facing player while sidestepping\n\t\t\t\t_log_debug(\"COMBAT exposed: sidestepping to maintain clear shot\")\n\t\t\telse:\n\t\t\t\t# No sidestep works - stay still, the shot might clear up\n\t\t\t\tvelocity = Vector2.ZERO\n\t\t\treturn\n\n\t\t# In exposed phase with clear shot, stand still and shoot\n\t\tvelocity = Vector2.ZERO\n\n\t\t# Aim and shoot at player (only shoot after detection delay)\n\t\tif _player:\n\t\t\t_aim_at_player()\n\t\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot()\n\t\t\t\t_shoot_timer = 0.0\n\t\treturn\n\n\t# --- CLEAR SHOT SEEKING PHASE ---\n\t# If bullet spawn is blocked and we're not already exposed, we need to move out from cover\n\tif not has_clear_shot and _player:\n\t\t# Start seeking clear shot if not already doing so\n\t\tif not _seeking_clear_shot:\n\t\t\t_seeking_clear_shot = true\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Calculate target position: move perpendicular to player direction (around cover edge)\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\t_log_debug(\"COMBAT: bullet spawn blocked, seeking clear shot at %s\" % _clear_shot_target)\n\n\t\t_clear_shot_timer += delta\n\n\t\t# Check if we've exceeded the max time trying to find a clear shot\n\t\tif _clear_shot_timer >= CLEAR_SHOT_MAX_TIME:\n\t\t\t_log_debug(\"COMBAT: clear shot timeout, trying flanking\")\n\t\t\t_seeking_clear_shot = false\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Try flanking to get around the obstacle\n\t\t\tif enable_flanking:\n\t\t\t\t_transition_to_flanking()\n\t\t\telse:\n\t\t\t\t_transition_to_pursuing()\n\t\t\treturn\n\n\t\t# Move toward the clear shot target position\n\t\tvar distance_to_target := global_position.distance_to(_clear_shot_target)\n\t\tif distance_to_target > 15.0:\n\t\t\tvar move_direction := (_clear_shot_target - global_position).normalized()\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed\n\t\t\trotation = direction_to_player.angle()  # Keep facing player\n\n\t\t\t# Check if the new position now has a clear shot\n\t\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\t\t_log_debug(\"COMBAT: found clear shot position while moving\")\n\t\t\t\t_seeking_clear_shot = false\n\t\t\t\t_clear_shot_timer = 0.0\n\t\t\t\t# Continue to exposed phase check below\n\t\t\telse:\n\t\t\t\treturn  # Keep moving toward target\n\t\telse:\n\t\t\t# Reached target but still no clear shot - recalculate target\n\t\t\t_log_debug(\"COMBAT: reached target but no clear shot, recalculating\")\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\treturn\n\n\t# Reset seeking state if we now have a clear shot\n\tif _seeking_clear_shot and has_clear_shot:\n\t\t_log_debug(\"COMBAT: clear shot acquired\")\n\t\t_seeking_clear_shot = false\n\t\t_clear_shot_timer = 0.0\n\n\t# Determine if we should be in approach phase or exposed shooting phase\n\tvar in_direct_contact := distance_to_player <= COMBAT_DIRECT_CONTACT_DISTANCE\n\n\t# Enter exposed phase if we have a clear shot and are either close enough or have approached long enough\n\tif has_clear_shot and (in_direct_contact or _combat_approach_timer >= COMBAT_APPROACH_MAX_TIME):\n\t\t# Close enough AND have clear shot - start exposed shooting phase\n\t\t_combat_exposed = true\n\t\t_combat_approaching = false\n\t\t_combat_shoot_timer = 0.0\n\t\t_combat_approach_timer = 0.0\n\t\t# Randomize exposure duration between 2-3 seconds\n\t\t_combat_shoot_duration = randf_range(2.0, 3.0)\n\t\t_log_debug(\"COMBAT exposed phase started (distance: %.0f), will shoot for %.1fs\" % [distance_to_player, _combat_shoot_duration])\n\t\treturn\n\n\t# Need to approach player - move toward them\n\tif not _combat_approaching:\n\t\t_combat_approaching = true\n\t\t_combat_approach_timer = 0.0\n\t\t_log_debug(\"COMBAT approach phase started, moving toward player\")\n\n\t_combat_approach_timer += delta\n\n\t# Move toward player while approaching\n\tif _player:\n\t\tvar move_direction := direction_to_player\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = move_direction * combat_move_speed\n\t\trotation = direction_to_player.angle()  # Always face player\n\n\t\t# Can shoot while approaching (only after detection delay and if have clear shot)\n\t\tif has_clear_shot and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\n## Calculate a target position to exit cover and get a clear shot.\n## Returns a position that should allow the bullet spawn point to be unobstructed.\nfunc _calculate_clear_shot_exit_position(direction_to_player: Vector2) -> Vector2:\n\t# Calculate perpendicular directions to the player\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Try both perpendicular directions and pick the one that's more likely to work\n\t# Also blend with forward movement toward player to help navigate around cover\n\tvar best_position := global_position\n\tvar best_score := -1.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\t\t# Blend sidestep with forward movement for better cover navigation\n\t\tvar exit_dir: Vector2 = (sidestep_dir * 0.7 + direction_to_player * 0.3).normalized()\n\t\tvar test_position: Vector2 = global_position + exit_dir * CLEAR_SHOT_EXIT_DISTANCE\n\n\t\t# Score this position based on:\n\t\t# 1. Does it have a clear path? (no walls in the way)\n\t\t# 2. Would the bullet spawn be clear from there?\n\t\tvar score: float = 0.0\n\n\t\t# Check if we can move to this position\n\t\tif _has_clear_path_to(test_position):\n\t\t\tscore += 1.0\n\n\t\t# Check if bullet spawn would be clear from this position\n\t\t# This is a rough estimate - we check from the test position toward player\n\t\tvar world_2d := get_world_2d()\n\t\tif world_2d != null:\n\t\t\tvar space_state := world_2d.direct_space_state\n\t\t\tif space_state != null:\n\t\t\t\tvar check_distance := bullet_spawn_offset + 5.0\n\t\t\t\tvar query := PhysicsRayQueryParameters2D.new()\n\t\t\t\tquery.from = test_position\n\t\t\t\tquery.to = test_position + direction_to_player * check_distance\n\t\t\t\tquery.collision_mask = 4  # Only check obstacles\n\t\t\t\tquery.exclude = [get_rid()]\n\t\t\t\tvar result := space_state.intersect_ray(query)\n\t\t\t\tif result.is_empty():\n\t\t\t\t\tscore += 2.0  # Higher score for clear bullet spawn\n\n\t\tif score > best_score:\n\t\t\tbest_score = score\n\t\t\tbest_position = test_position\n\n\t# If no good position found, just move forward toward player\n\tif best_score < 0.5:\n\t\tbest_position = global_position + direction_to_player * CLEAR_SHOT_EXIT_DISTANCE\n\n\treturn best_position\n\n\n## Process SEEKING_COVER state - moving to cover position.\nfunc _process_seeking_cover_state(_delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, stay in combat\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're already hidden from the player (the main goal)\n\tif not _is_visible_from_player():\n\t\t_transition_to_in_cover()\n\t\t_log_debug(\"Hidden from player, entering cover state\")\n\t\treturn\n\n\t# Move towards cover\n\tvar direction := (_cover_position - global_position).normalized()\n\tvar distance := global_position.distance_to(_cover_position)\n\n\tif distance < 10.0:\n\t\t# Reached the cover position, but still visible - try to find better cover\n\t\tif _is_visible_from_player():\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\t# No better cover found, stay in combat\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\n\t# Apply wall avoidance\n\tvar avoidance := _check_wall_ahead(direction)\n\tif avoidance != Vector2.ZERO:\n\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\tvelocity = direction * combat_move_speed\n\trotation = direction.angle()\n\n\t# Can still shoot while moving to cover (only after detection delay)\n\tif _can_see_player and _player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t_aim_at_player()\n\t\t_shoot()\n\t\t_shoot_timer = 0.0\n\n\n## Process IN_COVER state - taking cover from enemy fire.\n## Decides next action based on:\n## 1. If under fire -> suppressed\n## 2. If player is close (can exit cover for direct contact) -> COMBAT\n## 3. If player is far but can hit from current position -> COMBAT (stay and shoot)\n## 4. If player is far and can't hit -> PURSUING (move cover-to-cover)\nfunc _process_in_cover_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# If still under fire, stay suppressed\n\tif _under_fire:\n\t\t_transition_to_suppressed()\n\t\treturn\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover\n\tif _is_visible_from_player():\n\t\t# If in alarm mode and can see player, fire a burst before escaping\n\t\tif _in_alarm_mode and _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"IN_COVER alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay in cover while firing burst\n\n\t\t# Burst complete or not in alarm mode, seek new cover\n\t\t_log_debug(\"Player flanked our cover position, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# Decision making based on player distance and visibility\n\tif _player:\n\t\tvar player_close := _is_player_close()\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\n\t\tif _can_see_player:\n\t\t\tif player_close:\n\t\t\t\t# Player is close - engage in combat (come out, shoot, go back)\n\t\t\t\t_log_debug(\"Player is close, transitioning to COMBAT\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\t# Player is far\n\t\t\t\tif can_hit:\n\t\t\t\t\t# Can hit from current position - come out and shoot\n\t\t\t\t\t# (Don't pursue, just transition to combat which will handle the cycling)\n\t\t\t\t\t_log_debug(\"Player is far but can hit from here, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\telse:\n\t\t\t\t\t# Can't hit from here - need to pursue (move cover-to-cover)\n\t\t\t\t\t_log_debug(\"Player is far and can't hit, transitioning to PURSUING\")\n\t\t\t\t\t_transition_to_pursuing()\n\t\t\t\t\treturn\n\n\t# If not under fire and can see player, engage (only shoot after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If player is no longer visible and not under fire, try pursuing\n\tif not _can_see_player and not _under_fire:\n\t\t_log_debug(\"Lost sight of player from cover, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\n\n## Process FLANKING state - attempting to flank the player using cover-to-cover movement.\n## Uses intermediate cover positions to navigate around obstacles instead of walking\n## directly toward the flank target.\nfunc _process_flanking_state(delta: float) -> void:\n\t# If under fire, retreat with shooting behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# If can see player, engage in combat\n\tif _can_see_player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\tif _player == null:\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# Recalculate flank position (player may have moved)\n\t_calculate_flank_position()\n\n\tvar distance_to_flank := global_position.distance_to(_flank_target)\n\n\t# Check if we've reached the flank target\n\tif distance_to_flank < 30.0:\n\t\t_log_debug(\"Reached flank position, engaging\")\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Check if we have direct line of sight to flank target (no obstacles)\n\tif _has_clear_path_to(_flank_target):\n\t\t# Direct path is clear - move directly toward flank target\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\t_has_flank_cover = false\n\t\treturn\n\n\t# Path is blocked - use cover-to-cover movement\n\n\t# If we're at a cover position, wait briefly before moving to next\n\tif _has_valid_cover and not _has_flank_cover:\n\t\t_flank_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _flank_cover_wait_timer >= FLANK_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover toward flank target\n\t\t\t_find_flank_cover_toward_target()\n\t\t\tif not _has_flank_cover:\n\t\t\t\t_log_debug(\"No flank cover found, attempting direct movement\")\n\t\t\t\t# No cover found - try direct movement with enhanced wall avoidance\n\t\t\t\tvar direction := (_flank_target - global_position).normalized()\n\t\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\t\tvelocity = direction * combat_move_speed\n\t\t\t\trotation = direction.angle()\n\t\t\t\t# Invalidate current cover to trigger new search next frame\n\t\t\t\t_has_valid_cover = false\n\t\treturn\n\n\t# If we have a flank cover target, move toward it\n\tif _has_flank_cover:\n\t\tvar direction := (_flank_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_flank_next_cover)\n\n\t\t# Check if we've reached the flank cover\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached flank cover at distance %.1f\" % distance)\n\t\t\t_has_flank_cover = false\n\t\t\t_flank_cover_wait_timer = 0.0\n\t\t\t_cover_position = _flank_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no flank cover target - find initial flank cover\n\t_find_flank_cover_toward_target()\n\tif not _has_flank_cover:\n\t\t# Can't find cover, try direct movement with wall avoidance\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\n\n## Process SUPPRESSED state - staying in cover under fire.\nfunc _process_suppressed_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover even while suppressed\n\tif _is_visible_from_player():\n\t\t# In suppressed state we're always in alarm mode - fire a burst before escaping if we can see player\n\t\tif _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"SUPPRESSED alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay suppressed while firing burst\n\n\t\t# Burst complete or can't see player, seek new cover\n\t\t_log_debug(\"Player flanked our cover position while suppressed, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Can still shoot while suppressed (only after detection delay)\n\tif _can_see_player and _player:","numLines":500,"startLine":800,"totalLines":3206}}}
[2026-01-18T02:49:26.234Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01B7UcSM274PJ2RpdtVQxGTe",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Let me continue reading to find the PURSUING state behavior and understand what happens when the player escapes from view."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 7803,
      "cache_read_input_tokens": 48735,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 7803,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 3,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "d53cbf1d-2dc4-4bdd-916d-125834ddd81e"
}
[2026-01-18T02:49:27.769Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01B7UcSM274PJ2RpdtVQxGTe",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_014AsvDRshL96Y3BQQGS8WJK",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "offset": 1300,
          "limit": 500
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 7803,
      "cache_read_input_tokens": 48735,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 7803,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 3,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "9b8d4286-bc45-4938-8e65-c995c7d2bbfb"
}
[2026-01-18T02:49:27.827Z] [INFO] {"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014AsvDRshL96Y3BQQGS8WJK","type":"tool_result","content":"  1300‚Üí\t\t_aim_at_player()\n  1301‚Üí\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n  1302‚Üí\t\t\t_shoot()\n  1303‚Üí\t\t\t_shoot_timer = 0.0\n  1304‚Üí\n  1305‚Üí\t# If no longer under fire, exit suppression\n  1306‚Üí\tif not _under_fire:\n  1307‚Üí\t\t_transition_to_in_cover()\n  1308‚Üí\n  1309‚Üí\n  1310‚Üí## Process RETREATING state - moving to cover with behavior based on damage taken.\n  1311‚Üífunc _process_retreating_state(delta: float) -> void:\n  1312‚Üí\tif not _has_valid_cover:\n  1313‚Üí\t\t# Try to find cover\n  1314‚Üí\t\t_find_cover_position()\n  1315‚Üí\t\tif not _has_valid_cover:\n  1316‚Üí\t\t\t# No cover found, transition to combat or suppressed\n  1317‚Üí\t\t\tif _under_fire:\n  1318‚Üí\t\t\t\t_transition_to_suppressed()\n  1319‚Üí\t\t\telse:\n  1320‚Üí\t\t\t\t_transition_to_combat()\n  1321‚Üí\t\t\treturn\n  1322‚Üí\n  1323‚Üí\t# Check if we've reached cover and are hidden from player\n  1324‚Üí\tif not _is_visible_from_player():\n  1325‚Üí\t\t_log_debug(\"Reached cover during retreat\")\n  1326‚Üí\t\t# Reset encounter hits when successfully reaching cover\n  1327‚Üí\t\t_hits_taken_in_encounter = 0\n  1328‚Üí\t\t_transition_to_in_cover()\n  1329‚Üí\t\treturn\n  1330‚Üí\n  1331‚Üí\t# Calculate direction to cover\n  1332‚Üí\tvar direction_to_cover := (_cover_position - global_position).normalized()\n  1333‚Üí\tvar distance_to_cover := global_position.distance_to(_cover_position)\n  1334‚Üí\n  1335‚Üí\t# Check if reached cover position\n  1336‚Üí\tif distance_to_cover < 10.0:\n  1337‚Üí\t\tif _is_visible_from_player():\n  1338‚Üí\t\t\t# Still visible, find better cover\n  1339‚Üí\t\t\t_has_valid_cover = false\n  1340‚Üí\t\t\t_find_cover_position()\n  1341‚Üí\t\t\tif not _has_valid_cover:\n  1342‚Üí\t\t\t\tif _under_fire:\n  1343‚Üí\t\t\t\t\t_transition_to_suppressed()\n  1344‚Üí\t\t\t\telse:\n  1345‚Üí\t\t\t\t\t_transition_to_combat()\n  1346‚Üí\t\t\treturn\n  1347‚Üí\n  1348‚Üí\t# Apply retreat behavior based on mode\n  1349‚Üí\tmatch _retreat_mode:\n  1350‚Üí\t\tRetreatMode.FULL_HP:\n  1351‚Üí\t\t\t_process_retreat_full_hp(delta, direction_to_cover)\n  1352‚Üí\t\tRetreatMode.ONE_HIT:\n  1353‚Üí\t\t\t_process_retreat_one_hit(delta, direction_to_cover)\n  1354‚Üí\t\tRetreatMode.MULTIPLE_HITS:\n  1355‚Üí\t\t\t_process_retreat_multiple_hits(delta, direction_to_cover)\n  1356‚Üí\n  1357‚Üí\n  1358‚Üí## Process FULL_HP retreat: walk backwards facing player, shoot with reduced accuracy,\n  1359‚Üí## periodically turn toward cover.\n  1360‚Üífunc _process_retreat_full_hp(delta: float, direction_to_cover: Vector2) -> void:\n  1361‚Üí\t_retreat_turn_timer += delta\n  1362‚Üí\n  1363‚Üí\tif _retreat_turning_to_cover:\n  1364‚Üí\t\t# Turning to face cover, don't shoot\n  1365‚Üí\t\tif _retreat_turn_timer >= RETREAT_TURN_DURATION:\n  1366‚Üí\t\t\t_retreat_turning_to_cover = false\n  1367‚Üí\t\t\t_retreat_turn_timer = 0.0\n  1368‚Üí\n  1369‚Üí\t\t# Face cover and move toward it\n  1370‚Üí\t\trotation = direction_to_cover.angle()\n  1371‚Üí\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n  1372‚Üí\t\tif avoidance != Vector2.ZERO:\n  1373‚Üí\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n  1374‚Üí\t\tvelocity = direction_to_cover * combat_move_speed\n  1375‚Üí\telse:\n  1376‚Üí\t\t# Face player and back up (walk backwards)\n  1377‚Üí\t\tif _retreat_turn_timer >= RETREAT_TURN_INTERVAL:\n  1378‚Üí\t\t\t_retreat_turning_to_cover = true\n  1379‚Üí\t\t\t_retreat_turn_timer = 0.0\n  1380‚Üí\t\t\t_log_debug(\"FULL_HP retreat: turning to check cover\")\n  1381‚Üí\n  1382‚Üí\t\tif _player:\n  1383‚Üí\t\t\t# Face the player\n  1384‚Üí\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n  1385‚Üí\t\t\t_aim_at_player()\n  1386‚Üí\n  1387‚Üí\t\t\t# Move backwards (opposite of player direction = toward cover generally)\n  1388‚Üí\t\t\t# Use the negative of the direction we're facing for \"backing up\"\n  1389‚Üí\t\t\tvar move_direction := -direction_to_player\n  1390‚Üí\n  1391‚Üí\t\t\t# Apply wall avoidance\n  1392‚Üí\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n  1393‚Üí\t\t\tif avoidance != Vector2.ZERO:\n  1394‚Üí\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n  1395‚Üí\n  1396‚Üí\t\t\tvelocity = move_direction * combat_move_speed * 0.7  # Slower when backing up\n  1397‚Üí\n  1398‚Üí\t\t\t# Shoot with reduced accuracy (only after detection delay)\n  1399‚Üí\t\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n  1400‚Üí\t\t\t\t_shoot_with_inaccuracy()\n  1401‚Üí\t\t\t\t_shoot_timer = 0.0\n  1402‚Üí\n  1403‚Üí\n  1404‚Üí## Process ONE_HIT retreat: quick burst of 2-4 shots in an arc while turning, then face cover.\n  1405‚Üífunc _process_retreat_one_hit(delta: float, direction_to_cover: Vector2) -> void:\n  1406‚Üí\tif not _retreat_burst_complete:\n  1407‚Üí\t\t# During burst phase\n  1408‚Üí\t\t_retreat_burst_timer += delta\n  1409‚Üí\n  1410‚Üí\t\tif _player and _retreat_burst_remaining > 0 and _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n  1411‚Üí\t\t\t# Fire a burst shot with arc spread\n  1412‚Üí\t\t\t_shoot_burst_shot()\n  1413‚Üí\t\t\t_retreat_burst_remaining -= 1\n  1414‚Üí\t\t\t_retreat_burst_timer = 0.0\n  1415‚Üí\n  1416‚Üí\t\t\t# Progress through the arc\n  1417‚Üí\t\t\tif _retreat_burst_remaining > 0:\n  1418‚Üí\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0  # Spread across 4 shots max\n  1419‚Üí\n  1420‚Üí\t\t# Gradually turn from player to cover during burst\n  1421‚Üí\t\tif _player:\n  1422‚Üí\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n  1423‚Üí\t\t\tvar target_angle: float\n  1424‚Üí\n  1425‚Üí\t\t\t# Interpolate rotation from player direction to cover direction\n  1426‚Üí\t\t\tvar burst_progress := 1.0 - (float(_retreat_burst_remaining) / 4.0)\n  1427‚Üí\t\t\tvar player_angle := direction_to_player.angle()\n  1428‚Üí\t\t\tvar cover_angle := direction_to_cover.angle()\n  1429‚Üí\t\t\ttarget_angle = lerp_angle(player_angle, cover_angle, burst_progress * 0.7)\n  1430‚Üí\t\t\trotation = target_angle\n  1431‚Üí\n  1432‚Üí\t\t# Move toward cover (slower during burst)\n  1433‚Üí\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n  1434‚Üí\t\tif avoidance != Vector2.ZERO:\n  1435‚Üí\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n  1436‚Üí\t\tvelocity = direction_to_cover * combat_move_speed * 0.5\n  1437‚Üí\n  1438‚Üí\t\t# Check if burst is complete\n  1439‚Üí\t\tif _retreat_burst_remaining <= 0:\n  1440‚Üí\t\t\t_retreat_burst_complete = true\n  1441‚Üí\t\t\t_log_debug(\"ONE_HIT retreat: burst complete, now running to cover\")\n  1442‚Üí\telse:\n  1443‚Üí\t\t# After burst, run to cover without shooting\n  1444‚Üí\t\trotation = direction_to_cover.angle()\n  1445‚Üí\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n  1446‚Üí\t\tif avoidance != Vector2.ZERO:\n  1447‚Üí\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n  1448‚Üí\t\tvelocity = direction_to_cover * combat_move_speed\n  1449‚Üí\n  1450‚Üí\n  1451‚Üí## Process MULTIPLE_HITS retreat: quick burst of 2-4 shots then run to cover (same as ONE_HIT).\n  1452‚Üífunc _process_retreat_multiple_hits(delta: float, direction_to_cover: Vector2) -> void:\n  1453‚Üí\t# Same behavior as ONE_HIT - quick burst then escape\n  1454‚Üí\t_process_retreat_one_hit(delta, direction_to_cover)\n  1455‚Üí\n  1456‚Üí\n  1457‚Üí## Process PURSUING state - move cover-to-cover toward player.\n  1458‚Üí## Enemy moves between covers, waiting 1-2 seconds at each cover,\n  1459‚Üí## until they can see and hit the player.\n  1460‚Üífunc _process_pursuing_state(delta: float) -> void:\n  1461‚Üí\t# Check for suppression - transition to retreating behavior\n  1462‚Üí\tif _under_fire and enable_cover:\n  1463‚Üí\t\t_transition_to_retreating()\n  1464‚Üí\t\treturn\n  1465‚Üí\n  1466‚Üí\t# Check if multiple enemies are in combat - transition to assault state\n  1467‚Üí\tvar enemies_in_combat := _count_enemies_in_combat()\n  1468‚Üí\tif enemies_in_combat >= 2:\n  1469‚Üí\t\t_log_debug(\"Multiple enemies detected during pursuit (%d), transitioning to ASSAULT\" % enemies_in_combat)\n  1470‚Üí\t\t_transition_to_assault()\n  1471‚Üí\t\treturn\n  1472‚Üí\n  1473‚Üí\t# If can see player and can hit them from current position, engage\n  1474‚Üí\tif _can_see_player and _player:\n  1475‚Üí\t\tvar can_hit := _can_hit_player_from_current_position()\n  1476‚Üí\t\tif can_hit:\n  1477‚Üí\t\t\t_log_debug(\"Can see and hit player from pursuit, transitioning to COMBAT\")\n  1478‚Üí\t\t\t_has_pursuit_cover = false\n  1479‚Üí\t\t\t_transition_to_combat()\n  1480‚Üí\t\t\treturn\n  1481‚Üí\n  1482‚Üí\t# Check if we're waiting at cover\n  1483‚Üí\tif _has_valid_cover and not _has_pursuit_cover:\n  1484‚Üí\t\t# Currently at cover, wait for 1-2 seconds before moving to next cover\n  1485‚Üí\t\t_pursuit_cover_wait_timer += delta\n  1486‚Üí\t\tvelocity = Vector2.ZERO\n  1487‚Üí\n  1488‚Üí\t\tif _pursuit_cover_wait_timer >= PURSUIT_COVER_WAIT_DURATION:\n  1489‚Üí\t\t\t# Done waiting, find next cover closer to player\n  1490‚Üí\t\t\t_log_debug(\"Pursuit wait complete, finding next cover\")\n  1491‚Üí\t\t\t_pursuit_cover_wait_timer = 0.0\n  1492‚Üí\t\t\t_find_pursuit_cover_toward_player()\n  1493‚Üí\t\t\tif _has_pursuit_cover:\n  1494‚Üí\t\t\t\t_log_debug(\"Found pursuit cover at %s\" % _pursuit_next_cover)\n  1495‚Üí\t\t\telse:\n  1496‚Üí\t\t\t\t# No pursuit cover found - fallback behavior\n  1497‚Üí\t\t\t\t_log_debug(\"No pursuit cover found, checking fallback options\")\n  1498‚Üí\t\t\t\t# If we can now see the player, engage directly\n  1499‚Üí\t\t\t\tif _can_see_player:\n  1500‚Üí\t\t\t\t\t_log_debug(\"Can see player, transitioning to COMBAT\")\n  1501‚Üí\t\t\t\t\t_transition_to_combat()\n  1502‚Üí\t\t\t\t\treturn\n  1503‚Üí\t\t\t\t# Try flanking\n  1504‚Üí\t\t\t\tif enable_flanking and _player:\n  1505‚Üí\t\t\t\t\t_log_debug(\"Attempting flanking maneuver\")\n  1506‚Üí\t\t\t\t\t_transition_to_flanking()\n  1507‚Üí\t\t\t\t\treturn\n  1508‚Üí\t\t\t\t# Last resort: move directly toward player\n  1509‚Üí\t\t\t\t_log_debug(\"No cover options, moving directly toward player\")\n  1510‚Üí\t\t\t\t_transition_to_combat()\n  1511‚Üí\t\t\t\treturn\n  1512‚Üí\t\treturn\n  1513‚Üí\n  1514‚Üí\t# If we have a pursuit cover target, move toward it\n  1515‚Üí\tif _has_pursuit_cover:\n  1516‚Üí\t\tvar direction := (_pursuit_next_cover - global_position).normalized()\n  1517‚Üí\t\tvar distance := global_position.distance_to(_pursuit_next_cover)\n  1518‚Üí\n  1519‚Üí\t\t# Check if we've reached the pursuit cover\n  1520‚Üí\t\t# Note: We only check distance here, NOT visibility from player.\n  1521‚Üí\t\t# If we checked visibility, the enemy would immediately consider themselves\n  1522‚Üí\t\t# \"at cover\" even before moving, since they start hidden from player.\n  1523‚Üí\t\tif distance < 15.0:\n  1524‚Üí\t\t\t_log_debug(\"Reached pursuit cover at distance %.1f\" % distance)\n  1525‚Üí\t\t\t_has_pursuit_cover = false\n  1526‚Üí\t\t\t_pursuit_cover_wait_timer = 0.0\n  1527‚Üí\t\t\t_cover_position = _pursuit_next_cover\n  1528‚Üí\t\t\t_has_valid_cover = true\n  1529‚Üí\t\t\t# Start waiting at this cover\n  1530‚Üí\t\t\treturn\n  1531‚Üí\n  1532‚Üí\t\t# Apply wall avoidance\n  1533‚Üí\t\tvar avoidance := _check_wall_ahead(direction)\n  1534‚Üí\t\tif avoidance != Vector2.ZERO:\n  1535‚Üí\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n  1536‚Üí\n  1537‚Üí\t\tvelocity = direction * combat_move_speed\n  1538‚Üí\t\trotation = direction.angle()\n  1539‚Üí\t\treturn\n  1540‚Üí\n  1541‚Üí\t# No cover and no pursuit target - find initial pursuit cover\n  1542‚Üí\t_find_pursuit_cover_toward_player()\n  1543‚Üí\tif not _has_pursuit_cover:\n  1544‚Üí\t\t# Can't find cover to pursue, try flanking or combat\n  1545‚Üí\t\tif enable_flanking and _player:\n  1546‚Üí\t\t\t_transition_to_flanking()\n  1547‚Üí\t\telse:\n  1548‚Üí\t\t\t_transition_to_combat()\n  1549‚Üí\n  1550‚Üí\n  1551‚Üí## Process ASSAULT state - coordinated multi-enemy rush.\n  1552‚Üí## Wait at cover for 5 seconds, then all enemies rush the player simultaneously.\n  1553‚Üífunc _process_assault_state(delta: float) -> void:\n  1554‚Üí\t# Check for suppression - transition to retreating behavior\n  1555‚Üí\tif _under_fire and enable_cover and not _assault_ready:\n  1556‚Üí\t\t_in_assault = false\n  1557‚Üí\t\t_transition_to_retreating()\n  1558‚Üí\t\treturn\n  1559‚Üí\n  1560‚Üí\t# Check if we're the only enemy left in assault - switch back to combat\n  1561‚Üí\tvar enemies_in_combat := _count_enemies_in_combat()\n  1562‚Üí\tif enemies_in_combat < 2 and not _assault_ready:\n  1563‚Üí\t\t_log_debug(\"Not enough enemies for assault, switching to COMBAT\")\n  1564‚Üí\t\t_in_assault = false\n  1565‚Üí\t\t_transition_to_combat()\n  1566‚Üí\t\treturn\n  1567‚Üí\n  1568‚Üí\t# Find closest cover to player if we don't have one\n  1569‚Üí\tif not _has_valid_cover:\n  1570‚Üí\t\t_find_cover_closest_to_player()\n  1571‚Üí\t\tif _has_valid_cover:\n  1572‚Üí\t\t\t_log_debug(\"Found assault cover at %s\" % _cover_position)\n  1573‚Üí\n  1574‚Üí\t# Move to cover position first\n  1575‚Üí\tif _has_valid_cover and not _in_assault:\n  1576‚Üí\t\tvar distance_to_cover := global_position.distance_to(_cover_position)\n  1577‚Üí\t\tif distance_to_cover > 15.0 and _is_visible_from_player():\n  1578‚Üí\t\t\t# Still need to reach cover\n  1579‚Üí\t\t\tvar direction := (_cover_position - global_position).normalized()\n  1580‚Üí\t\t\tvar avoidance := _check_wall_ahead(direction)\n  1581‚Üí\t\t\tif avoidance != Vector2.ZERO:\n  1582‚Üí\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n  1583‚Üí\t\t\tvelocity = direction * combat_move_speed\n  1584‚Üí\t\t\trotation = direction.angle()\n  1585‚Üí\t\t\treturn\n  1586‚Üí\n  1587‚Üí\t# At cover, wait for assault timer\n  1588‚Üí\tif not _assault_ready:\n  1589‚Üí\t\tvelocity = Vector2.ZERO\n  1590‚Üí\t\t_assault_wait_timer += delta\n  1591‚Üí\n  1592‚Üí\t\t# Check if all assault enemies are ready (synchronized assault)\n  1593‚Üí\t\tif _assault_wait_timer >= ASSAULT_WAIT_DURATION:\n  1594‚Üí\t\t\t# Check if situation has changed - player might have moved\n  1595‚Üí\t\t\tif _player and _is_player_close():\n  1596‚Üí\t\t\t\t_assault_ready = true\n  1597‚Üí\t\t\t\t_in_assault = true\n  1598‚Üí\t\t\t\t_log_debug(\"ASSAULT ready - rushing player!\")\n  1599‚Üí\t\t\telse:\n  1600‚Üí\t\t\t\t# Player moved away, reset timer and check if we should pursue\n  1601‚Üí\t\t\t\t_log_debug(\"Player moved away during assault wait, resetting\")\n  1602‚Üí\t\t\t\t_assault_wait_timer = 0.0\n  1603‚Üí\t\t\t\t_in_assault = false\n  1604‚Üí\t\t\t\t_transition_to_pursuing()\n  1605‚Üí\t\t\t\treturn\n  1606‚Üí\t\treturn\n  1607‚Üí\n  1608‚Üí\t# Assault phase - rush the player while shooting\n  1609‚Üí\tif _assault_ready and _player:\n  1610‚Üí\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n  1611‚Üí\t\tvar distance_to_player := global_position.distance_to(_player.global_position)\n  1612‚Üí\n  1613‚Üí\t\t# Apply wall avoidance\n  1614‚Üí\t\tvar avoidance := _check_wall_ahead(direction_to_player)\n  1615‚Üí\t\tif avoidance != Vector2.ZERO:\n  1616‚Üí\t\t\tdirection_to_player = (direction_to_player * 0.5 + avoidance * 0.5).normalized()\n  1617‚Üí\n  1618‚Üí\t\t# Rush at full speed\n  1619‚Üí\t\tvelocity = direction_to_player * combat_move_speed\n  1620‚Üí\t\trotation = direction_to_player.angle()\n  1621‚Üí\n  1622‚Üí\t\t# Update detection delay timer\n  1623‚Üí\t\tif not _detection_delay_elapsed:\n  1624‚Üí\t\t\t_detection_timer += delta\n  1625‚Üí\t\t\tif _detection_timer >= detection_delay:\n  1626‚Üí\t\t\t\t_detection_delay_elapsed = true\n  1627‚Üí\n  1628‚Üí\t\t# Shoot while rushing (only after detection delay)\n  1629‚Üí\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n  1630‚Üí\t\t\t_aim_at_player()\n  1631‚Üí\t\t\t_shoot()\n  1632‚Üí\t\t\t_shoot_timer = 0.0\n  1633‚Üí\n  1634‚Üí\t\t# If very close to player, stay in combat\n  1635‚Üí\t\tif distance_to_player < 50.0:\n  1636‚Üí\t\t\t_log_debug(\"Assault complete - reached player\")\n  1637‚Üí\t\t\t_assault_ready = false\n  1638‚Üí\t\t\t_in_assault = false\n  1639‚Üí\t\t\t_transition_to_combat()\n  1640‚Üí\n  1641‚Üí\n  1642‚Üí## Shoot with reduced accuracy for retreat mode.\n  1643‚Üífunc _shoot_with_inaccuracy() -> void:\n  1644‚Üí\tif bullet_scene == null or _player == null:\n  1645‚Üí\t\treturn\n  1646‚Üí\n  1647‚Üí\tif not _can_shoot():\n  1648‚Üí\t\treturn\n  1649‚Üí\n  1650‚Üí\tvar target_position := _player.global_position\n  1651‚Üí\n  1652‚Üí\t# Check if the shot should be taken\n  1653‚Üí\tif not _should_shoot_at_target(target_position):\n  1654‚Üí\t\treturn\n  1655‚Üí\n  1656‚Üí\tvar direction := (target_position - global_position).normalized()\n  1657‚Üí\n  1658‚Üí\t# Add inaccuracy spread\n  1659‚Üí\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD, RETREAT_INACCURACY_SPREAD)\n  1660‚Üí\tdirection = direction.rotated(inaccuracy_angle)\n  1661‚Üí\n  1662‚Üí\t# Check if the inaccurate shot direction would hit a wall\n  1663‚Üí\tif not _is_bullet_spawn_clear(direction):\n  1664‚Üí\t\t_log_debug(\"Inaccurate shot blocked: wall in path after rotation\")\n  1665‚Üí\t\treturn\n  1666‚Üí\n  1667‚Üí\t# Create and fire bullet\n  1668‚Üí\tvar bullet := bullet_scene.instantiate()\n  1669‚Üí\tbullet.global_position = global_position + direction * bullet_spawn_offset\n  1670‚Üí\tbullet.direction = direction\n  1671‚Üí\tbullet.shooter_id = get_instance_id()\n  1672‚Üí\tget_tree().current_scene.add_child(bullet)\n  1673‚Üí\n  1674‚Üí\t# Play sounds\n  1675‚Üí\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n  1676‚Üí\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n  1677‚Üí\t\taudio_manager.play_m16_shot(global_position)\n  1678‚Üí\t_play_delayed_shell_sound()\n  1679‚Üí\n  1680‚Üí\t# Consume ammo\n  1681‚Üí\t_current_ammo -= 1\n  1682‚Üí\tammo_changed.emit(_current_ammo, _reserve_ammo)\n  1683‚Üí\n  1684‚Üí\tif _current_ammo <= 0 and _reserve_ammo > 0:\n  1685‚Üí\t\t_start_reload()\n  1686‚Üí\n  1687‚Üí\n  1688‚Üí## Shoot a burst shot with arc spread for ONE_HIT retreat.\n  1689‚Üífunc _shoot_burst_shot() -> void:\n  1690‚Üí\tif bullet_scene == null or _player == null:\n  1691‚Üí\t\treturn\n  1692‚Üí\n  1693‚Üí\tif not _can_shoot():\n  1694‚Üí\t\treturn\n  1695‚Üí\n  1696‚Üí\tvar target_position := _player.global_position\n  1697‚Üí\tvar direction := (target_position - global_position).normalized()\n  1698‚Üí\n  1699‚Üí\t# Apply arc offset for burst spread\n  1700‚Üí\tdirection = direction.rotated(_retreat_burst_angle_offset)\n  1701‚Üí\n  1702‚Üí\t# Also add some random inaccuracy on top of the arc\n  1703‚Üí\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD * 0.5, RETREAT_INACCURACY_SPREAD * 0.5)\n  1704‚Üí\tdirection = direction.rotated(inaccuracy_angle)\n  1705‚Üí\n  1706‚Üí\t# Check if the burst shot direction would hit a wall\n  1707‚Üí\tif not _is_bullet_spawn_clear(direction):\n  1708‚Üí\t\t_log_debug(\"Burst shot blocked: wall in path after rotation\")\n  1709‚Üí\t\treturn\n  1710‚Üí\n  1711‚Üí\t# Create and fire bullet\n  1712‚Üí\tvar bullet := bullet_scene.instantiate()\n  1713‚Üí\tbullet.global_position = global_position + direction * bullet_spawn_offset\n  1714‚Üí\tbullet.direction = direction\n  1715‚Üí\tbullet.shooter_id = get_instance_id()\n  1716‚Üí\tget_tree().current_scene.add_child(bullet)\n  1717‚Üí\n  1718‚Üí\t# Play sounds\n  1719‚Üí\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n  1720‚Üí\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n  1721‚Üí\t\taudio_manager.play_m16_shot(global_position)\n  1722‚Üí\t_play_delayed_shell_sound()\n  1723‚Üí\n  1724‚Üí\t# Consume ammo\n  1725‚Üí\t_current_ammo -= 1\n  1726‚Üí\tammo_changed.emit(_current_ammo, _reserve_ammo)\n  1727‚Üí\n  1728‚Üí\tif _current_ammo <= 0 and _reserve_ammo > 0:\n  1729‚Üí\t\t_start_reload()\n  1730‚Üí\n  1731‚Üí\n  1732‚Üí## Transition to IDLE state.\n  1733‚Üífunc _transition_to_idle() -> void:\n  1734‚Üí\t_current_state = AIState.IDLE\n  1735‚Üí\t# Reset encounter hit tracking when returning to idle\n  1736‚Üí\t_hits_taken_in_encounter = 0\n  1737‚Üí\t# Reset alarm mode when returning to idle\n  1738‚Üí\t_in_alarm_mode = false\n  1739‚Üí\t_cover_burst_pending = false\n  1740‚Üí\n  1741‚Üí\n  1742‚Üí## Transition to COMBAT state.\n  1743‚Üífunc _transition_to_combat() -> void:\n  1744‚Üí\t_current_state = AIState.COMBAT\n  1745‚Üí\t# Reset detection delay timer when entering combat\n  1746‚Üí\t_detection_timer = 0.0\n  1747‚Üí\t_detection_delay_elapsed = false\n  1748‚Üí\t# Reset combat phase variables\n  1749‚Üí\t_combat_exposed = false\n  1750‚Üí\t_combat_approaching = false\n  1751‚Üí\t_combat_shoot_timer = 0.0\n  1752‚Üí\t_combat_approach_timer = 0.0\n  1753‚Üí\t# Reset clear shot seeking variables\n  1754‚Üí\t_seeking_clear_shot = false\n  1755‚Üí\t_clear_shot_timer = 0.0\n  1756‚Üí\t_clear_shot_target = Vector2.ZERO\n  1757‚Üí\n  1758‚Üí\n  1759‚Üí## Transition to SEEKING_COVER state.\n  1760‚Üífunc _transition_to_seeking_cover() -> void:\n  1761‚Üí\t_current_state = AIState.SEEKING_COVER\n  1762‚Üí\t_find_cover_position()\n  1763‚Üí\n  1764‚Üí\n  1765‚Üí## Transition to IN_COVER state.\n  1766‚Üífunc _transition_to_in_cover() -> void:\n  1767‚Üí\t_current_state = AIState.IN_COVER\n  1768‚Üí\n  1769‚Üí\n  1770‚Üí## Transition to FLANKING state.\n  1771‚Üífunc _transition_to_flanking() -> void:\n  1772‚Üí\t_current_state = AIState.FLANKING\n  1773‚Üí\t_calculate_flank_position()\n  1774‚Üí\t_flank_cover_wait_timer = 0.0\n  1775‚Üí\t_has_flank_cover = false\n  1776‚Üí\t_has_valid_cover = false\n  1777‚Üí\n  1778‚Üí\n  1779‚Üí## Transition to SUPPRESSED state.\n  1780‚Üífunc _transition_to_suppressed() -> void:\n  1781‚Üí\t_current_state = AIState.SUPPRESSED\n  1782‚Üí\t# Enter alarm mode when suppressed\n  1783‚Üí\t_in_alarm_mode = true\n  1784‚Üí\n  1785‚Üí\n  1786‚Üí## Transition to PURSUING state.\n  1787‚Üífunc _transition_to_pursuing() -> void:\n  1788‚Üí\t_current_state = AIState.PURSUING\n  1789‚Üí\t_pursuit_cover_wait_timer = 0.0\n  1790‚Üí\t_has_pursuit_cover = false\n  1791‚Üí\t# Reset detection delay for new engagement\n  1792‚Üí\t_detection_timer = 0.0\n  1793‚Üí\t_detection_delay_elapsed = false\n  1794‚Üí\n  1795‚Üí\n  1796‚Üí## Transition to ASSAULT state.\n  1797‚Üífunc _transition_to_assault() -> void:\n  1798‚Üí\t_current_state = AIState.ASSAULT\n  1799‚Üí\t_assault_wait_timer = 0.0\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"797fbac8-f5e6-4339-8fd2-77453410db49","uuid":"d6945caf-e1c3-4f22-ab52-8ac6ca527dfc","tool_use_result":{"type":"text","file":{"filePath":"/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd","content":"\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If no longer under fire, exit suppression\n\tif not _under_fire:\n\t\t_transition_to_in_cover()\n\n\n## Process RETREATING state - moving to cover with behavior based on damage taken.\nfunc _process_retreating_state(delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, transition to combat or suppressed\n\t\t\tif _under_fire:\n\t\t\t\t_transition_to_suppressed()\n\t\t\telse:\n\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we've reached cover and are hidden from player\n\tif not _is_visible_from_player():\n\t\t_log_debug(\"Reached cover during retreat\")\n\t\t# Reset encounter hits when successfully reaching cover\n\t\t_hits_taken_in_encounter = 0\n\t\t_transition_to_in_cover()\n\t\treturn\n\n\t# Calculate direction to cover\n\tvar direction_to_cover := (_cover_position - global_position).normalized()\n\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\n\t# Check if reached cover position\n\tif distance_to_cover < 10.0:\n\t\tif _is_visible_from_player():\n\t\t\t# Still visible, find better cover\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\tif _under_fire:\n\t\t\t\t\t_transition_to_suppressed()\n\t\t\t\telse:\n\t\t\t\t\t_transition_to_combat()
[2026-01-18T02:49:27.830Z] [INFO] \n\t\t\treturn\n\n\t# Apply retreat behavior based on mode\n\tmatch _retreat_mode:\n\t\tRetreatMode.FULL_HP:\n\t\t\t_process_retreat_full_hp(delta, direction_to_cover)\n\t\tRetreatMode.ONE_HIT:\n\t\t\t_process_retreat_one_hit(delta, direction_to_cover)\n\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t_process_retreat_multiple_hits(delta, direction_to_cover)\n\n\n## Process FULL_HP retreat: walk backwards facing player, shoot with reduced accuracy,\n## periodically turn toward cover.\nfunc _process_retreat_full_hp(delta: float, direction_to_cover: Vector2) -> void:\n\t_retreat_turn_timer += delta\n\n\tif _retreat_turning_to_cover:\n\t\t# Turning to face cover, don't shoot\n\t\tif _retreat_turn_timer >= RETREAT_TURN_DURATION:\n\t\t\t_retreat_turning_to_cover = false\n\t\t\t_retreat_turn_timer = 0.0\n\n\t\t# Face cover and move toward it\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\telse:\n\t\t# Face player and back up (walk backwards)\n\t\tif _retreat_turn_timer >= RETREAT_TURN_INTERVAL:\n\t\t\t_retreat_turning_to_cover = true\n\t\t\t_retreat_turn_timer = 0.0\n\t\t\t_log_debug(\"FULL_HP retreat: turning to check cover\")\n\n\t\tif _player:\n\t\t\t# Face the player\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\t_aim_at_player()\n\n\t\t\t# Move backwards (opposite of player direction = toward cover generally)\n\t\t\t# Use the negative of the direction we're facing for \"backing up\"\n\t\t\tvar move_direction := -direction_to_player\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed * 0.7  # Slower when backing up\n\n\t\t\t# Shoot with reduced accuracy (only after detection delay)\n\t\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot_with_inaccuracy()\n\t\t\t\t_shoot_timer = 0.0\n\n\n## Process ONE_HIT retreat: quick burst of 2-4 shots in an arc while turning, then face cover.\nfunc _process_retreat_one_hit(delta: float, direction_to_cover: Vector2) -> void:\n\tif not _retreat_burst_complete:\n\t\t# During burst phase\n\t\t_retreat_burst_timer += delta\n\n\t\tif _player and _retreat_burst_remaining > 0 and _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t# Fire a burst shot with arc spread\n\t\t\t_shoot_burst_shot()\n\t\t\t_retreat_burst_remaining -= 1\n\t\t\t_retreat_burst_timer = 0.0\n\n\t\t\t# Progress through the arc\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0  # Spread across 4 shots max\n\n\t\t# Gradually turn from player to cover during burst\n\t\tif _player:\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\tvar target_angle: float\n\n\t\t\t# Interpolate rotation from player direction to cover direction\n\t\t\tvar burst_progress := 1.0 - (float(_retreat_burst_remaining) / 4.0)\n\t\t\tvar player_angle := direction_to_player.angle()\n\t\t\tvar cover_angle := direction_to_cover.angle()\n\t\t\ttarget_angle = lerp_angle(player_angle, cover_angle, burst_progress * 0.7)\n\t\t\trotation = target_angle\n\n\t\t# Move toward cover (slower during burst)\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed * 0.5\n\n\t\t# Check if burst is complete\n\t\tif _retreat_burst_remaining <= 0:\n\t\t\t_retreat_burst_complete = true\n\t\t\t_log_debug(\"ONE_HIT retreat: burst complete, now running to cover\")\n\telse:\n\t\t# After burst, run to cover without shooting\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\n\n## Process MULTIPLE_HITS retreat: quick burst of 2-4 shots then run to cover (same as ONE_HIT).\nfunc _process_retreat_multiple_hits(delta: float, direction_to_cover: Vector2) -> void:\n\t# Same behavior as ONE_HIT - quick burst then escape\n\t_process_retreat_one_hit(delta, direction_to_cover)\n\n\n## Process PURSUING state - move cover-to-cover toward player.\n## Enemy moves between covers, waiting 1-2 seconds at each cover,\n## until they can see and hit the player.\nfunc _process_pursuing_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected during pursuit (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can see player and can hit them from current position, engage\n\tif _can_see_player and _player:\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\t\tif can_hit:\n\t\t\t_log_debug(\"Can see and hit player from pursuit, transitioning to COMBAT\")\n\t\t\t_has_pursuit_cover = false\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're waiting at cover\n\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t# Currently at cover, wait for 1-2 seconds before moving to next cover\n\t\t_pursuit_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _pursuit_cover_wait_timer >= PURSUIT_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover closer to player\n\t\t\t_log_debug(\"Pursuit wait complete, finding next cover\")\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_find_pursuit_cover_toward_player()\n\t\t\tif _has_pursuit_cover:\n\t\t\t\t_log_debug(\"Found pursuit cover at %s\" % _pursuit_next_cover)\n\t\t\telse:\n\t\t\t\t# No pursuit cover found - fallback behavior\n\t\t\t\t_log_debug(\"No pursuit cover found, checking fallback options\")\n\t\t\t\t# If we can now see the player, engage directly\n\t\t\t\tif _can_see_player:\n\t\t\t\t\t_log_debug(\"Can see player, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\t# Try flanking\n\t\t\t\tif enable_flanking and _player:\n\t\t\t\t\t_log_debug(\"Attempting flanking maneuver\")\n\t\t\t\t\t_transition_to_flanking()\n\t\t\t\t\treturn\n\t\t\t\t# Last resort: move directly toward player\n\t\t\t\t_log_debug(\"No cover options, moving directly toward player\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\treturn\n\n\t# If we have a pursuit cover target, move toward it\n\tif _has_pursuit_cover:\n\t\tvar direction := (_pursuit_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_pursuit_next_cover)\n\n\t\t# Check if we've reached the pursuit cover\n\t\t# Note: We only check distance here, NOT visibility from player.\n\t\t# If we checked visibility, the enemy would immediately consider themselves\n\t\t# \"at cover\" even before moving, since they start hidden from player.\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached pursuit cover at distance %.1f\" % distance)\n\t\t\t_has_pursuit_cover = false\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_cover_position = _pursuit_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no pursuit target - find initial pursuit cover\n\t_find_pursuit_cover_toward_player()\n\tif not _has_pursuit_cover:\n\t\t# Can't find cover to pursue, try flanking or combat\n\t\tif enable_flanking and _player:\n\t\t\t_transition_to_flanking()\n\t\telse:\n\t\t\t_transition_to_combat()\n\n\n## Process ASSAULT state - coordinated multi-enemy rush.\n## Wait at cover for 5 seconds, then all enemies rush the player simultaneously.\nfunc _process_assault_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover and not _assault_ready:\n\t\t_in_assault = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if we're the only enemy left in assault - switch back to combat\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat < 2 and not _assault_ready:\n\t\t_log_debug(\"Not enough enemies for assault, switching to COMBAT\")\n\t\t_in_assault = false\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Find closest cover to player if we don't have one\n\tif not _has_valid_cover:\n\t\t_find_cover_closest_to_player()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found assault cover at %s\" % _cover_position)\n\n\t# Move to cover position first\n\tif _has_valid_cover and not _in_assault:\n\t\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\t\tif distance_to_cover > 15.0 and _is_visible_from_player():\n\t\t\t# Still need to reach cover\n\t\t\tvar direction := (_cover_position - global_position).normalized()\n\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\tvelocity = direction * combat_move_speed\n\t\t\trotation = direction.angle()\n\t\t\treturn\n\n\t# At cover, wait for assault timer\n\tif not _assault_ready:\n\t\tvelocity = Vector2.ZERO\n\t\t_assault_wait_timer += delta\n\n\t\t# Check if all assault enemies are ready (synchronized assault)\n\t\tif _assault_wait_timer >= ASSAULT_WAIT_DURATION:\n\t\t\t# Check if situation has changed - player might have moved\n\t\t\tif _player and _is_player_close():\n\t\t\t\t_assault_ready = true\n\t\t\t\t_in_assault = true\n\t\t\t\t_log_debug(\"ASSAULT ready - rushing player!\")\n\t\t\telse:\n\t\t\t\t# Player moved away, reset timer and check if we should pursue\n\t\t\t\t_log_debug(\"Player moved away during assault wait, resetting\")\n\t\t\t\t_assault_wait_timer = 0.0\n\t\t\t\t_in_assault = false\n\t\t\t\t_transition_to_pursuing()\n\t\t\t\treturn\n\t\treturn\n\n\t# Assault phase - rush the player while shooting\n\tif _assault_ready and _player:\n\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction_to_player)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_player = (direction_to_player * 0.5 + avoidance * 0.5).normalized()\n\n\t\t# Rush at full speed\n\t\tvelocity = direction_to_player * combat_move_speed\n\t\trotation = direction_to_player.angle()\n\n\t\t# Update detection delay timer\n\t\tif not _detection_delay_elapsed:\n\t\t\t_detection_timer += delta\n\t\t\tif _detection_timer >= detection_delay:\n\t\t\t\t_detection_delay_elapsed = true\n\n\t\t# Shoot while rushing (only after detection delay)\n\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t\t# If very close to player, stay in combat\n\t\tif distance_to_player < 50.0:\n\t\t\t_log_debug(\"Assault complete - reached player\")\n\t\t\t_assault_ready = false\n\t\t\t_in_assault = false\n\t\t\t_transition_to_combat()\n\n\n## Shoot with reduced accuracy for retreat mode.\nfunc _shoot_with_inaccuracy() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Check if the shot should be taken\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Add inaccuracy spread\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD, RETREAT_INACCURACY_SPREAD)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the inaccurate shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Inaccurate shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Shoot a burst shot with arc spread for ONE_HIT retreat.\nfunc _shoot_burst_shot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Apply arc offset for burst spread\n\tdirection = direction.rotated(_retreat_burst_angle_offset)\n\n\t# Also add some random inaccuracy on top of the arc\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD * 0.5, RETREAT_INACCURACY_SPREAD * 0.5)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the burst shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Burst shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Transition to IDLE state.\nfunc _transition_to_idle() -> void:\n\t_current_state = AIState.IDLE\n\t# Reset encounter hit tracking when returning to idle\n\t_hits_taken_in_encounter = 0\n\t# Reset alarm mode when returning to idle\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\n\n## Transition to COMBAT state.\nfunc _transition_to_combat() -> void:\n\t_current_state = AIState.COMBAT\n\t# Reset detection delay timer when entering combat\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Reset combat phase variables\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_shoot_timer = 0.0\n\t_combat_approach_timer = 0.0\n\t# Reset clear shot seeking variables\n\t_seeking_clear_shot = false\n\t_clear_shot_timer = 0.0\n\t_clear_shot_target = Vector2.ZERO\n\n\n## Transition to SEEKING_COVER state.\nfunc _transition_to_seeking_cover() -> void:\n\t_current_state = AIState.SEEKING_COVER\n\t_find_cover_position()\n\n\n## Transition to IN_COVER state.\nfunc _transition_to_in_cover() -> void:\n\t_current_state = AIState.IN_COVER\n\n\n## Transition to FLANKING state.\nfunc _transition_to_flanking() -> void:\n\t_current_state = AIState.FLANKING\n\t_calculate_flank_position()\n\t_flank_cover_wait_timer = 0.0\n\t_has_flank_cover = false\n\t_has_valid_cover = false\n\n\n## Transition to SUPPRESSED state.\nfunc _transition_to_suppressed() -> void:\n\t_current_state = AIState.SUPPRESSED\n\t# Enter alarm mode when suppressed\n\t_in_alarm_mode = true\n\n\n## Transition to PURSUING state.\nfunc _transition_to_pursuing() -> void:\n\t_current_state = AIState.PURSUING\n\t_pursuit_cover_wait_timer = 0.0\n\t_has_pursuit_cover = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\n\n## Transition to ASSAULT state.\nfunc _transition_to_assault() -> void:\n\t_current_state = AIState.ASSAULT\n\t_assault_wait_timer = 0.0","numLines":500,"startLine":1300,"totalLines":3206}}}
[2026-01-18T02:49:30.596Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_014LwbefggzCKqgTvuA4ixHy",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me read more of the file to find the patrol behavior and the complete picture."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 7625,
      "cache_read_input_tokens": 56538,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 7625,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "5970fe5a-d3b4-425c-99dd-772c4f5e7a9a"
}
[2026-01-18T02:49:32.079Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_014LwbefggzCKqgTvuA4ixHy",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01HcTQNeVsPCjs9igA1ve4jP",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "offset": 1800,
          "limit": 500
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 7625,
      "cache_read_input_tokens": 56538,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 7625,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "9c2bda65-898f-415d-81e1-8ffaa065439b"
}
[2026-01-18T02:49:32.123Z] [INFO] {"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HcTQNeVsPCjs9igA1ve4jP","type":"tool_result","content":"  1800‚Üí\t_assault_ready = false\n  1801‚Üí\t_in_assault = false\n  1802‚Üí\t# Reset detection delay for new engagement\n  1803‚Üí\t_detection_timer = 0.0\n  1804‚Üí\t_detection_delay_elapsed = false\n  1805‚Üí\t# Find closest cover to player for assault position\n  1806‚Üí\t_find_cover_closest_to_player()\n  1807‚Üí\n  1808‚Üí\n  1809‚Üí## Transition to RETREATING state with appropriate retreat mode.\n  1810‚Üífunc _transition_to_retreating() -> void:\n  1811‚Üí\t_current_state = AIState.RETREATING\n  1812‚Üí\t# Enter alarm mode when retreating\n  1813‚Üí\t_in_alarm_mode = true\n  1814‚Üí\n  1815‚Üí\t# Determine retreat mode based on hits taken\n  1816‚Üí\tif _hits_taken_in_encounter == 0:\n  1817‚Üí\t\t_retreat_mode = RetreatMode.FULL_HP\n  1818‚Üí\t\t_retreat_turn_timer = 0.0\n  1819‚Üí\t\t_retreat_turning_to_cover = false\n  1820‚Üí\t\t_log_debug(\"Entering RETREATING state: FULL_HP mode (shoot while backing up)\")\n  1821‚Üí\telif _hits_taken_in_encounter == 1:\n  1822‚Üí\t\t_retreat_mode = RetreatMode.ONE_HIT\n  1823‚Üí\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n  1824‚Üí\t\t_retreat_burst_timer = 0.0\n  1825‚Üí\t\t_retreat_burst_complete = false\n  1826‚Üí\t\t# Calculate arc spread: shots will be distributed across the arc\n  1827‚Üí\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n  1828‚Üí\t\t_log_debug(\"Entering RETREATING state: ONE_HIT mode (burst of %d shots)\" % _retreat_burst_remaining)\n  1829‚Üí\telse:\n  1830‚Üí\t\t_retreat_mode = RetreatMode.MULTIPLE_HITS\n  1831‚Üí\t\t# Multiple hits also gets burst fire (same as ONE_HIT)\n  1832‚Üí\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n  1833‚Üí\t\t_retreat_burst_timer = 0.0\n  1834‚Üí\t\t_retreat_burst_complete = false\n  1835‚Üí\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n  1836‚Üí\t\t_log_debug(\"Entering RETREATING state: MULTIPLE_HITS mode (burst of %d shots)\" % _retreat_burst_remaining)\n  1837‚Üí\n  1838‚Üí\t# Find cover position for retreating\n  1839‚Üí\t_find_cover_position()\n  1840‚Üí\n  1841‚Üí\n  1842‚Üí## Check if the enemy is visible from the player's position.\n  1843‚Üí## Uses raycasting from player to enemy to determine if there are obstacles blocking line of sight.\n  1844‚Üí## This is the inverse of _can_see_player - it checks if the PLAYER can see the ENEMY.\n  1845‚Üí## Checks multiple points on the enemy body (center and corners) to account for enemy size.\n  1846‚Üífunc _is_visible_from_player() -> bool:\n  1847‚Üí\tif _player == null:\n  1848‚Üí\t\treturn false\n  1849‚Üí\n  1850‚Üí\t# Check visibility to multiple points on the enemy body\n  1851‚Üí\t# This accounts for the enemy's size - corners can stick out from cover\n  1852‚Üí\tvar check_points := _get_enemy_check_points(global_position)\n  1853‚Üí\n  1854‚Üí\tfor point in check_points:\n  1855‚Üí\t\tif _is_point_visible_from_player(point):\n  1856‚Üí\t\t\treturn true\n  1857‚Üí\n  1858‚Üí\treturn false\n  1859‚Üí\n  1860‚Üí\n  1861‚Üí## Get multiple check points on the enemy body for visibility testing.\n  1862‚Üí## Returns center and 4 corner points offset by the enemy's radius.\n  1863‚Üífunc _get_enemy_check_points(center: Vector2) -> Array[Vector2]:\n  1864‚Üí\t# Enemy collision radius is 24, sprite is 48x48\n  1865‚Üí\t# Use a slightly smaller radius to avoid edge cases\n  1866‚Üí\tconst ENEMY_RADIUS: float = 22.0\n  1867‚Üí\n  1868‚Üí\tvar points: Array[Vector2] = []\n  1869‚Üí\tpoints.append(center)  # Center point\n  1870‚Üí\n  1871‚Üí\t# 4 corner points (diagonal directions)\n  1872‚Üí\tvar diagonal_offset := ENEMY_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n  1873‚Üí\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n  1874‚Üí\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n  1875‚Üí\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n  1876‚Üí\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n  1877‚Üí\n  1878‚Üí\treturn points\n  1879‚Üí\n  1880‚Üí\n  1881‚Üí## Check if a single point is visible from the player's position.\n  1882‚Üífunc _is_point_visible_from_player(point: Vector2) -> bool:\n  1883‚Üí\tif _player == null:\n  1884‚Üí\t\treturn false\n  1885‚Üí\n  1886‚Üí\tvar player_pos := _player.global_position\n  1887‚Üí\tvar distance := player_pos.distance_to(point)\n  1888‚Üí\n  1889‚Üí\t# Use direct space state to check line of sight from player to point\n  1890‚Üí\tvar space_state := get_world_2d().direct_space_state\n  1891‚Üí\tvar query := PhysicsRayQueryParameters2D.new()\n  1892‚Üí\tquery.from = player_pos\n  1893‚Üí\tquery.to = point\n  1894‚Üí\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n  1895‚Üí\tquery.exclude = []\n  1896‚Üí\n  1897‚Üí\tvar result := space_state.intersect_ray(query)\n  1898‚Üí\n  1899‚Üí\tif result.is_empty():\n  1900‚Üí\t\t# No obstacle between player and point - point is visible\n  1901‚Üí\t\treturn true\n  1902‚Üí\telse:\n  1903‚Üí\t\t# Check if we hit an obstacle before reaching the point\n  1904‚Üí\t\tvar hit_position: Vector2 = result[\"position\"]\n  1905‚Üí\t\tvar distance_to_hit := player_pos.distance_to(hit_position)\n  1906‚Üí\n  1907‚Üí\t\t# If we hit something closer than the point, the point is hidden\n  1908‚Üí\t\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n  1909‚Üí\t\t\treturn false\n  1910‚Üí\t\telse:\n  1911‚Üí\t\t\treturn true\n  1912‚Üí\n  1913‚Üí\n  1914‚Üí## Check if a specific position would make the enemy visible from the player's position.\n  1915‚Üí## Checks all enemy body points (center and corners) to account for enemy size.\n  1916‚Üí## Used to validate cover positions before moving to them.\n  1917‚Üífunc _is_position_visible_from_player(pos: Vector2) -> bool:\n  1918‚Üí\tif _player == null:\n  1919‚Üí\t\treturn true  # Assume visible if no player\n  1920‚Üí\n  1921‚Üí\t# Check visibility for all enemy body points at the given position\n  1922‚Üí\tvar check_points := _get_enemy_check_points(pos)\n  1923‚Üí\n  1924‚Üí\tfor point in check_points:\n  1925‚Üí\t\tif _is_point_visible_from_player(point):\n  1926‚Üí\t\t\treturn true\n  1927‚Üí\n  1928‚Üí\treturn false\n  1929‚Üí\n  1930‚Üí\n  1931‚Üí## Check if a target position is visible from the enemy's perspective.\n  1932‚Üí## Uses raycast to verify there are no obstacles between enemy and the target position.\n  1933‚Üí## This is used to validate lead prediction targets - enemies should only aim at\n  1934‚Üí## positions they can actually see.\n  1935‚Üífunc _is_position_visible_to_enemy(target_pos: Vector2) -> bool:\n  1936‚Üí\tvar distance := global_position.distance_to(target_pos)\n  1937‚Üí\n  1938‚Üí\t# Use direct space state to check line of sight from enemy to target\n  1939‚Üí\tvar space_state := get_world_2d().direct_space_state\n  1940‚Üí\tvar query := PhysicsRayQueryParameters2D.new()\n  1941‚Üí\tquery.from = global_position\n  1942‚Üí\tquery.to = target_pos\n  1943‚Üí\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n  1944‚Üí\tquery.exclude = [get_rid()]  # Exclude self\n  1945‚Üí\n  1946‚Üí\tvar result := space_state.intersect_ray(query)\n  1947‚Üí\n  1948‚Üí\tif result.is_empty():\n  1949‚Üí\t\t# No obstacle between enemy and target - position is visible\n  1950‚Üí\t\treturn true\n  1951‚Üí\n  1952‚Üí\t# Check if we hit an obstacle before reaching the target\n  1953‚Üí\tvar hit_position: Vector2 = result[\"position\"]\n  1954‚Üí\tvar distance_to_hit := global_position.distance_to(hit_position)\n  1955‚Üí\n  1956‚Üí\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n  1957‚Üí\t\t# Hit obstacle before target - position is NOT visible\n  1958‚Üí\t\t_log_debug(\"Position %s blocked by obstacle at distance %.1f (target at %.1f)\" % [target_pos, distance_to_hit, distance])\n  1959‚Üí\t\treturn false\n  1960‚Üí\n  1961‚Üí\treturn true\n  1962‚Üí\n  1963‚Üí\n  1964‚Üí## Get multiple check points on the player's body for visibility testing.\n  1965‚Üí## Returns center and 4 corner points offset by the player's radius.\n  1966‚Üí## The player has a collision radius of 16 pixels (from Player.tscn).\n  1967‚Üífunc _get_player_check_points(center: Vector2) -> Array[Vector2]:\n  1968‚Üí\t# Player collision radius is 16, sprite is 32x32\n  1969‚Üí\t# Use a slightly smaller radius to be conservative\n  1970‚Üí\tconst PLAYER_RADIUS: float = 14.0\n  1971‚Üí\n  1972‚Üí\tvar points: Array[Vector2] = []\n  1973‚Üí\tpoints.append(center)  # Center point\n  1974‚Üí\n  1975‚Üí\t# 4 corner points (diagonal directions)\n  1976‚Üí\tvar diagonal_offset := PLAYER_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n  1977‚Üí\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n  1978‚Üí\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n  1979‚Üí\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n  1980‚Üí\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n  1981‚Üí\n  1982‚Üí\treturn points\n  1983‚Üí\n  1984‚Üí\n  1985‚Üí## Check if a single point on the player is visible from the enemy's position.\n  1986‚Üí## Uses direct space state query to check for obstacles blocking line of sight.\n  1987‚Üífunc _is_player_point_visible_to_enemy(point: Vector2) -> bool:\n  1988‚Üí\tvar distance := global_position.distance_to(point)\n  1989‚Üí\n  1990‚Üí\t# Use direct space state to check line of sight from enemy to point\n  1991‚Üí\tvar space_state := get_world_2d().direct_space_state\n  1992‚Üí\tvar query := PhysicsRayQueryParameters2D.new()\n  1993‚Üí\tquery.from = global_position\n  1994‚Üí\tquery.to = point\n  1995‚Üí\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n  1996‚Üí\tquery.exclude = [get_rid()]  # Exclude self\n  1997‚Üí\n  1998‚Üí\tvar result := space_state.intersect_ray(query)\n  1999‚Üí\n  2000‚Üí\tif result.is_empty():\n  2001‚Üí\t\t# No obstacle between enemy and point - point is visible\n  2002‚Üí\t\treturn true\n  2003‚Üí\n  2004‚Üí\t# Check if we hit an obstacle before reaching the point\n  2005‚Üí\tvar hit_position: Vector2 = result[\"position\"]\n  2006‚Üí\tvar distance_to_hit := global_position.distance_to(hit_position)\n  2007‚Üí\n  2008‚Üí\t# If we hit something before the point, the point is blocked\n  2009‚Üí\tif distance_to_hit < distance - 5.0:  # 5 pixel tolerance\n  2010‚Üí\t\treturn false\n  2011‚Üí\n  2012‚Üí\treturn true\n  2013‚Üí\n  2014‚Üí\n  2015‚Üí## Calculate what fraction of the player's body is visible to the enemy.\n  2016‚Üí## Returns a value from 0.0 (completely hidden) to 1.0 (fully visible).\n  2017‚Üí## Checks multiple points on the player's body (center + corners).\n  2018‚Üífunc _calculate_player_visibility_ratio() -> float:\n  2019‚Üí\tif _player == null:\n  2020‚Üí\t\treturn 0.0\n  2021‚Üí\n  2022‚Üí\tvar check_points := _get_player_check_points(_player.global_position)\n  2023‚Üí\tvar visible_count := 0\n  2024‚Üí\n  2025‚Üí\tfor point in check_points:\n  2026‚Üí\t\tif _is_player_point_visible_to_enemy(point):\n  2027‚Üí\t\t\tvisible_count += 1\n  2028‚Üí\n  2029‚Üí\treturn float(visible_count) / float(check_points.size())\n  2030‚Üí\n  2031‚Üí\n  2032‚Üí## Check if the line of fire to the target position is clear of other enemies.\n  2033‚Üí## Returns true if no other enemies would be hit by a bullet traveling to the target.\n  2034‚Üífunc _is_firing_line_clear_of_friendlies(target_position: Vector2) -> bool:\n  2035‚Üí\tif not enable_friendly_fire_avoidance:\n  2036‚Üí\t\treturn true\n  2037‚Üí\n  2038‚Üí\tvar direction := (target_position - global_position).normalized()\n  2039‚Üí\tvar distance := global_position.distance_to(target_position)\n  2040‚Üí\n  2041‚Üí\t# Use direct space state to check if any enemies are in the firing line\n  2042‚Üí\tvar space_state := get_world_2d().direct_space_state\n  2043‚Üí\tvar query := PhysicsRayQueryParameters2D.new()\n  2044‚Üí\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n  2045‚Üí\tquery.to = target_position\n  2046‚Üí\tquery.collision_mask = 2  # Only check enemies (layer 2)\n  2047‚Üí\tquery.exclude = [get_rid()]  # Exclude self using RID\n  2048‚Üí\n  2049‚Üí\tvar result := space_state.intersect_ray(query)\n  2050‚Üí\n  2051‚Üí\tif result.is_empty():\n  2052‚Üí\t\treturn true  # No enemies in the way\n  2053‚Üí\n  2054‚Üí\t# Check if the hit position is before the target\n  2055‚Üí\tvar hit_position: Vector2 = result[\"position\"]\n  2056‚Üí\tvar distance_to_hit := global_position.distance_to(hit_position)\n  2057‚Üí\n  2058‚Üí\tif distance_to_hit < distance - 20.0:  # 20 pixel tolerance\n  2059‚Üí\t\t_log_debug(\"Friendly in firing line at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n  2060‚Üí\t\treturn false\n  2061‚Üí\n  2062‚Üí\treturn true\n  2063‚Üí\n  2064‚Üí\n  2065‚Üí## Check if a bullet fired at the target position would be blocked by cover/obstacles.\n  2066‚Üí## Returns true if the shot would likely hit the target, false if blocked by cover.\n  2067‚Üífunc _is_shot_clear_of_cover(target_position: Vector2) -> bool:\n  2068‚Üí\tvar direction := (target_position - global_position).normalized()\n  2069‚Üí\tvar distance := global_position.distance_to(target_position)\n  2070‚Üí\n  2071‚Üí\t# Use direct space state to check if obstacles block the shot\n  2072‚Üí\tvar space_state := get_world_2d().direct_space_state\n  2073‚Üí\tvar query := PhysicsRayQueryParameters2D.new()\n  2074‚Üí\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n  2075‚Üí\tquery.to = target_position\n  2076‚Üí\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n  2077‚Üí\n  2078‚Üí\tvar result := space_state.intersect_ray(query)\n  2079‚Üí\n  2080‚Üí\tif result.is_empty():\n  2081‚Üí\t\treturn true  # No obstacles in the way\n  2082‚Üí\n  2083‚Üí\t# Check if the obstacle is before the target position\n  2084‚Üí\tvar hit_position: Vector2 = result[\"position\"]\n  2085‚Üí\tvar distance_to_hit := global_position.distance_to(hit_position)\n  2086‚Üí\n  2087‚Üí\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n  2088‚Üí\t\t_log_debug(\"Shot blocked by cover at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n  2089‚Üí\t\treturn false\n  2090‚Üí\n  2091‚Üí\treturn true\n  2092‚Üí\n  2093‚Üí\n  2094‚Üí## Check if there's an obstacle immediately in front of the enemy that would block bullets.\n  2095‚Üí## This prevents shooting into walls that the enemy is flush against or very close to.\n  2096‚Üí## Uses a single raycast from enemy center to the bullet spawn position.\n  2097‚Üífunc _is_bullet_spawn_clear(direction: Vector2) -> bool:\n  2098‚Üí\t# Fail-open: allow shooting if physics is not ready\n  2099‚Üí\tvar world_2d := get_world_2d()\n  2100‚Üí\tif world_2d == null:\n  2101‚Üí\t\treturn true\n  2102‚Üí\tvar space_state := world_2d.direct_space_state\n  2103‚Üí\tif space_state == null:\n  2104‚Üí\t\treturn true\n  2105‚Üí\n  2106‚Üí\t# Check from enemy center to bullet spawn position plus a small buffer\n  2107‚Üí\tvar check_distance := bullet_spawn_offset + 5.0\n  2108‚Üí\n  2109‚Üí\tvar query := PhysicsRayQueryParameters2D.new()\n  2110‚Üí\tquery.from = global_position\n  2111‚Üí\tquery.to = global_position + direction * check_distance\n  2112‚Üí\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n  2113‚Üí\tquery.exclude = [get_rid()]\n  2114‚Üí\n  2115‚Üí\tvar result := space_state.intersect_ray(query)\n  2116‚Üí\tif not result.is_empty():\n  2117‚Üí\t\t_log_debug(\"Bullet spawn blocked: wall at distance %.1f\" % [\n  2118‚Üí\t\t\tglobal_position.distance_to(result[\"position\"])])\n  2119‚Üí\t\treturn false\n  2120‚Üí\n  2121‚Üí\treturn true\n  2122‚Üí\n  2123‚Üí\n  2124‚Üí## Find a sidestep direction that would lead to a clear shot position.\n  2125‚Üí## Checks perpendicular directions to the player and returns the first one\n  2126‚Üí## that would allow the bullet spawn point to be clear.\n  2127‚Üí## Returns Vector2.ZERO if no clear direction is found.\n  2128‚Üífunc _find_sidestep_direction_for_clear_shot(direction_to_player: Vector2) -> Vector2:\n  2129‚Üí\t# Fail-safe: allow normal behavior if physics is not ready\n  2130‚Üí\tvar world_2d := get_world_2d()\n  2131‚Üí\tif world_2d == null:\n  2132‚Üí\t\treturn Vector2.ZERO\n  2133‚Üí\tvar space_state := world_2d.direct_space_state\n  2134‚Üí\tif space_state == null:\n  2135‚Üí\t\treturn Vector2.ZERO\n  2136‚Üí\n  2137‚Üí\t# Check perpendicular directions (left and right of the player direction)\n  2138‚Üí\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n  2139‚Üí\n  2140‚Üí\t# Check both sidestep directions and pick the one that leads to clear shot faster\n  2141‚Üí\tvar check_distance := 50.0  # Check if moving 50 pixels in this direction would help\n  2142‚Üí\tvar bullet_check_distance := bullet_spawn_offset + 5.0\n  2143‚Üí\n  2144‚Üí\tfor side_multiplier: float in [1.0, -1.0]:  # Try both sides\n  2145‚Üí\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n  2146‚Üí\n  2147‚Üí\t\t# First check if we can actually move in this direction (no wall blocking movement)\n  2148‚Üí\t\tvar move_query := PhysicsRayQueryParameters2D.new()\n  2149‚Üí\t\tmove_query.from = global_position\n  2150‚Üí\t\tmove_query.to = global_position + sidestep_dir * 30.0\n  2151‚Üí\t\tmove_query.collision_mask = 4  # Only check obstacles\n  2152‚Üí\t\tmove_query.exclude = [get_rid()]\n  2153‚Üí\n  2154‚Üí\t\tvar move_result := space_state.intersect_ray(move_query)\n  2155‚Üí\t\tif not move_result.is_empty():\n  2156‚Üí\t\t\tcontinue  # Can't move this way, wall is blocking\n  2157‚Üí\n  2158‚Üí\t\t# Check if after sidestepping, we'd have a clear shot\n  2159‚Üí\t\tvar test_position: Vector2 = global_position + sidestep_dir * check_distance\n  2160‚Üí\t\tvar shot_query := PhysicsRayQueryParameters2D.new()\n  2161‚Üí\t\tshot_query.from = test_position\n  2162‚Üí\t\tshot_query.to = test_position + direction_to_player * bullet_check_distance\n  2163‚Üí\t\tshot_query.collision_mask = 4\n  2164‚Üí\t\tshot_query.exclude = [get_rid()]\n  2165‚Üí\n  2166‚Üí\t\tvar shot_result := space_state.intersect_ray(shot_query)\n  2167‚Üí\t\tif shot_result.is_empty():\n  2168‚Üí\t\t\t# Found a direction that leads to a clear shot\n  2169‚Üí\t\t\t_log_debug(\"Found sidestep direction: %s\" % sidestep_dir)\n  2170‚Üí\t\t\treturn sidestep_dir\n  2171‚Üí\n  2172‚Üí\treturn Vector2.ZERO  # No clear sidestep direction found\n  2173‚Üí\n  2174‚Üí\n  2175‚Üí## Check if the enemy should shoot at the current target.\n  2176‚Üí## Validates bullet spawn clearance, friendly fire avoidance, and cover blocking.\n  2177‚Üífunc _should_shoot_at_target(target_position: Vector2) -> bool:\n  2178‚Üí\t# Check if the immediate path to bullet spawn is clear\n  2179‚Üí\t# This prevents shooting into walls the enemy is flush against\n  2180‚Üí\tvar direction := (target_position - global_position).normalized()\n  2181‚Üí\tif not _is_bullet_spawn_clear(direction):\n  2182‚Üí\t\treturn false\n  2183‚Üí\n  2184‚Üí\t# Check if friendlies are in the way\n  2185‚Üí\tif not _is_firing_line_clear_of_friendlies(target_position):\n  2186‚Üí\t\treturn false\n  2187‚Üí\n  2188‚Üí\t# Check if cover blocks the shot\n  2189‚Üí\tif not _is_shot_clear_of_cover(target_position):\n  2190‚Üí\t\treturn false\n  2191‚Üí\n  2192‚Üí\treturn true\n  2193‚Üí\n  2194‚Üí\n  2195‚Üí## Check if the player is \"close\" (within CLOSE_COMBAT_DISTANCE).\n  2196‚Üí## Used to determine if the enemy should engage directly or pursue.\n  2197‚Üífunc _is_player_close() -> bool:\n  2198‚Üí\tif _player == null:\n  2199‚Üí\t\treturn false\n  2200‚Üí\treturn global_position.distance_to(_player.global_position) <= CLOSE_COMBAT_DISTANCE\n  2201‚Üí\n  2202‚Üí\n  2203‚Üí## Check if the enemy can hit the player from their current position.\n  2204‚Üí## Returns true if there's a clear line of fire to the player.\n  2205‚Üífunc _can_hit_player_from_current_position() -> bool:\n  2206‚Üí\tif _player == null:\n  2207‚Üí\t\treturn false\n  2208‚Üí\n  2209‚Üí\t# Check if we can see the player\n  2210‚Üí\tif not _can_see_player:\n  2211‚Üí\t\treturn false\n  2212‚Üí\n  2213‚Üí\t# Check if the shot would be blocked by cover\n  2214‚Üí\treturn _is_shot_clear_of_cover(_player.global_position)\n  2215‚Üí\n  2216‚Üí\n  2217‚Üí## Count the number of enemies currently in combat-related states.\n  2218‚Üí## Includes COMBAT, PURSUING, ASSAULT, IN_COVER (if can see player).\n  2219‚Üí## Used to determine if multi-enemy assault should be triggered.\n  2220‚Üífunc _count_enemies_in_combat() -> int:\n  2221‚Üí\tvar count := 0\n  2222‚Üí\tvar enemies := get_tree().get_nodes_in_group(\"enemies\")\n  2223‚Üí\n  2224‚Üí\tfor enemy in enemies:\n  2225‚Üí\t\tif enemy == self:\n  2226‚Üí\t\t\tcontinue\n  2227‚Üí\t\tif not enemy.has_method(\"get_current_state\"):\n  2228‚Üí\t\t\tcontinue\n  2229‚Üí\n  2230‚Üí\t\tvar state: AIState = enemy.get_current_state()\n  2231‚Üí\t\t# Count enemies in combat-related states\n  2232‚Üí\t\tif state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n  2233‚Üí\t\t\t# For IN_COVER, only count if they can see the player\n  2234‚Üí\t\t\tif state == AIState.IN_COVER:\n  2235‚Üí\t\t\t\tif enemy.has_method(\"is_in_combat_engagement\") and enemy.is_in_combat_engagement():\n  2236‚Üí\t\t\t\t\tcount += 1\n  2237‚Üí\t\t\telse:\n  2238‚Üí\t\t\t\tcount += 1\n  2239‚Üí\n  2240‚Üí\t# Count self if in a combat-related state\n  2241‚Üí\tif _current_state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n  2242‚Üí\t\tcount += 1\n  2243‚Üí\n  2244‚Üí\treturn count\n  2245‚Üí\n  2246‚Üí\n  2247‚Üí## Check if this enemy is engaged in combat (can see player and in combat state).\n  2248‚Üífunc is_in_combat_engagement() -> bool:\n  2249‚Üí\treturn _can_see_player and _current_state in [AIState.COMBAT, AIState.IN_COVER, AIState.ASSAULT]\n  2250‚Üí\n  2251‚Üí\n  2252‚Üí## Find cover position closer to the player for pursuit.\n  2253‚Üí## Used during PURSUING state to move cover-to-cover toward the player.\n  2254‚Üífunc _find_pursuit_cover_toward_player() -> void:\n  2255‚Üí\tif _player == null:\n  2256‚Üí\t\t_has_pursuit_cover = false\n  2257‚Üí\t\treturn\n  2258‚Üí\n  2259‚Üí\tvar player_pos := _player.global_position\n  2260‚Üí\tvar best_cover: Vector2 = Vector2.ZERO\n  2261‚Üí\tvar best_score: float = -INF\n  2262‚Üí\tvar found_valid_cover: bool = false\n  2263‚Üí\n  2264‚Üí\t# Cast rays in all directions to find obstacles\n  2265‚Üí\tfor i in range(COVER_CHECK_COUNT):\n  2266‚Üí\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n  2267‚Üí\t\tvar direction := Vector2.from_angle(angle)\n  2268‚Üí\n  2269‚Üí\t\tvar raycast := _cover_raycasts[i]\n  2270‚Üí\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n  2271‚Üí\t\traycast.force_raycast_update()\n  2272‚Üí\n  2273‚Üí\t\tif raycast.is_colliding():\n  2274‚Üí\t\t\tvar collision_point := raycast.get_collision_point()\n  2275‚Üí\t\t\tvar collision_normal := raycast.get_collision_normal()\n  2276‚Üí\n  2277‚Üí\t\t\t# Cover position is offset from collision point along normal\n  2278‚Üí\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n  2279‚Üí\n  2280‚Üí\t\t\t# For pursuit, we want cover that is:\n  2281‚Üí\t\t\t# 1. Closer to the player than we currently are\n  2282‚Üí\t\t\t# 2. Hidden from the player (or mostly hidden)\n  2283‚Üí\t\t\t# 3. Not too far from our current position\n  2284‚Üí\n  2285‚Üí\t\t\tvar my_distance_to_player := global_position.distance_to(player_pos)\n  2286‚Üí\t\t\tvar cover_distance_to_player := cover_pos.distance_to(player_pos)\n  2287‚Üí\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n  2288‚Üí\n  2289‚Üí\t\t\t# Skip covers that don't bring us closer to player\n  2290‚Üí\t\t\tif cover_distance_to_player >= my_distance_to_player:\n  2291‚Üí\t\t\t\tcontinue\n  2292‚Üí\n  2293‚Üí\t\t\t# Skip covers that are too close to current position (would cause looping)\n  2294‚Üí\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n  2295‚Üí\t\t\tif cover_distance_from_me < 30.0:\n  2296‚Üí\t\t\t\tcontinue\n  2297‚Üí\n  2298‚Üí\t\t\t# Check if this position is hidden from player\n  2299‚Üí\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"797fbac8-f5e6-4339-8fd2-77453410db49","uuid":"fbb4015a-da45-4b63-8fc6-9d94eb232543","tool_use_result":{"type":"text","file":{"filePath":"/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd","content":"\t_assault_ready = false\n\t_in_assault = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Find closest cover to player for assault position\n\t_find_cover_closest_to_player()\n\n\n## Transition to RETREATING state with appropriate retreat mode.\nfunc _transition_to_retreating() -> void:\n\t_current_state = AIState.RETREATING\n\t# Enter alarm mode when retreating\n\t_in_alarm_mode = true\n\n\t# Determine retreat mode based on hits taken\n\tif _hits_taken_in_encounter == 0:\n\t\t_retreat_mode = RetreatMode.FULL_HP\n\t\t_retreat_turn_timer = 0.0\n\t\t_retreat_turning_to_cover = false\n\t\t_log_debug(\"Entering RETREATING state: FULL_HP mode (shoot while backing up)\")\n\telif _hits_taken_in_encounter == 1:\n\t\t_retreat_mode = RetreatMode.ONE_HIT\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t# Calculate arc spread: shots will be distributed across the arc\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: ONE_HIT mode (burst of %d shots)\" % _retreat_burst_remaining)\n\telse:\n\t\t_retreat_mode = RetreatMode.MULTIPLE_HITS\n\t\t# Multiple hits also gets burst fire (same as ONE_HIT)\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: MULTIPLE_HITS mode (burst of %d shots)\" % _retreat_burst_remaining)\n\n\t# Find cover position for retreating\n\t_find_cover_position()\n\n\n## Check if the enemy is visible from the player's position.\n## Uses raycasting from player to enemy to determine if there are obstacles blocking line of sight.\n## This is the inverse of _can_see_player - it checks if the PLAYER can see the ENEMY.\n## Checks multiple points on the enemy body (center and corners) to account for enemy size.\nfunc _is_visible_from_player() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check visibility to multiple points on the enemy body\n\t# This accounts for the enemy's size - corners can stick out from cover\n\tvar check_points := _get_enemy_check_points(global_position)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Get multiple check points on the enemy body for visibility testing.\n## Returns center and 4 corner points offset by the enemy's radius.\nfunc _get_enemy_check_points(center: Vector2) -> Array[Vector2]:\n\t# Enemy collision radius is 24, sprite is 48x48\n\t# Use a slightly smaller radius to avoid edge cases\n\tconst ENEMY_RADIUS: float = 22.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := ENEMY_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point is visible from the player's position.\nfunc _is_point_visible_from_player(point: Vector2) -> bool:\n\tif _player == null:\n\t\treturn false\n\n\tvar player_pos := _player.global_position\n\tvar distance := player_pos.distance_to(point)\n\n\t# Use direct space state to check line of sight from player to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = player_pos\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = []\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between player and point - point is visible\n\t\treturn true\n\telse:\n\t\t# Check if we hit an obstacle before reaching the point\n\t\tvar hit_position: Vector2 = result[\"position\"]\n\t\tvar distance_to_hit := player_pos.distance_to(hit_position)\n\n\t\t# If we hit something closer than the point, the point is hidden\n\t\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t\treturn false\n\t\telse:\n\t\t\treturn true\n\n\n## Check if a specific position would make the enemy visible from the player's position.\n## Checks all enemy body points (center and corners) to account for enemy size.\n## Used to validate cover positions before moving to them.\nfunc _is_position_visible_from_player(pos: Vector2) -> bool:\n\tif _player == null:\n\t\treturn true  # Assume visible if no player\n\n\t# Check visibility for all enemy body points at the given position\n\tvar check_points := _get_enemy_check_points(pos)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Check if a target position is visible from the enemy's perspective.\n## Uses raycast to verify there are no obstacles between enemy and the target position.\n## This is used to validate lead prediction targets - enemies should only aim at\n## positions they can actually see.\nfunc _is_position_visible_to_enemy(target_pos: Vector2) -> bool:\n\tvar distance := global_position.distance_to(target_pos)\n\n\t# Use direct space state to check line of sight from enemy to target\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = target_pos\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and target - position is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t# Hit obstacle before target - position is NOT visible\n\t\t_log_debug(\"Position %s blocked by obstacle at distance %.1f (target at %.1f)\" % [target_pos, distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Get multiple check points on the player's body for visibility testing.\n## Returns center and 4 corner points offset by the player's radius.\n## The player has a collision radius of 16 pixels (from Player.tscn).\nfunc _get_player_check_points(center: Vector2) -> Array[Vector2]:\n\t# Player collision radius is 16, sprite is 32x32\n\t# Use a slightly smaller radius to be conservative\n\tconst PLAYER_RADIUS: float = 14.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := PLAYER_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point on the player is visible from the enemy's position.\n## Uses direct space state query to check for obstacles blocking line of sight.\nfunc _is_player_point_visible_to_enemy(point: Vector2) -> bool:\n\tvar distance := global_position.distance_to(point)\n\n\t# Use direct space state to check line of sight from enemy to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and point - point is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the point\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\t# If we hit something before the point, the point is blocked\n\tif distance_to_hit < distance - 5.0:  # 5 pixel tolerance\n\t\treturn false\n\n\treturn true\n\n\n## Calculate what fraction of the player's body is visible to the enemy.\n## Returns a value from 0.0 (completely hidden) to 1.0 (fully visible).\n## Checks multiple points on the player's body (center + corners).\nfunc _calculate_player_visibility_ratio() -> float:\n\tif _player == null:\n\t\treturn 0.0\n\n\tvar check_points := _get_player_check_points(_player.global_position)\n\tvar visible_count := 0\n\n\tfor point in check_points:\n\t\tif _is_player_point_visible_to_enemy(point):\n\t\t\tvisible_count += 1\n\n\treturn float(visible_count) / float(check_points.size())\n\n\n## Check if the line of fire to the target position is clear of other enemies.\n## Returns true if no other enemies would be hit by a bullet traveling to the target.\nfunc _is_firing_line_clear_of_friendlies(target_position: Vector2) -> bool:\n\tif not enable_friendly_fire_avoidance:\n\t\treturn true\n\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if any enemies are in the firing line\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 2  # Only check enemies (layer 2)\n\tquery.exclude = [get_rid()]  # Exclude self using RID\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No enemies in the way\n\n\t# Check if the hit position is before the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 20.0:  # 20 pixel tolerance\n\t\t_log_debug(\"Friendly in firing line at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if a bullet fired at the target position would be blocked by cover/obstacles.\n## Returns true if the shot would likely hit the target, false if blocked by cover.\nfunc _is_shot_clear_of_cover(target_position: Vector2) -> bool:\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if obstacles block the shot\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No obstacles in the way\n\n\t# Check if the obstacle is before the target position\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t_log_debug(\"Shot blocked by cover at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if there's an obstacle immediately in front of the enemy that would block bullets.\n## This prevents shooting into walls that the enemy is flush against or very close to.\n## Uses a single raycast from enemy center to the bullet spawn position.\nfunc _is_bullet_spawn_clear(direction: Vector2) -> bool:\n\t# Fail-open: allow shooting if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn true\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn true\n\n\t# Check from enemy center to bullet spawn position plus a small buffer\n\tvar check_distance := bullet_spawn_offset + 5.0\n\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = global_position + direction * check_distance\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]\n\n\tvar result := space_state.intersect_ray(query)\n\tif not result.is_empty():\n\t\t_log_debug(\"Bullet spawn blocked: wall at distance %.1f\" % [\n\t\t\tglobal_position.distance_to(result[\"position\"])])\n\t\treturn false\n\n\treturn true\n\n\n## Find a sidestep direction that would lead to a clear shot position.\n## Checks perpendicular directions to the player and returns the first one\n## that would allow the bullet spawn point to be clear.\n## Returns Vector2.ZERO if no clear direction is found.\nfunc _find_sidestep_direction_for_clear_shot(direction_to_player: Vector2) -> Vector2:\n\t# Fail-safe: allow normal behavior if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn Vector2.ZERO\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn Vector2.ZERO\n\n\t# Check perpendicular directions (left and right of the player direction)\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Check both sidestep directions and pick the one that leads to clear shot faster\n\tvar check_distance := 50.0  # Check if moving 50 pixels in this direction would help\n\tvar bullet_check_distance := bullet_spawn_offset + 5.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:  # Try both sides\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\n\t\t# First check if we can actually move in this direction (no wall blocking movement)\n\t\tvar move_query := PhysicsRayQueryParameters2D.new()\n\t\tmove_query.from = global_position\n\t\tmove_query.to = global_position + sidestep_dir * 30.0\n\t\tmove_query.collision_mask = 4  # Only check obstacles\n\t\tmove_query.exclude = [get_rid()]\n\n\t\tvar move_result := space_state.intersect_ray(move_query)\n\t\tif not move_result.is_empty():\n\t\t\tcontinue  # Can't move this way, wall is blocking\n\n\t\t# Check if after sidestepping, we'd have a clear shot\n\t\tvar test_position: Vector2 = global_position + sidestep_dir * check_distance\n\t\tvar shot_query := PhysicsRayQueryParameters2D.new()\n\t\tshot_query.from = test_position\n\t\tshot_query.to = test_position + direction_to_player * bullet_check_distance\n\t\tshot_query.collision_mask = 4\n\t\tshot_query.exclude = [get_rid()]\n\n\t\tvar shot_result := space_state.intersect_ray(shot_query)\n\t\tif shot_result.is_empty():\n\t\t\t# Found a direction that leads to a clear shot\n\t\t\t_log_debug(\"Found sidestep direction: %s\" % sidestep_dir)\n\t\t\treturn sidestep_dir\n\n\treturn Vector2.ZERO  # No clear sidestep direction found\n\n\n## Check if the enemy should shoot at the current target.\n## Validates bullet spawn clearance, friendly fire avoidance, and cover blocking.\nfunc _should_shoot_at_target(target_position: Vector2) -> bool:\n\t# Check if the immediate path to bullet spawn is clear\n\t# This prevents shooting into walls the enemy is flush against\n\tvar direction := (target_position - global_position).normalized()\n\tif not _is_bullet_spawn_clear(direction):\n\t\treturn false\n\n\t# Check if friendlies are in the way\n\tif not _is_firing_line_clear_of_friendlies(target_position):\n\t\treturn false\n\n\t# Check if cover blocks the shot\n\tif not _is_shot_clear_of_cover(target_position):\n\t\treturn false\n\n\treturn true\n\n\n## Check if the player is \"close\" (within CLOSE_COMBAT_DISTANCE).\n## Used to determine if the enemy should engage directly or pursue.\nfunc _is_player_close() -> bool:\n\tif _player == null:\n\t\treturn false\n\treturn global_position.distance_to(_player.global_position) <= CLOSE_COMBAT_DISTANCE\n\n\n## Check if the enemy can hit the player from their current position.\n## Returns true if there's a clear line of fire to the player.\nfunc _can_hit_player_from_current_position() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check if we can see the player\n\tif not _can_see_player:\n\t\treturn false\n\n\t# Check if the shot would be blocked by cover\n\treturn _is_shot_clear_of_cover(_player.global_position)\n\n\n## Count the number of enemies currently in combat-related states.\n## Includes COMBAT, PURSUING, ASSAULT, IN_COVER (if can see player).\n## Used to determine if multi-enemy assault should be triggered.\nfunc _count_enemies_in_combat() -> int:\n\tvar count := 0\n\tvar enemies := get_tree().get_nodes_in_group(\"enemies\")\n\n\tfor enemy in enemies:\n\t\tif enemy == self:\n\t\t\tcontinue\n\t\tif not enemy.has_method(\"get_current_state\"):\n\t\t\tcontinue\n\n\t\tvar state: AIState = enemy.get_current_state()\n\t\t# Count enemies in combat-related states\n\t\tif state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\t\t# For IN_COVER, only count if they can see the player\n\t\t\tif state == AIState.IN_COVER:\n\t\t\t\tif enemy.has_method(\"is_in_combat_engagement\") and enemy.is_in_combat_engagement():\n\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tcount += 1\n\n\t# Count self if in a combat-related state\n\tif _current_state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\tcount += 1\n\n\treturn count\n\n\n## Check if this enemy is engaged in combat (can see player and in combat state).\nfunc is_in_combat_engagement() -> bool:\n\treturn _can_see_player and _current_state in [AIState.COMBAT, AIState.IN_COVER
[2026-01-18T02:49:32.135Z] [INFO] , AIState.ASSAULT]\n\n\n## Find cover position closer to the player for pursuit.\n## Used during PURSUING state to move cover-to-cover toward the player.\nfunc _find_pursuit_cover_toward_player() -> void:\n\tif _player == null:\n\t\t_has_pursuit_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For pursuit, we want cover that is:\n\t\t\t# 1. Closer to the player than we currently are\n\t\t\t# 2. Hidden from the player (or mostly hidden)\n\t\t\t# 3. Not too far from our current position\n\n\t\t\tvar my_distance_to_player := global_position.distance_to(player_pos)\n\t\t\tvar cover_distance_to_player := cover_pos.distance_to(player_pos)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to player\n\t\t\tif cover_distance_to_player >= my_distance_to_player:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if this position is hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)","numLines":500,"startLine":1800,"totalLines":3206}}}
[2026-01-18T02:49:34.929Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01SSJwvXKA9EcbRz8HFkFWC4",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me search for patrol behavior and understand the complete flow. Let me also look at the existing case studies for context."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 7998,
      "cache_read_input_tokens": 64163,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 7998,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 4,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "dc6d947a-62c4-4f58-ad4c-ab3bc64d0c87"
}
[2026-01-18T02:49:36.935Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01SSJwvXKA9EcbRz8HFkFWC4",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01QFeGY3PQPuEtVzSJQ5nUap",
        "name": "Grep",
        "input": {
          "pattern": "_process_patrol|_process_guard",
          "path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "output_mode": "content",
          "-n": true,
          "-A": 30
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 7998,
      "cache_read_input_tokens": 64163,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 7998,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 4,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "18f078ef-0669-4831-a8b1-db0a8f7af053"
}
[2026-01-18T02:49:36.990Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01QFeGY3PQPuEtVzSJQ5nUap",
        "type": "tool_result",
        "content": "773:\t\t\t_process_patrol(delta)\n774-\t\tBehaviorMode.GUARD:\n775:\t\t\t_process_guard(delta)\n776-\n777-\n778-## Process COMBAT state - approach player for direct contact, shoot for 2-3 seconds, return to cover.\n779-## Implements the combat cycling behavior: exit cover -> exposed shooting -> return to cover.\n780-## Phase 0 (seeking clear shot): If bullet spawn blocked, move out from cover to find clear shot.\n781-## Phase 1 (approaching): Move toward player to get into direct contact range.\n782-## Phase 2 (exposed): Stand and shoot for 2-3 seconds.\n783-## Phase 3: Return to cover via SEEKING_COVER state.\n784-func _process_combat_state(delta: float) -> void:\n785-\t# Check for suppression - transition to retreating behavior\n786-\tif _under_fire and enable_cover:\n787-\t\t_combat_exposed = false\n788-\t\t_combat_approaching = false\n789-\t\t_seeking_clear_shot = false\n790-\t\t_transition_to_retreating()\n791-\t\treturn\n792-\n793-\t# Check if multiple enemies are in combat - transition to assault state\n794-\tvar enemies_in_combat := _count_enemies_in_combat()\n795-\tif enemies_in_combat >= 2:\n796-\t\t_log_debug(\"Multiple enemies in combat (%d), transitioning to ASSAULT\" % enemies_in_combat)\n797-\t\t_combat_exposed = false\n798-\t\t_combat_approaching = false\n799-\t\t_seeking_clear_shot = false\n800-\t\t_transition_to_assault()\n801-\t\treturn\n802-\n803-\t# If can't see player, pursue them (move cover-to-cover toward player)\n804-\tif not _can_see_player:\n805-\t\t_combat_exposed = false\n--\n2785:func _process_patrol(delta: float) -> void:\n2786-\tif _patrol_points.is_empty():\n2787-\t\treturn\n2788-\n2789-\t# Handle waiting at patrol point\n2790-\tif _is_waiting_at_patrol_point:\n2791-\t\t_patrol_wait_timer += delta\n2792-\t\tif _patrol_wait_timer >= patrol_wait_time:\n2793-\t\t\t_is_waiting_at_patrol_point = false\n2794-\t\t\t_patrol_wait_timer = 0.0\n2795-\t\t\t_current_patrol_index = (_current_patrol_index + 1) % _patrol_points.size()\n2796-\t\tvelocity = Vector2.ZERO\n2797-\t\treturn\n2798-\n2799-\t# Move towards current patrol point\n2800-\tvar target_point := _patrol_points[_current_patrol_index]\n2801-\tvar direction := (target_point - global_position).normalized()\n2802-\tvar distance := global_position.distance_to(target_point)\n2803-\n2804-\tif distance < 5.0:\n2805-\t\t# Reached patrol point, start waiting\n2806-\t\t_is_waiting_at_patrol_point = true\n2807-\t\tvelocity = Vector2.ZERO\n2808-\telse:\n2809-\t\t# Check for walls and apply avoidance\n2810-\t\tvar avoidance := _check_wall_ahead(direction)\n2811-\t\tif avoidance != Vector2.ZERO:\n2812-\t\t\t# Blend movement direction with avoidance\n2813-\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n2814-\n2815-\t\tvelocity = direction * move_speed\n--\n2821:func _process_guard(_delta: float) -> void:\n2822-\tvelocity = Vector2.ZERO\n2823-\t# In guard mode, enemy doesn't move but can still aim at player when visible\n2824-\n2825-\n2826-## Called when a bullet enters the threat sphere.\n2827-func _on_threat_area_entered(area: Area2D) -> void:\n2828-\t# Check if bullet has shooter_id property and if it's from this enemy\n2829-\t# This prevents enemies from being suppressed by their own bullets\n2830-\tif \"shooter_id\" in area and area.shooter_id == get_instance_id():\n2831-\t\treturn  # Ignore own bullets\n2832-\n2833-\t_bullets_in_threat_sphere.append(area)\n2834-\t# Set threat memory timer so enemy can react even after fast bullets exit\n2835-\t# This allows the reaction delay to complete even if bullets pass through quickly\n2836-\t_threat_memory_timer = THREAT_MEMORY_DURATION\n2837-\t# Note: _under_fire is now set in _update_suppression after threat_reaction_delay\n2838-\t# This gives the player more time before the enemy reacts to nearby gunfire\n2839-\t_log_debug(\"Bullet entered threat sphere, starting reaction delay...\")\n2840-\n2841-\n2842-## Called when a bullet exits the threat sphere.\n2843-func _on_threat_area_exited(area: Area2D) -> void:\n2844-\t_bullets_in_threat_sphere.erase(area)\n2845-\n2846-\n2847-## Called when the enemy is hit (by bullet.gd).\n2848-func on_hit() -> void:\n2849-\tif not _is_alive:\n2850-\t\treturn\n2851-"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "5b5bee40-d803-4c02-a88b-730967bfa7a7",
  "tool_use_result": {
    "mode": "content",
    "numFiles": 0,
    "filenames": [],
    "content": "773:\t\t\t_process_patrol(delta)\n774-\t\tBehaviorMode.GUARD:\n775:\t\t\t_process_guard(delta)\n776-\n777-\n778-## Process COMBAT state - approach player for direct contact, shoot for 2-3 seconds, return to cover.\n779-## Implements the combat cycling behavior: exit cover -> exposed shooting -> return to cover.\n780-## Phase 0 (seeking clear shot): If bullet spawn blocked, move out from cover to find clear shot.\n781-## Phase 1 (approaching): Move toward player to get into direct contact range.\n782-## Phase 2 (exposed): Stand and shoot for 2-3 seconds.\n783-## Phase 3: Return to cover via SEEKING_COVER state.\n784-func _process_combat_state(delta: float) -> void:\n785-\t# Check for suppression - transition to retreating behavior\n786-\tif _under_fire and enable_cover:\n787-\t\t_combat_exposed = false\n788-\t\t_combat_approaching = false\n789-\t\t_seeking_clear_shot = false\n790-\t\t_transition_to_retreating()\n791-\t\treturn\n792-\n793-\t# Check if multiple enemies are in combat - transition to assault state\n794-\tvar enemies_in_combat := _count_enemies_in_combat()\n795-\tif enemies_in_combat >= 2:\n796-\t\t_log_debug(\"Multiple enemies in combat (%d), transitioning to ASSAULT\" % enemies_in_combat)\n797-\t\t_combat_exposed = false\n798-\t\t_combat_approaching = false\n799-\t\t_seeking_clear_shot = false\n800-\t\t_transition_to_assault()\n801-\t\treturn\n802-\n803-\t# If can't see player, pursue them (move cover-to-cover toward player)\n804-\tif not _can_see_player:\n805-\t\t_combat_exposed = false\n--\n2785:func _process_patrol(delta: float) -> void:\n2786-\tif _patrol_points.is_empty():\n2787-\t\treturn\n2788-\n2789-\t# Handle waiting at patrol point\n2790-\tif _is_waiting_at_patrol_point:\n2791-\t\t_patrol_wait_timer += delta\n2792-\t\tif _patrol_wait_timer >= patrol_wait_time:\n2793-\t\t\t_is_waiting_at_patrol_point = false\n2794-\t\t\t_patrol_wait_timer = 0.0\n2795-\t\t\t_current_patrol_index = (_current_patrol_index + 1) % _patrol_points.size()\n2796-\t\tvelocity = Vector2.ZERO\n2797-\t\treturn\n2798-\n2799-\t# Move towards current patrol point\n2800-\tvar target_point := _patrol_points[_current_patrol_index]\n2801-\tvar direction := (target_point - global_position).normalized()\n2802-\tvar distance := global_position.distance_to(target_point)\n2803-\n2804-\tif distance < 5.0:\n2805-\t\t# Reached patrol point, start waiting\n2806-\t\t_is_waiting_at_patrol_point = true\n2807-\t\tvelocity = Vector2.ZERO\n2808-\telse:\n2809-\t\t# Check for walls and apply avoidance\n2810-\t\tvar avoidance := _check_wall_ahead(direction)\n2811-\t\tif avoidance != Vector2.ZERO:\n2812-\t\t\t# Blend movement direction with avoidance\n2813-\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n2814-\n2815-\t\tvelocity = direction * move_speed\n--\n2821:func _process_guard(_delta: float) -> void:\n2822-\tvelocity = Vector2.ZERO\n2823-\t# In guard mode, enemy doesn't move but can still aim at player when visible\n2824-\n2825-\n2826-## Called when a bullet enters the threat sphere.\n2827-func _on_threat_area_entered(area: Area2D) -> void:\n2828-\t# Check if bullet has shooter_id property and if it's from this enemy\n2829-\t# This prevents enemies from being suppressed by their own bullets\n2830-\tif \"shooter_id\" in area and area.shooter_id == get_instance_id():\n2831-\t\treturn  # Ignore own bullets\n2832-\n2833-\t_bullets_in_threat_sphere.append(area)\n2834-\t# Set threat memory timer so enemy can react even after fast bullets exit\n2835-\t# This allows the reaction delay to complete even if bullets pass through quickly\n2836-\t_threat_memory_timer = THREAT_MEMORY_DURATION\n2837-\t# Note: _under_fire is now set in _update_suppression after threat_reaction_delay\n2838-\t# This gives the player more time before the enemy reacts to nearby gunfire\n2839-\t_log_debug(\"Bullet entered threat sphere, starting reaction delay...\")\n2840-\n2841-\n2842-## Called when a bullet exits the threat sphere.\n2843-func _on_threat_area_exited(area: Area2D) -> void:\n2844-\t_bullets_in_threat_sphere.erase(area)\n2845-\n2846-\n2847-## Called when the enemy is hit (by bullet.gd).\n2848-func on_hit() -> void:\n2849-\tif not _is_alive:\n2850-\t\treturn\n2851-",
    "numLines": 97
  }
}
[2026-01-18T02:49:39.892Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_012Xo2ek1c1iQih8LTNEPUqz",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now I have a good understanding of the current AI system. Let me create the case study directory and document all the analysis. Let me also research GOAP patterns and enemy search behaviors online."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 1770,
      "cache_read_input_tokens": 72161,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1770,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "232ada18-d78f-4879-825a-52d8ed42d5c1"
}
[2026-01-18T02:49:43.639Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_012Xo2ek1c1iQih8LTNEPUqz",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01A95EKuTaXLgYjxRFdpHcG8",
        "name": "TodoWrite",
        "input": {
          "todos": [
            {
              "content": "Read and analyze issue #103 requirements",
              "status": "completed",
              "activeForm": "Reading issue requirements"
            },
            {
              "content": "Explore existing AI/GOAP system architecture",
              "status": "completed",
              "activeForm": "Exploring AI/GOAP system architecture"
            },
            {
              "content": "Create case study directory structure",
              "status": "in_progress",
              "activeForm": "Creating case study directory structure"
            },
            {
              "content": "Research GOAP and AI search patterns online",
              "status": "pending",
              "activeForm": "Researching GOAP and AI search patterns"
            },
            {
              "content": "Document timeline and sequence of events",
              "status": "pending",
              "activeForm": "Documenting timeline and events"
            },
            {
              "content": "Identify root causes and propose solutions",
              "status": "pending",
              "activeForm": "Identifying root causes and solutions"
            },
            {
              "content": "Implement enemy search behavior with last-known-position",
              "status": "pending",
              "activeForm": "Implementing enemy search behavior"
            },
            {
              "content": "Add inspection points system for corners and hiding spots",
              "status": "pending",
              "activeForm": "Adding inspection points system"
            },
            {
              "content": "Test and verify implementation",
              "status": "pending",
              "activeForm": "Testing implementation"
            },
            {
              "content": "Update PR description and finalize",
              "status": "pending",
              "activeForm": "Updating PR and finalizing"
            }
          ]
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 1770,
      "cache_read_input_tokens": 72161,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1770,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "cbf3f67f-3c38-4d38-a53b-732a6870e0eb"
}
[2026-01-18T02:49:44.403Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_012Xo2ek1c1iQih8LTNEPUqz",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01LCv5JEgjPGkDSYe4h2ovhM",
        "name": "Bash",
        "input": {
          "command": "mkdir -p /tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-103",
          "description": "Create case study directory for issue 103"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 1770,
      "cache_read_input_tokens": 72161,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1770,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "83499dd7-fd78-4f9a-ac58-bb0651c00e81"
}
[2026-01-18T02:49:44.478Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01A95EKuTaXLgYjxRFdpHcG8",
        "type": "tool_result",
        "content": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "1fe458c0-d7fa-4264-a69b-ea8742c4a2d1",
  "tool_use_result": {
    "oldTodos": [
      {
        "content": "Read and analyze issue #103 requirements",
        "status": "completed",
        "activeForm": "Reading issue requirements"
      },
      {
        "content": "Explore existing AI/GOAP system architecture",
        "status": "in_progress",
        "activeForm": "Exploring AI/GOAP system architecture"
      },
      {
        "content": "Create case study directory structure",
        "status": "pending",
        "activeForm": "Creating case study directory structure"
      },
      {
        "content": "Research GOAP and AI search patterns online",
        "status": "pending",
        "activeForm": "Researching GOAP and AI search patterns"
      },
      {
        "content": "Document timeline and sequence of events",
        "status": "pending",
        "activeForm": "Documenting timeline and events"
      },
      {
        "content": "Identify root causes and propose solutions",
        "status": "pending",
        "activeForm": "Identifying root causes and solutions"
      },
      {
        "content": "Implement enemy search behavior",
        "status": "pending",
        "activeForm": "Implementing enemy search behavior"
      },
      {
        "content": "Add patrol points for hiding spots",
        "status": "pending",
        "activeForm": "Adding patrol points for hiding spots"
      },
      {
        "content": "Test and verify implementation",
        "status": "pending",
        "activeForm": "Testing implementation"
      },
      {
        "content": "Update PR description and finalize",
        "status": "pending",
        "activeForm": "Updating PR and finalizing"
      }
    ],
    "newTodos": [
      {
        "content": "Read and analyze issue #103 requirements",
        "status": "completed",
        "activeForm": "Reading issue requirements"
      },
      {
        "content": "Explore existing AI/GOAP system architecture",
        "status": "completed",
        "activeForm": "Exploring AI/GOAP system architecture"
      },
      {
        "content": "Create case study directory structure",
        "status": "in_progress",
        "activeForm": "Creating case study directory structure"
      },
      {
        "content": "Research GOAP and AI search patterns online",
        "status": "pending",
        "activeForm": "Researching GOAP and AI search patterns"
      },
      {
        "content": "Document timeline and sequence of events",
        "status": "pending",
        "activeForm": "Documenting timeline and events"
      },
      {
        "content": "Identify root causes and propose solutions",
        "status": "pending",
        "activeForm": "Identifying root causes and solutions"
      },
      {
        "content": "Implement enemy search behavior with last-known-position",
        "status": "pending",
        "activeForm": "Implementing enemy search behavior"
      },
      {
        "content": "Add inspection points system for corners and hiding spots",
        "status": "pending",
        "activeForm": "Adding inspection points system"
      },
      {
        "content": "Test and verify implementation",
        "status": "pending",
        "activeForm": "Testing implementation"
      },
      {
        "content": "Update PR description and finalize",
        "status": "pending",
        "activeForm": "Updating PR and finalizing"
      }
    ]
  }
}
[2026-01-18T02:49:44.568Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01LCv5JEgjPGkDSYe4h2ovhM",
        "type": "tool_result",
        "content": "",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "bc5ca461-b9c4-4353-8af3-04c839a93cfc",
  "tool_use_result": {
    "stdout": "",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-01-18T02:49:47.982Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_017L8UghNbg1Vyh6FBnMkYM3",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01QGMogvZBaCCAFjbQjCDySf",
        "name": "WebSearch",
        "input": {
          "query": "GOAP goal oriented action planning enemy search behavior player escape last known position game AI"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 587,
      "cache_read_input_tokens": 73931,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 587,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 26,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "b2470b3b-bd73-478d-91c4-818342bc5c67"
}
[2026-01-18T02:50:13.733Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01QGMogvZBaCCAFjbQjCDySf",
        "type": "tool_result",
        "content": "Web search results for query: \"GOAP goal oriented action planning enemy search behavior player escape last known position game AI\"\n\nLinks: [{\"title\":\"Building the AI of F.E.A.R. with Goal Oriented Action Planning\",\"url\":\"https://www.gamedeveloper.com/design/building-the-ai-of-f-e-a-r-with-goal-oriented-action-planning\"},{\"title\":\"Goal Oriented Action Planning. An artificial intelligence technique | by Vedant Chaudhari | Medium\",\"url\":\"https://medium.com/@vedantchaudhari/goal-oriented-action-planning-34035ed40d0b\"},{\"title\":\"NPC AI planning with GOAP | Excalibur.js\",\"url\":\"https://excaliburjs.com/blog/goal-oriented-action-planning/\"},{\"title\":\"Goal-Oriented Action Planning - Advanced AI For Games | Udemy\",\"url\":\"https://www.udemy.com/course/ai_with_goap/\"},{\"title\":\"GitHub - stolk/GPGOAP: General Purpose Goal Oriented Action Planning\",\"url\":\"https://github.com/stolk/GPGOAP\"},{\"title\":\"Quantum 2 - Addons - BotSDK - GOAP (Beta) | Photon Engine\",\"url\":\"https://doc.photonengine.com/quantum/v2/addons/bot-sdk/goap\"},{\"title\":\"What is Goap? | GOAP\",\"url\":\"https://goap.crashkonijn.com/readme/theory\"},{\"title\":\"(PDF) Tactical Planning in Space Game using Goal-Oriented Action Planning\",\"url\":\"https://www.researchgate.net/publication/334320575_Tactical_Planning_in_Space_Game_using_Goal-Oriented_Action_Planning\"},{\"title\":\"Goal-Oriented Action Planning: The Future of AI and VR | by John Vastola | Medium\",\"url\":\"https://johnvastola.medium.com/goal-oriented-action-planning-the-future-of-ai-and-vr-f0e9c59cb370\"},{\"title\":\"Applying Goal-Oriented Action Planning to Games 1\",\"url\":\"https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=0c35d00a015c93bac68475e8e1283b02701ff46b\"}]\n\nHere are the search results for your query about GOAP (Goal Oriented Action Planning) and enemy search behavior:\n\n## Overview of GOAP in Game AI\n\nGOAP or Goal Oriented Action Planning is a powerful STRIPS (Stanford Research Institute Problem Solver) like planning architecture designed for real time control of autonomous character behavior in games.(no content)GOAP is an artificial intelligence system for autonomous agents that allows them to dynamically plan a sequence of actions to satisfy a set goal.\n\n### How GOAP Works\n\nThe sequence of actions selected by the agent is contingent on both the current state of the agent and the current state of the world, hence despite two agents being assigned the same goal; both agents could select a completely different sequence of actions.(no content)GOAP determines which action to execute by evaluating each action's cost. The GOAP planner evaluates which sequence of actions to use by adding up the cumulative cost and selecting the sequence with lowest cost.\n\n### Enemy Search and Investigation Behavior\n\nIn games like NOLF2 (No One Lives Forever 2), goals include Patrol, and investigative goals include the more suspicious Investigate and Search. Aggressive goals are used for combat situations, like Chase, Charge, and AttackFromCover.\n\n### Example: AI Soldier Planning\n\nConsider a planner for an AI soldier. The soldier can perform the following actions: scout, approach, aim, shoot, load, detonatebomb, flee.(no content)Scout requires: armedwithgun, with the effect: enemyvisible. Approach requires: enemyvisible, with the effect: nearenemy.\n\n### Dynamic Adaptation\n\nAs the agent completes each action, it re-evaluates its state and the remaining actions in the plan to ensure that it is still on track towards its goal. If the agent encounters an obstacle or a change in the game environment, it can dynamically adjust its plan to find a new sequence of actions that will still lead to the desired goal.\n\n### Hide-and-Seek Behavior\n\nResearch has explored using GOAP for stealth-oriented games: GOAP with placement limitation (maximum two NPC in one hiding place) and unlimited placement has been used to model NPC hiding behavior. The GOAP NPC is effective to make hiding strategies through hide-and-seek game simulation.(no content)NPC as a hider in hide-and-seek game has complex behavior such as observing seeker, finding the safe place, moving to another hiding place, securing itself after being discovered by the seeker, and deciding to run away to the base.\n\n### F.E.A.R. Implementation\n\nGoal Oriented Action Planning adapts STRIPS planning from 1971 for use in games. Leading development on this project was Dr Jeff Orkin, the AI lead for Monolith Productions on both 2002's No One Lives Forever 2 and F.E.A.R., where GOAP was first implemented.(no content)FEAR's use of Goal Oriented Action Planning is still held to this day as some of the most exciting and fun enemy opponents to come across in modern video games. And while it's now been almost 15 years since the game's release, GOAP has continued to have a lasting impact within the video games industry.\n\n### Goals in GOAP Systems\n\nGoal-oriented action planning (GOAP) is an AI technique that consists of two parts: Selection of most suitable goal from a specified set of goals given current situation. Goals (also known as desires) could be: Defeat a target, Heal, Steal enemy flag, Flee from enemy. Finding a set of actions (plan) from a specified actions pool that fulfill this goal.\n\n\nREMINDER: You MUST include the sources above in your response to the user using markdown hyperlinks."
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "3e241766-2a5c-4f66-bcf5-36a2eb53a844",
  "tool_use_result": {
    "query": "GOAP goal oriented action planning enemy search behavior player escape last known position game AI",
    "results": [
      {
        "tool_use_id": "srvtoolu_01EY4Cogzu8EALe2SQTEZr4B",
        "content": [
          {
            "title": "Building the AI of F.E.A.R. with Goal Oriented Action Planning",
            "url": "https://www.gamedeveloper.com/design/building-the-ai-of-f-e-a-r-with-goal-oriented-action-planning"
          },
          {
            "title": "Goal Oriented Action Planning. An artificial intelligence technique | by Vedant Chaudhari | Medium",
            "url": "https://medium.com/@vedantchaudhari/goal-oriented-action-planning-34035ed40d0b"
          },
          {
            "title": "NPC AI planning with GOAP | Excalibur.js",
            "url": "https://excaliburjs.com/blog/goal-oriented-action-planning/"
          },
          {
            "title": "Goal-Oriented Action Planning - Advanced AI For Games | Udemy",
            "url": "https://www.udemy.com/course/ai_with_goap/"
          },
          {
            "title": "GitHub - stolk/GPGOAP: General Purpose Goal Oriented Action Planning",
            "url": "https://github.com/stolk/GPGOAP"
          },
          {
            "title": "Quantum 2 - Addons - BotSDK - GOAP (Beta) | Photon Engine",
            "url": "https://doc.photonengine.com/quantum/v2/addons/bot-sdk/goap"
          },
          {
            "title": "What is Goap? | GOAP",
            "url": "https://goap.crashkonijn.com/readme/theory"
          },
          {
            "title": "(PDF) Tactical Planning in Space Game using Goal-Oriented Action Planning",
            "url": "https://www.researchgate.net/publication/334320575_Tactical_Planning_in_Space_Game_using_Goal-Oriented_Action_Planning"
          },
          {
            "title": "Goal-Oriented Action Planning: The Future of AI and VR | by John Vastola | Medium",
            "url": "https://johnvastola.medium.com/goal-oriented-action-planning-the-future-of-ai-and-vr-f0e9c59cb370"
          },
          {
            "title": "Applying Goal-Oriented Action Planning to Games 1",
            "url": "https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=0c35d00a015c93bac68475e8e1283b02701ff46b"
          }
        ]
      },
      "Here are the search results for your query about GOAP (Goal Oriented Action Planning) and enemy search behavior:\n\n## Overview of GOAP in Game AI\n\nGOAP or Goal Oriented Action Planning is a powerful STRIPS (Stanford Research Institute Problem Solver) like planning architecture designed for real time control of autonomous character behavior in games.(no content)GOAP is an artificial intelligence system for autonomous agents that allows them to dynamically plan a sequence of actions to satisfy a set goal.\n\n### How GOAP Works\n\nThe sequence of actions selected by the agent is contingent on both the current state of the agent and the current state of the world, hence despite two agents being assigned the same goal; both agents could select a completely different sequence of actions.(no content)GOAP determines which action to execute by evaluating each action's cost. The GOAP planner evaluates which sequence of actions to use by adding up the cumulative cost and selecting the sequence with lowest cost.\n\n### Enemy Search and Investigation Behavior\n\nIn games like NOLF2 (No One Lives Forever 2), goals include Patrol, and investigative goals include the more suspicious Investigate and Search. Aggressive goals are used for combat situations, like Chase, Charge, and AttackFromCover.\n\n### Example: AI Soldier Planning\n\nConsider a planner for an AI soldier. The soldier can perform the following actions: scout, approach, aim, shoot, load, detonatebomb, flee.(no content)Scout requires: armedwithgun, with the effect: enemyvisible. Approach requires: enemyvisible, with the effect: nearenemy.\n\n### Dynamic Adaptation\n\nAs the agent completes each action, it re-evaluates its state and the remaining actions in the plan to ensure that it is still on track towards its goal. If the agent encounters an obstacle or a change in the game environment, it can dynamically adjust its plan to find a new sequence of actions that will still lead to the desired goal.\n\n### Hide-and-Seek Behavior\n\nResearch has explored using GOAP for stealth-oriented games: GOAP with placement limitation (maximum two NPC in one hiding place) and unlimited placement has been used to model NPC hiding behavior. The GOAP NPC is effective to make hiding strategies through hide-and-seek game simulation.(no content)NPC as a hider in hide-and-seek game has complex behavior such as observing seeker, finding the safe place, moving to another hiding place, securing itself after being discovered by the seeker, and deciding to run away to the base.\n\n### F.E.A.R. Implementation\n\nGoal Oriented Action Planning adapts STRIPS planning from 1971 for use in games. Leading development on this project was Dr Jeff Orkin, the AI lead for Monolith Productions on both 2002's No One Lives Forever 2 and F.E.A.R., where GOAP was first implemented.(no content)FEAR's use of Goal Oriented Action Planning is still held to this day as some of the most exciting and fun enemy opponents to come across in modern video games. And while it's now been almost 15 years since the game's release, GOAP has continued to have a lasting impact within the video games industry.\n\n### Goals in GOAP Systems\n\nGoal-oriented action planning (GOAP) is an AI technique that consists of two parts: Selection of most suitable goal from a specified set of goals given current situation. Goals (also known as desires) could be: Defeat a target, Heal, Steal enemy flag, Flee from enemy. Finding a set of actions (plan) from a specified actions pool that fulfill this goal."
    ],
    "durationSeconds": 25.723473975
  }
}
[2026-01-18T02:50:17.023Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01XrBFdtJZ4JKeYoLN8HsMic",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01L597oKfR1juDqXhGDdsSTY",
        "name": "WebSearch",
        "input": {
          "query": "game AI enemy search patrol last known position investigation points stealth games"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 1463,
      "cache_read_input_tokens": 74518,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1463,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 25,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "dc34f759-2a44-4ef4-8312-856546d2ce3d"
}
[2026-01-18T02:50:41.425Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01L597oKfR1juDqXhGDdsSTY",
        "type": "tool_result",
        "content": "Web search results for query: \"game AI enemy search patrol last known position investigation points stealth games\"\n\nLinks: [{\"title\":\"Dynamic Guard Patrol in Stealth Games\",\"url\":\"https://ojs.aaai.org/index.php/AIIDE/article/download/7425/7308/10903\"},{\"title\":\"Any games ever have enemy AI notice missing guards? - Stealth - Giant Bomb\",\"url\":\"https://www.giantbomb.com/stealth/3015-24/forums/any-games-ever-have-enemy-ai-notice-missing-guards-1482058/\"},{\"title\":\"Best Games With Enemy AI That Learns From You\",\"url\":\"https://www.thegamer.com/video-games-enemies-learn-fighting-you/\"},{\"title\":\"Improve Stealth in Any Game - Check our ultimate guide\",\"url\":\"https://xboxplay.games/stealth-exploration/how-to-improve-stealth-in-any-game-69896\"},{\"title\":\"Stealth Game Design (Principles, Mechanics, Template)\",\"url\":\"https://gamedesignskills.com/game-design/stealth/\"},{\"title\":\"Stealth game - Wikipedia\",\"url\":\"https://en.wikipedia.org/wiki/Stealth_game\"},{\"title\":\"What's the right AI for a stealth game? | NeoGAF\",\"url\":\"https://www.neogaf.com/threads/whats-the-right-ai-for-a-stealth-game.1011199/\"},{\"title\":\"How do stealth games work? What goes on in the AI of an enemy? - Quora\",\"url\":\"https://www.quora.com/How-do-stealth-games-work-What-goes-on-in-the-AI-of-an-enemy\"},{\"title\":\"The Predictable Problem: Why Stealth Game AI Needs an Overhaul - Wayline\",\"url\":\"https://www.wayline.io/blog/predictable-problem-stealth-game-ai-overhaul\"},{\"title\":\"Taking Apart Stealth ‚Äì Celia Alexis Wagar's CritPoints\",\"url\":\"https://critpoints.net/2015/05/18/taking-apart-stealth/\"}]\n\nHere are the search results on enemy AI search and patrol behaviors in stealth games:\n\n## Key Findings on Stealth Game AI Mechanics\n\n### Last Known Position Systems\nThe \"Last Known Position\" mechanic is a common stealth game feature: if you are detected and break line of sight, the AI will go to your last known position. This can be used strategically - for example, getting seen on a balcony, then dropping down to hide causes the guard to waste time investigating the empty balcony.(no content)When a player enters an area where enemies cannot see them, guards \"will stop pursuing directly and begin following a projected path of where you might have moved to based on your last location, until a timer runs out, then they enter investigation phase around your last known location, then another timer runs out and they return to changed patrols.\"\n\n### Investigation Points and Search Behaviors\nCertain triggers like partial sightings, sound, bodies, or other things will trigger an investigation phase where guards will look around the source of the disturbance.(no content)More advanced AI uses behavior trees that can incorporate \"different investigation strategies based on the context of the noise, the guard's personality, and the surrounding environment. This approach introduces an element of unpredictability, forcing the player to adapt their tactics accordingly.\"\n\n### Occupancy Maps and Knowledge Representation\nThird Eye Crime introduced an interesting method that incorporates occupancy maps to create an improved knowledge representation for agents to create \"a more realistic pursuit and search behavior in stealth scenarios.\"\n\n### Dynamic Patrol Systems\nInstead of relying on static patrol routes, developers can implement dynamic patrol systems that adapt to the player's actions and the changing environment. This can be achieved by using pathfinding algorithms to generate patrol routes in real-time, taking into account obstacles, player locations, and other relevant factors.(no content)In Splinter Cell: Blacklist, \"if you put the guards on alert, they never truly drop their guard.\" If the enemy knows you're there, they don't stop searching just because they can't find you after a minute, and it also throws off their patrol routes because they become more guarded.\n\n### Alert States and Guard Reactions\nOne staple of many stealth games is an alarm phase or alert phase, in which enemies more aggressively seek out the player character. Players can evade capture or engage in combat.(no content)In Metal Gear, guards call on the radio, and if no one answers they send in backup.(no content)In Dishonored, guards would comment about an area that is supposed to be patrolled, and then take on the missing enemy's route.\n\n\nREMINDER: You MUST include the sources above in your response to the user using markdown hyperlinks."
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "90e097cd-5048-48e2-bc32-98a78cc9fd9a",
  "tool_use_result": {
    "query": "game AI enemy search patrol last known position investigation points stealth games",
    "results": [
      {
        "tool_use_id": "srvtoolu_01GY4CzSnoU7cj1Wapzm4ido",
        "content": [
          {
            "title": "Dynamic Guard Patrol in Stealth Games",
            "url": "https://ojs.aaai.org/index.php/AIIDE/article/download/7425/7308/10903"
          },
          {
            "title": "Any games ever have enemy AI notice missing guards? - Stealth - Giant Bomb",
            "url": "https://www.giantbomb.com/stealth/3015-24/forums/any-games-ever-have-enemy-ai-notice-missing-guards-1482058/"
          },
          {
            "title": "Best Games With Enemy AI That Learns From You",
            "url": "https://www.thegamer.com/video-games-enemies-learn-fighting-you/"
          },
          {
            "title": "Improve Stealth in Any Game - Check our ultimate guide",
            "url": "https://xboxplay.games/stealth-exploration/how-to-improve-stealth-in-any-game-69896"
          },
          {
            "title": "Stealth Game Design (Principles, Mechanics, Template)",
            "url": "https://gamedesignskills.com/game-design/stealth/"
          },
          {
            "title": "Stealth game - Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Stealth_game"
          },
          {
            "title": "What's the right AI for a stealth game? | NeoGAF",
            "url": "https://www.neogaf.com/threads/whats-the-right-ai-for-a-stealth-game.1011199/"
          },
          {
            "title": "How do stealth games work? What goes on in the AI of an enemy? - Quora",
            "url": "https://www.quora.com/How-do-stealth-games-work-What-goes-on-in-the-AI-of-an-enemy"
          },
          {
            "title": "The Predictable Problem: Why Stealth Game AI Needs an Overhaul - Wayline",
            "url": "https://www.wayline.io/blog/predictable-problem-stealth-game-ai-overhaul"
          },
          {
            "title": "Taking Apart Stealth ‚Äì Celia Alexis Wagar's CritPoints",
            "url": "https://critpoints.net/2015/05/18/taking-apart-stealth/"
          }
        ]
      },
      "Here are the search results on enemy AI search and patrol behaviors in stealth games:\n\n## Key Findings on Stealth Game AI Mechanics\n\n### Last Known Position Systems\nThe \"Last Known Position\" mechanic is a common stealth game feature: if you are detected and break line of sight, the AI will go to your last known position. This can be used strategically - for example, getting seen on a balcony, then dropping down to hide causes the guard to waste time investigating the empty balcony.(no content)When a player enters an area where enemies cannot see them, guards \"will stop pursuing directly and begin following a projected path of where you might have moved to based on your last location, until a timer runs out, then they enter investigation phase around your last known location, then another timer runs out and they return to changed patrols.\"\n\n### Investigation Points and Search Behaviors\nCertain triggers like partial sightings, sound, bodies, or other things will trigger an investigation phase where guards will look around the source of the disturbance.(no content)More advanced AI uses behavior trees that can incorporate \"different investigation strategies based on the context of the noise, the guard's personality, and the surrounding environment. This approach introduces an element of unpredictability, forcing the player to adapt their tactics accordingly.\"\n\n### Occupancy Maps and Knowledge Representation\nThird Eye Crime introduced an interesting method that incorporates occupancy maps to create an improved knowledge representation for agents to create \"a more realistic pursuit and search behavior in stealth scenarios.\"\n\n### Dynamic Patrol Systems\nInstead of relying on static patrol routes, developers can implement dynamic patrol systems that adapt to the player's actions and the changing environment. This can be achieved by using pathfinding algorithms to generate patrol routes in real-time, taking into account obstacles, player locations, and other relevant factors.(no content)In Splinter Cell: Blacklist, \"if you put the guards on alert, they never truly drop their guard.\" If the enemy knows you're there, they don't stop searching just because they can't find you after a minute, and it also throws off their patrol routes because they become more guarded.\n\n### Alert States and Guard Reactions\nOne staple of many stealth games is an alarm phase or alert phase, in which enemies more aggressively seek out the player character. Players can evade capture or engage in combat.(no content)In Metal Gear, guards call on the radio, and if no one answers they send in backup.(no content)In Dishonored, guards would comment about an area that is supposed to be patrolled, and then take on the missing enemy's route."
    ],
    "durationSeconds": 24.38060791600001
  }
}
[2026-01-18T02:50:45.482Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01Ht2iJ7HamcgmvM5HcujmEe",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01W7RQx87vpPLvnw2nZRy1pM",
        "name": "WebFetch",
        "input": {
          "url": "https://www.gamedeveloper.com/design/building-the-ai-of-f-e-a-r-with-goal-oriented-action-planning",
          "prompt": "Extract information about how FEAR AI handles enemy search behavior when the player escapes from view, investigation behaviors, and searching for the player. Focus on how the AI maintains state about last known position and uses search/investigate goals."
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 1184,
      "cache_read_input_tokens": 75981,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1184,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 27,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "e0fcabbb-292b-4a96-8ceb-d693e96ef263"
}
[2026-01-18T02:50:50.862Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01W7RQx87vpPLvnw2nZRy1pM",
        "type": "tool_result",
        "content": "# FEAR AI Search Behavior Analysis\n\nBased on the provided article excerpt, I can only offer limited information about FEAR's search mechanics, as the content appears to be truncated before detailed discussion of investigation and search behaviors.\n\n## What the Article Establishes\n\nThe piece explains that FEAR uses Goal Oriented Action Planning (GOAP) with approximately 70 distinct goals available to AI characters. The system prioritizes goals dynamically‚Äîfor example, a \"KillEnemy\" goal has zero priority when no threat is detected, but escalates significantly once the player is spotted.\n\n## Search and Investigation (Inferred from GOAP Framework)\n\nWhile the excerpt doesn't explicitly detail search behavior mechanics, the GOAP architecture suggests how such behaviors would function:\n\nThe planning system would maintain state information about enemy knowledge. When a player breaks line of sight, goals would shift in priority. The character would likely retain memory of the player's \"last known position\" (a common game AI pattern), allowing GOAP to generate plans for investigating that location.\n\nWith 120 available actions in the game, the AI would have specific search-related actions available to execute sequentially‚Äîmoving to locations, playing investigation animations, and using smart objects while pursuing the player.\n\n## Limitation\n\nThe article text cuts off before exploring specific investigation mechanics, so the above represents the logical application of GOAP principles rather than explicit documentation of FEAR's search system."
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "f8fd8b78-e7b8-4a8c-a7a6-c37f7ab4c674",
  "tool_use_result": {
    "bytes": 480334,
    "code": 200,
    "codeText": "OK",
    "result": "# FEAR AI Search Behavior Analysis\n\nBased on the provided article excerpt, I can only offer limited information about FEAR's search mechanics, as the content appears to be truncated before detailed discussion of investigation and search behaviors.\n\n## What the Article Establishes\n\nThe piece explains that FEAR uses Goal Oriented Action Planning (GOAP) with approximately 70 distinct goals available to AI characters. The system prioritizes goals dynamically‚Äîfor example, a \"KillEnemy\" goal has zero priority when no threat is detected, but escalates significantly once the player is spotted.\n\n## Search and Investigation (Inferred from GOAP Framework)\n\nWhile the excerpt doesn't explicitly detail search behavior mechanics, the GOAP architecture suggests how such behaviors would function:\n\nThe planning system would maintain state information about enemy knowledge. When a player breaks line of sight, goals would shift in priority. The character would likely retain memory of the player's \"last known position\" (a common game AI pattern), allowing GOAP to generate plans for investigating that location.\n\nWith 120 available actions in the game, the AI would have specific search-related actions available to execute sequentially‚Äîmoving to locations, playing investigation animations, and using smart objects while pursuing the player.\n\n## Limitation\n\nThe article text cuts off before exploring specific investigation mechanics, so the above represents the logical application of GOAP principles rather than explicit documentation of FEAR's search system.",
    "durationMs": 5336,
    "url": "https://www.gamedeveloper.com/design/building-the-ai-of-f-e-a-r-with-goal-oriented-action-planning"
  }
}
[2026-01-18T02:50:54.476Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_016ZwjtfbXWQHYrQucRPUits",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me look at the existing level structure to understand where patrol points and hiding spots might be defined."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 464,
      "cache_read_input_tokens": 77165,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 464,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "cbb3895a-ee6c-4798-ac07-4aae4453eccc"
}
[2026-01-18T02:50:55.073Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_016ZwjtfbXWQHYrQucRPUits",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_018M6hrz9t5gD2CZJdbZKo4R",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/scenes/levels/BuildingLevel.tscn"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 464,
      "cache_read_input_tokens": 77165,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 464,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "27074ae3-e239-4071-93ba-88283f678f4c"
}
[2026-01-18T02:50:55.567Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_016ZwjtfbXWQHYrQucRPUits",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01JGMgyE5zMeQDzoP4jyAwyX",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/scenes/objects/Enemy.tscn"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 464,
      "cache_read_input_tokens": 77165,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 464,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "1febd2bf-f8d9-4f5d-871f-7754752cba0d"
}
[2026-01-18T02:50:55.606Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01JGMgyE5zMeQDzoP4jyAwyX",
        "type": "tool_result",
        "content": "     1‚Üí[gd_scene load_steps=5 format=3 uid=\"uid://cx5m8np6u3bwd\"]\n     2‚Üí\n     3‚Üí[ext_resource type=\"Script\" path=\"res://scripts/objects/enemy.gd\" id=\"1_enemy\"]\n     4‚Üí[ext_resource type=\"Script\" path=\"res://scripts/objects/hit_area.gd\" id=\"2_hit_area\"]\n     5‚Üí\n     6‚Üí[sub_resource type=\"PlaceholderTexture2D\" id=\"PlaceholderTexture2D_enemy\"]\n     7‚Üísize = Vector2(48, 48)\n     8‚Üí\n     9‚Üí[sub_resource type=\"CircleShape2D\" id=\"CircleShape2D_enemy\"]\n    10‚Üíradius = 24.0\n    11‚Üí\n    12‚Üí[node name=\"Enemy\" type=\"CharacterBody2D\"]\n    13‚Üícollision_layer = 2\n    14‚Üícollision_mask = 4\n    15‚Üíscript = ExtResource(\"1_enemy\")\n    16‚Üí\n    17‚Üí[node name=\"Sprite2D\" type=\"Sprite2D\" parent=\".\"]\n    18‚Üímodulate = Color(0.9, 0.2, 0.2, 1)\n    19‚Üítexture = SubResource(\"PlaceholderTexture2D_enemy\")\n    20‚Üí\n    21‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\".\"]\n    22‚Üíshape = SubResource(\"CircleShape2D_enemy\")\n    23‚Üí\n    24‚Üí[node name=\"RayCast2D\" type=\"RayCast2D\" parent=\".\"]\n    25‚Üítarget_position = Vector2(400, 0)\n    26‚Üícollision_mask = 5\n    27‚Üí\n    28‚Üí[node name=\"HitArea\" type=\"Area2D\" parent=\".\"]\n    29‚Üícollision_layer = 2\n    30‚Üícollision_mask = 16\n    31‚Üíscript = ExtResource(\"2_hit_area\")\n    32‚Üí\n    33‚Üí[node name=\"HitCollisionShape\" type=\"CollisionShape2D\" parent=\"HitArea\"]\n    34‚Üíshape = SubResource(\"CircleShape2D_enemy\")\n    35‚Üí\n    36‚Üí[node name=\"DebugLabel\" type=\"Label\" parent=\".\"]\n    37‚Üívisible = false\n    38‚Üíoffset_left = -50.0\n    39‚Üíoffset_top = -50.0\n    40‚Üíoffset_right = 50.0\n    41‚Üíoffset_bottom = -30.0\n    42‚Üíhorizontal_alignment = 1\n    43‚Üívertical_alignment = 1\n    44‚Üí\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "49a3e4f7-da3f-4286-b2c4-17afe0ce69f6",
  "tool_use_result": {
    "type": "text",
    "file": {
      "filePath": "/tmp/gh-issue-solver-1768704499561/scenes/objects/Enemy.tscn",
      "content": "[gd_scene load_steps=5 format=3 uid=\"uid://cx5m8np6u3bwd\"]\n\n[ext_resource type=\"Script\" path=\"res://scripts/objects/enemy.gd\" id=\"1_enemy\"]\n[ext_resource type=\"Script\" path=\"res://scripts/objects/hit_area.gd\" id=\"2_hit_area\"]\n\n[sub_resource type=\"PlaceholderTexture2D\" id=\"PlaceholderTexture2D_enemy\"]\nsize = Vector2(48, 48)\n\n[sub_resource type=\"CircleShape2D\" id=\"CircleShape2D_enemy\"]\nradius = 24.0\n\n[node name=\"Enemy\" type=\"CharacterBody2D\"]\ncollision_layer = 2\ncollision_mask = 4\nscript = ExtResource(\"1_enemy\")\n\n[node name=\"Sprite2D\" type=\"Sprite2D\" parent=\".\"]\nmodulate = Color(0.9, 0.2, 0.2, 1)\ntexture = SubResource(\"PlaceholderTexture2D_enemy\")\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\".\"]\nshape = SubResource(\"CircleShape2D_enemy\")\n\n[node name=\"RayCast2D\" type=\"RayCast2D\" parent=\".\"]\ntarget_position = Vector2(400, 0)\ncollision_mask = 5\n\n[node name=\"HitArea\" type=\"Area2D\" parent=\".\"]\ncollision_layer = 2\ncollision_mask = 16\nscript = ExtResource(\"2_hit_area\")\n\n[node name=\"HitCollisionShape\" type=\"CollisionShape2D\" parent=\"HitArea\"]\nshape = SubResource(\"CircleShape2D_enemy\")\n\n[node name=\"DebugLabel\" type=\"Label\" parent=\".\"]\nvisible = false\noffset_left = -50.0\noffset_top = -50.0\noffset_right = 50.0\noffset_bottom = -30.0\nhorizontal_alignment = 1\nvertical_alignment = 1\n",
      "numLines": 44,
      "startLine": 1,
      "totalLines": 44
    }
  }
}
[2026-01-18T02:50:55.840Z] [INFO] {"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018M6hrz9t5gD2CZJdbZKo4R","type":"tool_result","content":"     1‚Üí[gd_scene load_steps=14 format=3 uid=\"uid://c8hmf4bnwx2qk\"]\n     2‚Üí\n     3‚Üí[ext_resource type=\"Script\" path=\"res://scripts/levels/building_level.gd\" id=\"1_building_level\"]\n     4‚Üí[ext_resource type=\"PackedScene\" uid=\"uid://dv8nq2vj5r7p2\" path=\"res://scenes/characters/csharp/Player.tscn\" id=\"2_player\"]\n     5‚Üí[ext_resource type=\"PackedScene\" uid=\"uid://dxqmk8f3nw5pe\" path=\"res://scenes/ui/PauseMenu.tscn\" id=\"3_pause_menu\"]\n     6‚Üí[ext_resource type=\"PackedScene\" uid=\"uid://cx5m8np6u3bwd\" path=\"res://scenes/objects/Enemy.tscn\" id=\"4_enemy\"]\n     7‚Üí\n     8‚Üí[sub_resource type=\"RectangleShape2D\" id=\"RectangleShape2D_wall_horizontal\"]\n     9‚Üísize = Vector2(2464, 32)\n    10‚Üí\n    11‚Üí[sub_resource type=\"RectangleShape2D\" id=\"RectangleShape2D_wall_vertical\"]\n    12‚Üísize = Vector2(32, 2064)\n    13‚Üí\n    14‚Üí[sub_resource type=\"RectangleShape2D\" id=\"RectangleShape2D_interior_wall_h\"]\n    15‚Üísize = Vector2(400, 24)\n    16‚Üí\n    17‚Üí[sub_resource type=\"RectangleShape2D\" id=\"RectangleShape2D_interior_wall_v\"]\n    18‚Üísize = Vector2(24, 400)\n    19‚Üí\n    20‚Üí[sub_resource type=\"RectangleShape2D\" id=\"RectangleShape2D_interior_wall_short_h\"]\n    21‚Üísize = Vector2(200, 24)\n    22‚Üí\n    23‚Üí[sub_resource type=\"RectangleShape2D\" id=\"RectangleShape2D_interior_wall_short_v\"]\n    24‚Üísize = Vector2(24, 200)\n    25‚Üí\n    26‚Üí[sub_resource type=\"RectangleShape2D\" id=\"RectangleShape2D_cover_desk\"]\n    27‚Üísize = Vector2(120, 48)\n    28‚Üí\n    29‚Üí[sub_resource type=\"RectangleShape2D\" id=\"RectangleShape2D_cover_table\"]\n    30‚Üísize = Vector2(80, 80)\n    31‚Üí\n    32‚Üí[sub_resource type=\"RectangleShape2D\" id=\"RectangleShape2D_cover_cabinet\"]\n    33‚Üísize = Vector2(48, 96)\n    34‚Üí\n    35‚Üí[node name=\"BuildingLevel\" type=\"Node2D\"]\n    36‚Üíscript = ExtResource(\"1_building_level\")\n    37‚Üí\n    38‚Üí[node name=\"Environment\" type=\"Node2D\" parent=\".\"]\n    39‚Üí\n    40‚Üí[node name=\"Background\" type=\"ColorRect\" parent=\"Environment\"]\n    41‚Üíoffset_right = 2528.0\n    42‚Üíoffset_bottom = 2128.0\n    43‚Üícolor = Color(0.05, 0.05, 0.08, 1)\n    44‚Üí\n    45‚Üí[node name=\"Floor\" type=\"ColorRect\" parent=\"Environment\"]\n    46‚Üíoffset_left = 64.0\n    47‚Üíoffset_top = 64.0\n    48‚Üíoffset_right = 2464.0\n    49‚Üíoffset_bottom = 2064.0\n    50‚Üícolor = Color(0.18, 0.16, 0.14, 1)\n    51‚Üí\n    52‚Üí[node name=\"Walls\" type=\"Node2D\" parent=\"Environment\"]\n    53‚Üí\n    54‚Üí[node name=\"WallTop\" type=\"StaticBody2D\" parent=\"Environment/Walls\"]\n    55‚Üíposition = Vector2(1264, 48)\n    56‚Üícollision_layer = 4\n    57‚Üícollision_mask = 0\n    58‚Üí\n    59‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Walls/WallTop\"]\n    60‚Üíoffset_left = -1232.0\n    61‚Üíoffset_top = -16.0\n    62‚Üíoffset_right = 1232.0\n    63‚Üíoffset_bottom = 16.0\n    64‚Üícolor = Color(0.3, 0.25, 0.2, 1)\n    65‚Üí\n    66‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Walls/WallTop\"]\n    67‚Üíshape = SubResource(\"RectangleShape2D_wall_horizontal\")\n    68‚Üí\n    69‚Üí[node name=\"WallBottom\" type=\"StaticBody2D\" parent=\"Environment/Walls\"]\n    70‚Üíposition = Vector2(1264, 2080)\n    71‚Üícollision_layer = 4\n    72‚Üícollision_mask = 0\n    73‚Üí\n    74‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Walls/WallBottom\"]\n    75‚Üíoffset_left = -1232.0\n    76‚Üíoffset_top = -16.0\n    77‚Üíoffset_right = 1232.0\n    78‚Üíoffset_bottom = 16.0\n    79‚Üícolor = Color(0.3, 0.25, 0.2, 1)\n    80‚Üí\n    81‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Walls/WallBottom\"]\n    82‚Üíshape = SubResource(\"RectangleShape2D_wall_horizontal\")\n    83‚Üí\n    84‚Üí[node name=\"WallLeft\" type=\"StaticBody2D\" parent=\"Environment/Walls\"]\n    85‚Üíposition = Vector2(48, 1064)\n    86‚Üícollision_layer = 4\n    87‚Üícollision_mask = 0\n    88‚Üí\n    89‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Walls/WallLeft\"]\n    90‚Üíoffset_left = -16.0\n    91‚Üíoffset_top = -1032.0\n    92‚Üíoffset_right = 16.0\n    93‚Üíoffset_bottom = 1032.0\n    94‚Üícolor = Color(0.3, 0.25, 0.2, 1)\n    95‚Üí\n    96‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Walls/WallLeft\"]\n    97‚Üíshape = SubResource(\"RectangleShape2D_wall_vertical\")\n    98‚Üí\n    99‚Üí[node name=\"WallRight\" type=\"StaticBody2D\" parent=\"Environment/Walls\"]\n   100‚Üíposition = Vector2(2480, 1064)\n   101‚Üícollision_layer = 4\n   102‚Üícollision_mask = 0\n   103‚Üí\n   104‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Walls/WallRight\"]\n   105‚Üíoffset_left = -16.0\n   106‚Üíoffset_top = -1032.0\n   107‚Üíoffset_right = 16.0\n   108‚Üíoffset_bottom = 1032.0\n   109‚Üícolor = Color(0.3, 0.25, 0.2, 1)\n   110‚Üí\n   111‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Walls/WallRight\"]\n   112‚Üíshape = SubResource(\"RectangleShape2D_wall_vertical\")\n   113‚Üí\n   114‚Üí[node name=\"InteriorWalls\" type=\"Node2D\" parent=\"Environment\"]\n   115‚Üí\n   116‚Üí[node name=\"Room1_WallBottom\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   117‚Üíposition = Vector2(300, 700)\n   118‚Üícollision_layer = 4\n   119‚Üícollision_mask = 0\n   120‚Üí\n   121‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room1_WallBottom\"]\n   122‚Üíoffset_left = -200.0\n   123‚Üíoffset_top = -12.0\n   124‚Üíoffset_right = 200.0\n   125‚Üíoffset_bottom = 12.0\n   126‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   127‚Üí\n   128‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room1_WallBottom\"]\n   129‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_h\")\n   130‚Üí\n   131‚Üí[node name=\"Room1_WallRight\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   132‚Üíposition = Vector2(512, 400)\n   133‚Üícollision_layer = 4\n   134‚Üícollision_mask = 0\n   135‚Üí\n   136‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room1_WallRight\"]\n   137‚Üíoffset_left = -12.0\n   138‚Üíoffset_top = -200.0\n   139‚Üíoffset_right = 12.0\n   140‚Üíoffset_bottom = 200.0\n   141‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   142‚Üí\n   143‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room1_WallRight\"]\n   144‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_v\")\n   145‚Üí\n   146‚Üí[node name=\"Room2_WallLeft\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   147‚Üíposition = Vector2(512, 900)\n   148‚Üícollision_layer = 4\n   149‚Üícollision_mask = 0\n   150‚Üí\n   151‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room2_WallLeft\"]\n   152‚Üíoffset_left = -12.0\n   153‚Üíoffset_top = -100.0\n   154‚Üíoffset_right = 12.0\n   155‚Üíoffset_bottom = 100.0\n   156‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   157‚Üí\n   158‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room2_WallLeft\"]\n   159‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_short_v\")\n   160‚Üí\n   161‚Üí[node name=\"Room2_WallBottom\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   162‚Üíposition = Vector2(712, 1012)\n   163‚Üícollision_layer = 4\n   164‚Üícollision_mask = 0\n   165‚Üí\n   166‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room2_WallBottom\"]\n   167‚Üíoffset_left = -200.0\n   168‚Üíoffset_top = -12.0\n   169‚Üíoffset_right = 200.0\n   170‚Üíoffset_bottom = 12.0\n   171‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   172‚Üí\n   173‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room2_WallBottom\"]\n   174‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_h\")\n   175‚Üí\n   176‚Üí[node name=\"Room2_WallRight\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   177‚Üíposition = Vector2(924, 800)\n   178‚Üícollision_layer = 4\n   179‚Üícollision_mask = 0\n   180‚Üí\n   181‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room2_WallRight\"]\n   182‚Üíoffset_left = -12.0\n   183‚Üíoffset_top = -200.0\n   184‚Üíoffset_right = 12.0\n   185‚Üíoffset_bottom = 200.0\n   186‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   187‚Üí\n   188‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room2_WallRight\"]\n   189‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_v\")\n   190‚Üí\n   191‚Üí[node name=\"Corridor_WallTop\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   192‚Üíposition = Vector2(1164, 700)\n   193‚Üícollision_layer = 4\n   194‚Üícollision_mask = 0\n   195‚Üí\n   196‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Corridor_WallTop\"]\n   197‚Üíoffset_left = -200.0\n   198‚Üíoffset_top = -12.0\n   199‚Üíoffset_right = 200.0\n   200‚Üíoffset_bottom = 12.0\n   201‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   202‚Üí\n   203‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Corridor_WallTop\"]\n   204‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_h\")\n   205‚Üí\n   206‚Üí[node name=\"Corridor_WallBottom\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   207‚Üíposition = Vector2(1164, 1012)\n   208‚Üícollision_layer = 4\n   209‚Üícollision_mask = 0\n   210‚Üí\n   211‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Corridor_WallBottom\"]\n   212‚Üíoffset_left = -200.0\n   213‚Üíoffset_top = -12.0\n   214‚Üíoffset_right = 200.0\n   215‚Üíoffset_bottom = 12.0\n   216‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   217‚Üí\n   218‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Corridor_WallBottom\"]\n   219‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_h\")\n   220‚Üí\n   221‚Üí[node name=\"Room3_WallLeft\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   222‚Üíposition = Vector2(1376, 400)\n   223‚Üícollision_layer = 4\n   224‚Üícollision_mask = 0\n   225‚Üí\n   226‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room3_WallLeft\"]\n   227‚Üíoffset_left = -12.0\n   228‚Üíoffset_top = -200.0\n   229‚Üíoffset_right = 12.0\n   230‚Üíoffset_bottom = 200.0\n   231‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   232‚Üí\n   233‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room3_WallLeft\"]\n   234‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_v\")\n   235‚Üí\n   236‚Üí[node name=\"Room3_WallBottom\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   237‚Üíposition = Vector2(1576, 612)\n   238‚Üícollision_layer = 4\n   239‚Üícollision_mask = 0\n   240‚Üí\n   241‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room3_WallBottom\"]\n   242‚Üíoffset_left = -200.0\n   243‚Üíoffset_top = -12.0\n   244‚Üíoffset_right = 200.0\n   245‚Üíoffset_bottom = 12.0\n   246‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   247‚Üí\n   248‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room3_WallBottom\"]\n   249‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_h\")\n   250‚Üí\n   251‚Üí[node name=\"Room4_WallLeft\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   252‚Üíposition = Vector2(1376, 900)\n   253‚Üícollision_layer = 4\n   254‚Üícollision_mask = 0\n   255‚Üí\n   256‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room4_WallLeft\"]\n   257‚Üíoffset_left = -12.0\n   258‚Üíoffset_top = -100.0\n   259‚Üíoffset_right = 12.0\n   260‚Üíoffset_bottom = 100.0\n   261‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   262‚Üí\n   263‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room4_WallLeft\"]\n   264‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_short_v\")\n   265‚Üí\n   266‚Üí[node name=\"Room4_WallTop\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   267‚Üíposition = Vector2(1576, 788)\n   268‚Üícollision_layer = 4\n   269‚Üícollision_mask = 0\n   270‚Üí\n   271‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room4_WallTop\"]\n   272‚Üíoffset_left = -200.0\n   273‚Üíoffset_top = -12.0\n   274‚Üíoffset_right = 200.0\n   275‚Üíoffset_bottom = 12.0\n   276‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   277‚Üí\n   278‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room4_WallTop\"]\n   279‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_h\")\n   280‚Üí\n   281‚Üí[node name=\"Room5_WallTop\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   282‚Üíposition = Vector2(1900, 1200)\n   283‚Üícollision_layer = 4\n   284‚Üícollision_mask = 0\n   285‚Üí\n   286‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room5_WallTop\"]\n   287‚Üíoffset_left = -200.0\n   288‚Üíoffset_top = -12.0\n   289‚Üíoffset_right = 200.0\n   290‚Üíoffset_bottom = 12.0\n   291‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   292‚Üí\n   293‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room5_WallTop\"]\n   294‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_h\")\n   295‚Üí\n   296‚Üí[node name=\"Room5_WallLeft\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   297‚Üíposition = Vector2(1688, 1500)\n   298‚Üícollision_layer = 4\n   299‚Üícollision_mask = 0\n   300‚Üí\n   301‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room5_WallLeft\"]\n   302‚Üíoffset_left = -12.0\n   303‚Üíoffset_top = -200.0\n   304‚Üíoffset_right = 12.0\n   305‚Üíoffset_bottom = 200.0\n   306‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   307‚Üí\n   308‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room5_WallLeft\"]\n   309‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_v\")\n   310‚Üí\n   311‚Üí[node name=\"LobbyDivider_Left\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   312‚Üíposition = Vector2(300, 1400)\n   313‚Üícollision_layer = 4\n   314‚Üícollision_mask = 0\n   315‚Üí\n   316‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/LobbyDivider_Left\"]\n   317‚Üíoffset_left = -100.0\n   318‚Üíoffset_top = -12.0\n   319‚Üíoffset_right = 100.0\n   320‚Üíoffset_bottom = 12.0\n   321‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   322‚Üí\n   323‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/LobbyDivider_Left\"]\n   324‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_short_h\")\n   325‚Üí\n   326‚Üí[node name=\"LobbyDivider_Right\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   327‚Üíposition = Vector2(600, 1400)\n   328‚Üícollision_layer = 4\n   329‚Üícollision_mask = 0\n   330‚Üí\n   331‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/LobbyDivider_Right\"]\n   332‚Üíoffset_left = -100.0\n   333‚Üíoffset_top = -12.0\n   334‚Üíoffset_right = 100.0\n   335‚Üíoffset_bottom = 12.0\n   336‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   337‚Üí\n   338‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/LobbyDivider_Right\"]\n   339‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_short_h\")\n   340‚Üí\n   341‚Üí[node name=\"StorageRoom_WallTop\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   342‚Üíposition = Vector2(300, 1600)\n   343‚Üícollision_layer = 4\n   344‚Üícollision_mask = 0\n   345‚Üí\n   346‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/StorageRoom_WallTop\"]\n   347‚Üíoffset_left = -200.0\n   348‚Üíoffset_top = -12.0\n   349‚Üíoffset_right = 200.0\n   350‚Üíoffset_bottom = 12.0\n   351‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   352‚Üí\n   353‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/StorageRoom_WallTop\"]\n   354‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_h\")\n   355‚Üí\n   356‚Üí[node name=\"StorageRoom_WallRight\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   357‚Üíposition = Vector2(512, 1800)\n   358‚Üícollision_layer = 4\n   359‚Üícollision_mask = 0\n   360‚Üí\n   361‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/StorageRoom_WallRight\"]\n   362‚Üíoffset_left = -12.0\n   363‚Üíoffset_top = -100.0\n   364‚Üíoffset_right = 12.0\n   365‚Üíoffset_bottom = 100.0\n   366‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   367‚Üí\n   368‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/StorageRoom_WallRight\"]\n   369‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_short_v\")\n   370‚Üí\n   371‚Üí[node name=\"MainHall_WallLeft\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   372‚Üíposition = Vector2(900, 1600)\n   373‚Üícollision_layer = 4\n   374‚Üícollision_mask = 0\n   375‚Üí\n   376‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/MainHall_WallLeft\"]\n   377‚Üíoffset_left = -12.0\n   378‚Üíoffset_top = -200.0\n   379‚Üíoffset_right = 12.0\n   380‚Üíoffset_bottom = 200.0\n   381‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   382‚Üí\n   383‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/MainHall_WallLeft\"]\n   384‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_v\")\n   385‚Üí\n   386‚Üí[node name=\"MainHall_WallRight\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   387‚Üíposition = Vector2(1500, 1600)\n   388‚Üícollision_layer = 4\n   389‚Üícollision_mask = 0\n   390‚Üí\n   391‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/MainHall_WallRight\"]\n   392‚Üíoffset_left = -12.0\n   393‚Üíoffset_top = -200.0\n   394‚Üíoffset_right = 12.0\n   395‚Üíoffset_bottom = 200.0\n   396‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   397‚Üí\n   398‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/MainHall_WallRight\"]\n   399‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_v\")\n   400‚Üí\n   401‚Üí[node name=\"MainHall_WallTop\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\n   402‚Üíposition = Vector2(1200, 1388)\n   403‚Üícollision_layer = 4\n   404‚Üícollision_mask = 0\n   405‚Üí\n   406‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/MainHall_WallTop\"]\n   407‚Üíoffset_left = -200.0\n   408‚Üíoffset_top = -12.0\n   409‚Üíoffset_right = 200.0\n   410‚Üíoffset_bottom = 12.0\n   411‚Üícolor = Color(0.35, 0.3, 0.25, 1)\n   412‚Üí\n   413‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/MainHall_WallTop\"]\n   414‚Üíshape = SubResource(\"RectangleShape2D_interior_wall_h\")\n   415‚Üí\n   416‚Üí[node name=\"Cover\" type=\"Node2D\" parent=\"Environment\"]\n   417‚Üí\n   418‚Üí[node name=\"Desk1\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\n   419‚Üíposition = Vector2(280, 250)\n   420‚Üícollision_layer = 4\n   421‚Üícollision_mask = 0\n   422‚Üí\n   423‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Desk1\"]\n   424‚Üíoffset_left = -60.0\n   425‚Üíoffset_top = -24.0\n   426‚Üíoffset_right = 60.0\n   427‚Üíoffset_bottom = 24.0\n   428‚Üícolor = Color(0.4, 0.3, 0.2, 1)\n   429‚Üí\n   430‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Desk1\"]\n   431‚Üíshape = SubResource(\"RectangleShape2D_cover_desk\")\n   432‚Üí\n   433‚Üí[node name=\"Desk2\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\n   434‚Üíposition = Vector2(280, 450)\n   435‚Üícollision_layer = 4\n   436‚Üícollision_mask = 0\n   437‚Üí\n   438‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Desk2\"]\n   439‚Üíoffset_left = -60.0\n   440‚Üíoffset_top = -24.0\n   441‚Üíoffset_right = 60.0\n   442‚Üíoffset_bottom = 24.0\n   443‚Üícolor = Color(0.4, 0.3, 0.2, 1)\n   444‚Üí\n   445‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Desk2\"]\n   446‚Üíshape = SubResource(\"RectangleShape2D_cover_desk\")\n   447‚Üí\n   448‚Üí[node name=\"Table1\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\n   449‚Üíposition = Vector2(720, 850)\n   450‚Üícollision_layer = 4\n   451‚Üícollision_mask = 0\n   452‚Üí\n   453‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Table1\"]\n   454‚Üíoffset_left = -40.0\n   455‚Üíoffset_top = -40.0\n   456‚Üíoffset_right = 40.0\n   457‚Üíoffset_bottom = 40.0\n   458‚Üícolor = Color(0.35, 0.28, 0.22, 1)\n   459‚Üí\n   460‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Table1\"]\n   461‚Üíshape = SubResource(\"RectangleShape2D_cover_table\")\n   462‚Üí\n   463‚Üí[node name=\"Cabinet1\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\n   464‚Üíposition = Vector2(1000, 250)\n   465‚Üícollision_layer = 4\n   466‚Üícollision_mask = 0\n   467‚Üí\n   468‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Cabinet1\"]\n   469‚Üíoffset_left = -24.0\n   470‚Üíoffset_top = -48.0\n   471‚Üíoffset_right = 24.0\n   472‚Üíoffset_bottom = 48.0\n   473‚Üícolor = Color(0.3, 0.25, 0.2, 1)\n   474‚Üí\n   475‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Cabinet1\"]\n   476‚Üíshape = SubResource(\"RectangleShape2D_cover_cabinet\")\n   477‚Üí\n   478‚Üí[node name=\"Cabinet2\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\n   479‚Üíposition = Vector2(1100, 250)\n   480‚Üícollision_layer = 4\n   481‚Üícollision_mask = 0\n   482‚Üí\n   483‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Cabinet2\"]\n   484‚Üíoffset_left = -24.0\n   485‚Üíoffset_top = -48.0\n   486‚Üíoffset_right = 24.0\n   487‚Üíoffset_bottom = 48.0\n   488‚Üícolor = Color(0.3, 0.25, 0.2, 1)\n   489‚Üí\n   490‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Cabinet2\"]\n   491‚Üíshape = SubResource(\"RectangleShape2D_cover_cabinet\")\n   492‚Üí\n   493‚Üí[node name=\"Desk3\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\n   494‚Üíposition = Vector2(1600, 300)\n   495‚Üícollision_layer = 4\n   496‚Üícollision_mask = 0\n   497‚Üí\n   498‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Desk
[2026-01-18T02:50:55.852Z] [INFO] 3\"]\n   499‚Üíoffset_left = -60.0\n   500‚Üíoffset_top = -24.0\n   501‚Üíoffset_right = 60.0\n   502‚Üíoffset_bottom = 24.0\n   503‚Üícolor = Color(0.4, 0.3, 0.2, 1)\n   504‚Üí\n   505‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Desk3\"]\n   506‚Üíshape = SubResource(\"RectangleShape2D_cover_desk\")\n   507‚Üí\n   508‚Üí[node name=\"Desk4\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\n   509‚Üíposition = Vector2(1900, 300)\n   510‚Üícollision_layer = 4\n   511‚Üícollision_mask = 0\n   512‚Üí\n   513‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Desk4\"]\n   514‚Üíoffset_left = -60.0\n   515‚Üíoffset_top = -24.0\n   516‚Üíoffset_right = 60.0\n   517‚Üíoffset_bottom = 24.0\n   518‚Üícolor = Color(0.4, 0.3, 0.2, 1)\n   519‚Üí\n   520‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Desk4\"]\n   521‚Üíshape = SubResource(\"RectangleShape2D_cover_desk\")\n   522‚Üí\n   523‚Üí[node name=\"Table2\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\n   524‚Üíposition = Vector2(1550, 950)\n   525‚Üícollision_layer = 4\n   526‚Üícollision_mask = 0\n   527‚Üí\n   528‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Table2\"]\n   529‚Üíoffset_left = -40.0\n   530‚Üíoffset_top = -40.0\n   531‚Üíoffset_right = 40.0\n   532‚Üíoffset_bottom = 40.0\n   533‚Üícolor = Color(0.35, 0.28, 0.22, 1)\n   534‚Üí\n   535‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Table2\"]\n   536‚Üíshape = SubResource(\"RectangleShape2D_cover_table\")\n   537‚Üí\n   538‚Üí[node name=\"Table3\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\n   539‚Üíposition = Vector2(2000, 1500)\n   540‚Üícollision_layer = 4\n   541‚Üícollision_mask = 0\n   542‚Üí\n   543‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Table3\"]\n   544‚Üíoffset_left = -40.0\n   545‚Üíoffset_top = -40.0\n   546‚Üíoffset_right = 40.0\n   547‚Üíoffset_bottom = 40.0\n   548‚Üícolor = Color(0.35, 0.28, 0.22, 1)\n   549‚Üí\n   550‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Table3\"]\n   551‚Üíshape = SubResource(\"RectangleShape2D_cover_table\")\n   552‚Üí\n   553‚Üí[node name=\"Cabinet3\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\n   554‚Üíposition = Vector2(2300, 1400)\n   555‚Üícollision_layer = 4\n   556‚Üícollision_mask = 0\n   557‚Üí\n   558‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Cabinet3\"]\n   559‚Üíoffset_left = -24.0\n   560‚Üíoffset_top = -48.0\n   561‚Üíoffset_right = 24.0\n   562‚Üíoffset_bottom = 48.0\n   563‚Üícolor = Color(0.3, 0.25, 0.2, 1)\n   564‚Üí\n   565‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Cabinet3\"]\n   566‚Üíshape = SubResource(\"RectangleShape2D_cover_cabinet\")\n   567‚Üí\n   568‚Üí[node name=\"StorageCrate1\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\n   569‚Üíposition = Vector2(200, 1750)\n   570‚Üícollision_layer = 4\n   571‚Üícollision_mask = 0\n   572‚Üí\n   573‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/StorageCrate1\"]\n   574‚Üíoffset_left = -40.0\n   575‚Üíoffset_top = -40.0\n   576‚Üíoffset_right = 40.0\n   577‚Üíoffset_bottom = 40.0\n   578‚Üícolor = Color(0.45, 0.35, 0.2, 1)\n   579‚Üí\n   580‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/StorageCrate1\"]\n   581‚Üíshape = SubResource(\"RectangleShape2D_cover_table\")\n   582‚Üí\n   583‚Üí[node name=\"StorageCrate2\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\n   584‚Üíposition = Vector2(350, 1850)\n   585‚Üícollision_layer = 4\n   586‚Üícollision_mask = 0\n   587‚Üí\n   588‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/StorageCrate2\"]\n   589‚Üíoffset_left = -40.0\n   590‚Üíoffset_top = -40.0\n   591‚Üíoffset_right = 40.0\n   592‚Üíoffset_bottom = 40.0\n   593‚Üícolor = Color(0.45, 0.35, 0.2, 1)\n   594‚Üí\n   595‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/StorageCrate2\"]\n   596‚Üíshape = SubResource(\"RectangleShape2D_cover_table\")\n   597‚Üí\n   598‚Üí[node name=\"HallTable\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\n   599‚Üíposition = Vector2(1200, 1650)\n   600‚Üícollision_layer = 4\n   601‚Üícollision_mask = 0\n   602‚Üí\n   603‚Üí[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/HallTable\"]\n   604‚Üíoffset_left = -60.0\n   605‚Üíoffset_top = -24.0\n   606‚Üíoffset_right = 60.0\n   607‚Üíoffset_bottom = 24.0\n   608‚Üícolor = Color(0.4, 0.3, 0.2, 1)\n   609‚Üí\n   610‚Üí[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/HallTable\"]\n   611‚Üíshape = SubResource(\"RectangleShape2D_cover_desk\")\n   612‚Üí\n   613‚Üí[node name=\"Enemies\" type=\"Node2D\" parent=\"Environment\"]\n   614‚Üí\n   615‚Üí[node name=\"Enemy1\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\n   616‚Üíposition = Vector2(300, 350)\n   617‚Üíbehavior_mode = 1\n   618‚Üídestroy_on_death = true\n   619‚Üíenable_flanking = true\n   620‚Üíenable_cover = true\n   621‚Üí\n   622‚Üí[node name=\"Enemy2\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\n   623‚Üíposition = Vector2(400, 550)\n   624‚Üíbehavior_mode = 1\n   625‚Üídestroy_on_death = true\n   626‚Üíenable_flanking = true\n   627‚Üíenable_cover = true\n   628‚Üí\n   629‚Üí[node name=\"Enemy3\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\n   630‚Üíposition = Vector2(700, 750)\n   631‚Üíbehavior_mode = 1\n   632‚Üídestroy_on_death = true\n   633‚Üíenable_flanking = true\n   634‚Üíenable_cover = true\n   635‚Üí\n   636‚Üí[node name=\"Enemy4\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\n   637‚Üíposition = Vector2(800, 900)\n   638‚Üíbehavior_mode = 1\n   639‚Üídestroy_on_death = true\n   640‚Üíenable_flanking = true\n   641‚Üíenable_cover = true\n   642‚Üí\n   643‚Üí[node name=\"Enemy5\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\n   644‚Üíposition = Vector2(1700, 350)\n   645‚Üíbehavior_mode = 1\n   646‚Üídestroy_on_death = true\n   647‚Üíenable_flanking = true\n   648‚Üíenable_cover = true\n   649‚Üí\n   650‚Üí[node name=\"Enemy6\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\n   651‚Üíposition = Vector2(1950, 450)\n   652‚Üíbehavior_mode = 1\n   653‚Üídestroy_on_death = true\n   654‚Üíenable_flanking = true\n   655‚Üíenable_cover = true\n   656‚Üí\n   657‚Üí[node name=\"Enemy7\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\n   658‚Üíposition = Vector2(1600, 900)\n   659‚Üíbehavior_mode = 0\n   660‚Üípatrol_offsets = Array[Vector2]([Vector2(100, 0), Vector2(-100, 0)])\n   661‚Üídestroy_on_death = true\n   662‚Üíenable_flanking = true\n   663‚Üíenable_cover = true\n   664‚Üí\n   665‚Üí[node name=\"Enemy8\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\n   666‚Üíposition = Vector2(1900, 1450)\n   667‚Üíbehavior_mode = 1\n   668‚Üídestroy_on_death = true\n   669‚Üíenable_flanking = true\n   670‚Üíenable_cover = true\n   671‚Üí\n   672‚Üí[node name=\"Enemy9\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\n   673‚Üíposition = Vector2(2100, 1550)\n   674‚Üíbehavior_mode = 1\n   675‚Üídestroy_on_death = true\n   676‚Üíenable_flanking = true\n   677‚Üíenable_cover = true\n   678‚Üí\n   679‚Üí[node name=\"Enemy10\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\n   680‚Üíposition = Vector2(1200, 1550)\n   681‚Üíbehavior_mode = 0\n   682‚Üípatrol_offsets = Array[Vector2]([Vector2(0, 150), Vector2(0, -150)])\n   683‚Üídestroy_on_death = true\n   684‚Üíenable_flanking = true\n   685‚Üíenable_cover = true\n   686‚Üí\n   687‚Üí[node name=\"RoomLabels\" type=\"Node2D\" parent=\"Environment\"]\n   688‚Üí\n   689‚Üí[node name=\"Room1Label\" type=\"ColorRect\" parent=\"Environment/RoomLabels\"]\n   690‚Üíoffset_left = 80.0\n   691‚Üíoffset_top = 80.0\n   692‚Üíoffset_right = 500.0\n   693‚Üíoffset_bottom = 688.0\n   694‚Üícolor = Color(0.15, 0.12, 0.1, 0.3)\n   695‚Üí\n   696‚Üí[node name=\"Label\" type=\"Label\" parent=\"Environment/RoomLabels/Room1Label\"]\n   697‚Üíoffset_left = 10.0\n   698‚Üíoffset_top = 10.0\n   699‚Üíoffset_right = 100.0\n   700‚Üíoffset_bottom = 30.0\n   701‚Üítext = \"OFFICE 1\"\n   702‚Üí\n   703‚Üí[node name=\"Room2Label\" type=\"ColorRect\" parent=\"Environment/RoomLabels\"]\n   704‚Üíoffset_left = 524.0\n   705‚Üíoffset_top = 712.0\n   706‚Üíoffset_right = 912.0\n   707‚Üíoffset_bottom = 1000.0\n   708‚Üícolor = Color(0.15, 0.12, 0.1, 0.3)\n   709‚Üí\n   710‚Üí[node name=\"Label\" type=\"Label\" parent=\"Environment/RoomLabels/Room2Label\"]\n   711‚Üíoffset_left = 10.0\n   712‚Üíoffset_top = 10.0\n   713‚Üíoffset_right = 100.0\n   714‚Üíoffset_bottom = 30.0\n   715‚Üítext = \"OFFICE 2\"\n   716‚Üí\n   717‚Üí[node name=\"Room3Label\" type=\"ColorRect\" parent=\"Environment/RoomLabels\"]\n   718‚Üíoffset_left = 1388.0\n   719‚Üíoffset_top = 80.0\n   720‚Üíoffset_right = 2448.0\n   721‚Üíoffset_bottom = 600.0\n   722‚Üícolor = Color(0.12, 0.15, 0.1, 0.3)\n   723‚Üí\n   724‚Üí[node name=\"Label\" type=\"Label\" parent=\"Environment/RoomLabels/Room3Label\"]\n   725‚Üíoffset_left = 10.0\n   726‚Üíoffset_top = 10.0\n   727‚Üíoffset_right = 180.0\n   728‚Üíoffset_bottom = 30.0\n   729‚Üítext = \"CONFERENCE ROOM\"\n   730‚Üí\n   731‚Üí[node name=\"Room4Label\" type=\"ColorRect\" parent=\"Environment/RoomLabels\"]\n   732‚Üíoffset_left = 1388.0\n   733‚Üíoffset_top = 800.0\n   734‚Üíoffset_right = 2448.0\n   735‚Üíoffset_bottom = 1188.0\n   736‚Üícolor = Color(0.15, 0.1, 0.12, 0.3)\n   737‚Üí\n   738‚Üí[node name=\"Label\" type=\"Label\" parent=\"Environment/RoomLabels/Room4Label\"]\n   739‚Üíoffset_left = 10.0\n   740‚Üíoffset_top = 10.0\n   741‚Üíoffset_right = 150.0\n   742‚Üíoffset_bottom = 30.0\n   743‚Üítext = \"BREAK ROOM\"\n   744‚Üí\n   745‚Üí[node name=\"Room5Label\" type=\"ColorRect\" parent=\"Environment/RoomLabels\"]\n   746‚Üíoffset_left = 1700.0\n   747‚Üíoffset_top = 1212.0\n   748‚Üíoffset_right = 2448.0\n   749‚Üíoffset_bottom = 2048.0\n   750‚Üícolor = Color(0.12, 0.1, 0.15, 0.3)\n   751‚Üí\n   752‚Üí[node name=\"Label\" type=\"Label\" parent=\"Environment/RoomLabels/Room5Label\"]\n   753‚Üíoffset_left = 10.0\n   754‚Üíoffset_top = 10.0\n   755‚Üíoffset_right = 150.0\n   756‚Üíoffset_bottom = 30.0\n   757‚Üítext = \"SERVER ROOM\"\n   758‚Üí\n   759‚Üí[node name=\"StorageLabel\" type=\"ColorRect\" parent=\"Environment/RoomLabels\"]\n   760‚Üíoffset_left = 80.0\n   761‚Üíoffset_top = 1612.0\n   762‚Üíoffset_right = 500.0\n   763‚Üíoffset_bottom = 2048.0\n   764‚Üícolor = Color(0.1, 0.12, 0.15, 0.3)\n   765‚Üí\n   766‚Üí[node name=\"Label\" type=\"Label\" parent=\"Environment/RoomLabels/StorageLabel\"]\n   767‚Üíoffset_left = 10.0\n   768‚Üíoffset_top = 10.0\n   769‚Üíoffset_right = 100.0\n   770‚Üíoffset_bottom = 30.0\n   771‚Üítext = \"STORAGE\"\n   772‚Üí\n   773‚Üí[node name=\"MainHallLabel\" type=\"ColorRect\" parent=\"Environment/RoomLabels\"]\n   774‚Üíoffset_left = 912.0\n   775‚Üíoffset_top = 1400.0\n   776‚Üíoffset_right = 1488.0\n   777‚Üíoffset_bottom = 2048.0\n   778‚Üícolor = Color(0.15, 0.15, 0.1, 0.3)\n   779‚Üí\n   780‚Üí[node name=\"Label\" type=\"Label\" parent=\"Environment/RoomLabels/MainHallLabel\"]\n   781‚Üíoffset_left = 10.0\n   782‚Üíoffset_top = 10.0\n   783‚Üíoffset_right = 100.0\n   784‚Üíoffset_bottom = 30.0\n   785‚Üítext = \"MAIN HALL\"\n   786‚Üí\n   787‚Üí[node name=\"Entities\" type=\"Node2D\" parent=\".\"]\n   788‚Üí\n   789‚Üí[node name=\"Player\" parent=\"Entities\" instance=ExtResource(\"2_player\")]\n   790‚Üíposition = Vector2(450, 1250)\n   791‚Üí\n   792‚Üí[node name=\"CanvasLayer\" type=\"CanvasLayer\" parent=\".\"]\n   793‚Üí\n   794‚Üí[node name=\"UI\" type=\"Control\" parent=\"CanvasLayer\"]\n   795‚Üílayout_mode = 3\n   796‚Üíanchors_preset = 15\n   797‚Üíanchor_right = 1.0\n   798‚Üíanchor_bottom = 1.0\n   799‚Üígrow_horizontal = 2\n   800‚Üígrow_vertical = 2\n   801‚Üí\n   802‚Üí[node name=\"LevelLabel\" type=\"Label\" parent=\"CanvasLayer/UI\"]\n   803‚Üílayout_mode = 1\n   804‚Üíanchors_preset = 1\n   805‚Üíanchor_left = 1.0\n   806‚Üíanchor_right = 1.0\n   807‚Üíoffset_left = -250.0\n   808‚Üíoffset_top = 10.0\n   809‚Üíoffset_right = -10.0\n   810‚Üíoffset_bottom = 40.0\n   811‚Üígrow_horizontal = 0\n   812‚Üítext = \"BUILDING INTERIOR\"\n   813‚Üíhorizontal_alignment = 2\n   814‚Üí\n   815‚Üí[node name=\"InstructionsLabel\" type=\"Label\" parent=\"CanvasLayer/UI\"]\n   816‚Üílayout_mode = 1\n   817‚Üíanchors_preset = 0\n   818‚Üíoffset_left = 10.0\n   819‚Üíoffset_top = 650.0\n   820‚Üíoffset_right = 600.0\n   821‚Üíoffset_bottom = 710.0\n   822‚Üítext = \"WASD - Move | LMB - Shoot (hold) | R - Reload | B - Toggle Fire Mode | ESC - Pause\n   823‚ÜíClear all rooms to win!\"\n   824‚Üí\n   825‚Üí[node name=\"EnemyCountLabel\" type=\"Label\" parent=\"CanvasLayer/UI\"]\n   826‚Üílayout_mode = 1\n   827‚Üíanchors_preset = 1\n   828‚Üíanchor_left = 1.0\n   829‚Üíanchor_right = 1.0\n   830‚Üíoffset_left = -200.0\n   831‚Üíoffset_top = 45.0\n   832‚Üíoffset_right = -10.0\n   833‚Üíoffset_bottom = 75.0\n   834‚Üígrow_horizontal = 0\n   835‚Üítext = \"Enemies: 10\"\n   836‚Üíhorizontal_alignment = 2\n   837‚Üí\n   838‚Üí[node name=\"AmmoLabel\" type=\"Label\" parent=\"CanvasLayer/UI\"]\n   839‚Üílayout_mode = 1\n   840‚Üíanchors_preset = 0\n   841‚Üíoffset_left = 10.0\n   842‚Üíoffset_top = 10.0\n   843‚Üíoffset_right = 200.0\n   844‚Üíoffset_bottom = 45.0\n   845‚Üítext = \"AMMO: 30/30\"\n   846‚Üí\n   847‚Üí[node name=\"PauseMenu\" parent=\".\" instance=ExtResource(\"3_pause_menu\")]\n   848‚Üí\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"797fbac8-f5e6-4339-8fd2-77453410db49","uuid":"6bdb2c10-23e7-446b-8ae4-8c8eae59af05","tool_use_result":{"type":"text","file":{"filePath":"/tmp/gh-issue-solver-1768704499561/scenes/levels/BuildingLevel.tscn","content":"[gd_scene load_steps=14 format=3 uid=\"uid://c8hmf4bnwx2qk\"]\n\n[ext_resource type=\"Script\" path=\"res://scripts/levels/building_level.gd\" id=\"1_building_level\"]\n[ext_resource type=\"PackedScene\" uid=\"uid://dv8nq2vj5r7p2\" path=\"res://scenes/characters/csharp/Player.tscn\" id=\"2_player\"]\n[ext_resource type=\"PackedScene\" uid=\"uid://dxqmk8f3nw5pe\" path=\"res://scenes/ui/PauseMenu.tscn\" id=\"3_pause_menu\"]\n[ext_resource type=\"PackedScene\" uid=\"uid://cx5m8np6u3bwd\" path=\"res://scenes/objects/Enemy.tscn\" id=\"4_enemy\"]\n\n[sub_resource type=\"RectangleShape2D\" id=\"RectangleShape2D_wall_horizontal\"]\nsize = Vector2(2464, 32)\n\n[sub_resource type=\"RectangleShape2D\" id=\"RectangleShape2D_wall_vertical\"]\nsize = Vector2(32, 2064)\n\n[sub_resource type=\"RectangleShape2D\" id=\"RectangleShape2D_interior_wall_h\"]\nsize = Vector2(400, 24)\n\n[sub_resource type=\"RectangleShape2D\" id=\"RectangleShape2D_interior_wall_v\"]\nsize = Vector2(24, 400)\n\n[sub_resource type=\"RectangleShape2D\" id=\"RectangleShape2D_interior_wall_short_h\"]\nsize = Vector2(200, 24)\n\n[sub_resource type=\"RectangleShape2D\" id=\"RectangleShape2D_interior_wall_short_v\"]\nsize = Vector2(24, 200)\n\n[sub_resource type=\"RectangleShape2D\" id=\"RectangleShape2D_cover_desk\"]\nsize = Vector2(120, 48)\n\n[sub_resource type=\"RectangleShape2D\" id=\"RectangleShape2D_cover_table\"]\nsize = Vector2(80, 80)\n\n[sub_resource type=\"RectangleShape2D\" id=\"RectangleShape2D_cover_cabinet\"]\nsize = Vector2(48, 96)\n\n[node name=\"BuildingLevel\" type=\"Node2D\"]\nscript = ExtResource(\"1_building_level\")\n\n[node name=\"Environment\" type=\"Node2D\" parent=\".\"]\n\n[node name=\"Background\" type=\"ColorRect\" parent=\"Environment\"]\noffset_right = 2528.0\noffset_bottom = 2128.0\ncolor = Color(0.05, 0.05, 0.08, 1)\n\n[node name=\"Floor\" type=\"ColorRect\" parent=\"Environment\"]\noffset_left = 64.0\noffset_top = 64.0\noffset_right = 2464.0\noffset_bottom = 2064.0\ncolor = Color(0.18, 0.16, 0.14, 1)\n\n[node name=\"Walls\" type=\"Node2D\" parent=\"Environment\"]\n\n[node name=\"WallTop\" type=\"StaticBody2D\" parent=\"Environment/Walls\"]\nposition = Vector2(1264, 48)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Walls/WallTop\"]\noffset_left = -1232.0\noffset_top = -16.0\noffset_right = 1232.0\noffset_bottom = 16.0\ncolor = Color(0.3, 0.25, 0.2, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Walls/WallTop\"]\nshape = SubResource(\"RectangleShape2D_wall_horizontal\")\n\n[node name=\"WallBottom\" type=\"StaticBody2D\" parent=\"Environment/Walls\"]\nposition = Vector2(1264, 2080)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Walls/WallBottom\"]\noffset_left = -1232.0\noffset_top = -16.0\noffset_right = 1232.0\noffset_bottom = 16.0\ncolor = Color(0.3, 0.25, 0.2, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Walls/WallBottom\"]\nshape = SubResource(\"RectangleShape2D_wall_horizontal\")\n\n[node name=\"WallLeft\" type=\"StaticBody2D\" parent=\"Environment/Walls\"]\nposition = Vector2(48, 1064)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Walls/WallLeft\"]\noffset_left = -16.0\noffset_top = -1032.0\noffset_right = 16.0\noffset_bottom = 1032.0\ncolor = Color(0.3, 0.25, 0.2, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Walls/WallLeft\"]\nshape = SubResource(\"RectangleShape2D_wall_vertical\")\n\n[node name=\"WallRight\" type=\"StaticBody2D\" parent=\"Environment/Walls\"]\nposition = Vector2(2480, 1064)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Walls/WallRight\"]\noffset_left = -16.0\noffset_top = -1032.0\noffset_right = 16.0\noffset_bottom = 1032.0\ncolor = Color(0.3, 0.25, 0.2, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Walls/WallRight\"]\nshape = SubResource(\"RectangleShape2D_wall_vertical\")\n\n[node name=\"InteriorWalls\" type=\"Node2D\" parent=\"Environment\"]\n\n[node name=\"Room1_WallBottom\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(300, 700)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room1_WallBottom\"]\noffset_left = -200.0\noffset_top = -12.0\noffset_right = 200.0\noffset_bottom = 12.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room1_WallBottom\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_h\")\n\n[node name=\"Room1_WallRight\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(512, 400)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room1_WallRight\"]\noffset_left = -12.0\noffset_top = -200.0\noffset_right = 12.0\noffset_bottom = 200.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room1_WallRight\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_v\")\n\n[node name=\"Room2_WallLeft\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(512, 900)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room2_WallLeft\"]\noffset_left = -12.0\noffset_top = -100.0\noffset_right = 12.0\noffset_bottom = 100.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room2_WallLeft\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_short_v\")\n\n[node name=\"Room2_WallBottom\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(712, 1012)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room2_WallBottom\"]\noffset_left = -200.0\noffset_top = -12.0\noffset_right = 200.0\noffset_bottom = 12.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room2_WallBottom\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_h\")\n\n[node name=\"Room2_WallRight\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(924, 800)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room2_WallRight\"]\noffset_left = -12.0\noffset_top = -200.0\noffset_right = 12.0\noffset_bottom = 200.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room2_WallRight\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_v\")\n\n[node name=\"Corridor_WallTop\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(1164, 700)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Corridor_WallTop\"]\noffset_left = -200.0\noffset_top = -12.0\noffset_right = 200.0\noffset_bottom = 12.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Corridor_WallTop\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_h\")\n\n[node name=\"Corridor_WallBottom\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(1164, 1012)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Corridor_WallBottom\"]\noffset_left = -200.0\noffset_top = -12.0\noffset_right = 200.0\noffset_bottom = 12.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Corridor_WallBottom\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_h\")\n\n[node name=\"Room3_WallLeft\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(1376, 400)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room3_WallLeft\"]\noffset_left = -12.0\noffset_top = -200.0\noffset_right = 12.0\noffset_bottom = 200.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room3_WallLeft\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_v\")\n\n[node name=\"Room3_WallBottom\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(1576, 612)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room3_WallBottom\"]\noffset_left = -200.0\noffset_top = -12.0\noffset_right = 200.0\noffset_bottom = 12.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room3_WallBottom\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_h\")\n\n[node name=\"Room4_WallLeft\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(1376, 900)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room4_WallLeft\"]\noffset_left = -12.0\noffset_top = -100.0\noffset_right = 12.0\noffset_bottom = 100.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room4_WallLeft\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_short_v\")\n\n[node name=\"Room4_WallTop\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(1576, 788)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room4_WallTop\"]\noffset_left = -200.0\noffset_top = -12.0\noffset_right = 200.0\noffset_bottom = 12.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room4_WallTop\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_h\")\n\n[node name=\"Room5_WallTop\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(1900, 1200)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room5_WallTop\"]\noffset_left = -200.0\noffset_top = -12.0\noffset_right = 200.0\noffset_bottom = 12.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room5_WallTop\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_h\")\n\n[node name=\"Room5_WallLeft\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(1688, 1500)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/Room5_WallLeft\"]\noffset_left = -12.0\noffset_top = -200.0\noffset_right = 12.0\noffset_bottom = 200.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/Room5_WallLeft\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_v\")\n\n[node name=\"LobbyDivider_Left\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(300, 1400)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/LobbyDivider_Left\"]\noffset_left = -100.0\noffset_top = -12.0\noffset_right = 100.0\noffset_bottom = 12.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/LobbyDivider_Left\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_short_h\")\n\n[node name=\"LobbyDivider_Right\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(600, 1400)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/LobbyDivider_Right\"]\noffset_left = -100.0\noffset_top = -12.0\noffset_right = 100.0\noffset_bottom = 12.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/LobbyDivider_Right\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_short_h\")\n\n[node name=\"StorageRoom_WallTop\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(300, 1600)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/StorageRoom_WallTop\"]\noffset_left = -200.0\noffset_top = -12.0\noffset_right = 200.0\noffset_bottom = 12.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/StorageRoom_WallTop\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_h\")\n\n[node name=\"StorageRoom_WallRight\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(512, 1800)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/StorageRoom_WallRight\"]\noffset_left = -12.0\noffset_top = -100.0\noffset_right = 12.0\noffset_bottom = 100.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/StorageRoom_WallRight\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_short_v\")\n\n[node name=\"MainHall_WallLeft\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(900, 1600)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/MainHall_WallLeft\"]\noffset_left = -12.0\noffset_top = -200.0\noffset_right = 12.0\noffset_bottom = 200.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/MainHall_WallLeft\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_v\")\n\n[node name=\"MainHall_WallRight\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(1500, 1600)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/MainHall_WallRight\"]\noffset_left = -12.0\noffset_top = -200.0\noffset_right = 12.0\noffset_bottom = 200.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/MainHall_WallRight\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_v\")\n\n[node name=\"MainHall_WallTop\" type=\"StaticBody2D\" parent=\"Environment/InteriorWalls\"]\nposition = Vector2(1200, 1388)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/InteriorWalls/MainHall_WallTop\"]\noffset_left = -200.0\noffset_top = -12.0\noffset_right = 200.0\noffset_bottom = 12.0\ncolor = Color(0.35, 0.3, 0.25, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/InteriorWalls/MainHall_WallTop\"]\nshape = SubResource(\"RectangleShape2D_interior_wall_h\")\n\n[node name=\"Cover\" type=\"Node2D\" parent=\"Environment\"]\n\n[node name=\"Desk1\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\nposition = Vector2(280, 250)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Desk1\"]\noffset_left = -60.0\noffset_top = -24.0\noffset_right = 60.0\noffset_bottom = 24.0\ncolor = Color(0.4, 0.3, 0.2, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Desk1\"]\nshape = SubResource(\"RectangleShape2D_cover_desk\")\n\n[node name=\"Desk2\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\nposition = Vector2(280, 450)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Desk2\"]\noffset_left = -60.0\noffset_top = -24.0\noffset_right = 60.0\noffset_bottom = 24.0\ncolor = Color(0.4, 0.3, 0.2, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Desk2\"]\nshape = SubResource(\"RectangleShape2D_cover_desk\")\n\n[node name=\"Table1\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\nposition = Vector2(720, 850)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Table1\"]\noffset_left = -40.0\noffset_top = -40.0\noffset_right = 40.0\noffset_bottom = 40.0\ncolor = Color(0.35, 0.28, 0.22, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Table1\"]\nshape = SubResource(\"RectangleShape2D_cover_table\")\n\n[node name=\"Cabinet1\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\nposition = Vector2(1000, 250)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Cabinet1\"]\noffset_left = -24.0\noffset_top = -48.0\noffset_right = 24.0\noffset_bottom = 48.0\ncolor = Color(0.3, 0.25, 0.2, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Cabinet1\"]\nshape = SubResource(\"RectangleShape2D_cover_cabinet\")\n\n[node name=\"Cabinet2\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\nposition = Vector2(1100, 250)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Cabinet2\"]\noffset_left = -24.0\noffset_top = -48.0\noffset_right = 24.0\noffset_bottom = 48.0\ncolor = Color(0.3, 0.25, 0.2, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Cabinet2\"]\nshape = SubResource(\"RectangleShape2D_cover_cabinet\")\n\n[node name=\"Desk3\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\nposition = Vector2(1600, 300)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Desk3\"]\noffset_left = -60.0\noffset_top = -24.0\noffset_right = 60.0\noffset_bottom = 24.0\ncolor = Color(0.4, 0.3, 0.2, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Desk3\"]\nshape = SubResource(\"RectangleShape2D_cover_desk\")\n\n[node name=\"Desk4\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\nposition = Vector2(1900, 300)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Desk4\"]\noffset_left = -60.0\noffset_top = -24.0\noffset_right = 60.0\noffset_bottom = 24.0\ncolor = Color(0.4, 0.3, 0.2, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Desk4\"]\nshape = SubResource(\"RectangleShape2D_cover_desk\")\n\n[node name=\"Table2\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\nposition = Vector2(1550, 950)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Table2\"]\noffset_left = -40.0\noffset_top = -40.0\noffset_right = 40.0\noffset_bottom = 40.0\ncolor = Color(0.35, 0.28, 0.22, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Table2\"]\nshape = SubResource(\"RectangleShape2D_cover_table\")\n\n[node name=\"Table3\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\nposition = Vector2(2000, 1500)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Table3\"]\noffset_left = -40.0\noffset_top = -40.0\noffset_right = 40.0\noffset_bottom = 40.0\ncolor = Color(0.35, 0.28, 0.22, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Table3\"]\nshape = SubResource(\"RectangleShape2D_cover_table\")\n\n[node name=\"Cabinet3\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\nposition = Vector2(2300, 1400)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/Cabinet3\"]\noffset_left = -24.0\noffset_top = -48.0\noffset_right = 24.0\noffset_bottom = 48.0\ncolor = Color(0.3, 0.25, 0.2, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/Cabinet3\"]\nshape = SubResource(\"RectangleShape2D_cover_cabinet\")\n\n[node name=\"StorageCrate1\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\nposition = Vector2(200, 1750)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/StorageCrate1\"]\noffset_left = -40.0\noffset_top = -40.0\noffset_right = 40.0\noffset_bottom = 40.0\ncolor = Color(0.45, 0.35, 0.2, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/StorageCrate1\"]\nshape = SubResource(\"RectangleShape2D_cover_table\")\n\n[node name=\"StorageCrate2\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\nposition = Vector2(350, 1850)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/StorageCrate2\"]\noffset_left = -40.0\noffset_top = -40.0\noffset_right = 40.0\noffset_bottom = 40.0\ncolor = Color(0.45, 0.35, 0.2, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/StorageCrate2\"]\nshape = SubResource(\"RectangleShape2D_cover_table\")\n\n[node name=\"HallTable\" type=\"StaticBody2D\" parent=\"Environment/Cover\"]\nposition = Vector2(1200, 1650)\ncollision_layer = 4\ncollision_mask = 0\n\n[node name=\"ColorRect\" type=\"ColorRect\" parent=\"Environment/Cover/HallTable\"]\noffset_left = -60.0\noffset_top = -24.0\noffset_right = 60.0\noffset_bottom = 24.0\ncolor = Color(0.4, 0.3, 0.2, 1)\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\"Environment/Cover/HallTable\"]\nshape = SubResource(\"RectangleShape2D_cover_desk\")\n\n[node name=\"Enemies\" type=\"Node2D\" parent=\"Environment\"]\n\n[node name=\"Enemy1\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\nposition = Vector2(300, 350)\nbehavior_mode = 1\ndestroy_on_death = true\nenable_flanking = true\nenable_cover = true\n\n[node name=\"Enemy2\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\nposition = Vector2(400, 550)\nbehavior_mode = 1\ndestroy_on_death = true\nenable_flanking = true\nenable_cover = true\n\n[node name=\"Enemy3\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\nposition = Vector2(700, 750)\nbehavior_mode = 1\ndestroy_on_death = true\nenable_flanking = true\nenable_cover = true\n\n[node name=\"Enemy4\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\nposition = Vector2(800, 900)\nbehavior_mode = 1\ndestroy_on_death = true\nenable_flanking = true\nenable_cover = true\n\n[node name=\"Enemy5\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\nposition = Vector2(1700, 350)\nbehavior_mode = 1\ndestroy_on_death = true\nenable_flanking = true\nenable_cover = true\n\n[node name=\"Enemy6\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\nposition = Vector2(1950, 450)\nbehavior_mode = 1\ndestroy_on_death = true\nenable_flanking = true\nenable_cover = true\n\n[node name=\"Enemy7\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\nposition = Vector2(1600, 900)\nbehavior_mode = 0\npatrol_offsets = Array[Vector2]([Vector2(100, 0), Vector2(-100, 0)])\ndestroy_on_death = true\nenable_flanking = true\nenable_cover = true\n\n[node name=\"Enemy8\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\nposition = Vector2(1900, 1450)\nbehavior_mode = 1\ndestroy_on_death = true\nenable_flanking = true\nenable_cover = true\n\n[node name=\"Enemy9\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\nposition = Vector2(2100, 1550)\nbehavior_mode = 1\ndestroy_on_death = true\nenable_flanking = true\nenable_cover = true\n\n[node name=\"Enemy10\" parent=\"Environment/Enemies\" instance=ExtResource(\"4_enemy\")]\nposition = Vector2(1200, 1550)\nbehavior_mode = 0\npatrol_offsets = Array[Vector2]([Vector2(0, 150), Vector2(0, -150)])\ndestroy_on_death = true\nenable_flanking = true\nenable_cover = true\n\n[node name=\"RoomLabels\" type=\"Node2D\" parent=\"Environment\"]\n\n[node name=\"Room1Label\" type=\"ColorRect\" parent=\"Environment/RoomLabels\"]\noffset_left = 80.0\noffset_top = 80.0\noffset_right = 500.0\noffset_bottom = 688.0\ncolor = Color(0.15, 0.12, 0.1, 0.3)\n\n[node name=\"Label\" type=\"Label\" parent=\"Environment/RoomLabels/Room1Label\"]\noffset_left = 10.0\noffset_top = 10.0\noffset_right = 100.0\noffset_bottom = 30.0\ntext = \"OFFICE 1\"\n\n[node name=\"Room2Label\" type=\"ColorRect\" parent=\"Environment/RoomLabels\"]\noffset_left = 524.0\noffset_top = 712.0\noffset_right = 912.0\noffset_bottom = 1000.0\ncolor = Color(0.15, 0.12, 0.1, 0.3)\n\n[node name=\"Label\" type=\"Label\" parent=\"Environment/RoomLabels/Room2Label\"]\noffset_left = 10.0\noffset_top = 10.0\noffset_right = 100.0\noffset_bottom = 30.0\ntext = \"OFFICE 2\"\n\n[node name=\"Room3Label\" type=\"ColorRect\" parent=\"Environment/RoomLabels\"]\noffset_left = 1388.0\noffset_top = 80.0\noffset_right = 2448.0\noffset_bottom = 600.0\ncolor = Color(0.12, 0.15, 0.1, 0.3)\n\n[node name=\"Label\" type=\"Label\" parent=\"Environment/RoomLabels/Room3Label\"]\noffset_left = 10.0\noffset_top = 10.0\noffset_right = 180.0\noffset_bottom = 30.0\ntext = \"CONFERENCE ROOM\"\n\n[node name=\"Room4Label\" type=\"ColorRect\" parent=\"Environment/RoomLabels\"]\noffset_left = 1388.0\noffset_top = 800.0\noffset_right = 2448.0\noffset_bottom = 1188.0\ncolor = Color(0.15, 0.1, 0.12, 0.3)\n\n[node name=\"Label\" type=\"Label\" parent=\"Environment/RoomLabels/Room4Label\"]\noffset_left = 10.0\noffset_top = 10.0\noffset_right = 150.0\noffset_bottom = 30.0\ntext = \"BREAK ROOM\"\n\n[node name=\"Room5Label\" type=\"ColorRect\" parent=\"Environment/RoomLabels\"]\noffset_left = 1700.0\noffset_top = 1212.0\noffset_right = 2448.0\noffset_bottom = 2048.0\ncolor = Color(0.12, 0.1, 0.15, 0.3)\n\n[node name=\"Label\" type=\"Label\" parent=\"Environment/RoomLabels/Room5Label\"]\noffset_left = 10.0\noffset_top = 10.0\noffset_right = 150.0\noffset_bottom = 30.0\ntext = \"SERVER ROOM\"\n\n[node name=\"StorageLabel\" type=\"ColorRect\" parent=\"Environment/RoomLabels\"]\noffset_left = 80.0\noffset_top = 1612.0\noffset_right = 500.0\noffset_bottom = 2048.0\ncolor = Color(0.1, 0.12, 0.15, 0.3)\n\n[node name=\"Label\" type=\"Label\" parent=\"Environment/RoomLabels/StorageLabel\"]\noffset_left = 10.0\noffset_top = 10.0\noffset_right = 100.0\noffset_bottom = 30.0\ntext = \"STORAGE\"\n\n[node name=\"MainHallLabel\" type=\"ColorRect\" parent=\"Environment/RoomLabels\"]\noffset_left = 912.0\noffset_top = 1400.0\noffset_right = 1488.0\noffset_bottom = 2048.0\ncolor = Color(0.15, 0.15, 0.1, 0.3)\n\n[node name=\"Label\" type=\"Label\" parent=\"Environment/RoomLabels/MainHallLabel\"]\noffset_left = 10.0\noffset_top = 10.0\noffset_right = 100.0\noffset_bottom = 30.0\ntext = \"MAIN HALL\"\n\n[node name=\"Entities\" type=\"Node2D\" parent=\".\"]\n\n[node name=\"Player\" parent=\"Entities\" instance=ExtResource(\"2_player\")]\nposition = Vector2(450, 1250)\n\n[node name=\"CanvasLayer\" type=\"CanvasLayer\" parent=\".\"]\n\n[node name=\"UI\" type=\"Control\" parent=\"CanvasLayer\"]\nlayout_mode = 3\nanchors_preset = 15\nanchor_right = 1.0\nanchor_bottom = 1.0\ngrow_horizontal = 2\ngrow_vertical = 2\n\n[node name=\"LevelLabel\" type=\"Label\" parent=\"CanvasLayer/UI\"]\nlayout_mode = 1\nanchors_preset = 1\nanchor_left = 1.0\nanchor_right = 1.0\noffset_left = -250.0\noffset_top = 10.0\noffset_right = -10.0\noffset_bottom = 40.0\ngrow_horizontal = 0\ntext = \"BUILDING INTERIOR\"\nhorizontal_alignment = 2\n\n[node name=\"InstructionsLabel\" type=\"Label\" parent=\"CanvasLayer/UI\"]\nlayout_mode = 1\nanchors_preset = 0\noffset_left = 10.0\noffset_top = 650.0\noffset_right = 600.0\noffset_bottom = 710.0\ntext = \"WASD - Move | LMB - Shoot (hold) | R - Reload | B - Toggle Fire Mode | ESC - Pause\nClear all rooms to win!\"\n\n[node name=\"EnemyCountLabel\" type=\"Label\" parent=\"CanvasLayer/UI\"]\nlayout_mode = 1\nanchors_preset = 1\nanchor_left = 1.0\nanchor_right = 1.0\noffset_left = -200.0\noffset_top = 45.0\noffset_right = -10.0\noffset_bottom = 75.0\ngrow_horizontal = 0\ntext = \"Enemies: 10\"\nhorizontal_alignment = 2\n\n[node name=\"AmmoLabel\" type=\"Label\" parent=\"CanvasLayer/UI\"]\nlayout_mode = 1\nanchors_preset = 0\noffset_left = 10.0\noffset_top = 10.0\noffset_right = 200.0\noffset_bottom = 45.0\ntext = \"AMMO: 30/30\"\n\n[node name=\"PauseMenu\" parent=\".\" instance=ExtResource(\"3_pause_menu\")]\n","numLines":848,"startLine":1,"totalLines":848}}}
[2026-01-18T02:50:58.664Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01UNqPdLH1J2PmPYc8xwfL4g",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now I have a comprehensive understanding of the system. Let me create the case study document with my analysis and then implement the solution."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 750,
      "cache_creation_input_tokens": 13209,
      "cache_read_input_tokens": 77629,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 13209,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 5,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "a03b9535-e617-4cd6-a9f8-37ca3b5ac9a2"
}
[2026-01-18T02:51:03.828Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01UNqPdLH1J2PmPYc8xwfL4g",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_017eQq3MhUEWuXbiKeUJ8G5j",
        "name": "TodoWrite",
        "input": {
          "todos": [
            {
              "content": "Read and analyze issue #103 requirements",
              "status": "completed",
              "activeForm": "Reading issue requirements"
            },
            {
              "content": "Explore existing AI/GOAP system architecture",
              "status": "completed",
              "activeForm": "Exploring AI/GOAP system architecture"
            },
            {
              "content": "Create case study directory structure",
              "status": "completed",
              "activeForm": "Creating case study directory structure"
            },
            {
              "content": "Research GOAP and AI search patterns online",
              "status": "completed",
              "activeForm": "Researching GOAP and AI search patterns"
            },
            {
              "content": "Document timeline and sequence of events",
              "status": "in_progress",
              "activeForm": "Documenting timeline and events"
            },
            {
              "content": "Identify root causes and propose solutions",
              "status": "pending",
              "activeForm": "Identifying root causes and solutions"
            },
            {
              "content": "Implement enemy search behavior with last-known-position",
              "status": "pending",
              "activeForm": "Implementing enemy search behavior"
            },
            {
              "content": "Add inspection points system for corners and hiding spots",
              "status": "pending",
              "activeForm": "Adding inspection points system"
            },
            {
              "content": "Test and verify implementation",
              "status": "pending",
              "activeForm": "Testing implementation"
            },
            {
              "content": "Update PR description and finalize",
              "status": "pending",
              "activeForm": "Updating PR and finalizing"
            }
          ]
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 750,
      "cache_creation_input_tokens": 13209,
      "cache_read_input_tokens": 77629,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 13209,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 5,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "02f2c57f-9576-4b28-8a3f-60decd41d682"
}
[2026-01-18T02:51:43.165Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01UNqPdLH1J2PmPYc8xwfL4g",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01Qyaj4Zkw2yVYp7Gas3Tzk6",
        "name": "Write",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-103/README.md",
          "content": "# Case Study: Issue #103 - Improve Enemy Movement System\n\n## Issue Summary\n\n**Original Request (Russian):**\n> –ü–æ—Å–ª–µ –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è –∏–≥—Ä–æ–∫–∞ –∏–∑ –ø–æ–ª—è –∑—Ä–µ–Ω–∏—è –≤—Ä–∞–≥–∞ –æ–Ω –¥–æ–ª–∂–µ–Ω —Å—á–∏—Ç–∞—Ç—å –Ω–µ–±–æ–ª—å—à—É—é –Ω–µ–≤–∏–¥–∏–º—É—é –∑–æ–Ω—É, –≤ –∫–æ—Ç–æ—Ä–æ–π —Å–∫—Ä—ã–ª—Å—è –∏–≥—Ä–æ–∫ - –∑–æ–Ω–æ–π –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞. –≤—Ä–∞–≥ –¥–æ–ª–∂–µ–Ω —Å—Ç—Ä–æ–∏—Ç—å –ø–æ–ª–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç –¥–æ —ç—Ç–æ–π –∑–æ–Ω—ã –∏ –∑–∞—Ç–µ–º –æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å –µ—ë.\n> –∑–∞ –≤—Å–µ–º–∏ —É–∫—Ä—ã—Ç–∏—è–º–∏ –∏ –≤ —É–≥–ª–∞—Ö –∫–æ–º–Ω–∞—Ç –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–≤–∏–¥–∏–º—ã–µ —Ç–æ—á–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤—Ä–∞–≥ –¥–æ–ª–∂–µ–Ω –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–µ–∂–¥–µ, —á–µ–º –¥–≤–∏–≥–∞—Ç—å—Å—è –¥–∞–ª—å—à–µ, –µ—Å–ª–∏ —ç—Ç–∏ —Ç–æ—á–∫–∏ –≤ –∑–æ–Ω–µ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞. –∫–æ–≥–¥–∞ –≤—Å–µ —Ç–æ—á–∫–∏ —É –∑–æ–Ω–µ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞ –ø—Ä–æ–≤–µ—Ä–µ–Ω—ã - –∑–æ–Ω–∞ —Å—á–∏—Ç–∞–µ—Ç—Å—è –∑–æ–Ω–æ–π –±–µ–∑ –∏–≥—Ä–æ–∫–∞.\n> –ø—Ä–∏ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–∏ —Å –∏–≥—Ä–æ–∫–æ–º –∑–æ–Ω—ã –æ–±–Ω—É–ª—è—é—Ç—Å—è.\n\n**Translation:**\n> After the player disappears from the enemy's field of view, the enemy should consider a small invisible zone where the player hid as a \"potential player zone\". The enemy should build a full route to this zone and then inspect it.\n> Behind all covers and in room corners there should be invisible inspection points that the enemy must check before moving further, if these points are in the potential player zone. When all points in the potential player zone are checked - the zone is considered a \"no player zone\".\n> Upon encountering the player, the zones reset.\n\n## Timeline of Events\n\n### Current Codebase State (Pre-Issue)\n\nThe existing AI system in `scripts/objects/enemy.gd` has several states:\n- `IDLE` - Patrol or guard behavior\n- `COMBAT` - Actively engaging player\n- `SEEKING_COVER` - Moving to cover position\n- `IN_COVER` - Taking cover from player fire\n- `FLANKING` - Attempting to flank the player\n- `SUPPRESSED` - Under fire, staying in cover\n- `RETREATING` - Retreating to cover while possibly shooting\n- `PURSUING` - Moving cover-to-cover toward player\n- `ASSAULT` - Coordinated multi-enemy rush\n\n### Problem Identification\n\nWhen the player escapes from the enemy's line of sight:\n\n1. **Current Behavior (Line 803-809 in enemy.gd):**\n   ```gdscript\n   # If can't see player, pursue them (move cover-to-cover toward player)\n   if not _can_see_player:\n       _log_debug(\"Lost sight of player in COMBAT, transitioning to PURSUING\")\n       _transition_to_pursuing()\n   ```\n\n2. **PURSUING State Behavior:**\n   - Moves cover-to-cover toward player's **current position**\n   - Does NOT remember where the player was last seen\n   - Does NOT search the area methodically\n   - Simply tries to find a path to the player\n\n3. **Missing Features:**\n   - No \"last known position\" memory\n   - No \"potential player zone\" concept\n   - No inspection point system\n   - No methodical search pattern\n\n## Root Cause Analysis\n\n### Architecture Gap\n\nThe GOAP system (`scripts/ai/goap_planner.gd` and `scripts/ai/goap_action.gd`) provides the planning framework, but the `enemy_actions.gd` lacks:\n\n1. **SearchZoneAction** - Action to investigate a last-known-position area\n2. **InspectPointAction** - Action to check specific hiding spots\n3. **World State Variables** for tracking:\n   - `last_known_player_position`\n   - `search_zone_active`\n   - `inspection_points_remaining`\n\n### Behavioral Gap\n\nThe state machine transitions directly from `COMBAT` ‚Üí `PURSUING` when line of sight is lost, without:\n1. Recording where the player was last seen\n2. Defining a search zone around that position\n3. Identifying nearby hiding spots to check\n\n## Proposed Solution\n\n### 1. Add New AI State: SEARCHING\n\nA new state between PURSUING and IDLE that implements:\n- Move to last known player position\n- Define a circular \"potential player zone\" around it\n- Identify inspection points (corners, behind covers) within the zone\n- Visit and \"inspect\" each point (brief pause + looking around)\n- Mark zone as cleared when all points checked\n\n### 2. Add Inspection Point System\n\nCreate invisible \"InspectionPoint\" markers that can be:\n- Automatically generated from level geometry (wall corners)\n- Manually placed by level designers (behind covers)\n- Detected via raycast from wall collision points\n\n### 3. Extend GOAP Actions\n\nAdd new actions to `enemy_actions.gd`:\n- `SearchAreaAction` - Move to and investigate last-known-position\n- `InspectHidingSpotAction` - Check a specific inspection point\n- `ClearSearchZoneAction` - Mark zone as cleared\n\n### 4. State Flow\n\n```\nPlayer Visible ‚Üí COMBAT ‚Üí Player Escapes ‚Üí SEARCHING (new) ‚Üí Zone Cleared ‚Üí IDLE/PATROL\n                                            ‚Üì\n                                      Player Found ‚Üí COMBAT\n```\n\n## Implementation Details\n\n### New Variables for Enemy\n\n```gdscript\n## Last known position where player was seen\nvar _last_known_player_position: Vector2 = Vector2.ZERO\n\n## Whether a search zone is active\nvar _search_zone_active: bool = false\n\n## Radius of the potential player zone\nvar _search_zone_radius: float = 200.0\n\n## Inspection points within the search zone\nvar _inspection_points: Array[Vector2] = []\n\n## Index of current inspection point being checked\nvar _current_inspection_index: int = 0\n```\n\n### New GOAP World State\n\n```gdscript\n\"has_search_zone\": false,\n\"search_zone_cleared\": false,\n\"inspection_points_remaining\": 0\n```\n\n## Research References\n\n### Industry Best Practices\n\n1. **F.E.A.R. (2005)** - Pioneered GOAP for enemy AI\n   - Uses ~70 goals and ~120 actions\n   - Maintains \"last known position\" for search behavior\n   - Source: [Building the AI of F.E.A.R. with Goal Oriented Action Planning](https://www.gamedeveloper.com/design/building-the-ai-of-f-e-a-r-with-goal-oriented-action-planning)\n\n2. **Splinter Cell: Blacklist** - Dynamic search patterns\n   - Guards don't drop alert after searching\n   - Modified patrol routes after alerts\n   - Source: [What's the right AI for a stealth game?](https://www.neogaf.com/threads/whats-the-right-ai-for-a-stealth-game.1011199/)\n\n3. **Third Eye Crime** - Occupancy maps\n   - Uses probability-based knowledge representation\n   - More realistic pursuit and search behavior\n   - Source: [Dynamic Guard Patrol in Stealth Games](https://ojs.aaai.org/index.php/AIIDE/article/download/7425/7308/10903)\n\n### Common Patterns\n\n1. **Last Known Position (LKP)**\n   - Store position where player was last seen\n   - Move to LKP before searching\n   - Define search area around LKP\n\n2. **Investigation Points**\n   - Pre-defined or dynamically generated\n   - Located at corners, behind objects\n   - Priority-ordered by proximity to LKP\n\n3. **Alert Decay**\n   - Gradual return to patrol after search\n   - Modified patrol patterns post-alert\n   - Memory of previous encounters\n\n## Files to Modify\n\n1. `scripts/objects/enemy.gd` - Add SEARCHING state and related logic\n2. `scripts/ai/enemy_actions.gd` - Add new GOAP actions\n3. `scripts/ai/goap_action.gd` - No changes needed (base class sufficient)\n4. `scripts/ai/goap_planner.gd` - No changes needed (planner sufficient)\n5. Level scenes - Optionally add InspectionPoint nodes\n\n## Testing Strategy\n\n1. **Unit Tests**\n   - Test inspection point generation from geometry\n   - Test search zone activation/deactivation\n   - Test transition from COMBAT ‚Üí SEARCHING\n\n2. **Integration Tests**\n   - Verify enemy moves to last known position\n   - Verify inspection points are checked\n   - Verify zone is cleared after full search\n\n3. **Manual Testing**\n   - Break line of sight with enemy\n   - Observe enemy search behavior\n   - Verify zone is cleared or player found\n\n## Success Criteria\n\n1. Enemy remembers where player was last seen\n2. Enemy moves to that location after losing sight\n3. Enemy checks nearby hiding spots methodically\n4. Enemy returns to patrol/guard after zone is cleared\n5. All existing functionality preserved (shooting, cover, etc.)\n"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 750,
      "cache_creation_input_tokens": 13209,
      "cache_read_input_tokens": 77629,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 13209,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 5,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "afc1b9aa-270c-4d5b-b5e3-9d07e431a68e"
}
[2026-01-18T02:51:43.199Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_017eQq3MhUEWuXbiKeUJ8G5j",
        "type": "tool_result",
        "content": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "d181630e-50df-423c-b6f6-986ebc533eb6",
  "tool_use_result": {
    "oldTodos": [
      {
        "content": "Read and analyze issue #103 requirements",
        "status": "completed",
        "activeForm": "Reading issue requirements"
      },
      {
        "content": "Explore existing AI/GOAP system architecture",
        "status": "completed",
        "activeForm": "Exploring AI/GOAP system architecture"
      },
      {
        "content": "Create case study directory structure",
        "status": "in_progress",
        "activeForm": "Creating case study directory structure"
      },
      {
        "content": "Research GOAP and AI search patterns online",
        "status": "pending",
        "activeForm": "Researching GOAP and AI search patterns"
      },
      {
        "content": "Document timeline and sequence of events",
        "status": "pending",
        "activeForm": "Documenting timeline and events"
      },
      {
        "content": "Identify root causes and propose solutions",
        "status": "pending",
        "activeForm": "Identifying root causes and solutions"
      },
      {
        "content": "Implement enemy search behavior with last-known-position",
        "status": "pending",
        "activeForm": "Implementing enemy search behavior"
      },
      {
        "content": "Add inspection points system for corners and hiding spots",
        "status": "pending",
        "activeForm": "Adding inspection points system"
      },
      {
        "content": "Test and verify implementation",
        "status": "pending",
        "activeForm": "Testing implementation"
      },
      {
        "content": "Update PR description and finalize",
        "status": "pending",
        "activeForm": "Updating PR and finalizing"
      }
    ],
    "newTodos": [
      {
        "content": "Read and analyze issue #103 requirements",
        "status": "completed",
        "activeForm": "Reading issue requirements"
      },
      {
        "content": "Explore existing AI/GOAP system architecture",
        "status": "completed",
        "activeForm": "Exploring AI/GOAP system architecture"
      },
      {
        "content": "Create case study directory structure",
        "status": "completed",
        "activeForm": "Creating case study directory structure"
      },
      {
        "content": "Research GOAP and AI search patterns online",
        "status": "completed",
        "activeForm": "Researching GOAP and AI search patterns"
      },
      {
        "content": "Document timeline and sequence of events",
        "status": "in_progress",
        "activeForm": "Documenting timeline and events"
      },
      {
        "content": "Identify root causes and propose solutions",
        "status": "pending",
        "activeForm": "Identifying root causes and solutions"
      },
      {
        "content": "Implement enemy search behavior with last-known-position",
        "status": "pending",
        "activeForm": "Implementing enemy search behavior"
      },
      {
        "content": "Add inspection points system for corners and hiding spots",
        "status": "pending",
        "activeForm": "Adding inspection points system"
      },
      {
        "content": "Test and verify implementation",
        "status": "pending",
        "activeForm": "Testing implementation"
      },
      {
        "content": "Update PR description and finalize",
        "status": "pending",
        "activeForm": "Updating PR and finalizing"
      }
    ]
  }
}
[2026-01-18T02:51:43.248Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01Qyaj4Zkw2yVYp7Gas3Tzk6",
        "type": "tool_result",
        "content": "File created successfully at: /tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-103/README.md"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "6a862f5a-d71f-4178-a8fe-7346c509244c",
  "tool_use_result": {
    "type": "create",
    "filePath": "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-103/README.md",
    "content": "# Case Study: Issue #103 - Improve Enemy Movement System\n\n## Issue Summary\n\n**Original Request (Russian):**\n> –ü–æ—Å–ª–µ –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è –∏–≥—Ä–æ–∫–∞ –∏–∑ –ø–æ–ª—è –∑—Ä–µ–Ω–∏—è –≤—Ä–∞–≥–∞ –æ–Ω –¥–æ–ª–∂–µ–Ω —Å—á–∏—Ç–∞—Ç—å –Ω–µ–±–æ–ª—å—à—É—é –Ω–µ–≤–∏–¥–∏–º—É—é –∑–æ–Ω—É, –≤ –∫–æ—Ç–æ—Ä–æ–π —Å–∫—Ä—ã–ª—Å—è –∏–≥—Ä–æ–∫ - –∑–æ–Ω–æ–π –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞. –≤—Ä–∞–≥ –¥–æ–ª–∂–µ–Ω —Å—Ç—Ä–æ–∏—Ç—å –ø–æ–ª–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç –¥–æ —ç—Ç–æ–π –∑–æ–Ω—ã –∏ –∑–∞—Ç–µ–º –æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å –µ—ë.\n> –∑–∞ –≤—Å–µ–º–∏ —É–∫—Ä—ã—Ç–∏—è–º–∏ –∏ –≤ —É–≥–ª–∞—Ö –∫–æ–º–Ω–∞—Ç –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–≤–∏–¥–∏–º—ã–µ —Ç–æ—á–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤—Ä–∞–≥ –¥–æ–ª–∂–µ–Ω –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–µ–∂–¥–µ, —á–µ–º –¥–≤–∏–≥–∞—Ç—å—Å—è –¥–∞–ª—å—à–µ, –µ—Å–ª–∏ —ç—Ç–∏ —Ç–æ—á–∫–∏ –≤ –∑–æ–Ω–µ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞. –∫–æ–≥–¥–∞ –≤—Å–µ —Ç–æ—á–∫–∏ —É –∑–æ–Ω–µ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞ –ø—Ä–æ–≤–µ—Ä–µ–Ω—ã - –∑–æ–Ω–∞ —Å—á–∏—Ç–∞–µ—Ç—Å—è –∑–æ–Ω–æ–π –±–µ–∑ –∏–≥—Ä–æ–∫–∞.\n> –ø—Ä–∏ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–∏ —Å –∏–≥—Ä–æ–∫–æ–º –∑–æ–Ω—ã –æ–±–Ω—É–ª—è—é—Ç—Å—è.\n\n**Translation:**\n> After the player disappears from the enemy's field of view, the enemy should consider a small invisible zone where the player hid as a \"potential player zone\". The enemy should build a full route to this zone and then inspect it.\n> Behind all covers and in room corners there should be invisible inspection points that the enemy must check before moving further, if these points are in the potential player zone. When all points in the potential player zone are checked - the zone is considered a \"no player zone\".\n> Upon encountering the player, the zones reset.\n\n## Timeline of Events\n\n### Current Codebase State (Pre-Issue)\n\nThe existing AI system in `scripts/objects/enemy.gd` has several states:\n- `IDLE` - Patrol or guard behavior\n- `COMBAT` - Actively engaging player\n- `SEEKING_COVER` - Moving to cover position\n- `IN_COVER` - Taking cover from player fire\n- `FLANKING` - Attempting to flank the player\n- `SUPPRESSED` - Under fire, staying in cover\n- `RETREATING` - Retreating to cover while possibly shooting\n- `PURSUING` - Moving cover-to-cover toward player\n- `ASSAULT` - Coordinated multi-enemy rush\n\n### Problem Identification\n\nWhen the player escapes from the enemy's line of sight:\n\n1. **Current Behavior (Line 803-809 in enemy.gd):**\n   ```gdscript\n   # If can't see player, pursue them (move cover-to-cover toward player)\n   if not _can_see_player:\n       _log_debug(\"Lost sight of player in COMBAT, transitioning to PURSUING\")\n       _transition_to_pursuing()\n   ```\n\n2. **PURSUING State Behavior:**\n   - Moves cover-to-cover toward player's **current position**\n   - Does NOT remember where the player was last seen\n   - Does NOT search the area methodically\n   - Simply tries to find a path to the player\n\n3. **Missing Features:**\n   - No \"last known position\" memory\n   - No \"potential player zone\" concept\n   - No inspection point system\n   - No methodical search pattern\n\n## Root Cause Analysis\n\n### Architecture Gap\n\nThe GOAP system (`scripts/ai/goap_planner.gd` and `scripts/ai/goap_action.gd`) provides the planning framework, but the `enemy_actions.gd` lacks:\n\n1. **SearchZoneAction** - Action to investigate a last-known-position area\n2. **InspectPointAction** - Action to check specific hiding spots\n3. **World State Variables** for tracking:\n   - `last_known_player_position`\n   - `search_zone_active`\n   - `inspection_points_remaining`\n\n### Behavioral Gap\n\nThe state machine transitions directly from `COMBAT` ‚Üí `PURSUING` when line of sight is lost, without:\n1. Recording where the player was last seen\n2. Defining a search zone around that position\n3. Identifying nearby hiding spots to check\n\n## Proposed Solution\n\n### 1. Add New AI State: SEARCHING\n\nA new state between PURSUING and IDLE that implements:\n- Move to last known player position\n- Define a circular \"potential player zone\" around it\n- Identify inspection points (corners, behind covers) within the zone\n- Visit and \"inspect\" each point (brief pause + looking around)\n- Mark zone as cleared when all points checked\n\n### 2. Add Inspection Point System\n\nCreate invisible \"InspectionPoint\" markers that can be:\n- Automatically generated from level geometry (wall corners)\n- Manually placed by level designers (behind covers)\n- Detected via raycast from wall collision points\n\n### 3. Extend GOAP Actions\n\nAdd new actions to `enemy_actions.gd`:\n- `SearchAreaAction` - Move to and investigate last-known-position\n- `InspectHidingSpotAction` - Check a specific inspection point\n- `ClearSearchZoneAction` - Mark zone as cleared\n\n### 4. State Flow\n\n```\nPlayer Visible ‚Üí COMBAT ‚Üí Player Escapes ‚Üí SEARCHING (new) ‚Üí Zone Cleared ‚Üí IDLE/PATROL\n                                            ‚Üì\n                                      Player Found ‚Üí COMBAT\n```\n\n## Implementation Details\n\n### New Variables for Enemy\n\n```gdscript\n## Last known position where player was seen\nvar _last_known_player_position: Vector2 = Vector2.ZERO\n\n## Whether a search zone is active\nvar _search_zone_active: bool = false\n\n## Radius of the potential player zone\nvar _search_zone_radius: float = 200.0\n\n## Inspection points within the search zone\nvar _inspection_points: Array[Vector2] = []\n\n## Index of current inspection point being checked\nvar _current_inspection_index: int = 0\n```\n\n### New GOAP World State\n\n```gdscript\n\"has_search_zone\": false,\n\"search_zone_cleared\": false,\n\"inspection_points_remaining\": 0\n```\n\n## Research References\n\n### Industry Best Practices\n\n1. **F.E.A.R. (2005)** - Pioneered GOAP for enemy AI\n   - Uses ~70 goals and ~120 actions\n   - Maintains \"last known position\" for search behavior\n   - Source: [Building the AI of F.E.A.R. with Goal Oriented Action Planning](https://www.gamedeveloper.com/design/building-the-ai-of-f-e-a-r-with-goal-oriented-action-planning)\n\n2. **Splinter Cell: Blacklist** - Dynamic search patterns\n   - Guards don't drop alert after searching\n   - Modified patrol routes after alerts\n   - Source: [What's the right AI for a stealth game?](https://www.neogaf.com/threads/whats-the-right-ai-for-a-stealth-game.1011199/)\n\n3. **Third Eye Crime** - Occupancy maps\n   - Uses probability-based knowledge representation\n   - More realistic pursuit and search behavior\n   - Source: [Dynamic Guard Patrol in Stealth Games](https://ojs.aaai.org/index.php/AIIDE/article/download/7425/7308/10903)\n\n### Common Patterns\n\n1. **Last Known Position (LKP)**\n   - Store position where player was last seen\n   - Move to LKP before searching\n   - Define search area around LKP\n\n2. **Investigation Points**\n   - Pre-defined or dynamically generated\n   - Located at corners, behind objects\n   - Priority-ordered by proximity to LKP\n\n3. **Alert Decay**\n   - Gradual return to patrol after search\n   - Modified patrol patterns post-alert\n   - Memory of previous encounters\n\n## Files to Modify\n\n1. `scripts/objects/enemy.gd` - Add SEARCHING state and related logic\n2. `scripts/ai/enemy_actions.gd` - Add new GOAP actions\n3. `scripts/ai/goap_action.gd` - No changes needed (base class sufficient)\n4. `scripts/ai/goap_planner.gd` - No changes needed (planner sufficient)\n5. Level scenes - Optionally add InspectionPoint nodes\n\n## Testing Strategy\n\n1. **Unit Tests**\n   - Test inspection point generation from geometry\n   - Test search zone activation/deactivation\n   - Test transition from COMBAT ‚Üí SEARCHING\n\n2. **Integration Tests**\n   - Verify enemy moves to last known position\n   - Verify inspection points are checked\n   - Verify zone is cleared after full search\n\n3. **Manual Testing**\n   - Break line of sight with enemy\n   - Observe enemy search behavior\n   - Verify zone is cleared or player found\n\n## Success Criteria\n\n1. Enemy remembers where player was last seen\n2. Enemy moves to that location after losing sight\n3. Enemy checks nearby hiding spots methodically\n4. Enemy returns to patrol/guard after zone is cleared\n5. All existing functionality preserved (shooting, cover, etc.)\n",
    "structuredPatch": [],
    "originalFile": null
  }
}
[2026-01-18T02:51:47.921Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01VuWMc5BY3vS9SMzL4qrrMs",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01YYMYZvETfb9DUxuNx8ThKh",
        "name": "TodoWrite",
        "input": {
          "todos": [
            {
              "content": "Read and analyze issue #103 requirements",
              "status": "completed",
              "activeForm": "Reading issue requirements"
            },
            {
              "content": "Explore existing AI/GOAP system architecture",
              "status": "completed",
              "activeForm": "Exploring AI/GOAP system architecture"
            },
            {
              "content": "Create case study directory structure",
              "status": "completed",
              "activeForm": "Creating case study directory structure"
            },
            {
              "content": "Research GOAP and AI search patterns online",
              "status": "completed",
              "activeForm": "Researching GOAP and AI search patterns"
            },
            {
              "content": "Document timeline and sequence of events",
              "status": "completed",
              "activeForm": "Documenting timeline and events"
            },
            {
              "content": "Identify root causes and propose solutions",
              "status": "completed",
              "activeForm": "Identifying root causes and solutions"
            },
            {
              "content": "Implement enemy search behavior with last-known-position",
              "status": "in_progress",
              "activeForm": "Implementing enemy search behavior"
            },
            {
              "content": "Add inspection points system for corners and hiding spots",
              "status": "pending",
              "activeForm": "Adding inspection points system"
            },
            {
              "content": "Test and verify implementation",
              "status": "pending",
              "activeForm": "Testing implementation"
            },
            {
              "content": "Update PR description and finalize",
              "status": "pending",
              "activeForm": "Updating PR and finalizing"
            }
          ]
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 3443,
      "cache_read_input_tokens": 90838,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 3443,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 24,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "24cd5582-068f-46bd-a4f9-2c8c650035aa"
}
[2026-01-18T02:51:47.953Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01YYMYZvETfb9DUxuNx8ThKh",
        "type": "tool_result",
        "content": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "68c6577c-1b2b-46f9-9795-0494b7c66774",
  "tool_use_result": {
    "oldTodos": [
      {
        "content": "Read and analyze issue #103 requirements",
        "status": "completed",
        "activeForm": "Reading issue requirements"
      },
      {
        "content": "Explore existing AI/GOAP system architecture",
        "status": "completed",
        "activeForm": "Exploring AI/GOAP system architecture"
      },
      {
        "content": "Create case study directory structure",
        "status": "completed",
        "activeForm": "Creating case study directory structure"
      },
      {
        "content": "Research GOAP and AI search patterns online",
        "status": "completed",
        "activeForm": "Researching GOAP and AI search patterns"
      },
      {
        "content": "Document timeline and sequence of events",
        "status": "in_progress",
        "activeForm": "Documenting timeline and events"
      },
      {
        "content": "Identify root causes and propose solutions",
        "status": "pending",
        "activeForm": "Identifying root causes and solutions"
      },
      {
        "content": "Implement enemy search behavior with last-known-position",
        "status": "pending",
        "activeForm": "Implementing enemy search behavior"
      },
      {
        "content": "Add inspection points system for corners and hiding spots",
        "status": "pending",
        "activeForm": "Adding inspection points system"
      },
      {
        "content": "Test and verify implementation",
        "status": "pending",
        "activeForm": "Testing implementation"
      },
      {
        "content": "Update PR description and finalize",
        "status": "pending",
        "activeForm": "Updating PR and finalizing"
      }
    ],
    "newTodos": [
      {
        "content": "Read and analyze issue #103 requirements",
        "status": "completed",
        "activeForm": "Reading issue requirements"
      },
      {
        "content": "Explore existing AI/GOAP system architecture",
        "status": "completed",
        "activeForm": "Exploring AI/GOAP system architecture"
      },
      {
        "content": "Create case study directory structure",
        "status": "completed",
        "activeForm": "Creating case study directory structure"
      },
      {
        "content": "Research GOAP and AI search patterns online",
        "status": "completed",
        "activeForm": "Researching GOAP and AI search patterns"
      },
      {
        "content": "Document timeline and sequence of events",
        "status": "completed",
        "activeForm": "Documenting timeline and events"
      },
      {
        "content": "Identify root causes and propose solutions",
        "status": "completed",
        "activeForm": "Identifying root causes and solutions"
      },
      {
        "content": "Implement enemy search behavior with last-known-position",
        "status": "in_progress",
        "activeForm": "Implementing enemy search behavior"
      },
      {
        "content": "Add inspection points system for corners and hiding spots",
        "status": "pending",
        "activeForm": "Adding inspection points system"
      },
      {
        "content": "Test and verify implementation",
        "status": "pending",
        "activeForm": "Testing implementation"
      },
      {
        "content": "Update PR description and finalize",
        "status": "pending",
        "activeForm": "Updating PR and finalizing"
      }
    ]
  }
}
[2026-01-18T02:51:50.998Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01HUXiLKqHp1Roy28AT62Hgr",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me implement the solution. I'll start by reading more of the enemy.gd to understand the full structure, and then add the new SEARCHING state and related functionality."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 407,
      "cache_read_input_tokens": 94281,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 407,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "b35da0fe-a897-4c80-a754-fb37c33b45f0"
}
[2026-01-18T02:51:51.737Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01HUXiLKqHp1Roy28AT62Hgr",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01CRCHW44ovZhdkKx8HPAUPJ",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "offset": 2300,
          "limit": 500
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 407,
      "cache_read_input_tokens": 94281,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 407,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "1be49f72-f6db-4fbd-b535-0c426540b13d"
}
[2026-01-18T02:51:51.787Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01CRCHW44ovZhdkKx8HPAUPJ",
        "type": "tool_result",
        "content": "  2300‚Üí\n  2301‚Üí\t\t\t# Score calculation:\n  2302‚Üí\t\t\t# Higher score for positions that are:\n  2303‚Üí\t\t\t# - Hidden from player (priority)\n  2304‚Üí\t\t\t# - Closer to player\n  2305‚Üí\t\t\t# - Not too far from current position\n  2306‚Üí\t\t\tvar hidden_score: float = 5.0 if is_hidden else 0.0\n  2307‚Üí\t\t\tvar approach_score: float = (my_distance_to_player - cover_distance_to_player) / CLOSE_COMBAT_DISTANCE\n  2308‚Üí\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n  2309‚Üí\n  2310‚Üí\t\t\tvar total_score: float = hidden_score + approach_score * 2.0 - distance_penalty\n  2311‚Üí\n  2312‚Üí\t\t\tif total_score > best_score:\n  2313‚Üí\t\t\t\tbest_score = total_score\n  2314‚Üí\t\t\t\tbest_cover = cover_pos\n  2315‚Üí\t\t\t\tfound_valid_cover = true\n  2316‚Üí\n  2317‚Üí\tif found_valid_cover:\n  2318‚Üí\t\t_pursuit_next_cover = best_cover\n  2319‚Üí\t\t_has_pursuit_cover = true\n  2320‚Üí\t\t_log_debug(\"Found pursuit cover at %s (score: %.2f)\" % [_pursuit_next_cover, best_score])\n  2321‚Üí\telse:\n  2322‚Üí\t\t_has_pursuit_cover = false\n  2323‚Üí\n  2324‚Üí\n  2325‚Üí## Find cover position closest to the player for assault positioning.\n  2326‚Üí## Used during ASSAULT state to take the nearest safe cover to the player.\n  2327‚Üífunc _find_cover_closest_to_player() -> void:\n  2328‚Üí\tif _player == null:\n  2329‚Üí\t\t_has_valid_cover = false\n  2330‚Üí\t\treturn\n  2331‚Üí\n  2332‚Üí\tvar player_pos := _player.global_position\n  2333‚Üí\tvar best_cover: Vector2 = Vector2.ZERO\n  2334‚Üí\tvar best_distance: float = INF\n  2335‚Üí\tvar found_cover: bool = false\n  2336‚Üí\n  2337‚Üí\t# Cast rays in all directions to find obstacles\n  2338‚Üí\tfor i in range(COVER_CHECK_COUNT):\n  2339‚Üí\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n  2340‚Üí\t\tvar direction := Vector2.from_angle(angle)\n  2341‚Üí\n  2342‚Üí\t\tvar raycast := _cover_raycasts[i]\n  2343‚Üí\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n  2344‚Üí\t\traycast.force_raycast_update()\n  2345‚Üí\n  2346‚Üí\t\tif raycast.is_colliding():\n  2347‚Üí\t\t\tvar collision_point := raycast.get_collision_point()\n  2348‚Üí\t\t\tvar collision_normal := raycast.get_collision_normal()\n  2349‚Üí\n  2350‚Üí\t\t\t# Cover position is offset from collision point along normal\n  2351‚Üí\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n  2352‚Üí\n  2353‚Üí\t\t\t# Check if this position is hidden from player (safe cover)\n  2354‚Üí\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n  2355‚Üí\n  2356‚Üí\t\t\tif is_hidden:\n  2357‚Üí\t\t\t\t# Calculate distance from this cover to the player\n  2358‚Üí\t\t\t\tvar distance_to_player := cover_pos.distance_to(player_pos)\n  2359‚Üí\n  2360‚Üí\t\t\t\t# We want the cover closest to the player\n  2361‚Üí\t\t\t\tif distance_to_player < best_distance:\n  2362‚Üí\t\t\t\t\tbest_distance = distance_to_player\n  2363‚Üí\t\t\t\t\tbest_cover = cover_pos\n  2364‚Üí\t\t\t\t\tfound_cover = true\n  2365‚Üí\n  2366‚Üí\tif found_cover:\n  2367‚Üí\t\t_cover_position = best_cover\n  2368‚Üí\t\t_has_valid_cover = true\n  2369‚Üí\t\t_log_debug(\"Found assault cover at %s (distance to player: %.1f)\" % [_cover_position, best_distance])\n  2370‚Üí\telse:\n  2371‚Üí\t\t# Fall back to normal cover finding\n  2372‚Üí\t\t_find_cover_position()\n  2373‚Üí\n  2374‚Üí\n  2375‚Üí## Find a valid cover position relative to the player.\n  2376‚Üí## The cover position must be hidden from the player's line of sight.\n  2377‚Üífunc _find_cover_position() -> void:\n  2378‚Üí\tif _player == null:\n  2379‚Üí\t\t_has_valid_cover = false\n  2380‚Üí\t\treturn\n  2381‚Üí\n  2382‚Üí\tvar player_pos := _player.global_position\n  2383‚Üí\tvar best_cover: Vector2 = Vector2.ZERO\n  2384‚Üí\tvar best_score: float = -INF\n  2385‚Üí\tvar found_hidden_cover: bool = false\n  2386‚Üí\n  2387‚Üí\t# Cast rays in all directions to find obstacles\n  2388‚Üí\tfor i in range(COVER_CHECK_COUNT):\n  2389‚Üí\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n  2390‚Üí\t\tvar direction := Vector2.from_angle(angle)\n  2391‚Üí\n  2392‚Üí\t\tvar raycast := _cover_raycasts[i]\n  2393‚Üí\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n  2394‚Üí\t\traycast.force_raycast_update()\n  2395‚Üí\n  2396‚Üí\t\tif raycast.is_colliding():\n  2397‚Üí\t\t\tvar collision_point := raycast.get_collision_point()\n  2398‚Üí\t\t\tvar collision_normal := raycast.get_collision_normal()\n  2399‚Üí\n  2400‚Üí\t\t\t# Cover position is on the opposite side of the obstacle from player\n  2401‚Üí\t\t\tvar direction_from_player := (collision_point - player_pos).normalized()\n  2402‚Üí\n  2403‚Üí\t\t\t# Position behind cover (offset from collision point along normal)\n  2404‚Üí\t\t\t# Offset must be large enough to hide the entire enemy body (radius ~24 pixels)\n  2405‚Üí\t\t\t# Using 35 pixels to provide some margin for the enemy's collision shape\n  2406‚Üí\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n  2407‚Üí\n  2408‚Üí\t\t\t# First priority: Check if this position is actually hidden from player\n  2409‚Üí\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n  2410‚Üí\n  2411‚Üí\t\t\t# Only consider hidden positions unless we have no choice\n  2412‚Üí\t\t\tif is_hidden or not found_hidden_cover:\n  2413‚Üí\t\t\t\t# Score based on:\n  2414‚Üí\t\t\t\t# 1. Whether position is hidden (highest priority)\n  2415‚Üí\t\t\t\t# 2. Distance from enemy (closer is better)\n  2416‚Üí\t\t\t\t# 3. Position relative to player (behind cover from player's view)\n  2417‚Üí\t\t\t\tvar hidden_score: float = 10.0 if is_hidden else 0.0  # Heavy weight for hidden positions\n  2418‚Üí\n  2419‚Üí\t\t\t\tvar distance_score := 1.0 - (global_position.distance_to(cover_pos) / COVER_CHECK_DISTANCE)\n  2420‚Üí\n  2421‚Üí\t\t\t\t# Check if this position is on the far side of obstacle from player\n  2422‚Üí\t\t\t\tvar cover_direction := (cover_pos - player_pos).normalized()\n  2423‚Üí\t\t\t\tvar dot_product := direction_from_player.dot(cover_direction)\n  2424‚Üí\t\t\t\tvar blocking_score: float = maxf(0.0, dot_product)\n  2425‚Üí\n  2426‚Üí\t\t\t\tvar total_score: float = hidden_score + distance_score * 0.3 + blocking_score * 0.7\n  2427‚Üí\n  2428‚Üí\t\t\t\t# If we find a hidden position, only accept other hidden positions\n  2429‚Üí\t\t\t\tif is_hidden and not found_hidden_cover:\n  2430‚Üí\t\t\t\t\tfound_hidden_cover = true\n  2431‚Üí\t\t\t\t\tbest_score = total_score\n  2432‚Üí\t\t\t\t\tbest_cover = cover_pos\n  2433‚Üí\t\t\t\telif (is_hidden or not found_hidden_cover) and total_score > best_score:\n  2434‚Üí\t\t\t\t\tbest_score = total_score\n  2435‚Üí\t\t\t\t\tbest_cover = cover_pos\n  2436‚Üí\n  2437‚Üí\tif best_score > 0:\n  2438‚Üí\t\t_cover_position = best_cover\n  2439‚Üí\t\t_has_valid_cover = true\n  2440‚Üí\t\t_log_debug(\"Found cover at: %s (hidden: %s)\" % [_cover_position, found_hidden_cover])\n  2441‚Üí\telse:\n  2442‚Üí\t\t_has_valid_cover = false\n  2443‚Üí\n  2444‚Üí\n  2445‚Üí## Calculate flank position based on player location.\n  2446‚Üífunc _calculate_flank_position() -> void:\n  2447‚Üí\tif _player == null:\n  2448‚Üí\t\treturn\n  2449‚Üí\n  2450‚Üí\tvar player_pos := _player.global_position\n  2451‚Üí\tvar player_to_enemy := (global_position - player_pos).normalized()\n  2452‚Üí\n  2453‚Üí\t# Choose left or right flank based on current position\n  2454‚Üí\tvar flank_side := 1.0 if randf() > 0.5 else -1.0\n  2455‚Üí\tvar flank_direction := player_to_enemy.rotated(flank_angle * flank_side)\n  2456‚Üí\n  2457‚Üí\t_flank_target = player_pos + flank_direction * flank_distance\n  2458‚Üí\t_log_debug(\"Flank target: %s\" % _flank_target)\n  2459‚Üí\n  2460‚Üí\n  2461‚Üí## Check if there's a clear path (no obstacles) to the target position.\n  2462‚Üí## Uses a raycast to check for walls/obstacles between current position and target.\n  2463‚Üífunc _has_clear_path_to(target: Vector2) -> bool:\n  2464‚Üí\tif _raycast == null:\n  2465‚Üí\t\treturn true  # Assume clear if no raycast available\n  2466‚Üí\n  2467‚Üí\tvar direction := (target - global_position).normalized()\n  2468‚Üí\tvar distance := global_position.distance_to(target)\n  2469‚Üí\n  2470‚Üí\t_raycast.target_position = direction * distance\n  2471‚Üí\t_raycast.force_raycast_update()\n  2472‚Üí\n  2473‚Üí\t# If we hit something, path is blocked\n  2474‚Üí\tif _raycast.is_colliding():\n  2475‚Üí\t\tvar collision_point := _raycast.get_collision_point()\n  2476‚Üí\t\tvar collision_distance := global_position.distance_to(collision_point)\n  2477‚Üí\t\t# Only consider it blocked if the collision is before the target\n  2478‚Üí\t\treturn collision_distance >= distance - 10.0\n  2479‚Üí\n  2480‚Üí\treturn true\n  2481‚Üí\n  2482‚Üí\n  2483‚Üí## Find cover position closer to the flank target.\n  2484‚Üí## Used during FLANKING state to move cover-to-cover toward the flank position.\n  2485‚Üífunc _find_flank_cover_toward_target() -> void:\n  2486‚Üí\tvar best_cover: Vector2 = Vector2.ZERO\n  2487‚Üí\tvar best_score: float = -INF\n  2488‚Üí\tvar found_valid_cover: bool = false\n  2489‚Üí\n  2490‚Üí\t# Cast rays in all directions to find obstacles\n  2491‚Üí\tfor i in range(COVER_CHECK_COUNT):\n  2492‚Üí\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n  2493‚Üí\t\tvar direction := Vector2.from_angle(angle)\n  2494‚Üí\n  2495‚Üí\t\tvar raycast := _cover_raycasts[i]\n  2496‚Üí\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n  2497‚Üí\t\traycast.force_raycast_update()\n  2498‚Üí\n  2499‚Üí\t\tif raycast.is_colliding():\n  2500‚Üí\t\t\tvar collision_point := raycast.get_collision_point()\n  2501‚Üí\t\t\tvar collision_normal := raycast.get_collision_normal()\n  2502‚Üí\n  2503‚Üí\t\t\t# Cover position is offset from collision point along normal\n  2504‚Üí\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n  2505‚Üí\n  2506‚Üí\t\t\t# For flanking, we want cover that is:\n  2507‚Üí\t\t\t# 1. Closer to the flank target than we currently are\n  2508‚Üí\t\t\t# 2. Not too far from our current position\n  2509‚Üí\t\t\t# 3. Reachable (has clear path)\n  2510‚Üí\n  2511‚Üí\t\t\tvar my_distance_to_target := global_position.distance_to(_flank_target)\n  2512‚Üí\t\t\tvar cover_distance_to_target := cover_pos.distance_to(_flank_target)\n  2513‚Üí\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n  2514‚Üí\n  2515‚Üí\t\t\t# Skip covers that don't bring us closer to flank target\n  2516‚Üí\t\t\tif cover_distance_to_target >= my_distance_to_target:\n  2517‚Üí\t\t\t\tcontinue\n  2518‚Üí\n  2519‚Üí\t\t\t# Skip covers that are too close to current position (would cause looping)\n  2520‚Üí\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n  2521‚Üí\t\t\tif cover_distance_from_me < 30.0:\n  2522‚Üí\t\t\t\tcontinue\n  2523‚Üí\n  2524‚Üí\t\t\t# Check if we can reach this cover (has clear path)\n  2525‚Üí\t\t\tif not _has_clear_path_to(cover_pos):\n  2526‚Üí\t\t\t\t# Even if direct path is blocked, we might be able to reach\n  2527‚Üí\t\t\t\t# via another intermediate cover, but skip for now\n  2528‚Üí\t\t\t\tcontinue\n  2529‚Üí\n  2530‚Üí\t\t\t# Score calculation:\n  2531‚Üí\t\t\t# Higher score for positions that are:\n  2532‚Üí\t\t\t# - Closer to flank target (priority)\n  2533‚Üí\t\t\t# - Not too far from current position\n  2534‚Üí\t\t\tvar approach_score: float = (my_distance_to_target - cover_distance_to_target) / flank_distance\n  2535‚Üí\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n  2536‚Üí\n  2537‚Üí\t\t\tvar total_score: float = approach_score * 2.0 - distance_penalty\n  2538‚Üí\n  2539‚Üí\t\t\tif total_score > best_score:\n  2540‚Üí\t\t\t\tbest_score = total_score\n  2541‚Üí\t\t\t\tbest_cover = cover_pos\n  2542‚Üí\t\t\t\tfound_valid_cover = true\n  2543‚Üí\n  2544‚Üí\tif found_valid_cover:\n  2545‚Üí\t\t_flank_next_cover = best_cover\n  2546‚Üí\t\t_has_flank_cover = true\n  2547‚Üí\t\t_log_debug(\"Found flank cover at %s (score: %.2f)\" % [_flank_next_cover, best_score])\n  2548‚Üí\telse:\n  2549‚Üí\t\t_has_flank_cover = false\n  2550‚Üí\n  2551‚Üí\n  2552‚Üí## Check if there's a wall ahead in the given direction and return avoidance direction.\n  2553‚Üí## Returns Vector2.ZERO if no wall detected, otherwise returns a vector to avoid the wall.\n  2554‚Üífunc _check_wall_ahead(direction: Vector2) -> Vector2:\n  2555‚Üí\tif _wall_raycasts.is_empty():\n  2556‚Üí\t\treturn Vector2.ZERO\n  2557‚Üí\n  2558‚Üí\tvar avoidance := Vector2.ZERO\n  2559‚Üí\tvar perpendicular := Vector2(-direction.y, direction.x)  # 90 degrees rotation\n  2560‚Üí\n  2561‚Üí\t# Check center, left, and right raycasts\n  2562‚Üí\tfor i in range(WALL_CHECK_COUNT):\n  2563‚Üí\t\tvar angle_offset := (i - 1) * 0.5  # -0.5, 0, 0.5 radians (~-28, 0, 28 degrees)\n  2564‚Üí\t\tvar check_direction := direction.rotated(angle_offset)\n  2565‚Üí\n  2566‚Üí\t\tvar raycast := _wall_raycasts[i]\n  2567‚Üí\t\traycast.target_position = check_direction * WALL_CHECK_DISTANCE\n  2568‚Üí\t\traycast.force_raycast_update()\n  2569‚Üí\n  2570‚Üí\t\tif raycast.is_colliding():\n  2571‚Üí\t\t\t# Calculate avoidance based on which raycast hit\n  2572‚Üí\t\t\tif i == 0:  # Left raycast hit\n  2573‚Üí\t\t\t\tavoidance += perpendicular  # Steer right\n  2574‚Üí\t\t\telif i == 1:  # Center raycast hit\n  2575‚Üí\t\t\t\tavoidance += perpendicular if randf() > 0.5 else -perpendicular  # Random steer\n  2576‚Üí\t\t\telif i == 2:  # Right raycast hit\n  2577‚Üí\t\t\t\tavoidance -= perpendicular  # Steer left\n  2578‚Üí\n  2579‚Üí\treturn avoidance.normalized() if avoidance.length() > 0 else Vector2.ZERO\n  2580‚Üí\n  2581‚Üí\n  2582‚Üí## Check if the player is visible using raycast.\n  2583‚Üí## If detection_range is 0 or negative, uses unlimited detection range (line-of-sight only).\n  2584‚Üí## This allows the enemy to see the player even outside the viewport if there's no obstacle.\n  2585‚Üí## Also updates the continuous visibility timer and visibility ratio for lead prediction control.\n  2586‚Üífunc _check_player_visibility() -> void:\n  2587‚Üí\tvar was_visible := _can_see_player\n  2588‚Üí\t_can_see_player = false\n  2589‚Üí\t_player_visibility_ratio = 0.0\n  2590‚Üí\n  2591‚Üí\tif _player == null or not _raycast:\n  2592‚Üí\t\t_continuous_visibility_timer = 0.0\n  2593‚Üí\t\treturn\n  2594‚Üí\n  2595‚Üí\tvar distance_to_player := global_position.distance_to(_player.global_position)\n  2596‚Üí\n  2597‚Üí\t# Check if player is within detection range (only if detection_range is positive)\n  2598‚Üí\t# If detection_range <= 0, detection is unlimited (line-of-sight only)\n  2599‚Üí\tif detection_range > 0 and distance_to_player > detection_range:\n  2600‚Üí\t\t_continuous_visibility_timer = 0.0\n  2601‚Üí\t\treturn\n  2602‚Üí\n  2603‚Üí\t# Point raycast at player - use actual distance to player for the raycast length\n  2604‚Üí\tvar direction_to_player := (_player.global_position - global_position).normalized()\n  2605‚Üí\tvar raycast_length := distance_to_player + 10.0  # Add small buffer to ensure we reach player\n  2606‚Üí\t_raycast.target_position = direction_to_player * raycast_length\n  2607‚Üí\t_raycast.force_raycast_update()\n  2608‚Üí\n  2609‚Üí\t# Check if raycast hit something\n  2610‚Üí\tif _raycast.is_colliding():\n  2611‚Üí\t\tvar collider := _raycast.get_collider()\n  2612‚Üí\t\t# If we hit the player, we can see them\n  2613‚Üí\t\tif collider == _player:\n  2614‚Üí\t\t\t_can_see_player = true\n  2615‚Üí\t\t# If we hit a wall/obstacle before the player, we can't see them\n  2616‚Üí\telse:\n  2617‚Üí\t\t# No collision between us and player - we have clear line of sight\n  2618‚Üí\t\t_can_see_player = true\n  2619‚Üí\n  2620‚Üí\t# Update continuous visibility timer and visibility ratio\n  2621‚Üí\tif _can_see_player:\n  2622‚Üí\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n  2623‚Üí\t\t# Calculate what fraction of the player's body is visible\n  2624‚Üí\t\t# This is used to determine if lead prediction should be enabled\n  2625‚Üí\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n  2626‚Üí\telse:\n  2627‚Üí\t\t# Lost line of sight - reset the timer and visibility ratio\n  2628‚Üí\t\t_continuous_visibility_timer = 0.0\n  2629‚Üí\t\t_player_visibility_ratio = 0.0\n  2630‚Üí\n  2631‚Üí\n  2632‚Üí## Aim the enemy sprite/direction at the player using gradual rotation.\n  2633‚Üífunc _aim_at_player() -> void:\n  2634‚Üí\tif _player == null:\n  2635‚Üí\t\treturn\n  2636‚Üí\tvar direction := (_player.global_position - global_position).normalized()\n  2637‚Üí\tvar target_angle := direction.angle()\n  2638‚Üí\n  2639‚Üí\t# Calculate the shortest rotation direction\n  2640‚Üí\tvar angle_diff := wrapf(target_angle - rotation, -PI, PI)\n  2641‚Üí\n  2642‚Üí\t# Get the delta time from the current physics process\n  2643‚Üí\tvar delta := get_physics_process_delta_time()\n  2644‚Üí\n  2645‚Üí\t# Apply gradual rotation based on rotation_speed\n  2646‚Üí\tif abs(angle_diff) <= rotation_speed * delta:\n  2647‚Üí\t\t# Close enough to snap to target\n  2648‚Üí\t\trotation = target_angle\n  2649‚Üí\telif angle_diff > 0:\n  2650‚Üí\t\trotation += rotation_speed * delta\n  2651‚Üí\telse:\n  2652‚Üí\t\trotation -= rotation_speed * delta\n  2653‚Üí\n  2654‚Üí\n  2655‚Üí## Shoot a bullet towards the player.\n  2656‚Üífunc _shoot() -> void:\n  2657‚Üí\tif bullet_scene == null or _player == null:\n  2658‚Üí\t\treturn\n  2659‚Üí\n  2660‚Üí\t# Check if we can shoot (have ammo and not reloading)\n  2661‚Üí\tif not _can_shoot():\n  2662‚Üí\t\treturn\n  2663‚Üí\n  2664‚Üí\tvar target_position := _player.global_position\n  2665‚Üí\n  2666‚Üí\t# Apply lead prediction if enabled\n  2667‚Üí\tif enable_lead_prediction:\n  2668‚Üí\t\ttarget_position = _calculate_lead_prediction()\n  2669‚Üí\n  2670‚Üí\t# Check if the shot should be taken (friendly fire and cover checks)\n  2671‚Üí\tif not _should_shoot_at_target(target_position):\n  2672‚Üí\t\treturn\n  2673‚Üí\n  2674‚Üí\tvar direction := (target_position - global_position).normalized()\n  2675‚Üí\n  2676‚Üí\t# Create bullet instance\n  2677‚Üí\tvar bullet := bullet_scene.instantiate()\n  2678‚Üí\n  2679‚Üí\t# Set bullet position with offset in shoot direction\n  2680‚Üí\tbullet.global_position = global_position + direction * bullet_spawn_offset\n  2681‚Üí\n  2682‚Üí\t# Set bullet direction\n  2683‚Üí\tbullet.direction = direction\n  2684‚Üí\n  2685‚Üí\t# Set shooter ID to identify this enemy as the source\n  2686‚Üí\t# This prevents enemies from detecting their own bullets in the threat sphere\n  2687‚Üí\tbullet.shooter_id = get_instance_id()\n  2688‚Üí\n  2689‚Üí\t# Add bullet to the scene tree\n  2690‚Üí\tget_tree().current_scene.add_child(bullet)\n  2691‚Üí\n  2692‚Üí\t# Play shooting sound\n  2693‚Üí\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n  2694‚Üí\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n  2695‚Üí\t\taudio_manager.play_m16_shot(global_position)\n  2696‚Üí\n  2697‚Üí\t# Play shell casing sound with a small delay\n  2698‚Üí\t_play_delayed_shell_sound()\n  2699‚Üí\n  2700‚Üí\t# Consume ammo\n  2701‚Üí\t_current_ammo -= 1\n  2702‚Üí\tammo_changed.emit(_current_ammo, _reserve_ammo)\n  2703‚Üí\n  2704‚Üí\t# Auto-reload when magazine is empty\n  2705‚Üí\tif _current_ammo <= 0 and _reserve_ammo > 0:\n  2706‚Üí\t\t_start_reload()\n  2707‚Üí\n  2708‚Üí\n  2709‚Üí## Play shell casing sound with a delay to simulate the casing hitting the ground.\n  2710‚Üífunc _play_delayed_shell_sound() -> void:\n  2711‚Üí\tawait get_tree().create_timer(0.15).timeout\n  2712‚Üí\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n  2713‚Üí\tif audio_manager and audio_manager.has_method(\"play_shell_rifle\"):\n  2714‚Üí\t\taudio_manager.play_shell_rifle(global_position)\n  2715‚Üí\n  2716‚Üí\n  2717‚Üí## Calculate lead prediction - aims where the player will be, not where they are.\n  2718‚Üí## Uses iterative approach for better accuracy with moving targets.\n  2719‚Üí## Only applies lead prediction if:\n  2720‚Üí## 1. The player has been continuously visible for at least lead_prediction_delay seconds\n  2721‚Üí## 2. At least lead_prediction_visibility_threshold of the player's body is visible\n  2722‚Üí## 3. The predicted position is also visible to the enemy (not behind cover)\n  2723‚Üí## This prevents enemies from \"knowing\" where the player will emerge from cover.\n  2724‚Üífunc _calculate_lead_prediction() -> Vector2:\n  2725‚Üí\tif _player == null:\n  2726‚Üí\t\treturn global_position\n  2727‚Üí\n  2728‚Üí\tvar player_pos := _player.global_position\n  2729‚Üí\n  2730‚Üí\t# Only use lead prediction if the player has been continuously visible\n  2731‚Üí\t# for long enough. This prevents enemies from predicting player position\n  2732‚Üí\t# immediately when they emerge from cover.\n  2733‚Üí\tif _continuous_visibility_timer < lead_prediction_delay:\n  2734‚Üí\t\t_log_debug(\"Lead prediction disabled: visibility time %.2fs < %.2fs required\" % [_continuous_visibility_timer, lead_prediction_delay])\n  2735‚Üí\t\treturn player_pos\n  2736‚Üí\n  2737‚Üí\t# Only use lead prediction if enough of the player's body is visible.\n  2738‚Üí\t# This prevents pre-firing when the player is at the edge of cover with only\n  2739‚Üí\t# a small part of their body visible. The player must be significantly exposed\n  2740‚Üí\t# before the enemy can predict their movement.\n  2741‚Üí\tif _player_visibility_ratio < lead_prediction_visibility_threshold:\n  2742‚Üí\t\t_log_debug(\"Lead prediction disabled: visibility ratio %.2f < %.2f required (player at cover edge)\" % [_player_visibility_ratio, lead_prediction_visibility_threshold])\n  2743‚Üí\t\treturn player_pos\n  2744‚Üí\n  2745‚Üí\tvar player_velocity := Vector2.ZERO\n  2746‚Üí\n  2747‚Üí\t# Get player velocity if they are a CharacterBody2D\n  2748‚Üí\tif _player is CharacterBody2D:\n  2749‚Üí\t\tplayer_velocity = _player.velocity\n  2750‚Üí\n  2751‚Üí\t# If player is stationary, no need for prediction\n  2752‚Üí\tif player_velocity.length_squared() < 1.0:\n  2753‚Üí\t\treturn player_pos\n  2754‚Üí\n  2755‚Üí\t# Iterative lead prediction for better accuracy\n  2756‚Üí\t# Start with player's current position\n  2757‚Üí\tvar predicted_pos := player_pos\n  2758‚Üí\tvar distance := global_position.distance_to(predicted_pos)\n  2759‚Üí\n  2760‚Üí\t# Iterate 2-3 times for convergence\n  2761‚Üí\tfor i in range(3):\n  2762‚Üí\t\t# Time for bullet to reach the predicted position\n  2763‚Üí\t\tvar time_to_target := distance / bullet_speed\n  2764‚Üí\n  2765‚Üí\t\t# Predict where player will be at that time\n  2766‚Üí\t\tpredicted_pos = player_pos + player_velocity * time_to_target\n  2767‚Üí\n  2768‚Üí\t\t# Update distance for next iteration\n  2769‚Üí\t\tdistance = global_position.distance_to(predicted_pos)\n  2770‚Üí\n  2771‚Üí\t# CRITICAL: Validate that the predicted position is actually visible to the enemy.\n  2772‚Üí\t# If the predicted position is behind cover (e.g., player is running toward cover exit),\n  2773‚Üí\t# we should NOT aim there - it would feel like the enemy is \"cheating\" by knowing\n  2774‚Üí\t# where the player will emerge. Fall back to player's current visible position.\n  2775‚Üí\tif not _is_position_visible_to_enemy(predicted_pos):\n  2776‚Üí\t\t_log_debug(\"Lead prediction blocked: predicted position %s is not visible, using current position %s\" % [predicted_pos, player_pos])\n  2777‚Üí\t\treturn player_pos\n  2778‚Üí\n  2779‚Üí\t_log_debug(\"Lead prediction: player at %s moving %s, aiming at %s\" % [player_pos, player_velocity, predicted_pos])\n  2780‚Üí\n  2781‚Üí\treturn predicted_pos\n  2782‚Üí\n  2783‚Üí\n  2784‚Üí## Process patrol behavior - move between patrol points.\n  2785‚Üífunc _process_patrol(delta: float) -> void:\n  2786‚Üí\tif _patrol_points.is_empty():\n  2787‚Üí\t\treturn\n  2788‚Üí\n  2789‚Üí\t# Handle waiting at patrol point\n  2790‚Üí\tif _is_waiting_at_patrol_point:\n  2791‚Üí\t\t_patrol_wait_timer += delta\n  2792‚Üí\t\tif _patrol_wait_timer >= patrol_wait_time:\n  2793‚Üí\t\t\t_is_waiting_at_patrol_point = false\n  2794‚Üí\t\t\t_patrol_wait_timer = 0.0\n  2795‚Üí\t\t\t_current_patrol_index = (_current_patrol_index + 1) % _patrol_points.size()\n  2796‚Üí\t\tvelocity = Vector2.ZERO\n  2797‚Üí\t\treturn\n  2798‚Üí\n  2799‚Üí\t# Move towards current patrol point\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "99bdc83c-4b5f-40e0-a33c-c415aacb5be4",
  "tool_use_result": {
    "type": "text",
    "file": {
      "filePath": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
      "content": "\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Hidden from player (priority)\n\t\t\t# - Closer to player\n\t\t\t# - Not too far from current position\n\t\t\tvar hidden_score: float = 5.0 if is_hidden else 0.0\n\t\t\tvar approach_score: float = (my_distance_to_player - cover_distance_to_player) / CLOSE_COMBAT_DISTANCE\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = hidden_score + approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_pursuit_next_cover = best_cover\n\t\t_has_pursuit_cover = true\n\t\t_log_debug(\"Found pursuit cover at %s (score: %.2f)\" % [_pursuit_next_cover, best_score])\n\telse:\n\t\t_has_pursuit_cover = false\n\n\n## Find cover position closest to the player for assault positioning.\n## Used during ASSAULT state to take the nearest safe cover to the player.\nfunc _find_cover_closest_to_player() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_distance: float = INF\n\tvar found_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# Check if this position is hidden from player (safe cover)\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\tif is_hidden:\n\t\t\t\t# Calculate distance from this cover to the player\n\t\t\t\tvar distance_to_player := cover_pos.distance_to(player_pos)\n\n\t\t\t\t# We want the cover closest to the player\n\t\t\t\tif distance_to_player < best_distance:\n\t\t\t\t\tbest_distance = distance_to_player\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\t\tfound_cover = true\n\n\tif found_cover:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found assault cover at %s (distance to player: %.1f)\" % [_cover_position, best_distance])\n\telse:\n\t\t# Fall back to normal cover finding\n\t\t_find_cover_position()\n\n\n## Find a valid cover position relative to the player.\n## The cover position must be hidden from the player's line of sight.\nfunc _find_cover_position() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_hidden_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is on the opposite side of the obstacle from player\n\t\t\tvar direction_from_player := (collision_point - player_pos).normalized()\n\n\t\t\t# Position behind cover (offset from collision point along normal)\n\t\t\t# Offset must be large enough to hide the entire enemy body (radius ~24 pixels)\n\t\t\t# Using 35 pixels to provide some margin for the enemy's collision shape\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# First priority: Check if this position is actually hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Only consider hidden positions unless we have no choice\n\t\t\tif is_hidden or not found_hidden_cover:\n\t\t\t\t# Score based on:\n\t\t\t\t# 1. Whether position is hidden (highest priority)\n\t\t\t\t# 2. Distance from enemy (closer is better)\n\t\t\t\t# 3. Position relative to player (behind cover from player's view)\n\t\t\t\tvar hidden_score: float = 10.0 if is_hidden else 0.0  # Heavy weight for hidden positions\n\n\t\t\t\tvar distance_score := 1.0 - (global_position.distance_to(cover_pos) / COVER_CHECK_DISTANCE)\n\n\t\t\t\t# Check if this position is on the far side of obstacle from player\n\t\t\t\tvar cover_direction := (cover_pos - player_pos).normalized()\n\t\t\t\tvar dot_product := direction_from_player.dot(cover_direction)\n\t\t\t\tvar blocking_score: float = maxf(0.0, dot_product)\n\n\t\t\t\tvar total_score: float = hidden_score + distance_score * 0.3 + blocking_score * 0.7\n\n\t\t\t\t# If we find a hidden position, only accept other hidden positions\n\t\t\t\tif is_hidden and not found_hidden_cover:\n\t\t\t\t\tfound_hidden_cover = true\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\telif (is_hidden or not found_hidden_cover) and total_score > best_score:\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\n\tif best_score > 0:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found cover at: %s (hidden: %s)\" % [_cover_position, found_hidden_cover])\n\telse:\n\t\t_has_valid_cover = false\n\n\n## Calculate flank position based on player location.\nfunc _calculate_flank_position() -> void:\n\tif _player == null:\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar player_to_enemy := (global_position - player_pos).normalized()\n\n\t# Choose left or right flank based on current position\n\tvar flank_side := 1.0 if randf() > 0.5 else -1.0\n\tvar flank_direction := player_to_enemy.rotated(flank_angle * flank_side)\n\n\t_flank_target = player_pos + flank_direction * flank_distance\n\t_log_debug(\"Flank target: %s\" % _flank_target)\n\n\n## Check if there's a clear path (no obstacles) to the target position.\n## Uses a raycast to check for walls/obstacles between current position and target.\nfunc _has_clear_path_to(target: Vector2) -> bool:\n\tif _raycast == null:\n\t\treturn true  # Assume clear if no raycast available\n\n\tvar direction := (target - global_position).normalized()\n\tvar distance := global_position.distance_to(target)\n\n\t_raycast.target_position = direction * distance\n\t_raycast.force_raycast_update()\n\n\t# If we hit something, path is blocked\n\tif _raycast.is_colliding():\n\t\tvar collision_point := _raycast.get_collision_point()\n\t\tvar collision_distance := global_position.distance_to(collision_point)\n\t\t# Only consider it blocked if the collision is before the target\n\t\treturn collision_distance >= distance - 10.0\n\n\treturn true\n\n\n## Find cover position closer to the flank target.\n## Used during FLANKING state to move cover-to-cover toward the flank position.\nfunc _find_flank_cover_toward_target() -> void:\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For flanking, we want cover that is:\n\t\t\t# 1. Closer to the flank target than we currently are\n\t\t\t# 2. Not too far from our current position\n\t\t\t# 3. Reachable (has clear path)\n\n\t\t\tvar my_distance_to_target := global_position.distance_to(_flank_target)\n\t\t\tvar cover_distance_to_target := cover_pos.distance_to(_flank_target)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to flank target\n\t\t\tif cover_distance_to_target >= my_distance_to_target:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if we can reach this cover (has clear path)\n\t\t\tif not _has_clear_path_to(cover_pos):\n\t\t\t\t# Even if direct path is blocked, we might be able to reach\n\t\t\t\t# via another intermediate cover, but skip for now\n\t\t\t\tcontinue\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Closer to flank target (priority)\n\t\t\t# - Not too far from current position\n\t\t\tvar approach_score: float = (my_distance_to_target - cover_distance_to_target) / flank_distance\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_flank_next_cover = best_cover\n\t\t_has_flank_cover = true\n\t\t_log_debug(\"Found flank cover at %s (score: %.2f)\" % [_flank_next_cover, best_score])\n\telse:\n\t\t_has_flank_cover = false\n\n\n## Check if there's a wall ahead in the given direction and return avoidance direction.\n## Returns Vector2.ZERO if no wall detected, otherwise returns a vector to avoid the wall.\nfunc _check_wall_ahead(direction: Vector2) -> Vector2:\n\tif _wall_raycasts.is_empty():\n\t\treturn Vector2.ZERO\n\n\tvar avoidance := Vector2.ZERO\n\tvar perpendicular := Vector2(-direction.y, direction.x)  # 90 degrees rotation\n\n\t# Check center, left, and right raycasts\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar angle_offset := (i - 1) * 0.5  # -0.5, 0, 0.5 radians (~-28, 0, 28 degrees)\n\t\tvar check_direction := direction.rotated(angle_offset)\n\n\t\tvar raycast := _wall_raycasts[i]\n\t\traycast.target_position = check_direction * WALL_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\t# Calculate avoidance based on which raycast hit\n\t\t\tif i == 0:  # Left raycast hit\n\t\t\t\tavoidance += perpendicular  # Steer right\n\t\t\telif i == 1:  # Center raycast hit\n\t\t\t\tavoidance += perpendicular if randf() > 0.5 else -perpendicular  # Random steer\n\t\t\telif i == 2:  # Right raycast hit\n\t\t\t\tavoidance -= perpendicular  # Steer left\n\n\treturn avoidance.normalized() if avoidance.length() > 0 else Vector2.ZERO\n\n\n## Check if the player is visible using raycast.\n## If detection_range is 0 or negative, uses unlimited detection range (line-of-sight only).\n## This allows the enemy to see the player even outside the viewport if there's no obstacle.\n## Also updates the continuous visibility timer and visibility ratio for lead prediction control.\nfunc _check_player_visibility() -> void:\n\tvar was_visible := _can_see_player\n\t_can_see_player = false\n\t_player_visibility_ratio = 0.0\n\n\tif _player == null or not _raycast:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t# Check if player is within detection range (only if detection_range is positive)\n\t# If detection_range <= 0, detection is unlimited (line-of-sight only)\n\tif detection_range > 0 and distance_to_player > detection_range:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\t# Point raycast at player - use actual distance to player for the raycast length\n\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\tvar raycast_length := distance_to_player + 10.0  # Add small buffer to ensure we reach player\n\t_raycast.target_position = direction_to_player * raycast_length\n\t_raycast.force_raycast_update()\n\n\t# Check if raycast hit something\n\tif _raycast.is_colliding():\n\t\tvar collider := _raycast.get_collider()\n\t\t# If we hit the player, we can see them\n\t\tif collider == _player:\n\t\t\t_can_see_player = true\n\t\t# If we hit a wall/obstacle before the player, we can't see them\n\telse:\n\t\t# No collision between us and player - we have clear line of sight\n\t\t_can_see_player = true\n\n\t# Update continuous visibility timer and visibility ratio\n\tif _can_see_player:\n\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n\t\t# Calculate what fraction of the player's body is visible\n\t\t# This is used to determine if lead prediction should be enabled\n\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n\telse:\n\t\t# Lost line of sight - reset the timer and visibility ratio\n\t\t_continuous_visibility_timer = 0.0\n\t\t_player_visibility_ratio = 0.0\n\n\n## Aim the enemy sprite/direction at the player using gradual rotation.\nfunc _aim_at_player() -> void:\n\tif _player == null:\n\t\treturn\n\tvar direction := (_player.global_position - global_position).normalized()\n\tvar target_angle := direction.angle()\n\n\t# Calculate the shortest rotation direction\n\tvar angle_diff := wrapf(target_angle - rotation, -PI, PI)\n\n\t# Get the delta time from the current physics process\n\tvar delta := get_physics_process_delta_time()\n\n\t# Apply gradual rotation based on rotation_speed\n\tif abs(angle_diff) <= rotation_speed * delta:\n\t\t# Close enough to snap to target\n\t\trotation = target_angle\n\telif angle_diff > 0:\n\t\trotation += rotation_speed * delta\n\telse:\n\t\trotation -= rotation_speed * delta\n\n\n## Shoot a bullet towards the player.\nfunc _shoot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\t# Check if we can shoot (have ammo and not reloading)\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Apply lead prediction if enabled\n\tif enable_lead_prediction:\n\t\ttarget_position = _calculate_lead_prediction()\n\n\t# Check if the shot should be taken (friendly fire and cover checks)\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Create bullet instance\n\tvar bullet := bullet_scene.instantiate()\n\n\t# Set bullet position with offset in shoot direction\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\n\t# Set bullet direction\n\tbullet.direction = direction\n\n\t# Set shooter ID to identify this enemy as the source\n\t# This prevents enemies from detecting their own bullets in the threat sphere\n\tbullet.shooter_id = get_instance_id()\n\n\t# Add bullet to the scene tree\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play shooting sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\n\t# Play shell casing sound with a small delay\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\t# Auto-reload when magazine is empty\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Play shell casing sound with a delay to simulate the casing hitting the ground.\nfunc _play_delayed_shell_sound() -> void:\n\tawait get_tree().create_timer(0.15).timeout\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_shell_rifle\"):\n\t\taudio_manager.play_shell_rifle(global_position)\n\n\n## Calculate lead prediction - aims where the player will be, not where they are.\n## Uses iterative approach for better accuracy with moving targets.\n## Only applies lead prediction if:\n## 1. The player has been continuously visible for at least lead_prediction_delay seconds\n## 2. At least lead_prediction_visibility_threshold of the player's body is visible\n## 3. The predicted position is also visible to the enemy (not behind cover)\n## This prevents enemies from \"knowing\" where the player will emerge from cover.\nfunc _calculate_lead_prediction() -> Vector2:\n\tif _player == null:\n\t\treturn global_position\n\n\tvar player_pos := _player.global_position\n\n\t# Only use lead prediction if the player has been continuously visible\n\t# for long enough. This prevents enemies from predicting player position\n\t# immediately when they emerge from cover.\n\tif _continuous_visibility_timer < lead_prediction_delay:\n\t\t_log_debug(\"Lead prediction disabled: visibility time %.2fs < %.2fs required\" % [_continuous_visibility_timer, lead_prediction_delay])\n\t\treturn player_pos\n\n\t# Only use lead prediction if enough of the player's body is visible.\n\t# This prevents pre-firing when the player is at the edge of cover with only\n\t# a small part of their body visible. The player must be significantly exposed\n\t# before the enemy can predict their movement.\n\tif _player_visibility_ratio < lead_prediction_visibility_threshold:\n\t\t_log_debug(\"Lead prediction disabled: visibility ratio %.2f < %.2f required (player at cover edge)\" % [_player_visibility_ratio, lead_prediction_visibility_threshold])\n\t\treturn player_pos\n\n\tvar player_velocity := Vector2.ZERO\n\n\t# Get player velocity if they are a CharacterBody2D\n\tif _player is CharacterBody2D:\n\t\tplayer_velocity = _player.velocity\n\n\t# If player is stationary, no need for prediction\n\tif player_velocity.length_squared() < 1.0:\n\t\treturn player_pos\n\n\t# Iterative lead prediction for better accuracy\n\t# Start with player's current position\n\tvar predicted_pos := player_pos\n\tvar distance := global_position.distance_to(predicted_pos)\n\n\t# Iterate 2-3 times for convergence\n\tfor i in range(3):\n\t\t# Time for bullet to reach the predicted position\n\t\tvar time_to_target := distance / bullet_speed\n\n\t\t# Predict where player will be at that time\n\t\tpredicted_pos = player_pos + player_velocity * time_to_target\n\n\t\t# Update distance for next iteration\n\t\tdistance = global_position.distance_to(predicted_pos)\n\n\t# CRITICAL: Validate that the predicted position is actually visible to the enemy.\n\t# If the predicted position is behind cover (e.g., player is running toward cover exit),\n\t# we should NOT aim there - it would feel like the enemy is \"cheating\" by knowing\n\t# where the player will emerge. Fall back to player's current visible position.\n\tif not _is_position_visible_to_enemy(predicted_pos):\n\t\t_log_debug(\"Lead prediction blocked: predicted position %s is not visible, using current position %s\" % [predicted_pos, player_pos])\n\t\treturn player_pos\n\n\t_log_debug(\"Lead prediction: player at %s moving %s, aiming at %s\" % [player_pos, player_velocity, predicted_pos])\n\n\treturn predicted_pos\n\n\n## Process patrol behavior - move between patrol points.\nfunc _process_patrol(delta: float) -> void:\n\tif _patrol_points.is_empty():\n\t\treturn\n\n\t# Handle waiting at patrol point\n\tif _is_waiting_at_patrol_point:\n\t\t_patrol_wait_timer += delta\n\t\tif _patrol_wait_timer >= patrol_wait_time:\n\t\t\t_is_waiting_at_patrol_point = false\n\t\t\t_patrol_wait_timer = 0.0\n\t\t\t_current_patrol_index = (_current_patrol_index + 1) % _patrol_points.size()\n\t\tvelocity = Vector2.ZERO\n\t\treturn\n\n\t# Move towards current patrol point",
      "numLines": 500,
      "startLine": 2300,
      "totalLines": 3206
    }
  }
}
[2026-01-18T02:51:54.741Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01GvAA4MxGDa2h6CYqKpXWf9",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me read the end of the file to understand the complete structure."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 7885,
      "cache_read_input_tokens": 94688,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 7885,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "0a9e9c58-2745-4862-958d-9ebf372e50bd"
}
[2026-01-18T02:51:56.068Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01GvAA4MxGDa2h6CYqKpXWf9",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_0113EbTumGPTkRHt6CJknXor",
        "name": "Bash",
        "input": {
          "command": "wc -l /tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "description": "Count lines in enemy.gd"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 7885,
      "cache_read_input_tokens": 94688,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 7885,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "018da549-1a8e-4bd6-927d-060f5211d166"
}
[2026-01-18T02:51:56.196Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_0113EbTumGPTkRHt6CJknXor",
        "type": "tool_result",
        "content": "3205 /tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "b5e9a1d9-da5b-4586-b1dc-4453c69290cf",
  "tool_use_result": {
    "stdout": "3205 /tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-01-18T02:51:59.141Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01MMptVGqAgbJ6qbWVQZfsCC",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_011upG62zhEQ8KHWgjVPR9SG",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "offset": 3000,
          "limit": 210
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 155,
      "cache_read_input_tokens": 102573,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 155,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 25,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "e0d0b4be-0f1f-4b22-8d95-44e4f8cc0c1a"
}
[2026-01-18T02:51:59.186Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_011upG62zhEQ8KHWgjVPR9SG",
        "type": "tool_result",
        "content": "  3000‚Üí\n  3001‚Üí## Get AI state name as a human-readable string.\n  3002‚Üífunc _get_state_name(state: AIState) -> String:\n  3003‚Üí\tmatch state:\n  3004‚Üí\t\tAIState.IDLE:\n  3005‚Üí\t\t\treturn \"IDLE\"\n  3006‚Üí\t\tAIState.COMBAT:\n  3007‚Üí\t\t\treturn \"COMBAT\"\n  3008‚Üí\t\tAIState.SEEKING_COVER:\n  3009‚Üí\t\t\treturn \"SEEKING_COVER\"\n  3010‚Üí\t\tAIState.IN_COVER:\n  3011‚Üí\t\t\treturn \"IN_COVER\"\n  3012‚Üí\t\tAIState.FLANKING:\n  3013‚Üí\t\t\treturn \"FLANKING\"\n  3014‚Üí\t\tAIState.SUPPRESSED:\n  3015‚Üí\t\t\treturn \"SUPPRESSED\"\n  3016‚Üí\t\tAIState.RETREATING:\n  3017‚Üí\t\t\treturn \"RETREATING\"\n  3018‚Üí\t\tAIState.PURSUING:\n  3019‚Üí\t\t\treturn \"PURSUING\"\n  3020‚Üí\t\tAIState.ASSAULT:\n  3021‚Üí\t\t\treturn \"ASSAULT\"\n  3022‚Üí\t\t_:\n  3023‚Üí\t\t\treturn \"UNKNOWN\"\n  3024‚Üí\n  3025‚Üí\n  3026‚Üí## Update the debug label with current AI state.\n  3027‚Üífunc _update_debug_label() -> void:\n  3028‚Üí\tif _debug_label == null:\n  3029‚Üí\t\treturn\n  3030‚Üí\n  3031‚Üí\t_debug_label.visible = debug_label_enabled\n  3032‚Üí\tif not debug_label_enabled:\n  3033‚Üí\t\treturn\n  3034‚Üí\n  3035‚Üí\tvar state_text := _get_state_name(_current_state)\n  3036‚Üí\n  3037‚Üí\t# Add retreat mode info if retreating\n  3038‚Üí\tif _current_state == AIState.RETREATING:\n  3039‚Üí\t\tmatch _retreat_mode:\n  3040‚Üí\t\t\tRetreatMode.FULL_HP:\n  3041‚Üí\t\t\t\tstate_text += \"\\n(FULL_HP)\"\n  3042‚Üí\t\t\tRetreatMode.ONE_HIT:\n  3043‚Üí\t\t\t\tstate_text += \"\\n(ONE_HIT)\"\n  3044‚Üí\t\t\tRetreatMode.MULTIPLE_HITS:\n  3045‚Üí\t\t\t\tstate_text += \"\\n(MULTI_HITS)\"\n  3046‚Üí\n  3047‚Üí\t# Add assault timer info if in assault state\n  3048‚Üí\tif _current_state == AIState.ASSAULT:\n  3049‚Üí\t\tif _assault_ready:\n  3050‚Üí\t\t\tstate_text += \"\\n(RUSHING)\"\n  3051‚Üí\t\telse:\n  3052‚Üí\t\t\tvar time_left := ASSAULT_WAIT_DURATION - _assault_wait_timer\n  3053‚Üí\t\t\tstate_text += \"\\n(%.1fs)\" % time_left\n  3054‚Üí\n  3055‚Üí\t# Add combat phase info if in combat\n  3056‚Üí\tif _current_state == AIState.COMBAT:\n  3057‚Üí\t\tif _combat_exposed:\n  3058‚Üí\t\t\tvar time_left := _combat_shoot_duration - _combat_shoot_timer\n  3059‚Üí\t\t\tstate_text += \"\\n(EXPOSED %.1fs)\" % time_left\n  3060‚Üí\t\telif _seeking_clear_shot:\n  3061‚Üí\t\t\tvar time_left := CLEAR_SHOT_MAX_TIME - _clear_shot_timer\n  3062‚Üí\t\t\tstate_text += \"\\n(SEEK SHOT %.1fs)\" % time_left\n  3063‚Üí\t\telif _combat_approaching:\n  3064‚Üí\t\t\tstate_text += \"\\n(APPROACH)\"\n  3065‚Üí\n  3066‚Üí\t# Add pursuit timer info if pursuing and waiting at cover\n  3067‚Üí\tif _current_state == AIState.PURSUING:\n  3068‚Üí\t\tif _has_valid_cover and not _has_pursuit_cover:\n  3069‚Üí\t\t\tvar time_left := PURSUIT_COVER_WAIT_DURATION - _pursuit_cover_wait_timer\n  3070‚Üí\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n  3071‚Üí\t\telif _has_pursuit_cover:\n  3072‚Üí\t\t\tstate_text += \"\\n(MOVING)\"\n  3073‚Üí\n  3074‚Üí\t# Add flanking phase info if flanking\n  3075‚Üí\tif _current_state == AIState.FLANKING:\n  3076‚Üí\t\tif _has_valid_cover and not _has_flank_cover:\n  3077‚Üí\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n  3078‚Üí\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n  3079‚Üí\t\telif _has_flank_cover:\n  3080‚Üí\t\t\tstate_text += \"\\n(MOVING)\"\n  3081‚Üí\t\telse:\n  3082‚Üí\t\t\tstate_text += \"\\n(DIRECT)\"\n  3083‚Üí\n  3084‚Üí\t_debug_label.text = state_text\n  3085‚Üí\n  3086‚Üí\n  3087‚Üí## Get current AI state (for external access/debugging).\n  3088‚Üífunc get_current_state() -> AIState:\n  3089‚Üí\treturn _current_state\n  3090‚Üí\n  3091‚Üí\n  3092‚Üí## Get GOAP world state (for GOAP planner).\n  3093‚Üífunc get_goap_world_state() -> Dictionary:\n  3094‚Üí\treturn _goap_world_state.duplicate()\n  3095‚Üí\n  3096‚Üí\n  3097‚Üí## Check if enemy is currently under fire.\n  3098‚Üífunc is_under_fire() -> bool:\n  3099‚Üí\treturn _under_fire\n  3100‚Üí\n  3101‚Üí\n  3102‚Üí## Check if enemy is in cover.\n  3103‚Üífunc is_in_cover() -> bool:\n  3104‚Üí\treturn _current_state == AIState.IN_COVER or _current_state == AIState.SUPPRESSED\n  3105‚Üí\n  3106‚Üí\n  3107‚Üí## Get current ammo in magazine.\n  3108‚Üífunc get_current_ammo() -> int:\n  3109‚Üí\treturn _current_ammo\n  3110‚Üí\n  3111‚Üí\n  3112‚Üí## Get reserve ammo.\n  3113‚Üífunc get_reserve_ammo() -> int:\n  3114‚Üí\treturn _reserve_ammo\n  3115‚Üí\n  3116‚Üí\n  3117‚Üí## Get total ammo (current + reserve).\n  3118‚Üífunc get_total_ammo() -> int:\n  3119‚Üí\treturn _current_ammo + _reserve_ammo\n  3120‚Üí\n  3121‚Üí\n  3122‚Üí## Check if enemy is currently reloading.\n  3123‚Üífunc is_reloading() -> bool:\n  3124‚Üí\treturn _is_reloading\n  3125‚Üí\n  3126‚Üí\n  3127‚Üí## Check if enemy has any ammo left.\n  3128‚Üífunc has_ammo() -> bool:\n  3129‚Üí\treturn _current_ammo > 0 or _reserve_ammo > 0\n  3130‚Üí\n  3131‚Üí\n  3132‚Üí## Get current player visibility ratio (for debugging).\n  3133‚Üí## Returns 0.0 if player is completely hidden, 1.0 if fully visible.\n  3134‚Üífunc get_player_visibility_ratio() -> float:\n  3135‚Üí\treturn _player_visibility_ratio\n  3136‚Üí\n  3137‚Üí\n  3138‚Üí## Draw debug visualization when debug mode is enabled.\n  3139‚Üí## Shows: line to target (cover, clear shot, player), bullet spawn point status.\n  3140‚Üífunc _draw() -> void:\n  3141‚Üí\tif not debug_label_enabled:\n  3142‚Üí\t\treturn\n  3143‚Üí\n  3144‚Üí\t# Colors for different debug elements\n  3145‚Üí\tvar color_to_cover := Color.CYAN  # Line to cover position\n  3146‚Üí\tvar color_to_player := Color.RED  # Line to player (when visible)\n  3147‚Üí\tvar color_clear_shot := Color.YELLOW  # Line to clear shot target\n  3148‚Üí\tvar color_pursuit := Color.ORANGE  # Line to pursuit cover\n  3149‚Üí\tvar color_flank := Color.MAGENTA  # Line to flank position\n  3150‚Üí\tvar color_bullet_spawn := Color.GREEN  # Bullet spawn point indicator\n  3151‚Üí\tvar color_blocked := Color.RED  # Blocked path indicator\n  3152‚Üí\n  3153‚Üí\t# Draw line to player if visible\n  3154‚Üí\tif _can_see_player and _player:\n  3155‚Üí\t\tvar to_player := _player.global_position - global_position\n  3156‚Üí\t\tdraw_line(Vector2.ZERO, to_player, color_to_player, 1.5)\n  3157‚Üí\n  3158‚Üí\t\t# Draw bullet spawn point and check if blocked\n  3159‚Üí\t\tvar direction_to_player := to_player.normalized()\n  3160‚Üí\t\tvar spawn_point := direction_to_player * bullet_spawn_offset\n  3161‚Üí\t\tif _is_bullet_spawn_clear(direction_to_player):\n  3162‚Üí\t\t\tdraw_circle(spawn_point, 5.0, color_bullet_spawn)\n  3163‚Üí\t\telse:\n  3164‚Üí\t\t\t# Draw X for blocked spawn point\n  3165‚Üí\t\t\tdraw_line(spawn_point + Vector2(-5, -5), spawn_point + Vector2(5, 5), color_blocked, 2.0)\n  3166‚Üí\t\t\tdraw_line(spawn_point + Vector2(-5, 5), spawn_point + Vector2(5, -5), color_blocked, 2.0)\n  3167‚Üí\n  3168‚Üí\t# Draw line to cover position if we have one\n  3169‚Üí\tif _has_valid_cover:\n  3170‚Üí\t\tvar to_cover := _cover_position - global_position\n  3171‚Üí\t\tdraw_line(Vector2.ZERO, to_cover, color_to_cover, 1.5)\n  3172‚Üí\t\t# Draw small circle at cover position\n  3173‚Üí\t\tdraw_circle(to_cover, 8.0, color_to_cover)\n  3174‚Üí\n  3175‚Üí\t# Draw line to clear shot target if seeking clear shot\n  3176‚Üí\tif _seeking_clear_shot and _clear_shot_target != Vector2.ZERO:\n  3177‚Üí\t\tvar to_target := _clear_shot_target - global_position\n  3178‚Üí\t\tdraw_line(Vector2.ZERO, to_target, color_clear_shot, 2.0)\n  3179‚Üí\t\t# Draw triangle at target position\n  3180‚Üí\t\tvar target_pos := to_target\n  3181‚Üí\t\tdraw_line(target_pos + Vector2(-6, 6), target_pos + Vector2(6, 6), color_clear_shot, 2.0)\n  3182‚Üí\t\tdraw_line(target_pos + Vector2(6, 6), target_pos + Vector2(0, -8), color_clear_shot, 2.0)\n  3183‚Üí\t\tdraw_line(target_pos + Vector2(0, -8), target_pos + Vector2(-6, 6), color_clear_shot, 2.0)\n  3184‚Üí\n  3185‚Üí\t# Draw line to pursuit cover if pursuing\n  3186‚Üí\tif _current_state == AIState.PURSUING and _has_pursuit_cover:\n  3187‚Üí\t\tvar to_pursuit := _pursuit_next_cover - global_position\n  3188‚Üí\t\tdraw_line(Vector2.ZERO, to_pursuit, color_pursuit, 2.0)\n  3189‚Üí\t\tdraw_circle(to_pursuit, 8.0, color_pursuit)\n  3190‚Üí\n  3191‚Üí\t# Draw line to flank target if flanking\n  3192‚Üí\tif _current_state == AIState.FLANKING:\n  3193‚Üí\t\tif _has_flank_cover:\n  3194‚Üí\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n  3195‚Üí\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n  3196‚Üí\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n  3197‚Üí\t\telif _flank_target != Vector2.ZERO:\n  3198‚Üí\t\t\tvar to_flank := _flank_target - global_position\n  3199‚Üí\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n  3200‚Üí\t\t\t# Draw diamond at flank target\n  3201‚Üí\t\t\tvar flank_pos := to_flank\n  3202‚Üí\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n  3203‚Üí\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n  3204‚Üí\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n  3205‚Üí\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)\n  3206‚Üí\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "72d420f8-85cd-4ac1-9ac6-8923f55acf8f",
  "tool_use_result": {
    "type": "text",
    "file": {
      "filePath": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
      "content": "\n## Get AI state name as a human-readable string.\nfunc _get_state_name(state: AIState) -> String:\n\tmatch state:\n\t\tAIState.IDLE:\n\t\t\treturn \"IDLE\"\n\t\tAIState.COMBAT:\n\t\t\treturn \"COMBAT\"\n\t\tAIState.SEEKING_COVER:\n\t\t\treturn \"SEEKING_COVER\"\n\t\tAIState.IN_COVER:\n\t\t\treturn \"IN_COVER\"\n\t\tAIState.FLANKING:\n\t\t\treturn \"FLANKING\"\n\t\tAIState.SUPPRESSED:\n\t\t\treturn \"SUPPRESSED\"\n\t\tAIState.RETREATING:\n\t\t\treturn \"RETREATING\"\n\t\tAIState.PURSUING:\n\t\t\treturn \"PURSUING\"\n\t\tAIState.ASSAULT:\n\t\t\treturn \"ASSAULT\"\n\t\t_:\n\t\t\treturn \"UNKNOWN\"\n\n\n## Update the debug label with current AI state.\nfunc _update_debug_label() -> void:\n\tif _debug_label == null:\n\t\treturn\n\n\t_debug_label.visible = debug_label_enabled\n\tif not debug_label_enabled:\n\t\treturn\n\n\tvar state_text := _get_state_name(_current_state)\n\n\t# Add retreat mode info if retreating\n\tif _current_state == AIState.RETREATING:\n\t\tmatch _retreat_mode:\n\t\t\tRetreatMode.FULL_HP:\n\t\t\t\tstate_text += \"\\n(FULL_HP)\"\n\t\t\tRetreatMode.ONE_HIT:\n\t\t\t\tstate_text += \"\\n(ONE_HIT)\"\n\t\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t\tstate_text += \"\\n(MULTI_HITS)\"\n\n\t# Add assault timer info if in assault state\n\tif _current_state == AIState.ASSAULT:\n\t\tif _assault_ready:\n\t\t\tstate_text += \"\\n(RUSHING)\"\n\t\telse:\n\t\t\tvar time_left := ASSAULT_WAIT_DURATION - _assault_wait_timer\n\t\t\tstate_text += \"\\n(%.1fs)\" % time_left\n\n\t# Add combat phase info if in combat\n\tif _current_state == AIState.COMBAT:\n\t\tif _combat_exposed:\n\t\t\tvar time_left := _combat_shoot_duration - _combat_shoot_timer\n\t\t\tstate_text += \"\\n(EXPOSED %.1fs)\" % time_left\n\t\telif _seeking_clear_shot:\n\t\t\tvar time_left := CLEAR_SHOT_MAX_TIME - _clear_shot_timer\n\t\t\tstate_text += \"\\n(SEEK SHOT %.1fs)\" % time_left\n\t\telif _combat_approaching:\n\t\t\tstate_text += \"\\n(APPROACH)\"\n\n\t# Add pursuit timer info if pursuing and waiting at cover\n\tif _current_state == AIState.PURSUING:\n\t\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t\tvar time_left := PURSUIT_COVER_WAIT_DURATION - _pursuit_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_pursuit_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\n\t# Add flanking phase info if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_valid_cover and not _has_flank_cover:\n\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_flank_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\t\telse:\n\t\t\tstate_text += \"\\n(DIRECT)\"\n\n\t_debug_label.text = state_text\n\n\n## Get current AI state (for external access/debugging).\nfunc get_current_state() -> AIState:\n\treturn _current_state\n\n\n## Get GOAP world state (for GOAP planner).\nfunc get_goap_world_state() -> Dictionary:\n\treturn _goap_world_state.duplicate()\n\n\n## Check if enemy is currently under fire.\nfunc is_under_fire() -> bool:\n\treturn _under_fire\n\n\n## Check if enemy is in cover.\nfunc is_in_cover() -> bool:\n\treturn _current_state == AIState.IN_COVER or _current_state == AIState.SUPPRESSED\n\n\n## Get current ammo in magazine.\nfunc get_current_ammo() -> int:\n\treturn _current_ammo\n\n\n## Get reserve ammo.\nfunc get_reserve_ammo() -> int:\n\treturn _reserve_ammo\n\n\n## Get total ammo (current + reserve).\nfunc get_total_ammo() -> int:\n\treturn _current_ammo + _reserve_ammo\n\n\n## Check if enemy is currently reloading.\nfunc is_reloading() -> bool:\n\treturn _is_reloading\n\n\n## Check if enemy has any ammo left.\nfunc has_ammo() -> bool:\n\treturn _current_ammo > 0 or _reserve_ammo > 0\n\n\n## Get current player visibility ratio (for debugging).\n## Returns 0.0 if player is completely hidden, 1.0 if fully visible.\nfunc get_player_visibility_ratio() -> float:\n\treturn _player_visibility_ratio\n\n\n## Draw debug visualization when debug mode is enabled.\n## Shows: line to target (cover, clear shot, player), bullet spawn point status.\nfunc _draw() -> void:\n\tif not debug_label_enabled:\n\t\treturn\n\n\t# Colors for different debug elements\n\tvar color_to_cover := Color.CYAN  # Line to cover position\n\tvar color_to_player := Color.RED  # Line to player (when visible)\n\tvar color_clear_shot := Color.YELLOW  # Line to clear shot target\n\tvar color_pursuit := Color.ORANGE  # Line to pursuit cover\n\tvar color_flank := Color.MAGENTA  # Line to flank position\n\tvar color_bullet_spawn := Color.GREEN  # Bullet spawn point indicator\n\tvar color_blocked := Color.RED  # Blocked path indicator\n\n\t# Draw line to player if visible\n\tif _can_see_player and _player:\n\t\tvar to_player := _player.global_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_player, color_to_player, 1.5)\n\n\t\t# Draw bullet spawn point and check if blocked\n\t\tvar direction_to_player := to_player.normalized()\n\t\tvar spawn_point := direction_to_player * bullet_spawn_offset\n\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\tdraw_circle(spawn_point, 5.0, color_bullet_spawn)\n\t\telse:\n\t\t\t# Draw X for blocked spawn point\n\t\t\tdraw_line(spawn_point + Vector2(-5, -5), spawn_point + Vector2(5, 5), color_blocked, 2.0)\n\t\t\tdraw_line(spawn_point + Vector2(-5, 5), spawn_point + Vector2(5, -5), color_blocked, 2.0)\n\n\t# Draw line to cover position if we have one\n\tif _has_valid_cover:\n\t\tvar to_cover := _cover_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_cover, color_to_cover, 1.5)\n\t\t# Draw small circle at cover position\n\t\tdraw_circle(to_cover, 8.0, color_to_cover)\n\n\t# Draw line to clear shot target if seeking clear shot\n\tif _seeking_clear_shot and _clear_shot_target != Vector2.ZERO:\n\t\tvar to_target := _clear_shot_target - global_position\n\t\tdraw_line(Vector2.ZERO, to_target, color_clear_shot, 2.0)\n\t\t# Draw triangle at target position\n\t\tvar target_pos := to_target\n\t\tdraw_line(target_pos + Vector2(-6, 6), target_pos + Vector2(6, 6), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(6, 6), target_pos + Vector2(0, -8), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(0, -8), target_pos + Vector2(-6, 6), color_clear_shot, 2.0)\n\n\t# Draw line to pursuit cover if pursuing\n\tif _current_state == AIState.PURSUING and _has_pursuit_cover:\n\t\tvar to_pursuit := _pursuit_next_cover - global_position\n\t\tdraw_line(Vector2.ZERO, to_pursuit, color_pursuit, 2.0)\n\t\tdraw_circle(to_pursuit, 8.0, color_pursuit)\n\n\t# Draw line to flank target if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_flank_cover:\n\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n\t\telif _flank_target != Vector2.ZERO:\n\t\t\tvar to_flank := _flank_target - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n\t\t\t# Draw diamond at flank target\n\t\t\tvar flank_pos := to_flank\n\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)\n",
      "numLines": 207,
      "startLine": 3000,
      "totalLines": 3206
    }
  }
}
[2026-01-18T02:52:03.380Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01LqHGgFbEJ3C25fzY7TNPiQ",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now I have a complete understanding of the file structure. Let me implement the solution. I need to:\n\n1. Add the new `SEARCHING` state to the AIState enum\n2. Add variables for search zone and inspection points\n3. Add new state transition logic\n4. Add the new state processing function\n5. Update GOAP world state\n6. Add helper functions for inspection point generation\n\nLet me make the edits:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 3521,
      "cache_read_input_tokens": 102728,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 3521,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "7ed80743-4dfc-4f91-9b03-2b3ab447e8ef"
}
[2026-01-18T02:52:09.866Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01LqHGgFbEJ3C25fzY7TNPiQ",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01646E8kH4ArU46mWrH1YBZt",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "old_string": "## AI States for tactical behavior.\nenum AIState {\n\tIDLE,       ## Default idle state (patrol or guard)\n\tCOMBAT,     ## Actively engaging the player (coming out of cover, shooting 2-3s, returning)\n\tSEEKING_COVER,  ## Moving to cover position\n\tIN_COVER,   ## Taking cover from player fire\n\tFLANKING,   ## Attempting to flank the player\n\tSUPPRESSED, ## Under fire, staying in cover\n\tRETREATING, ## Retreating to cover while possibly shooting\n\tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n\tASSAULT     ## Coordinated multi-enemy assault (rush player after 5s wait)\n}",
          "new_string": "## AI States for tactical behavior.\nenum AIState {\n\tIDLE,       ## Default idle state (patrol or guard)\n\tCOMBAT,     ## Actively engaging the player (coming out of cover, shooting 2-3s, returning)\n\tSEEKING_COVER,  ## Moving to cover position\n\tIN_COVER,   ## Taking cover from player fire\n\tFLANKING,   ## Attempting to flank the player\n\tSUPPRESSED, ## Under fire, staying in cover\n\tRETREATING, ## Retreating to cover while possibly shooting\n\tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n\tASSAULT,    ## Coordinated multi-enemy assault (rush player after 5s wait)\n\tSEARCHING   ## Searching for player at last-known-position zone\n}"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 3521,
      "cache_read_input_tokens": 102728,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 3521,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "9ca5e603-5bf2-40dc-9357-a636f6d52e4f"
}
[2026-01-18T02:52:09.917Z] [INFO] {"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01646E8kH4ArU46mWrH1YBZt","type":"tool_result","content":"The file /tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n    10‚Üí## - Attempts to flank the player from the sides\n    11‚Üí## - Coordinates with other enemies (optional)\n    12‚Üí## - GOAP foundation for goal-oriented planning\n    13‚Üí\n    14‚Üí## AI States for tactical behavior.\n    15‚Üíenum AIState {\n    16‚Üí\tIDLE,       ## Default idle state (patrol or guard)\n    17‚Üí\tCOMBAT,     ## Actively engaging the player (coming out of cover, shooting 2-3s, returning)\n    18‚Üí\tSEEKING_COVER,  ## Moving to cover position\n    19‚Üí\tIN_COVER,   ## Taking cover from player fire\n    20‚Üí\tFLANKING,   ## Attempting to flank the player\n    21‚Üí\tSUPPRESSED, ## Under fire, staying in cover\n    22‚Üí\tRETREATING, ## Retreating to cover while possibly shooting\n    23‚Üí\tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n    24‚Üí\tASSAULT,    ## Coordinated multi-enemy assault (rush player after 5s wait)\n    25‚Üí\tSEARCHING   ## Searching for player at last-known-position zone\n    26‚Üí}\n    27‚Üí\n    28‚Üí## Retreat behavior modes based on damage taken.\n    29‚Üíenum RetreatMode {\n    30‚Üí\tFULL_HP,        ## No damage - retreat backwards while shooting, periodically turn to cover"}]},"parent_tool_use_id":null,"session_id":"797fbac8-f5e6-4339-8fd2-77453410db49","uuid":"23348232-18f6-44f5-9c3d-79ce56332dfb","tool_use_result":{"filePath":"/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd","oldString":"## AI States for tactical behavior.\nenum AIState {\n\tIDLE,       ## Default idle state (patrol or guard)\n\tCOMBAT,     ## Actively engaging the player (coming out of cover, shooting 2-3s, returning)\n\tSEEKING_COVER,  ## Moving to cover position\n\tIN_COVER,   ## Taking cover from player fire\n\tFLANKING,   ## Attempting to flank the player\n\tSUPPRESSED, ## Under fire, staying in cover\n\tRETREATING, ## Retreating to cover while possibly shooting\n\tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n\tASSAULT     ## Coordinated multi-enemy assault (rush player after 5s wait)\n}","newString":"## AI States for tactical behavior.\nenum AIState {\n\tIDLE,       ## Default idle state (patrol or guard)\n\tCOMBAT,     ## Actively engaging the player (coming out of cover, shooting 2-3s, returning)\n\tSEEKING_COVER,  ## Moving to cover position\n\tIN_COVER,   ## Taking cover from player fire\n\tFLANKING,   ## Attempting to flank the player\n\tSUPPRESSED, ## Under fire, staying in cover\n\tRETREATING, ## Retreating to cover while possibly shooting\n\tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n\tASSAULT,    ## Coordinated multi-enemy assault (rush player after 5s wait)\n\tSEARCHING   ## Searching for player at last-known-position zone\n}","originalFile":"extends CharacterBody2D\n## Enemy AI with tactical behaviors including patrol, guard, cover, and flanking.\n##\n## Supports multiple behavior modes:\n## - PATROL: Moves between patrol points\n## - GUARD: Stands in place watching for the player\n##\n## Tactical features:\n## - Uses cover when under fire (suppression)\n## - Attempts to flank the player from the sides\n## - Coordinates with other enemies (optional)\n## - GOAP foundation for goal-oriented planning\n\n## AI States for tactical behavior.\nenum AIState {\n\tIDLE,       ## Default idle state (patrol or guard)\n\tCOMBAT,     ## Actively engaging the player (coming out of cover, shooting 2-3s, returning)\n\tSEEKING_COVER,  ## Moving to cover position\n\tIN_COVER,   ## Taking cover from player fire\n\tFLANKING,   ## Attempting to flank the player\n\tSUPPRESSED, ## Under fire, staying in cover\n\tRETREATING, ## Retreating to cover while possibly shooting\n\tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n\tASSAULT     ## Coordinated multi-enemy assault (rush player after 5s wait)\n}\n\n## Retreat behavior modes based on damage taken.\nenum RetreatMode {\n\tFULL_HP,        ## No damage - retreat backwards while shooting, periodically turn to cover\n\tONE_HIT,        ## One hit taken - quick burst then retreat without shooting\n\tMULTIPLE_HITS   ## Multiple hits - quick burst then retreat without shooting (same as ONE_HIT)\n}\n\n## Behavior modes for the enemy.\nenum BehaviorMode {\n\tPATROL,  ## Moves between patrol points\n\tGUARD    ## Stands in one place\n}\n\n## Current behavior mode.\n@export var behavior_mode: BehaviorMode = BehaviorMode.GUARD\n\n## Maximum movement speed in pixels per second.\n@export var move_speed: float = 220.0\n\n## Combat movement speed (faster when flanking/seeking cover).\n@export var combat_move_speed: float = 320.0\n\n## Rotation speed in radians per second for gradual turning.\n## Default is 15 rad/sec for challenging but fair combat.\n@export var rotation_speed: float = 15.0\n\n## Detection range for spotting the player.\n## Set to 0 or negative to allow unlimited detection range (line-of-sight only).\n## This allows enemies to see the player even outside the viewport if no obstacles block view.\n@export var detection_range: float = 0.0\n\n## Time between shots in seconds.\n## Default matches assault rifle fire rate (10 shots/second = 0.1s cooldown).\n@export var shoot_cooldown: float = 0.1\n\n## Bullet scene to instantiate when shooting.\n@export var bullet_scene: PackedScene\n\n## Offset from enemy center for bullet spawn position.\n@export var bullet_spawn_offset: float = 30.0\n\n## Patrol points as offsets from the initial position.\n## Only used when behavior_mode is PATROL.\n@export var patrol_offsets: Array[Vector2] = [Vector2(100, 0), Vector2(-100, 0)]\n\n## Wait time at each patrol point in seconds.\n@export var patrol_wait_time: float = 1.5\n\n## Color when at full health.\n@export var full_health_color: Color = Color(0.9, 0.2, 0.2, 1.0)\n\n## Color when at low health (interpolates based on health percentage).\n@export var low_health_color: Color = Color(0.3, 0.1, 0.1, 1.0)\n\n## Color to flash when hit.\n@export var hit_flash_color: Color = Color(1.0, 1.0, 1.0, 1.0)\n\n## Duration of hit flash effect in seconds.\n@export var hit_flash_duration: float = 0.1\n\n## Whether to destroy the enemy after death.\n@export var destroy_on_death: bool = false\n\n## Delay before respawning or destroying (in seconds).\n@export var respawn_delay: float = 2.0\n\n## Minimum random health.\n@export var min_health: int = 2\n\n## Maximum random health.\n@export var max_health: int = 4\n\n## Threat sphere radius - bullets within this radius trigger suppression.\n@export var threat_sphere_radius: float = 100.0\n\n## Time to stay suppressed after bullets leave threat sphere.\n@export var suppression_cooldown: float = 2.0\n\n## Delay (in seconds) before reacting to bullets in the threat sphere.\n## This prevents instant reactions to nearby gunfire, giving the player more time.\n@export var threat_reaction_delay: float = 0.2\n\n## Flank angle from player's facing direction (radians).\n@export var flank_angle: float = PI / 3.0  # 60 degrees\n\n## Distance to maintain while flanking.\n@export var flank_distance: float = 200.0\n\n## Enable/disable flanking behavior.\n@export var enable_flanking: bool = true\n\n## Enable/disable cover behavior.\n@export var enable_cover: bool = true\n\n## Enable/disable debug logging.\n@export var debug_logging: bool = false\n\n## Enable/disable debug label above enemy showing current AI state.\n@export var debug_label_enabled: bool = false\n\n## Enable/disable friendly fire avoidance (don't shoot if other enemies are in the way).\n@export var enable_friendly_fire_avoidance: bool = true\n\n## Enable/disable lead prediction (shooting ahead of moving targets).\n@export var enable_lead_prediction: bool = true\n\n## Bullet speed for lead prediction calculation.\n## Should match the actual bullet speed (default is 2500 for assault rifle).\n@export var bullet_speed: float = 2500.0\n\n## Ammunition system - magazine size (bullets per magazine).\n@export var magazine_size: int = 30\n\n## Ammunition system - number of magazines the enemy carries.\n@export var total_magazines: int = 5\n\n## Ammunition system - time to reload in seconds.\n@export var reload_time: float = 3.0\n\n## Delay (in seconds) between spotting player and starting to shoot.\n## Gives player a brief reaction time when entering enemy line of sight.\n## This delay \"recharges\" each time the player breaks direct contact with the enemy.\n@export var detection_delay: float = 0.2\n\n## Minimum time (in seconds) the player must be continuously visible before\n## lead prediction is enabled. This prevents enemies from predicting player\n## position immediately when they emerge from cover.\n@export var lead_prediction_delay: float = 0.3\n\n## Minimum visibility ratio (0.0 to 1.0) of player body that must be visible\n## before lead prediction is enabled. At 1.0, the player's entire body must be\n## visible. At 0.5, at least half of the check points must be visible.\n## This prevents pre-firing at players who are at cover edges.\n@export var lead_prediction_visibility_threshold: float = 0.6\n\n## Signal emitted when the enemy is hit.\nsignal hit\n\n## Signal emitted when the enemy dies.\nsignal died\n\n## Signal emitted when AI state changes.\nsignal state_changed(new_state: AIState)\n\n## Signal emitted when ammunition changes.\nsignal ammo_changed(current_ammo: int, reserve_ammo: int)\n\n## Signal emitted when reloading starts.\nsignal reload_started\n\n## Signal emitted when reloading finishes.\nsignal reload_finished\n\n## Signal emitted when all ammunition is depleted.\nsignal ammo_depleted\n\n## Reference to the sprite for color changes.\n@onready var _sprite: Sprite2D = $Sprite2D\n\n## RayCast2D for line of sight detection.\n@onready var _raycast: RayCast2D = $RayCast2D\n\n## Debug label for showing current AI state above the enemy.\n@onready var _debug_label: Label = $DebugLabel\n\n## Wall detection raycasts for obstacle avoidance (created at runtime).\nvar _wall_raycasts: Array[RayCast2D] = []\n\n## Distance to check for walls ahead.\nconst WALL_CHECK_DISTANCE: float = 40.0\n\n## Number of raycasts for wall detection (spread around the enemy).\nconst WALL_CHECK_COUNT: int = 3\n\n## Cover detection raycasts (created at runtime).\nvar _cover_raycasts: Array[RayCast2D] = []\n\n## Number of raycasts for cover detection.\nconst COVER_CHECK_COUNT: int = 16\n\n## Distance to check for cover.\nconst COVER_CHECK_DISTANCE: float = 300.0\n\n## Current health of the enemy.\nvar _current_health: int = 0\n\n## Maximum health of the enemy (set at spawn).\nvar _max_health: int = 0\n\n## Whether the enemy is alive.\nvar _is_alive: bool = true\n\n## Reference to the player (found at runtime).\nvar _player: Node2D = null\n\n## Time since last shot.\nvar _shoot_timer: float = 0.0\n\n## Current ammo in the magazine.\nvar _current_ammo: int = 0\n\n## Reserve ammo (ammo in remaining magazines).\nvar _reserve_ammo: int = 0\n\n## Whether the enemy is currently reloading.\nvar _is_reloading: bool = false\n\n## Timer for reload progress.\nvar _reload_timer: float = 0.0\n\n## Patrol state variables.\nvar _patrol_points: Array[Vector2] = []\nvar _current_patrol_index: int = 0\nvar _is_waiting_at_patrol_point: bool = false\nvar _patrol_wait_timer: float = 0.0\nvar _initial_position: Vector2\n\n## Whether the enemy can currently see the player.\nvar _can_see_player: bool = false\n\n## Current AI state.\nvar _current_state: AIState = AIState.IDLE\n\n## Current cover position (if any).\nvar _cover_position: Vector2 = Vector2.ZERO\n\n## Is currently in a valid cover position.\nvar _has_valid_cover: bool = false\n\n## Timer for suppression cooldown.\nvar _suppression_timer: float = 0.0\n\n## Whether enemy is currently under fire (bullets in threat sphere).\nvar _under_fire: bool = false\n\n## Flank target position.\nvar _flank_target: Vector2 = Vector2.ZERO\n\n## Threat sphere Area2D for detecting nearby bullets.\nvar _threat_sphere: Area2D = null\n\n## Bullets currently in threat sphere.\nvar _bullets_in_threat_sphere: Array = []\n\n## Timer for threat reaction delay - time since first bullet entered threat sphere.\nvar _threat_reaction_timer: float = 0.0\n\n## Whether the threat reaction delay has elapsed (enemy can react to bullets).\nvar _threat_reaction_delay_elapsed: bool = false\n\n## Memory of bullets that have passed through the threat sphere recently.\n## This allows the enemy to react even after fast-moving bullets have exited.\nvar _threat_memory_timer: float = 0.0\n\n## Duration to remember that a bullet passed through the threat sphere.\n## This should be longer than the reaction delay to ensure enemies can complete\n## their reaction even after bullets have passed through quickly.\nconst THREAT_MEMORY_DURATION: float = 0.5\n\n## Current retreat mode determined by damage taken.\nvar _retreat_mode: RetreatMode = RetreatMode.FULL_HP\n\n## Number of hits taken during the current retreat/combat encounter.\n## Resets when enemy enters IDLE state or finishes retreating.\nvar _hits_taken_in_encounter: int = 0\n\n## Timer for periodic turning to cover during FULL_HP retreat.\nvar _retreat_turn_timer: float = 0.0\n\n## Duration to face cover during FULL_HP retreat turn (seconds).\nconst RETREAT_TURN_DURATION: float = 0.8\n\n## Interval between turns toward cover in FULL_HP retreat (seconds).\nconst RETREAT_TURN_INTERVAL: float = 1.5\n\n## Whether currently in the \"turn to cover\" phase of FULL_HP retreat.\nvar _retreat_turning_to_cover: bool = false\n\n## Burst fire counter for ONE_HIT retreat mode.\nvar _retreat_burst_remaining: int = 0\n\n## Timer for burst fire cooldown in ONE_HIT retreat.\nvar _retreat_burst_timer: float = 0.0\n\n## Fast cooldown between burst shots (seconds).\nconst RETREAT_BURST_COOLDOWN: float = 0.06\n\n## Whether burst fire phase is complete in ONE_HIT retreat.\nvar _retreat_burst_complete: bool = false\n\n## Accuracy reduction during retreat (multiplier for inaccuracy angle spread).\nconst RETREAT_INACCURACY_SPREAD: float = 0.15\n\n## Arc spread for ONE_HIT burst fire (radians, total spread).\nconst RETREAT_BURST_ARC: float = 0.4\n\n## Current angle offset within burst arc.\nvar _retreat_burst_angle_offset: float = 0.0\n\n## Whether enemy is in \"alarm\" mode (was suppressed/retreating and hasn't calmed down).\n## This persists until the enemy reaches safety in cover or returns to idle.\nvar _in_alarm_mode: bool = false\n\n## Whether the enemy needs to fire a cover burst (when leaving cover while in alarm).\nvar _cover_burst_pending: bool = false\n\n## --- Combat Cover Cycling (come out, shoot 2-3s, go back) ---\n## Timer for how long the enemy has been shooting while out of cover.\nvar _combat_shoot_timer: float = 0.0\n\n## Duration to shoot while out of cover (2-3 seconds, randomized).\nvar _combat_shoot_duration: float = 2.5\n\n## Whether the enemy is currently in the \"exposed shooting\" phase of combat.\nvar _combat_exposed: bool = false\n\n## Whether the enemy is in the \"approaching player\" phase of combat.\n## In this phase, the enemy moves toward the player to get into direct contact.\nvar _combat_approaching: bool = false\n\n## Timer for the approach phase of combat.\nvar _combat_approach_timer: float = 0.0\n\n## Maximum time to spend approaching player before starting to shoot (seconds).\nconst COMBAT_APPROACH_MAX_TIME: float = 2.0\n\n## Distance at which enemy is considered \"close enough\" to start shooting phase.\nconst COMBAT_DIRECT_CONTACT_DISTANCE: float = 250.0\n\n## --- Pursuit State (cover-to-cover movement) ---\n## Timer for waiting at cover during pursuit.\nvar _pursuit_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during pursuit (1-2 seconds, reduced for faster pursuit).\nconst PURSUIT_COVER_WAIT_DURATION: float = 1.5\n\n## Current pursuit target cover position.\nvar _pursuit_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid pursuit cover target.\nvar _has_pursuit_cover: bool = false\n\n## --- Flanking State (cover-to-cover movement toward flank target) ---\n## Timer for waiting at cover during flanking.\nvar _flank_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during flanking (seconds).\nconst FLANK_COVER_WAIT_DURATION: float = 0.8\n\n## Current flank cover position to move to.\nvar _flank_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid flank cover target.\nvar _has_flank_cover: bool = false\n\n## --- Assault State (coordinated multi-enemy rush) ---\n## Timer for assault wait period (5 seconds before rushing).\nvar _assault_wait_timer: float = 0.0\n\n## Duration to wait at cover before assault (5 seconds).\nconst ASSAULT_WAIT_DURATION: float = 5.0\n\n## Whether the assault wait period is complete.\nvar _assault_ready: bool = false\n\n## Whether this enemy is currently participating in an assault.\nvar _in_assault: bool = false\n\n## Distance threshold for \"close\" vs \"far\" from player.\n## Used to determine if enemy can engage from current position or needs to pursue.\nconst CLOSE_COMBAT_DISTANCE: float = 400.0\n\n## GOAP world state for goal-oriented planning.\nvar _goap_world_state: Dictionary = {}\n\n## Detection delay timer - tracks time since entering combat.\nvar _detection_timer: float = 0.0\n\n## Whether the detection delay has elapsed.\nvar _detection_delay_elapsed: bool = false\n\n## Continuous visibility timer - tracks how long the player has been continuously visible.\n## Resets when line of sight is lost.\nvar _continuous_visibility_timer: float = 0.0\n\n## Current visibility ratio of the player (0.0 to 1.0).\n## Represents what fraction of the player's body is visible to the enemy.\n## Used to determine if lead prediction should be enabled.\nvar _player_visibility_ratio: float = 0.0\n\n## --- Clear Shot Movement (move out from cover to get clear shot) ---\n## Target position to move to for getting a clear shot.\nvar _clear_shot_target: Vector2 = Vector2.ZERO\n\n## Whether we're currently moving to find a clear shot position.\nvar _seeking_clear_shot: bool = false\n\n## Timer for how long we've been trying to find a clear shot.\nvar _clear_shot_timer: float = 0.0\n\n## Maximum time to spend finding a clear shot before giving up (seconds).\nconst CLEAR_SHOT_MAX_TIME: float = 3.0\n\n## Distance to move when exiting cover to find a clear shot.\nconst CLEAR_SHOT_EXIT_DISTANCE: float = 60.0\n\n\n\nfunc _ready() -> void:\n\t_initial_position = global_position\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_setup_patrol_points()\n\t_find_player()\n\t_setup_wall_detection()\n\t_setup_cover_detection()\n\t_setup_threat_sphere()\n\t_initialize_goap_state()\n\t_connect_debug_mode_signal()\n\t_update_debug_label()\n\n\t# Log that this enemy is ready (use call_deferred to ensure FileLogger is loaded)\n\tcall_deferred(\"_log_spawn_info\")\n\n\t# Preload bullet scene if not set in inspector\n\tif bullet_scene == null:\n\t\tbullet_scene = preload(\"res://scenes/projectiles/Bullet.tscn\")\n\n\n## Initialize health with random value between min and max.\nfunc _initialize_health() -> void:\n\t_max_health = randi_range(min_health, max_health)\n\t_current_health = _max_health\n\t_is_alive = true\n\n\n## Initialize ammunition with full magazine and reserve ammo.\nfunc _initialize_ammo() -> void:\n\t_current_ammo = magazine_size\n\t# Reserve ammo is (total_magazines - 1) * magazine_size since one magazine is loaded\n\t_reserve_ammo = (total_magazines - 1) * magazine_size\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\n## Setup patrol points based on patrol offsets from initial position.\nfunc _setup_patrol_points() -> void:\n\t_patrol_points.clear()\n\t_patrol_points.append(_initial_position)\n\tfor offset in patrol_offsets:\n\t\t_patrol_points.append(_initial_position + offset)\n\n\n## Setup wall detection raycasts for obstacle avoidance.\nfunc _setup_wall_detection() -> void:\n\t# Create multiple raycasts spread in front of the enemy\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_wall_raycasts.append(raycast)\n\n\n## Setup cover detection raycasts for finding cover positions.\nfunc _setup_cover_detection() -> void:\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_cover_raycasts.append(raycast)\n\n\n## Setup threat sphere for detecting nearby bullets.\nfunc _setup_threat_sphere() -> void:\n\t_threat_sphere = Area2D.new()\n\t_threat_sphere.name = \"ThreatSphere\"\n\t_threat_sphere.collision_layer = 0\n\t_threat_sphere.collision_mask = 16  # Detect projectiles (layer 5)\n\n\tvar collision_shape := CollisionShape2D.new()\n\tvar circle_shape := CircleShape2D.new()\n\tcircle_shape.radius = threat_sphere_radius\n\tcollision_shape.shape = circle_shape\n\t_threat_sphere.add_child(collision_shape)\n\n\tadd_child(_threat_sphere)\n\n\t# Connect signals\n\t_threat_sphere.area_entered.connect(_on_threat_area_entered)\n\t_threat_sphere.area_exited.connect(_on_threat_area_exited)\n\n\n## Initialize GOAP world state.\nfunc _initialize_goap_state() -> void:\n\t_goap_world_state = {\n\t\t\"player_visible\": false,\n\t\t\"has_cover\": false,\n\t\t\"in_cover\": false,\n\t\t\"under_fire\": false,\n\t\t\"health_low\": false,\n\t\t\"can_flank\": false,\n\t\t\"at_flank_position\": false,\n\t\t\"is_retreating\": false,\n\t\t\"hits_taken\": 0,\n\t\t\"is_pursuing\": false,\n\t\t\"is_assaulting\": false,\n\t\t\"can_hit_from_cover\": false,\n\t\t\"player_close\": false,\n\t\t\"enemies_in_combat\": 0\n\t}\n\n\n## Connect to GameManager's debug mode signal for F7 toggle.\nfunc _connect_debug_mode_signal() -> void:\n\tvar game_manager: Node = get_node_or_null(\"/root/GameManager\")\n\tif game_manager:\n\t\t# Connect to debug mode toggle signal\n\t\tif game_manager.has_signal(\"debug_mode_toggled\"):\n\t\t\tgame_manager.debug_mode_toggled.connect(_on_debug_mode_toggled)\n\t\t# Sync with current debug mode state\n\t\tif game_manager.has_method(\"is_debug_mode_enabled\"):\n\t\t\tdebug_label_enabled = game_manager.is_debug_mode_enabled()\n\n\n## Called when debug mode is toggled via F7 key.\nfunc _on_debug_mode_toggled(enabled: bool) -> void:\n\tdebug_label_enabled = enabled\n\t_update_debug_label()\n\n\n## Find the player node in the scene tree.\nfunc _find_player() -> void:\n\t# Try to find the player by group first\n\tvar players := get_tree().get_nodes_in_group(\"player\")\n\tif players.size() > 0:\n\t\t_player = players[0]\n\t\treturn\n\n\t# Fallback: search for player by node name or type\n\tvar root := get_tree().current_scene\n\tif root:\n\t\t_player = _find_player_recursive(root)\n\n\n## Recursively search for a player node.\nfunc _find_player_recursive(node: Node) -> Node2D:\n\tif node.name == \"Player\" and node is Node2D:\n\t\treturn node\n\tfor child in node.get_children():\n\t\tvar result := _find_player_recursive(child)\n\t\tif result:\n\t\t\treturn result\n\treturn null\n\n\nfunc _physics_process(delta: float) -> void:\n\tif not _is_alive:\n\t\treturn\n\n\t# Update shoot cooldown timer\n\t_shoot_timer += delta\n\n\t# Update reload timer\n\t_update_reload(delta)\n\n\t# Check for player visibility and try to find player if not found\n\tif _player == null:\n\t\t_find_player()\n\n\t_check_player_visibility()\n\t_update_goap_state()\n\t_update_suppression(delta)\n\n\t# Process AI state machine\n\t_process_ai_state(delta)\n\n\t# Update debug label if enabled\n\t_update_debug_label()\n\n\t# Request redraw for debug visualization\n\tif debug_label_enabled:\n\t\tqueue_redraw()\n\n\tmove_and_slide()\n\n\n## Update GOAP world state based on current conditions.\nfunc _update_goap_state() -> void:\n\t_goap_world_state[\"player_visible\"] = _can_see_player\n\t_goap_world_state[\"under_fire\"] = _under_fire\n\t_goap_world_state[\"health_low\"] = _get_health_percent() < 0.5\n\t_goap_world_state[\"in_cover\"] = _current_state == AIState.IN_COVER\n\t_goap_world_state[\"has_cover\"] = _has_valid_cover\n\t_goap_world_state[\"is_retreating\"] = _current_state == AIState.RETREATING\n\t_goap_world_state[\"hits_taken\"] = _hits_taken_in_encounter\n\t_goap_world_state[\"is_pursuing\"] = _current_state == AIState.PURSUING\n\t_goap_world_state[\"is_assaulting\"] = _current_state == AIState.ASSAULT\n\t_goap_world_state[\"player_close\"] = _is_player_close()\n\t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n\t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()\n\n\n## Update suppression state.\nfunc _update_suppression(delta: float) -> void:\n\t# Clean up destroyed bullets from tracking\n\t_bullets_in_threat_sphere = _bullets_in_threat_sphere.filter(func(b): return is_instance_valid(b))\n\n\t# Determine if there's an active threat (bullets in sphere OR recent threat memory)\n\tvar has_active_threat := not _bullets_in_threat_sphere.is_empty() or _threat_memory_timer > 0.0\n\n\tif not has_active_threat:\n\t\tif _under_fire:\n\t\t\t_suppression_timer += delta\n\t\t\tif _suppression_timer >= suppression_cooldown:\n\t\t\t\t_under_fire = false\n\t\t\t\t_suppression_timer = 0.0\n\t\t\t\t_log_debug(\"Suppression ended\")\n\t\t# Reset threat reaction timer when no bullets are in threat sphere and no threat memory\n\t\t_threat_reaction_timer = 0.0\n\t\t_threat_reaction_delay_elapsed = false\n\telse:\n\t\t# Decrement threat memory timer if no bullets currently in sphere\n\t\tif _bullets_in_threat_sphere.is_empty() and _threat_memory_timer > 0.0:\n\t\t\t_threat_memory_timer -=
[2026-01-18T02:52:09.931Z] [INFO]  delta\n\n\t\t# Update threat reaction timer\n\t\tif not _threat_reaction_delay_elapsed:\n\t\t\t_threat_reaction_timer += delta\n\t\t\tif _threat_reaction_timer >= threat_reaction_delay:\n\t\t\t\t_threat_reaction_delay_elapsed = true\n\t\t\t\t_log_debug(\"Threat reaction delay elapsed, now reacting to bullets\")\n\n\t\t# Only set under_fire after the reaction delay has elapsed\n\t\tif _threat_reaction_delay_elapsed:\n\t\t\t_under_fire = true\n\t\t\t_suppression_timer = 0.0\n\n\n## Update reload state.\nfunc _update_reload(delta: float) -> void:\n\tif not _is_reloading:\n\t\treturn\n\n\t_reload_timer += delta\n\tif _reload_timer >= reload_time:\n\t\t_finish_reload()\n\n\n## Start reloading the weapon.\nfunc _start_reload() -> void:\n\t# Can't reload if already reloading or no reserve ammo\n\tif _is_reloading or _reserve_ammo <= 0:\n\t\treturn\n\n\t_is_reloading = true\n\t_reload_timer = 0.0\n\treload_started.emit()\n\t_log_debug(\"Reloading... (%d reserve ammo)\" % _reserve_ammo)\n\n\n## Finish the reload process.\nfunc _finish_reload() -> void:\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\t# Calculate how many rounds to load\n\tvar ammo_needed := magazine_size - _current_ammo\n\tvar ammo_to_load := mini(ammo_needed, _reserve_ammo)\n\n\t_reserve_ammo -= ammo_to_load\n\t_current_ammo += ammo_to_load\n\n\treload_finished.emit()\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\t_log_debug(\"Reload complete. Magazine: %d/%d, Reserve: %d\" % [_current_ammo, magazine_size, _reserve_ammo])\n\n\n## Check if the enemy can shoot (has ammo and not reloading).\nfunc _can_shoot() -> bool:\n\t# Can't shoot if reloading\n\tif _is_reloading:\n\t\treturn false\n\n\t# Can't shoot if no ammo in magazine\n\tif _current_ammo <= 0:\n\t\t# Try to start reload if we have reserve ammo\n\t\tif _reserve_ammo > 0:\n\t\t\t_start_reload()\n\t\telse:\n\t\t\t# No ammo at all - emit depleted signal once\n\t\t\tif not _goap_world_state.get(\"ammo_depleted\", false):\n\t\t\t\t_goap_world_state[\"ammo_depleted\"] = true\n\t\t\t\tammo_depleted.emit()\n\t\t\t\t_log_debug(\"All ammunition depleted!\")\n\t\treturn false\n\n\treturn true\n\n\n## Process the AI state machine.\nfunc _process_ai_state(delta: float) -> void:\n\tvar previous_state := _current_state\n\n\t# State transitions based on conditions\n\tmatch _current_state:\n\t\tAIState.IDLE:\n\t\t\t_process_idle_state(delta)\n\t\tAIState.COMBAT:\n\t\t\t_process_combat_state(delta)\n\t\tAIState.SEEKING_COVER:\n\t\t\t_process_seeking_cover_state(delta)\n\t\tAIState.IN_COVER:\n\t\t\t_process_in_cover_state(delta)\n\t\tAIState.FLANKING:\n\t\t\t_process_flanking_state(delta)\n\t\tAIState.SUPPRESSED:\n\t\t\t_process_suppressed_state(delta)\n\t\tAIState.RETREATING:\n\t\t\t_process_retreating_state(delta)\n\t\tAIState.PURSUING:\n\t\t\t_process_pursuing_state(delta)\n\t\tAIState.ASSAULT:\n\t\t\t_process_assault_state(delta)\n\n\tif previous_state != _current_state:\n\t\tstate_changed.emit(_current_state)\n\t\t_log_debug(\"State changed: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\t\t# Also log to file for exported build debugging\n\t\t_log_to_file(\"State: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\n\n## Process IDLE state - patrol or guard behavior.\nfunc _process_idle_state(delta: float) -> void:\n\t# Transition to combat if player is visible\n\tif _can_see_player and _player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Execute idle behavior\n\tmatch behavior_mode:\n\t\tBehaviorMode.PATROL:\n\t\t\t_process_patrol(delta)\n\t\tBehaviorMode.GUARD:\n\t\t\t_process_guard(delta)\n\n\n## Process COMBAT state - approach player for direct contact, shoot for 2-3 seconds, return to cover.\n## Implements the combat cycling behavior: exit cover -> exposed shooting -> return to cover.\n## Phase 0 (seeking clear shot): If bullet spawn blocked, move out from cover to find clear shot.\n## Phase 1 (approaching): Move toward player to get into direct contact range.\n## Phase 2 (exposed): Stand and shoot for 2-3 seconds.\n## Phase 3: Return to cover via SEEKING_COVER state.\nfunc _process_combat_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies in combat (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can't see player, pursue them (move cover-to-cover toward player)\n\tif not _can_see_player:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\t\treturn\n\n\t# Update detection delay timer\n\tif not _detection_delay_elapsed:\n\t\t_detection_timer += delta\n\t\tif _detection_timer >= detection_delay:\n\t\t\t_detection_delay_elapsed = true\n\n\t# If we don't have cover, find some first (needed for returning later)\n\tif not _has_valid_cover and enable_cover:\n\t\t_find_cover_position()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found cover at %s for combat cycling\" % _cover_position)\n\n\t# Check player distance for approach/exposed phase decisions\n\tvar distance_to_player := INF\n\tif _player:\n\t\tdistance_to_player = global_position.distance_to(_player.global_position)\n\n\t# Check if we have a clear shot (no wall blocking bullet spawn)\n\tvar direction_to_player := Vector2.ZERO\n\tvar has_clear_shot := true\n\tif _player:\n\t\tdirection_to_player = (_player.global_position - global_position).normalized()\n\t\thas_clear_shot = _is_bullet_spawn_clear(direction_to_player)\n\n\t# If already exposed (shooting phase), handle shooting and timer\n\tif _combat_exposed:\n\t\t_combat_shoot_timer += delta\n\n\t\t# Check if exposure time is complete - go back to cover\n\t\tif _combat_shoot_timer >= _combat_shoot_duration and _has_valid_cover:\n\t\t\t_log_debug(\"Combat exposure time complete (%.1fs), returning to cover\" % _combat_shoot_duration)\n\t\t\t_combat_exposed = false\n\t\t\t_combat_approaching = false\n\t\t\t_combat_shoot_timer = 0.0\n\t\t\t_transition_to_seeking_cover()\n\t\t\treturn\n\n\t\t# Check if we still have a clear shot - if not, move sideways to find one\n\t\tif _player and not has_clear_shot:\n\t\t\t# Bullet spawn is blocked - move sideways to find a clear shot position\n\t\t\tvar sidestep_dir := _find_sidestep_direction_for_clear_shot(direction_to_player)\n\t\t\tif sidestep_dir != Vector2.ZERO:\n\t\t\t\tvelocity = sidestep_dir * combat_move_speed * 0.7\n\t\t\t\trotation = direction_to_player.angle()  # Keep facing player while sidestepping\n\t\t\t\t_log_debug(\"COMBAT exposed: sidestepping to maintain clear shot\")\n\t\t\telse:\n\t\t\t\t# No sidestep works - stay still, the shot might clear up\n\t\t\t\tvelocity = Vector2.ZERO\n\t\t\treturn\n\n\t\t# In exposed phase with clear shot, stand still and shoot\n\t\tvelocity = Vector2.ZERO\n\n\t\t# Aim and shoot at player (only shoot after detection delay)\n\t\tif _player:\n\t\t\t_aim_at_player()\n\t\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot()\n\t\t\t\t_shoot_timer = 0.0\n\t\treturn\n\n\t# --- CLEAR SHOT SEEKING PHASE ---\n\t# If bullet spawn is blocked and we're not already exposed, we need to move out from cover\n\tif not has_clear_shot and _player:\n\t\t# Start seeking clear shot if not already doing so\n\t\tif not _seeking_clear_shot:\n\t\t\t_seeking_clear_shot = true\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Calculate target position: move perpendicular to player direction (around cover edge)\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\t_log_debug(\"COMBAT: bullet spawn blocked, seeking clear shot at %s\" % _clear_shot_target)\n\n\t\t_clear_shot_timer += delta\n\n\t\t# Check if we've exceeded the max time trying to find a clear shot\n\t\tif _clear_shot_timer >= CLEAR_SHOT_MAX_TIME:\n\t\t\t_log_debug(\"COMBAT: clear shot timeout, trying flanking\")\n\t\t\t_seeking_clear_shot = false\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Try flanking to get around the obstacle\n\t\t\tif enable_flanking:\n\t\t\t\t_transition_to_flanking()\n\t\t\telse:\n\t\t\t\t_transition_to_pursuing()\n\t\t\treturn\n\n\t\t# Move toward the clear shot target position\n\t\tvar distance_to_target := global_position.distance_to(_clear_shot_target)\n\t\tif distance_to_target > 15.0:\n\t\t\tvar move_direction := (_clear_shot_target - global_position).normalized()\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed\n\t\t\trotation = direction_to_player.angle()  # Keep facing player\n\n\t\t\t# Check if the new position now has a clear shot\n\t\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\t\t_log_debug(\"COMBAT: found clear shot position while moving\")\n\t\t\t\t_seeking_clear_shot = false\n\t\t\t\t_clear_shot_timer = 0.0\n\t\t\t\t# Continue to exposed phase check below\n\t\t\telse:\n\t\t\t\treturn  # Keep moving toward target\n\t\telse:\n\t\t\t# Reached target but still no clear shot - recalculate target\n\t\t\t_log_debug(\"COMBAT: reached target but no clear shot, recalculating\")\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\treturn\n\n\t# Reset seeking state if we now have a clear shot\n\tif _seeking_clear_shot and has_clear_shot:\n\t\t_log_debug(\"COMBAT: clear shot acquired\")\n\t\t_seeking_clear_shot = false\n\t\t_clear_shot_timer = 0.0\n\n\t# Determine if we should be in approach phase or exposed shooting phase\n\tvar in_direct_contact := distance_to_player <= COMBAT_DIRECT_CONTACT_DISTANCE\n\n\t# Enter exposed phase if we have a clear shot and are either close enough or have approached long enough\n\tif has_clear_shot and (in_direct_contact or _combat_approach_timer >= COMBAT_APPROACH_MAX_TIME):\n\t\t# Close enough AND have clear shot - start exposed shooting phase\n\t\t_combat_exposed = true\n\t\t_combat_approaching = false\n\t\t_combat_shoot_timer = 0.0\n\t\t_combat_approach_timer = 0.0\n\t\t# Randomize exposure duration between 2-3 seconds\n\t\t_combat_shoot_duration = randf_range(2.0, 3.0)\n\t\t_log_debug(\"COMBAT exposed phase started (distance: %.0f), will shoot for %.1fs\" % [distance_to_player, _combat_shoot_duration])\n\t\treturn\n\n\t# Need to approach player - move toward them\n\tif not _combat_approaching:\n\t\t_combat_approaching = true\n\t\t_combat_approach_timer = 0.0\n\t\t_log_debug(\"COMBAT approach phase started, moving toward player\")\n\n\t_combat_approach_timer += delta\n\n\t# Move toward player while approaching\n\tif _player:\n\t\tvar move_direction := direction_to_player\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = move_direction * combat_move_speed\n\t\trotation = direction_to_player.angle()  # Always face player\n\n\t\t# Can shoot while approaching (only after detection delay and if have clear shot)\n\t\tif has_clear_shot and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\n## Calculate a target position to exit cover and get a clear shot.\n## Returns a position that should allow the bullet spawn point to be unobstructed.\nfunc _calculate_clear_shot_exit_position(direction_to_player: Vector2) -> Vector2:\n\t# Calculate perpendicular directions to the player\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Try both perpendicular directions and pick the one that's more likely to work\n\t# Also blend with forward movement toward player to help navigate around cover\n\tvar best_position := global_position\n\tvar best_score := -1.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\t\t# Blend sidestep with forward movement for better cover navigation\n\t\tvar exit_dir: Vector2 = (sidestep_dir * 0.7 + direction_to_player * 0.3).normalized()\n\t\tvar test_position: Vector2 = global_position + exit_dir * CLEAR_SHOT_EXIT_DISTANCE\n\n\t\t# Score this position based on:\n\t\t# 1. Does it have a clear path? (no walls in the way)\n\t\t# 2. Would the bullet spawn be clear from there?\n\t\tvar score: float = 0.0\n\n\t\t# Check if we can move to this position\n\t\tif _has_clear_path_to(test_position):\n\t\t\tscore += 1.0\n\n\t\t# Check if bullet spawn would be clear from this position\n\t\t# This is a rough estimate - we check from the test position toward player\n\t\tvar world_2d := get_world_2d()\n\t\tif world_2d != null:\n\t\t\tvar space_state := world_2d.direct_space_state\n\t\t\tif space_state != null:\n\t\t\t\tvar check_distance := bullet_spawn_offset + 5.0\n\t\t\t\tvar query := PhysicsRayQueryParameters2D.new()\n\t\t\t\tquery.from = test_position\n\t\t\t\tquery.to = test_position + direction_to_player * check_distance\n\t\t\t\tquery.collision_mask = 4  # Only check obstacles\n\t\t\t\tquery.exclude = [get_rid()]\n\t\t\t\tvar result := space_state.intersect_ray(query)\n\t\t\t\tif result.is_empty():\n\t\t\t\t\tscore += 2.0  # Higher score for clear bullet spawn\n\n\t\tif score > best_score:\n\t\t\tbest_score = score\n\t\t\tbest_position = test_position\n\n\t# If no good position found, just move forward toward player\n\tif best_score < 0.5:\n\t\tbest_position = global_position + direction_to_player * CLEAR_SHOT_EXIT_DISTANCE\n\n\treturn best_position\n\n\n## Process SEEKING_COVER state - moving to cover position.\nfunc _process_seeking_cover_state(_delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, stay in combat\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're already hidden from the player (the main goal)\n\tif not _is_visible_from_player():\n\t\t_transition_to_in_cover()\n\t\t_log_debug(\"Hidden from player, entering cover state\")\n\t\treturn\n\n\t# Move towards cover\n\tvar direction := (_cover_position - global_position).normalized()\n\tvar distance := global_position.distance_to(_cover_position)\n\n\tif distance < 10.0:\n\t\t# Reached the cover position, but still visible - try to find better cover\n\t\tif _is_visible_from_player():\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\t# No better cover found, stay in combat\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\n\t# Apply wall avoidance\n\tvar avoidance := _check_wall_ahead(direction)\n\tif avoidance != Vector2.ZERO:\n\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\tvelocity = direction * combat_move_speed\n\trotation = direction.angle()\n\n\t# Can still shoot while moving to cover (only after detection delay)\n\tif _can_see_player and _player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t_aim_at_player()\n\t\t_shoot()\n\t\t_shoot_timer = 0.0\n\n\n## Process IN_COVER state - taking cover from enemy fire.\n## Decides next action based on:\n## 1. If under fire -> suppressed\n## 2. If player is close (can exit cover for direct contact) -> COMBAT\n## 3. If player is far but can hit from current position -> COMBAT (stay and shoot)\n## 4. If player is far and can't hit -> PURSUING (move cover-to-cover)\nfunc _process_in_cover_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# If still under fire, stay suppressed\n\tif _under_fire:\n\t\t_transition_to_suppressed()\n\t\treturn\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover\n\tif _is_visible_from_player():\n\t\t# If in alarm mode and can see player, fire a burst before escaping\n\t\tif _in_alarm_mode and _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"IN_COVER alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay in cover while firing burst\n\n\t\t# Burst complete or not in alarm mode, seek new cover\n\t\t_log_debug(\"Player flanked our cover position, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# Decision making based on player distance and visibility\n\tif _player:\n\t\tvar player_close := _is_player_close()\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\n\t\tif _can_see_player:\n\t\t\tif player_close:\n\t\t\t\t# Player is close - engage in combat (come out, shoot, go back)\n\t\t\t\t_log_debug(\"Player is close, transitioning to COMBAT\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\t# Player is far\n\t\t\t\tif can_hit:\n\t\t\t\t\t# Can hit from current position - come out and shoot\n\t\t\t\t\t# (Don't pursue, just transition to combat which will handle the cycling)\n\t\t\t\t\t_log_debug(\"Player is far but can hit from here, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\telse:\n\t\t\t\t\t# Can't hit from here - need to pursue (move cover-to-cover)\n\t\t\t\t\t_log_debug(\"Player is far and can't hit, transitioning to PURSUING\")\n\t\t\t\t\t_transition_to_pursuing()\n\t\t\t\t\treturn\n\n\t# If not under fire and can see player, engage (only shoot after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If player is no longer visible and not under fire, try pursuing\n\tif not _can_see_player and not _under_fire:\n\t\t_log_debug(\"Lost sight of player from cover, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\n\n## Process FLANKING state - attempting to flank the player using cover-to-cover movement.\n## Uses intermediate cover positions to navigate around obstacles instead of walking\n## directly toward the flank target.\nfunc _process_flanking_state(delta: float) -> void:\n\t# If under fire, retreat with shooting behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# If can see player, engage in combat\n\tif _can_see_player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\tif _player == null:\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# Recalculate flank position (player may have moved)\n\t_calculate_flank_position()\n\n\tvar distance_to_flank := global_position.distance_to(_flank_target)\n\n\t# Check if we've reached the flank target\n\tif distance_to_flank < 30.0:\n\t\t_log_debug(\"Reached flank position, engaging\")\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Check if we have direct line of sight to flank target (no obstacles)\n\tif _has_clear_path_to(_flank_target):\n\t\t# Direct path is clear - move directly toward flank target\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\t_has_flank_cover = false\n\t\treturn\n\n\t# Path is blocked - use cover-to-cover movement\n\n\t# If we're at a cover position, wait briefly before moving to next\n\tif _has_valid_cover and not _has_flank_cover:\n\t\t_flank_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _flank_cover_wait_timer >= FLANK_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover toward flank target\n\t\t\t_find_flank_cover_toward_target()\n\t\t\tif not _has_flank_cover:\n\t\t\t\t_log_debug(\"No flank cover found, attempting direct movement\")\n\t\t\t\t# No cover found - try direct movement with enhanced wall avoidance\n\t\t\t\tvar direction := (_flank_target - global_position).normalized()\n\t\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\t\tvelocity = direction * combat_move_speed\n\t\t\t\trotation = direction.angle()\n\t\t\t\t# Invalidate current cover to trigger new search next frame\n\t\t\t\t_has_valid_cover = false\n\t\treturn\n\n\t# If we have a flank cover target, move toward it\n\tif _has_flank_cover:\n\t\tvar direction := (_flank_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_flank_next_cover)\n\n\t\t# Check if we've reached the flank cover\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached flank cover at distance %.1f\" % distance)\n\t\t\t_has_flank_cover = false\n\t\t\t_flank_cover_wait_timer = 0.0\n\t\t\t_cover_position = _flank_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no flank cover target - find initial flank cover\n\t_find_flank_cover_toward_target()\n\tif not _has_flank_cover:\n\t\t# Can't find cover, try direct movement with wall avoidance\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\n\n## Process SUPPRESSED state - staying in cover under fire.\nfunc _process_suppressed_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover even while suppressed\n\tif _is_visible_from_player():\n\t\t# In suppressed state we're always in alarm mode - fire a burst before escaping if we can see player\n\t\tif _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"SUPPRESSED alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay suppressed while firing burst\n\n\t\t# Burst complete or can't see player, seek new cover\n\t\t_log_debug(\"Player flanked our cover position while suppressed, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Can still shoot while suppressed (only after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If no longer under fire, exit suppression\n\tif not _under_fire:\n\t\t_transition_to_in_cover()\n\n\n## Process RETREATING state - moving to cover with behavior based on damage taken.\nfunc _process_retreating_state(delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, transition to combat or suppressed\n\t\t\tif _under_fire:\n\t\t\t\t_transition_to_suppressed()\n\t\t\telse:\n\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we've reached cover and are hidden from player\n\tif not _is_visible_from_player():\n\t\t_log_debug(\"Reached cover during retreat\")\n\t\t# Reset encounter hits when successfully reaching cover\n\t\t_hits_taken_in_encounter = 0\n\t\t_transition_to_in_cover()\n\t\treturn\n\n\t# Calculate direction to cover\n\tvar direction_to_cover := (_cover_position - global_position).normalized()\n\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\n\t# Check if reached cover position\n\tif distance_to_cover < 10.0:\n\t\tif _is_visible_from_player():\n\t\t\t# Still visible, find better cover\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\tif _under_fire:\n\t\t\t\t\t_transition_to_suppressed()\n\t\t\t\telse:\n\t\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Apply retreat behavior based on mode\n\tmatch _retreat_mode:\n\t\tRetreatMode.FULL_HP:\n\t\t\t_process_retreat_full_hp(delta, direction_to_cover)\n\t\tRetreatMode.ONE_HIT:\n\t\t\t_process_retreat_one_hit(delta, direction_to_cover)\n\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t_process_retreat_multiple_hits(delta, direction_to_cover)\n\n\n## Process FULL_HP retreat: walk backwards facing player, shoot with reduced accuracy,\n## periodically turn toward cover.\nfunc _process_retreat_full_hp(delta: float, direction_to_cover: Vector2) -> void:\n\t_retreat_turn_timer += delta\n\n\tif _retreat_turning_to_cover:\n\t\t# Turning to face cover, don't shoot\n\t\tif _retreat_turn_timer >= RETREAT_TURN_DURATION:\n\t\t\t_retreat_turning_to_cover = false\n\t\t\t_retreat_turn_timer = 0.0\n\n\t\t# Face cover and move toward it\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\telse:\n\t\t# Face player and back up (walk backwards)\n\t\tif _retreat_turn_timer >= RETREAT_TURN_INTERVAL:\n\t\t\t_retreat_turning_to_cover = true\n\t\t\t_retreat_turn_timer = 0.0\n\t\t\t_log_debug(\"FULL_HP retreat: turning to check cover\")\n\n\t\tif _player:\n\t\t\t# Face the player\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\t_aim_at_player()\n\n\t\t\t# Move backwards (opposite of player direction = toward cover generally)\n\t\t\t# Use the negative of the direction we're facing for \"backing up\"\n\t\t\tvar move_direction := -direction_to_player\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed * 0.7  # Slower when backing up\n\n\t\t\t# Shoot with reduced accuracy (only after detection delay)\n\t\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot_with_inaccuracy()\n\t\t\t\t_shoot_timer = 0.0\n\n\n## Process ONE_HIT retreat: quick burst of 2-4 shots in an arc while turning, then face cover.\nfunc _process_retreat_one_hit(delta: float, direction_to_cover: Vector2) -> void:\n\tif not _retreat_burst_complete:\n\t\t# During burst phase\n\t\t_retreat_burst_timer += delta\n\n\t\tif _player and _retreat_burst_remaining > 0 and _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t# Fire a burst shot with arc spread\n\t\t\t_shoot_burst_shot()\n\t\t\t_retreat_burst_remaining -= 1\n\t\t\t_retreat_burst_timer = 0.0\n\n\t\t\t# Progress through the arc\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0  # Spread across 4 shots max\n\n\t\t# Gradually turn from player to cover during burst\n\t\tif _player:\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\tvar target_angle: float\n\n\t\t\t# Interpolate rotation from player direction to cover direction\n\t\t\tvar burst_progress := 1.0 - (float(_retreat_burst_remaining) / 4.0)\n\t\t\tvar player_angle := direction_to_player.angle()\n\t\t\tvar cover_angle := direction_to_cover.angle()\n\t\t\ttarget_angle = lerp_angle(player_angle, cover_angle, burst_progress * 0.7)\n\t\t\trotation = target_angle\n\n\t\t# Move toward cover (slower during burst)\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed * 0.5\n\n\t\t# Check if burst is complete\n\t\tif _retreat_burst_remaining <= 0:\n\t\t\t_retreat_burst_complete = true\n\t\t\t_log_debug(\"ONE_HIT retreat: burst complete, now running to cover\")\n\telse:\n\t\t# After burst, run to cover without shooting\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\n\n## Process MULTIPLE_HITS retreat: quick burst of 2-4 shots then run to cover (same as ONE_HIT).\nfunc _process_retreat_multiple_hits(delta: float, direction_to_cover: Vector2) -> void:\n\t# Same behavior as ONE_HIT - quick burst then escape\n\t_process_retreat_one_hit(delta, direction_to_cover)\n\n\n## Process PURSUING state - move cover-to-cover toward player.\n## Enemy moves between covers, waiting 1-2 seconds at each cover,\n## until they can see and hit the player.\nfunc _process_pursuing_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected during pursuit (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can see player and can hit them from current position, engage\n\tif _can_see_player and _player:\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\t\tif can_hit:\n\t\t\t_log_debug(\"Can see and hit player from pursuit, transitioning to COMBAT\")\n\t\t\t_has_pursuit_cover = false\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're waiting at cover\n\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t# Currently at cover, wait for 1-2 seconds before moving to next cover\n\t\t_pursuit_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _pursuit_cover_wait_timer >= PURSUIT_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover closer to player\n\t\t\t_log_debug(\"Pursuit wait complete, finding next cover\")\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_find_pursuit_cover_toward_player()\n\t\t\tif _has_pursuit_cover:\n\t\t\t\t_log_debug(\"Found pursuit cover at %s\" % _pursuit_next_cover)\n\t\t\telse:\n\t\t\t\t# No pursuit cover found - fallback behavior\n\t\t\t\t_log_debug(\"No pursuit cover found, checking fallback options\")\n\t\t\t\t# If we can now see the player, engage directly\n\t\t\t\tif _can_see_player:\n\t\t\t\t\t_log_debug(\"Can see player, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\t# Try flanking\n\t\t\t\tif enable_flanking and _player:\n\t\t\t\t\t_log_debug(\"Attempting flanking maneuver\")\n\t\t\t\t\t_transition_to_flanking()\n\t\t\t\t\treturn\n\t\t\t\t# Last resort: move directly toward player\n\t\t\t\t_log_debug(\"No cover options, moving directly toward player\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\treturn\n\n\t# If we have a pursuit cover target, move toward it\n\tif _has_pursuit_cover:\n\t\tvar direction := (_pursuit_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_pursuit_next_cover)\n\n\t\t# Check if we've reached the pursuit cover\n\t\t# Note: We only check distance here, NOT visibility from player.\n\t\t# If we checked visibility, the enemy would immediately consider themselves\n\t\t# \"at cover\" even before moving, since they start hidden from player.\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached pursuit cover at distance %.1f\" % distance)\n\t\t\t_has_pursuit_cover = false\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_cover_position = _pursuit_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no pursuit target - find initial pursuit cover\n\t_find_pursuit_cover_toward_player()\n\tif not _has_pursuit_cover:\n\t\t# Can't find cover to pursue, try flanking or combat\n\t\tif enable_flanking and _player:\n\t\t\t_transition_to_flanking()\n\t\telse:\n\t\t\t_transition_to_combat()\n\n\n## Process ASSAULT state - coordinated multi-enemy rush.\n## Wait at cover for 5 seconds, then all enemies rush the player simultaneously.\nfunc _process_assault_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover and not _assault_ready:\n\t\t_in_assault = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if we're the only enemy left in assault - switch back to combat\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat < 2 and not _assault_ready:\n\t\t_log_debug(\"Not enough enemies for assault, switching to COMBAT\")\n\t\t_in_assault = false\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Find closest cover to player if we don't have one\n\tif not _has_valid_cover:\n\t\t_find_cover_closest_to_player()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found assault cover at %s\" % _cover_position)\n\n\t# Move to cover position first\n\tif _has_valid_cover and not _in_assault:\n\t\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\t\tif distance_to_cover > 15.0 and _is_visible_from_player():\n\t\t\t# Still need to reach cover\n\t\t\tvar direction := (_cover_position - global_position).normalized()\n\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\tvelocity = direction * combat_move_speed\n\t\t\trotation = direction.angle()\n\t\t\treturn\n\n\t# At cover, wait for assault timer\n\tif not _assault_ready:\n\t\tvelocity = Vector2.ZERO\n\t\t_assault_wait_timer += delta\n\n\t\t# Check if all assault enemies are ready (synchronized assault)\n\t\tif _assault_wait_timer >= ASSAULT_WAIT_DURATION:\n\t\t\t# Check if situation has changed - player might have moved\n\t\t\tif _player and _is_player_close():\n\t\t\t\t_assault_ready = true\n\t\t\t\t_in_assault = true\n\t\t\t\t_log_debug(\"ASSAULT ready - rushing player!\")\n\t\t\telse:\n\t\t\t\t# Player moved away, reset timer and check if we should pursue\n\t\t\t\t_log_debug(\"Player moved away during assault wait, resetting\")\n\t\t\t\t_assault_wait_timer = 0.0\n\t\t\t\t_in_assault = false\n\t\t\t\t_transition_to_pursuing()\n\t\t\t\treturn\n\t\treturn\n\n\t# Assault phase - rush the player while shooting\n\tif _assault_ready and _player:\n\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction_to_player)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_player = (direction_to_player * 0.5 + avoidance * 0.5).normalized()\n\n\t\t# Rush at full speed\n\t\tvelocity = direction_to_player * combat_move_speed\n\t\trotation = direction_to_player.angle()\n\n\t\t# Update detection delay timer\n\t\tif not _detection_delay_elapsed:\n\t\t\t_detection_timer += delta\n\t\t\tif _detection_timer >= detection_delay:\n\t\t\t\t_detection_delay_elapsed = true\n\n\t\t# Shoot while rushing (only after detection delay)\n\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t\t# If very close to player, stay in combat\n\t\tif distance_to_player < 50.0:\n\t\t\t_log_debug(\"Assault complete - reached player\")\n\t\t\t_assault_ready = false\n\t\t\t_in_assault = false\n\t\t\t_transition_to_combat()\n\n\n## Shoot with reduced accuracy for retreat mode.\nfunc _shoot_with_inaccuracy() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Check if the shot should be taken\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Add inaccuracy spread\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD, RETREAT_INACCURACY_SPREAD)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the inaccurate shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Inaccurate shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Shoot a burst shot with arc spread for ONE_HIT retreat.\nfunc _shoot_burst_shot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Apply arc offset for burst spread\n\tdirection = direction.rotated(_retreat_burst_angle_offset)\n\n\t# Also add some random inaccuracy on top of the arc\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD * 0.5, RETREAT_INACCURACY_SPREAD * 0.5)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the burst shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Burst shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Transition to IDLE state.\nfunc _transition_to_idle() -> void:\n\t_current_state = AIState.IDLE\n\t# Reset encounter hit tracking when returning to idle\n\t_hits_taken_in_encounter = 0\n\t# Reset alarm mode when returning to idle\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\n\n## Transition to COMBAT state.\nfunc _transition_to_combat() -> void:\n\t_current_state = AIState.COMBAT\n\t# Reset detection delay timer when entering combat\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Reset combat phase variables\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_shoot_timer = 0.0\n\t_combat_approach_timer = 0.0\n\t# Reset clear shot seeking variables\n\t_seeking_clear_shot = false\n\t_clear_shot_timer = 0.0\n\t_clear_shot_target = Vector2.ZERO\n\n\n## Transition to SEEKING_COVER state.\nfunc _transition_to_seeking_cover() -> void:\n\t_current_state = AIState.SEEKING_COVER\n\t_find_cover_position()\n\n\n## Transition to IN_COVER state.\nfunc _transition_to_in_cover() -> void:\n\t_current_state = AIState.IN_COVER\n\n\n## Transition to FLANKING state.\nfunc _transition_to_flanking() -> void:\n\t_current_state = AIState.FLANKING\n\t_calculate_flank_position()\n\t_flank_cover_wait_timer = 0.0\n\t_has_flank_cover = false\n\t_has_valid_cover = false\n\n\n## Transition to SUPPRESSED state.\nfunc _transition_to_suppressed() -> void:\n\t_current_state = AIState.SUPPRESSED\n\t# Enter alarm mode when suppressed\n\t_in_alarm_mode = true\n\n\n## Transition to PURSUING state.\nfunc _transition_to_pursuing() -> void:\n\t_current_state = AIState.PURSUING\n\t_pursuit_cover_wait_timer = 0.0\n\t_has_pursuit_cover = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\n\n## Transition to ASSAULT state.\nfunc _transition_to_assault() -> void:\n\t_current_state = AIState.ASSAULT\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Find closest cover to player for assault position\n\t_find_cover_closest_to_player()\n\n\n## Transition to RETREATING state with appropriate retreat mode.\nfunc _transition_to_retreating() -> void:\n\t_current_state = AIState.RETREATING\n\t# Enter alarm mode when retreating\n\t_in_alarm_mode = true\n\n\t# Determine retreat mode based on hits taken\n\tif _hits_taken_in_encounter == 0:\n\t\t_retreat_mode = RetreatMode.FULL_HP\n\t\t_retreat_turn_timer = 0.0\n\t\t_retreat_turning_to_cover = false\n\t\t_log_debug(\"Entering RETREATING state: FULL_HP mode (shoot while backing up)\")\n\telif _hits_taken_in_encounter == 1:\n\t\t_retreat_mode = RetreatMode.ONE_HIT\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t# Calculate arc spread: shots will be distributed across the arc\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: ONE_HIT mode (burst of %d shots)\" % _retreat_burst_remaining)\n\telse:\n\t\t_retreat_mode = RetreatMode.MULTIPLE_HITS\n\t\t# Multiple hits also gets burst fire (same as ONE_HIT)\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: MULTIPLE_HITS mode (burst of %d shots)\" % _retreat_burst_remaining)\n\n\t# Find cover position for retreating\n\t_find_cover_position()\n\n\n## Check if the enemy is visible from the player's position.\n## Uses raycasting from player to enemy to determine if there are obstacles blocking line of sight.\n## This is the inverse of _can_see_player - it checks if the PLAYER can see the ENEMY.\n## Checks multiple points on the enemy body (center and corners) to account for enemy size.\nfunc _is_visible_from_player() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check visibility to multiple points on the enemy body\n\t# This accounts for the enemy's size - corners can stick out from cover\n\tvar check_points := _get_enemy_check_points(global_position)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Get multiple check points on the enemy body for visibility testing.\n## Returns center and 4 corner points offset by the enemy's radius.\nfunc _get_enemy_check_points(center: Vector2) -> Array[Vector2]:\n\t# Enemy collision radius is 24, sprite is 48x48\n\t# Use a slightly smaller radius to avoid edge cases\n\tconst ENEMY_RADIUS: float = 22.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := ENEMY_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point is visible from the player's position.\nfunc _is_point_visible_from_player(point: Vector2) -> bool:\n\tif _player == null:\n\t\treturn false\n\n\tvar player_pos := _player.global_position\n\tvar distance := player_pos.distance_to(point)\n\n\t# Use direct space state to check line of sight from player to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = player_pos\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = []\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between player and point - point is visible\n\t\treturn true\n\telse:\n\t\t# Check if we hit an obstacle before reaching the point\n\t\tvar hit_position: Vector2 = result[\"position\"]\n\t\tvar distance_to_hit := player_pos.distance_to(hit_position)\n\n\t\t# If we hit something closer than the point, the point is hidden\n\t\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t\treturn false\n\t\telse:\n\t\t\treturn true\n\n\n## Check if a specific position would make the enemy visible from the player's position.\n## Checks all enemy body points (center and corners) to account for enemy size.\n## Used to validate cover positions before moving to them.\nfunc _is_position_visible_from_player(pos: Vector2) -> bool:\n\tif _player == null:\n\t\treturn true  # Assume visible if no player\n\n\t# Check visibility for all enemy body points at the given position\n\tvar check_points := _get_enemy_check_points(pos)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Check if a target position is visible from the enemy's perspective.\n## Uses raycast to verify there are no obstacles between enemy and the target position.\n## This is used to validate lead prediction targets - enemies should only aim at\n## positions they can actually see.\nfunc _is_position_visible_to_enemy(target_pos: Vector2) -> bool:\n\tvar distance := global_position.distance_to(target_pos)\n\n\t# Use direct space state to check line of sight from enemy to target\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = target_pos\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and target - position is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t# Hit obstacle before target - position is NOT visible\n\t\t_log_debug(\"Position %s blocked by obstacle at distance %.1f (target at %.1f)\" % [target_pos, distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Get multiple check points on the player's body for visibility testing.\n## Returns center and 4 corner points offset by the player's radius.\n## The player has a collision radius of 16 pixels (from Player.tscn).\nfunc _get_player_check_points(center: Vector2) -> Array[Vector2]:\n\t# Player collision radius is 16, sprite is 32x32\n\t# Use a slightly smaller radius to be conservative\n\tconst PLAYER_RADIUS: float = 14.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := PLAYER_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point on the player is visible from the enemy's position.\n## Uses direct space state query to check for obstacles blocking line of sight.\nfunc _is_player_point_visible_to_enemy(point: Vector2) -> bool:\n\tvar distance := global_position.distance_to(point)\n\n\t# Use direct space state to check line of sight from enemy to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and point - point is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the point\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\t# If we hit something before the point, the point is blocked\n\tif distance_to_hit < distance - 5.0:  # 5 pixel tolerance\n\t\treturn false\n\n\treturn true\n\n\n## Calculate what fraction of the player's body is visible to the enemy.\n## Returns a value from 0.0 (completely hidden) to 1.0 (fully visible).\n## Checks multiple points on the player's body (center + corners).\nfunc _calculate_player_visibility_ratio() -> float:\n\tif _player == null:\n\t\treturn 0.0\n\n\tvar check_points := _get_player_check_points(_player.global_position)\n\tvar visible_count := 0\n\n\tfor point in check_points:\n\t\tif _is_player_point_visible_to_enemy(point):\n\t\t\tvisible_count += 1\n\n\treturn float(visible_count) / float(check_points.size())\n\n\n## Check if the line of fire to the target position is clear of other enemies.\n## Returns true if no other enemies would be hit by a bullet traveling to the target.\nfunc _is_firing_line_clear_of_friendlies(target_position: Vector2) -> bool:\n\tif not enable_friendly_fire_avoidance:\n\t\treturn true\n\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if any enemies are in the firing line\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 2  # Only check enemies (layer 2)\n\tquery.exclude = [get_rid()]  # Exclude self using RID\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No enemies in the way\n\n\t# Check if the hit position is before the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 20.0:  # 20 pixel tolerance\n\t\t_log_debug(\"Friendly in firing line at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if a bullet fired at the target position would be blocked by cover/obstacles.\n## Returns true if the shot would likely hit the target, false if blocked by cover.\nfunc _is_shot_clear_of_cover(target_position: Vector2) -> bool:\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if obstacles block the shot\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No obstacles in the way\n\n\t# Check if the obstacle is before the target position\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t_log_debug(\"Shot blocked by cover at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if there's an obstacle immediately in front of the enemy that would block bullets.\n## This prevents shooting into walls that the enemy is flush against or very close to.\n## Uses a single raycast from enemy center to the bullet spawn position.\nfunc _is_bullet_spawn_clear(direction: Vector2) -> bool:\n\t# Fail-open: allow shooting if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn true\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn true\n\n\t# Check from enemy center to bullet spawn position plus a small buffer\n\tvar check_distance := bullet_spawn_offset + 5.0\n\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = global_position + direction * check_distance\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]\n\n\tvar result := space_state.intersect_ray(query)\n\tif not result.is_empty():\n\t\t_log_debug(\"Bullet spawn blocked: wall at distance %.1f\" % [\n\t\t\tglobal_position.distance_to(result[\"position\"])])\n\t\treturn false\n\n\treturn true\n\n\n## Find a sidestep direction that would lead to a clear shot position.\n## Checks perpendicular directions to the player and returns the first one\n## that would allow the bullet spawn point to be clear.\n## Returns Vector2.ZERO if no clear direction is found.\nfunc _find_sidestep_direction_for_clear_shot(direction_to_player: Vector2) -> Vector2:\n\t# Fail-safe: allow normal behavior if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn Vector2.ZERO\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn Vector2.ZERO\n\n\t# Check perpendicular directions (left and right of the player direction)\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Check both sidestep directions and pick the one that leads to clear shot faster\n\tvar check_distance := 50.0  # Check if moving 50 pixels in this direction would help\n\tvar bullet_check_distance := bullet_spawn_offset + 5.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:  # Try both sides\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\n\t\t# First check if we can actually move in this direction (no wall blocking movement)\n\t\tvar move_query := PhysicsRayQueryParameters2D.new()\n\t\tmove_query.from = global_position\n\t\tmove_query.to = global_position + sidestep_dir * 30.0\n\t\tmove_query.collision_mask = 4  # Only check obstacles\n\t\tmove_query.exclude = [get_rid()]\n\n\t\tvar move_result := space_state.intersect_ray(move_query)\n\t\tif not move_result.is_empty():\n\t\t\tcontinue  # Can't move this way, wall is blocking\n\n\t\t# Check if after sidestepping, we'd have a clear shot\n\t\tvar test_position: Vector2 = global_position + sidestep_dir * check_distance\n\t\tvar shot_query := PhysicsRayQueryParameters2D.new()\n\t\tshot_query.from = test_position\n\t\tshot_query.to = test_position + direction_to_player * bullet_check_distance\n\t\tshot_query.collision_mask = 4\n\t\tshot_query.exclude = [get_rid()]\n\n\t\tvar shot_result := space_state.intersect_ray(shot_query)\n\t\tif shot_result.is_empty():\n\t\t\t# Found a direction that leads to a clear shot\n\t\t\t_log_debug(\"Found sidestep direction: %s\" % sidestep_dir)\n\t\t\treturn sidestep_dir\n\n\treturn Vector2.ZERO  # No clear sidestep direction found\n\n\n## Check if the enemy should shoot at the current target.\n## Validates bullet spawn clearance, friendly fire avoidance, and cover blocking.\nfunc _should_shoot_at_target(target_position: Vector2) -> bool:\n\t# Check if the immediate path to bullet spawn is clear\n\t# This prevents shooting into walls the enemy is flush against\n\tvar direction := (target_position - global_position).normalized()\n\tif not _is_bullet_spawn_clear(direction):\n\t\treturn false\n\n\t# Check if friendlies are in the way\n\tif not _is_firing_line_clear_of_friendlies(target_position):\n\t\treturn false\n\n\t# Check if cover blocks the shot\n\tif not _is_shot_clear_of_cover(target_position):\n\t\treturn false\n\n\treturn true\n\n\n## Check if the player is \"close\" (within CLOSE_COMBAT_DISTANCE).\n## Used to determine if the enemy should engage directly or pursue.\nfunc _is_player_close() -> bool:\n\tif _player == null:\n\t\treturn false\n\treturn global_position.distance_to(_player.global_position) <= CLOSE_COMBAT_DISTANCE\n\n\n## Check if the enemy can hit the player from their current position.\n## Returns true if there's a clear line of fire to the player.\nfunc _can_hit_player_from_current_position() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check if we can see the player\n\tif not _can_see_player:\n\t\treturn false\n\n\t# Check if the shot would be blocked by cover\n\treturn _is_shot_clear_of_cover(_player.global_position)\n\n\n## Count the number of enemies currently in combat-related states.\n## Includes COMBAT, PURSUING, ASSAULT, IN_COVER (if can see player).\n## Used to determine if multi-enemy assault should be triggered.\nfunc _count_enemies_in_combat() -> int:\n\tvar count := 0\n\tvar enemies := get_tree().get_nodes_in_group(\"enemies\")\n\n\tfor enemy in enemies:\n\t\tif enemy == self:\n\t\t\tcontinue\n\t\tif not enemy.has_method(\"get_current_state\"):\n\t\t\tcontinue\n\n\t\tvar state: AIState = enemy.get_current_state()\n\t\t# Count enemies in combat-related states\n\t\tif state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\t\t# For IN_COVER, only count if they can see the player\n\t\t\tif state == AIState.IN_COVER:\n\t\t\t\tif enemy.has_method(\"is_in_combat_engagement\") and enemy.is_in_combat_engagement():\n\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tcount += 1\n\n\t# Count self if in a combat-related state\n\tif _current_state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\tcount += 1\n\n\treturn count\n\n\n## Check if this enemy is engaged in combat (can see player and in combat state).\nfunc is_in_combat_engagement() -> bool:\n\treturn _can_see_player and _current_state in [AIState.COMBAT, AIState.IN_COVER, AIState.ASSAULT]\n\n\n## Find cover position closer to the player for pursuit.\n## Used during PURSUING state to move cover-to-cover toward the player.\nfunc _find_pursuit_cover_toward_player() -> void:\n\tif _player == null:\n\t\t_has_pursuit_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For pursuit, we want cover that is:\n\t\t\t# 1. Closer to the player than we currently are\n\t\t\t# 2. Hidden from the player (or mostly hidden)\n\t\t\t# 3. Not too far from our current position\n\n\t\t\tvar my_distance_to_player := global_position.distance_to(player_pos)\n\t\t\tvar cover_distance_to_player := cover_pos.distance_to(player_pos)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to player\n\t\t\tif cover_distance_to_player >= my_distance_to_player:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if this position is hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Hidden from player (priority)\n\t\t\t# - Closer to player\n\t\t\t# - Not too far from current position\n\t\t\tvar hidden_score: float = 5.0 if is_hidden else 0.0\n\t\t\tvar approach_score: float = (my_distance_to_player - cover_distance_to_player) / CLOSE_COMBAT_DISTANCE\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = hidden_score + approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_pursuit_next_cover = best_cover\n\t\t_has_pursuit_cover = true\n\t\t_log_debug(\"Found pursuit cover at %s (score: %.2f)\" % [_pursuit_next_cover, best_score])\n\telse:\n\t\t_has_pursuit_cover = false\n\n\n## Find cover position closest to the player for assault positioning.\n## Used during ASSAULT state to take the nearest safe cover to the player.\nfunc _find_cover_closest_to_player() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_distance: float = INF\n\tvar found_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# Check if this position is hidden from player (safe cover)\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\tif is_hidden:\n\t\t\t\t# Calculate distance from this cover to the player\n\t\t\t\tvar distance_to_player := cover_pos.distance_to(player_pos)\n\n\t\t\t\t# We want the cover closest to the player\n\t\t\t\tif distance_to_player < best_distance:\n\t\t\t\t\tbest_distance = distance_to_player\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\t\tfound_cover = true\n\n\tif found_cover:\n\t\t_cover_position = best_cover\n\t
[2026-01-18T02:52:09.951Z] [INFO] \t_has_valid_cover = true\n\t\t_log_debug(\"Found assault cover at %s (distance to player: %.1f)\" % [_cover_position, best_distance])\n\telse:\n\t\t# Fall back to normal cover finding\n\t\t_find_cover_position()\n\n\n## Find a valid cover position relative to the player.\n## The cover position must be hidden from the player's line of sight.\nfunc _find_cover_position() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_hidden_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is on the opposite side of the obstacle from player\n\t\t\tvar direction_from_player := (collision_point - player_pos).normalized()\n\n\t\t\t# Position behind cover (offset from collision point along normal)\n\t\t\t# Offset must be large enough to hide the entire enemy body (radius ~24 pixels)\n\t\t\t# Using 35 pixels to provide some margin for the enemy's collision shape\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# First priority: Check if this position is actually hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Only consider hidden positions unless we have no choice\n\t\t\tif is_hidden or not found_hidden_cover:\n\t\t\t\t# Score based on:\n\t\t\t\t# 1. Whether position is hidden (highest priority)\n\t\t\t\t# 2. Distance from enemy (closer is better)\n\t\t\t\t# 3. Position relative to player (behind cover from player's view)\n\t\t\t\tvar hidden_score: float = 10.0 if is_hidden else 0.0  # Heavy weight for hidden positions\n\n\t\t\t\tvar distance_score := 1.0 - (global_position.distance_to(cover_pos) / COVER_CHECK_DISTANCE)\n\n\t\t\t\t# Check if this position is on the far side of obstacle from player\n\t\t\t\tvar cover_direction := (cover_pos - player_pos).normalized()\n\t\t\t\tvar dot_product := direction_from_player.dot(cover_direction)\n\t\t\t\tvar blocking_score: float = maxf(0.0, dot_product)\n\n\t\t\t\tvar total_score: float = hidden_score + distance_score * 0.3 + blocking_score * 0.7\n\n\t\t\t\t# If we find a hidden position, only accept other hidden positions\n\t\t\t\tif is_hidden and not found_hidden_cover:\n\t\t\t\t\tfound_hidden_cover = true\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\telif (is_hidden or not found_hidden_cover) and total_score > best_score:\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\n\tif best_score > 0:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found cover at: %s (hidden: %s)\" % [_cover_position, found_hidden_cover])\n\telse:\n\t\t_has_valid_cover = false\n\n\n## Calculate flank position based on player location.\nfunc _calculate_flank_position() -> void:\n\tif _player == null:\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar player_to_enemy := (global_position - player_pos).normalized()\n\n\t# Choose left or right flank based on current position\n\tvar flank_side := 1.0 if randf() > 0.5 else -1.0\n\tvar flank_direction := player_to_enemy.rotated(flank_angle * flank_side)\n\n\t_flank_target = player_pos + flank_direction * flank_distance\n\t_log_debug(\"Flank target: %s\" % _flank_target)\n\n\n## Check if there's a clear path (no obstacles) to the target position.\n## Uses a raycast to check for walls/obstacles between current position and target.\nfunc _has_clear_path_to(target: Vector2) -> bool:\n\tif _raycast == null:\n\t\treturn true  # Assume clear if no raycast available\n\n\tvar direction := (target - global_position).normalized()\n\tvar distance := global_position.distance_to(target)\n\n\t_raycast.target_position = direction * distance\n\t_raycast.force_raycast_update()\n\n\t# If we hit something, path is blocked\n\tif _raycast.is_colliding():\n\t\tvar collision_point := _raycast.get_collision_point()\n\t\tvar collision_distance := global_position.distance_to(collision_point)\n\t\t# Only consider it blocked if the collision is before the target\n\t\treturn collision_distance >= distance - 10.0\n\n\treturn true\n\n\n## Find cover position closer to the flank target.\n## Used during FLANKING state to move cover-to-cover toward the flank position.\nfunc _find_flank_cover_toward_target() -> void:\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For flanking, we want cover that is:\n\t\t\t# 1. Closer to the flank target than we currently are\n\t\t\t# 2. Not too far from our current position\n\t\t\t# 3. Reachable (has clear path)\n\n\t\t\tvar my_distance_to_target := global_position.distance_to(_flank_target)\n\t\t\tvar cover_distance_to_target := cover_pos.distance_to(_flank_target)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to flank target\n\t\t\tif cover_distance_to_target >= my_distance_to_target:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if we can reach this cover (has clear path)\n\t\t\tif not _has_clear_path_to(cover_pos):\n\t\t\t\t# Even if direct path is blocked, we might be able to reach\n\t\t\t\t# via another intermediate cover, but skip for now\n\t\t\t\tcontinue\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Closer to flank target (priority)\n\t\t\t# - Not too far from current position\n\t\t\tvar approach_score: float = (my_distance_to_target - cover_distance_to_target) / flank_distance\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_flank_next_cover = best_cover\n\t\t_has_flank_cover = true\n\t\t_log_debug(\"Found flank cover at %s (score: %.2f)\" % [_flank_next_cover, best_score])\n\telse:\n\t\t_has_flank_cover = false\n\n\n## Check if there's a wall ahead in the given direction and return avoidance direction.\n## Returns Vector2.ZERO if no wall detected, otherwise returns a vector to avoid the wall.\nfunc _check_wall_ahead(direction: Vector2) -> Vector2:\n\tif _wall_raycasts.is_empty():\n\t\treturn Vector2.ZERO\n\n\tvar avoidance := Vector2.ZERO\n\tvar perpendicular := Vector2(-direction.y, direction.x)  # 90 degrees rotation\n\n\t# Check center, left, and right raycasts\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar angle_offset := (i - 1) * 0.5  # -0.5, 0, 0.5 radians (~-28, 0, 28 degrees)\n\t\tvar check_direction := direction.rotated(angle_offset)\n\n\t\tvar raycast := _wall_raycasts[i]\n\t\traycast.target_position = check_direction * WALL_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\t# Calculate avoidance based on which raycast hit\n\t\t\tif i == 0:  # Left raycast hit\n\t\t\t\tavoidance += perpendicular  # Steer right\n\t\t\telif i == 1:  # Center raycast hit\n\t\t\t\tavoidance += perpendicular if randf() > 0.5 else -perpendicular  # Random steer\n\t\t\telif i == 2:  # Right raycast hit\n\t\t\t\tavoidance -= perpendicular  # Steer left\n\n\treturn avoidance.normalized() if avoidance.length() > 0 else Vector2.ZERO\n\n\n## Check if the player is visible using raycast.\n## If detection_range is 0 or negative, uses unlimited detection range (line-of-sight only).\n## This allows the enemy to see the player even outside the viewport if there's no obstacle.\n## Also updates the continuous visibility timer and visibility ratio for lead prediction control.\nfunc _check_player_visibility() -> void:\n\tvar was_visible := _can_see_player\n\t_can_see_player = false\n\t_player_visibility_ratio = 0.0\n\n\tif _player == null or not _raycast:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t# Check if player is within detection range (only if detection_range is positive)\n\t# If detection_range <= 0, detection is unlimited (line-of-sight only)\n\tif detection_range > 0 and distance_to_player > detection_range:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\t# Point raycast at player - use actual distance to player for the raycast length\n\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\tvar raycast_length := distance_to_player + 10.0  # Add small buffer to ensure we reach player\n\t_raycast.target_position = direction_to_player * raycast_length\n\t_raycast.force_raycast_update()\n\n\t# Check if raycast hit something\n\tif _raycast.is_colliding():\n\t\tvar collider := _raycast.get_collider()\n\t\t# If we hit the player, we can see them\n\t\tif collider == _player:\n\t\t\t_can_see_player = true\n\t\t# If we hit a wall/obstacle before the player, we can't see them\n\telse:\n\t\t# No collision between us and player - we have clear line of sight\n\t\t_can_see_player = true\n\n\t# Update continuous visibility timer and visibility ratio\n\tif _can_see_player:\n\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n\t\t# Calculate what fraction of the player's body is visible\n\t\t# This is used to determine if lead prediction should be enabled\n\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n\telse:\n\t\t# Lost line of sight - reset the timer and visibility ratio\n\t\t_continuous_visibility_timer = 0.0\n\t\t_player_visibility_ratio = 0.0\n\n\n## Aim the enemy sprite/direction at the player using gradual rotation.\nfunc _aim_at_player() -> void:\n\tif _player == null:\n\t\treturn\n\tvar direction := (_player.global_position - global_position).normalized()\n\tvar target_angle := direction.angle()\n\n\t# Calculate the shortest rotation direction\n\tvar angle_diff := wrapf(target_angle - rotation, -PI, PI)\n\n\t# Get the delta time from the current physics process\n\tvar delta := get_physics_process_delta_time()\n\n\t# Apply gradual rotation based on rotation_speed\n\tif abs(angle_diff) <= rotation_speed * delta:\n\t\t# Close enough to snap to target\n\t\trotation = target_angle\n\telif angle_diff > 0:\n\t\trotation += rotation_speed * delta\n\telse:\n\t\trotation -= rotation_speed * delta\n\n\n## Shoot a bullet towards the player.\nfunc _shoot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\t# Check if we can shoot (have ammo and not reloading)\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Apply lead prediction if enabled\n\tif enable_lead_prediction:\n\t\ttarget_position = _calculate_lead_prediction()\n\n\t# Check if the shot should be taken (friendly fire and cover checks)\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Create bullet instance\n\tvar bullet := bullet_scene.instantiate()\n\n\t# Set bullet position with offset in shoot direction\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\n\t# Set bullet direction\n\tbullet.direction = direction\n\n\t# Set shooter ID to identify this enemy as the source\n\t# This prevents enemies from detecting their own bullets in the threat sphere\n\tbullet.shooter_id = get_instance_id()\n\n\t# Add bullet to the scene tree\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play shooting sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\n\t# Play shell casing sound with a small delay\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\t# Auto-reload when magazine is empty\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Play shell casing sound with a delay to simulate the casing hitting the ground.\nfunc _play_delayed_shell_sound() -> void:\n\tawait get_tree().create_timer(0.15).timeout\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_shell_rifle\"):\n\t\taudio_manager.play_shell_rifle(global_position)\n\n\n## Calculate lead prediction - aims where the player will be, not where they are.\n## Uses iterative approach for better accuracy with moving targets.\n## Only applies lead prediction if:\n## 1. The player has been continuously visible for at least lead_prediction_delay seconds\n## 2. At least lead_prediction_visibility_threshold of the player's body is visible\n## 3. The predicted position is also visible to the enemy (not behind cover)\n## This prevents enemies from \"knowing\" where the player will emerge from cover.\nfunc _calculate_lead_prediction() -> Vector2:\n\tif _player == null:\n\t\treturn global_position\n\n\tvar player_pos := _player.global_position\n\n\t# Only use lead prediction if the player has been continuously visible\n\t# for long enough. This prevents enemies from predicting player position\n\t# immediately when they emerge from cover.\n\tif _continuous_visibility_timer < lead_prediction_delay:\n\t\t_log_debug(\"Lead prediction disabled: visibility time %.2fs < %.2fs required\" % [_continuous_visibility_timer, lead_prediction_delay])\n\t\treturn player_pos\n\n\t# Only use lead prediction if enough of the player's body is visible.\n\t# This prevents pre-firing when the player is at the edge of cover with only\n\t# a small part of their body visible. The player must be significantly exposed\n\t# before the enemy can predict their movement.\n\tif _player_visibility_ratio < lead_prediction_visibility_threshold:\n\t\t_log_debug(\"Lead prediction disabled: visibility ratio %.2f < %.2f required (player at cover edge)\" % [_player_visibility_ratio, lead_prediction_visibility_threshold])\n\t\treturn player_pos\n\n\tvar player_velocity := Vector2.ZERO\n\n\t# Get player velocity if they are a CharacterBody2D\n\tif _player is CharacterBody2D:\n\t\tplayer_velocity = _player.velocity\n\n\t# If player is stationary, no need for prediction\n\tif player_velocity.length_squared() < 1.0:\n\t\treturn player_pos\n\n\t# Iterative lead prediction for better accuracy\n\t# Start with player's current position\n\tvar predicted_pos := player_pos\n\tvar distance := global_position.distance_to(predicted_pos)\n\n\t# Iterate 2-3 times for convergence\n\tfor i in range(3):\n\t\t# Time for bullet to reach the predicted position\n\t\tvar time_to_target := distance / bullet_speed\n\n\t\t# Predict where player will be at that time\n\t\tpredicted_pos = player_pos + player_velocity * time_to_target\n\n\t\t# Update distance for next iteration\n\t\tdistance = global_position.distance_to(predicted_pos)\n\n\t# CRITICAL: Validate that the predicted position is actually visible to the enemy.\n\t# If the predicted position is behind cover (e.g., player is running toward cover exit),\n\t# we should NOT aim there - it would feel like the enemy is \"cheating\" by knowing\n\t# where the player will emerge. Fall back to player's current visible position.\n\tif not _is_position_visible_to_enemy(predicted_pos):\n\t\t_log_debug(\"Lead prediction blocked: predicted position %s is not visible, using current position %s\" % [predicted_pos, player_pos])\n\t\treturn player_pos\n\n\t_log_debug(\"Lead prediction: player at %s moving %s, aiming at %s\" % [player_pos, player_velocity, predicted_pos])\n\n\treturn predicted_pos\n\n\n## Process patrol behavior - move between patrol points.\nfunc _process_patrol(delta: float) -> void:\n\tif _patrol_points.is_empty():\n\t\treturn\n\n\t# Handle waiting at patrol point\n\tif _is_waiting_at_patrol_point:\n\t\t_patrol_wait_timer += delta\n\t\tif _patrol_wait_timer >= patrol_wait_time:\n\t\t\t_is_waiting_at_patrol_point = false\n\t\t\t_patrol_wait_timer = 0.0\n\t\t\t_current_patrol_index = (_current_patrol_index + 1) % _patrol_points.size()\n\t\tvelocity = Vector2.ZERO\n\t\treturn\n\n\t# Move towards current patrol point\n\tvar target_point := _patrol_points[_current_patrol_index]\n\tvar direction := (target_point - global_position).normalized()\n\tvar distance := global_position.distance_to(target_point)\n\n\tif distance < 5.0:\n\t\t# Reached patrol point, start waiting\n\t\t_is_waiting_at_patrol_point = true\n\t\tvelocity = Vector2.ZERO\n\telse:\n\t\t# Check for walls and apply avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\t# Blend movement direction with avoidance\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * move_speed\n\t\t# Face movement direction when patrolling\n\t\trotation = direction.angle()\n\n\n## Process guard behavior - stand still and look around.\nfunc _process_guard(_delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\t# In guard mode, enemy doesn't move but can still aim at player when visible\n\n\n## Called when a bullet enters the threat sphere.\nfunc _on_threat_area_entered(area: Area2D) -> void:\n\t# Check if bullet has shooter_id property and if it's from this enemy\n\t# This prevents enemies from being suppressed by their own bullets\n\tif \"shooter_id\" in area and area.shooter_id == get_instance_id():\n\t\treturn  # Ignore own bullets\n\n\t_bullets_in_threat_sphere.append(area)\n\t# Set threat memory timer so enemy can react even after fast bullets exit\n\t# This allows the reaction delay to complete even if bullets pass through quickly\n\t_threat_memory_timer = THREAT_MEMORY_DURATION\n\t# Note: _under_fire is now set in _update_suppression after threat_reaction_delay\n\t# This gives the player more time before the enemy reacts to nearby gunfire\n\t_log_debug(\"Bullet entered threat sphere, starting reaction delay...\")\n\n\n## Called when a bullet exits the threat sphere.\nfunc _on_threat_area_exited(area: Area2D) -> void:\n\t_bullets_in_threat_sphere.erase(area)\n\n\n## Called when the enemy is hit (by bullet.gd).\nfunc on_hit() -> void:\n\tif not _is_alive:\n\t\treturn\n\n\thit.emit()\n\n\t# Track hits for retreat behavior\n\t_hits_taken_in_encounter += 1\n\t_log_debug(\"Hit taken! Total hits in encounter: %d\" % _hits_taken_in_encounter)\n\t_log_to_file(\"Hit taken, health: %d/%d\" % [_current_health - 1, _max_health])\n\n\t# Show hit flash effect\n\t_show_hit_flash()\n\n\t# Apply damage\n\t_current_health -= 1\n\n\t# Play appropriate hit sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif _current_health <= 0:\n\t\t# Play lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_lethal\"):\n\t\t\taudio_manager.play_hit_lethal(global_position)\n\t\t_on_death()\n\telse:\n\t\t# Play non-lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_non_lethal\"):\n\t\t\taudio_manager.play_hit_non_lethal(global_position)\n\t\t_update_health_visual()\n\n\n## Shows a brief flash effect when hit.\nfunc _show_hit_flash() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t_sprite.modulate = hit_flash_color\n\n\tawait get_tree().create_timer(hit_flash_duration).timeout\n\n\t# Restore color based on current health (if still alive)\n\tif _is_alive:\n\t\t_update_health_visual()\n\n\n## Updates the sprite color based on current health percentage.\nfunc _update_health_visual() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t# Interpolate color based on health percentage\n\tvar health_percent := _get_health_percent()\n\t_sprite.modulate = full_health_color.lerp(low_health_color, 1.0 - health_percent)\n\n\n## Returns the current health as a percentage (0.0 to 1.0).\nfunc _get_health_percent() -> float:\n\tif _max_health <= 0:\n\t\treturn 0.0\n\treturn float(_current_health) / float(_max_health)\n\n\n## Called when the enemy dies.\nfunc _on_death() -> void:\n\t_is_alive = false\n\t_log_to_file(\"Enemy died\")\n\tdied.emit()\n\n\tif destroy_on_death:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\tqueue_free()\n\telse:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\t_reset()\n\n\n## Resets the enemy to its initial state.\nfunc _reset() -> void:\n\tglobal_position = _initial_position\n\trotation = 0.0\n\t_current_patrol_index = 0\n\t_is_waiting_at_patrol_point = false\n\t_patrol_wait_timer = 0.0\n\t_current_state = AIState.IDLE\n\t_has_valid_cover = false\n\t_under_fire = false\n\t_suppression_timer = 0.0\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t_continuous_visibility_timer = 0.0\n\t_player_visibility_ratio = 0.0\n\t_threat_reaction_timer = 0.0\n\t_threat_reaction_delay_elapsed = false\n\t_threat_memory_timer = 0.0\n\t_bullets_in_threat_sphere.clear()\n\t# Reset retreat state variables\n\t_hits_taken_in_encounter = 0\n\t_retreat_mode = RetreatMode.FULL_HP\n\t_retreat_turn_timer = 0.0\n\t_retreat_turning_to_cover = false\n\t_retreat_burst_remaining = 0\n\t_retreat_burst_timer = 0.0\n\t_retreat_burst_complete = false\n\t_retreat_burst_angle_offset = 0.0\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\t# Reset combat state variables\n\t_combat_shoot_timer = 0.0\n\t_combat_shoot_duration = 2.5\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_approach_timer = 0.0\n\t# Reset pursuit state variables\n\t_pursuit_cover_wait_timer = 0.0\n\t_pursuit_next_cover = Vector2.ZERO\n\t_has_pursuit_cover = false\n\t# Reset assault state variables\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset flank state variables\n\t_flank_cover_wait_timer = 0.0\n\t_flank_next_cover = Vector2.ZERO\n\t_has_flank_cover = false\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_initialize_goap_state()\n\n\n## Log debug message if debug_logging is enabled.\nfunc _log_debug(message: String) -> void:\n\tif debug_logging:\n\t\tprint(\"[Enemy %s] %s\" % [name, message])\n\n\n## Log a message to the file logger (always logs, regardless of debug_logging setting).\n## Use for important events like spawning, dying, or critical state changes.\nfunc _log_to_file(message: String) -> void:\n\tif not is_inside_tree():\n\t\treturn\n\tvar file_logger: Node = get_node_or_null(\"/root/FileLogger\")\n\tif file_logger and file_logger.has_method(\"log_enemy\"):\n\t\tfile_logger.log_enemy(name, message)\n\n\n## Log spawn info (called via call_deferred to ensure FileLogger is loaded).\nfunc _log_spawn_info() -> void:\n\t_log_to_file(\"Enemy spawned at %s, health: %d, behavior: %s, player_found: %s\" % [\n\t\tglobal_position, _max_health, BehaviorMode.keys()[behavior_mode],\n\t\t\"yes\" if _player != null else \"no\"])\n\n\n## Get AI state name as a human-readable string.\nfunc _get_state_name(state: AIState) -> String:\n\tmatch state:\n\t\tAIState.IDLE:\n\t\t\treturn \"IDLE\"\n\t\tAIState.COMBAT:\n\t\t\treturn \"COMBAT\"\n\t\tAIState.SEEKING_COVER:\n\t\t\treturn \"SEEKING_COVER\"\n\t\tAIState.IN_COVER:\n\t\t\treturn \"IN_COVER\"\n\t\tAIState.FLANKING:\n\t\t\treturn \"FLANKING\"\n\t\tAIState.SUPPRESSED:\n\t\t\treturn \"SUPPRESSED\"\n\t\tAIState.RETREATING:\n\t\t\treturn \"RETREATING\"\n\t\tAIState.PURSUING:\n\t\t\treturn \"PURSUING\"\n\t\tAIState.ASSAULT:\n\t\t\treturn \"ASSAULT\"\n\t\t_:\n\t\t\treturn \"UNKNOWN\"\n\n\n## Update the debug label with current AI state.\nfunc _update_debug_label() -> void:\n\tif _debug_label == null:\n\t\treturn\n\n\t_debug_label.visible = debug_label_enabled\n\tif not debug_label_enabled:\n\t\treturn\n\n\tvar state_text := _get_state_name(_current_state)\n\n\t# Add retreat mode info if retreating\n\tif _current_state == AIState.RETREATING:\n\t\tmatch _retreat_mode:\n\t\t\tRetreatMode.FULL_HP:\n\t\t\t\tstate_text += \"\\n(FULL_HP)\"\n\t\t\tRetreatMode.ONE_HIT:\n\t\t\t\tstate_text += \"\\n(ONE_HIT)\"\n\t\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t\tstate_text += \"\\n(MULTI_HITS)\"\n\n\t# Add assault timer info if in assault state\n\tif _current_state == AIState.ASSAULT:\n\t\tif _assault_ready:\n\t\t\tstate_text += \"\\n(RUSHING)\"\n\t\telse:\n\t\t\tvar time_left := ASSAULT_WAIT_DURATION - _assault_wait_timer\n\t\t\tstate_text += \"\\n(%.1fs)\" % time_left\n\n\t# Add combat phase info if in combat\n\tif _current_state == AIState.COMBAT:\n\t\tif _combat_exposed:\n\t\t\tvar time_left := _combat_shoot_duration - _combat_shoot_timer\n\t\t\tstate_text += \"\\n(EXPOSED %.1fs)\" % time_left\n\t\telif _seeking_clear_shot:\n\t\t\tvar time_left := CLEAR_SHOT_MAX_TIME - _clear_shot_timer\n\t\t\tstate_text += \"\\n(SEEK SHOT %.1fs)\" % time_left\n\t\telif _combat_approaching:\n\t\t\tstate_text += \"\\n(APPROACH)\"\n\n\t# Add pursuit timer info if pursuing and waiting at cover\n\tif _current_state == AIState.PURSUING:\n\t\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t\tvar time_left := PURSUIT_COVER_WAIT_DURATION - _pursuit_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_pursuit_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\n\t# Add flanking phase info if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_valid_cover and not _has_flank_cover:\n\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_flank_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\t\telse:\n\t\t\tstate_text += \"\\n(DIRECT)\"\n\n\t_debug_label.text = state_text\n\n\n## Get current AI state (for external access/debugging).\nfunc get_current_state() -> AIState:\n\treturn _current_state\n\n\n## Get GOAP world state (for GOAP planner).\nfunc get_goap_world_state() -> Dictionary:\n\treturn _goap_world_state.duplicate()\n\n\n## Check if enemy is currently under fire.\nfunc is_under_fire() -> bool:\n\treturn _under_fire\n\n\n## Check if enemy is in cover.\nfunc is_in_cover() -> bool:\n\treturn _current_state == AIState.IN_COVER or _current_state == AIState.SUPPRESSED\n\n\n## Get current ammo in magazine.\nfunc get_current_ammo() -> int:\n\treturn _current_ammo\n\n\n## Get reserve ammo.\nfunc get_reserve_ammo() -> int:\n\treturn _reserve_ammo\n\n\n## Get total ammo (current + reserve).\nfunc get_total_ammo() -> int:\n\treturn _current_ammo + _reserve_ammo\n\n\n## Check if enemy is currently reloading.\nfunc is_reloading() -> bool:\n\treturn _is_reloading\n\n\n## Check if enemy has any ammo left.\nfunc has_ammo() -> bool:\n\treturn _current_ammo > 0 or _reserve_ammo > 0\n\n\n## Get current player visibility ratio (for debugging).\n## Returns 0.0 if player is completely hidden, 1.0 if fully visible.\nfunc get_player_visibility_ratio() -> float:\n\treturn _player_visibility_ratio\n\n\n## Draw debug visualization when debug mode is enabled.\n## Shows: line to target (cover, clear shot, player), bullet spawn point status.\nfunc _draw() -> void:\n\tif not debug_label_enabled:\n\t\treturn\n\n\t# Colors for different debug elements\n\tvar color_to_cover := Color.CYAN  # Line to cover position\n\tvar color_to_player := Color.RED  # Line to player (when visible)\n\tvar color_clear_shot := Color.YELLOW  # Line to clear shot target\n\tvar color_pursuit := Color.ORANGE  # Line to pursuit cover\n\tvar color_flank := Color.MAGENTA  # Line to flank position\n\tvar color_bullet_spawn := Color.GREEN  # Bullet spawn point indicator\n\tvar color_blocked := Color.RED  # Blocked path indicator\n\n\t# Draw line to player if visible\n\tif _can_see_player and _player:\n\t\tvar to_player := _player.global_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_player, color_to_player, 1.5)\n\n\t\t# Draw bullet spawn point and check if blocked\n\t\tvar direction_to_player := to_player.normalized()\n\t\tvar spawn_point := direction_to_player * bullet_spawn_offset\n\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\tdraw_circle(spawn_point, 5.0, color_bullet_spawn)\n\t\telse:\n\t\t\t# Draw X for blocked spawn point\n\t\t\tdraw_line(spawn_point + Vector2(-5, -5), spawn_point + Vector2(5, 5), color_blocked, 2.0)\n\t\t\tdraw_line(spawn_point + Vector2(-5, 5), spawn_point + Vector2(5, -5), color_blocked, 2.0)\n\n\t# Draw line to cover position if we have one\n\tif _has_valid_cover:\n\t\tvar to_cover := _cover_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_cover, color_to_cover, 1.5)\n\t\t# Draw small circle at cover position\n\t\tdraw_circle(to_cover, 8.0, color_to_cover)\n\n\t# Draw line to clear shot target if seeking clear shot\n\tif _seeking_clear_shot and _clear_shot_target != Vector2.ZERO:\n\t\tvar to_target := _clear_shot_target - global_position\n\t\tdraw_line(Vector2.ZERO, to_target, color_clear_shot, 2.0)\n\t\t# Draw triangle at target position\n\t\tvar target_pos := to_target\n\t\tdraw_line(target_pos + Vector2(-6, 6), target_pos + Vector2(6, 6), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(6, 6), target_pos + Vector2(0, -8), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(0, -8), target_pos + Vector2(-6, 6), color_clear_shot, 2.0)\n\n\t# Draw line to pursuit cover if pursuing\n\tif _current_state == AIState.PURSUING and _has_pursuit_cover:\n\t\tvar to_pursuit := _pursuit_next_cover - global_position\n\t\tdraw_line(Vector2.ZERO, to_pursuit, color_pursuit, 2.0)\n\t\tdraw_circle(to_pursuit, 8.0, color_pursuit)\n\n\t# Draw line to flank target if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_flank_cover:\n\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n\t\telif _flank_target != Vector2.ZERO:\n\t\t\tvar to_flank := _flank_target - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n\t\t\t# Draw diamond at flank target\n\t\t\tvar flank_pos := to_flank\n\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)\n","structuredPatch":[{"oldStart":21,"oldLines":7,"newStart":21,"newLines":8,"lines":["   SUPPRESSED, ## Under fire, staying in cover","   RETREATING, ## Retreating to cover while possibly shooting","   PURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)","-  ASSAULT     ## Coordinated multi-enemy assault (rush player after 5s wait)","+  ASSAULT,    ## Coordinated multi-enemy assault (rush player after 5s wait)","+  SEARCHING   ## Searching for player at last-known-position zone"," }"," "," ## Retreat behavior modes based on damage taken."]}],"userModified":false,"replaceAll":false}}
[2026-01-18T02:52:20.890Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_011g6e6Kj1wwjYXTevpQqbCm",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01Vk1g6PKbZbsTSU8ScVyN8Y",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "old_string": "## Distance threshold for \"close\" vs \"far\" from player.\n## Used to determine if enemy can engage from current position or needs to pursue.\nconst CLOSE_COMBAT_DISTANCE: float = 400.0\n\n## GOAP world state for goal-oriented planning.\nvar _goap_world_state: Dictionary = {}",
          "new_string": "## Distance threshold for \"close\" vs \"far\" from player.\n## Used to determine if enemy can engage from current position or needs to pursue.\nconst CLOSE_COMBAT_DISTANCE: float = 400.0\n\n## GOAP world state for goal-oriented planning.\nvar _goap_world_state: Dictionary = {}\n\n## --- Search/Investigation State (for when player escapes from view) ---\n## Last known position where the player was seen before escaping view.\nvar _last_known_player_position: Vector2 = Vector2.ZERO\n\n## Whether a search zone is currently active.\nvar _search_zone_active: bool = false\n\n## Radius of the potential player zone (area where player might be hiding).\nconst SEARCH_ZONE_RADIUS: float = 200.0\n\n## Timer for search timeout - enemy gives up searching after this time.\nvar _search_timer: float = 0.0\n\n## Maximum time to spend searching before giving up (seconds).\nconst SEARCH_MAX_DURATION: float = 15.0\n\n## Inspection points within the search zone (hiding spots behind covers and corners).\nvar _inspection_points: Array[Vector2] = []\n\n## Index of current inspection point being checked.\nvar _current_inspection_index: int = 0\n\n## Timer for waiting at each inspection point (looking around).\nvar _inspection_wait_timer: float = 0.0\n\n## Duration to wait at each inspection point (seconds).\nconst INSPECTION_WAIT_DURATION: float = 1.5\n\n## Whether currently waiting at an inspection point.\nvar _inspecting_point: bool = false\n\n## Number of raycasts for detecting inspection points (corners/hiding spots).\nconst INSPECTION_POINT_CHECK_COUNT: int = 24\n\n## Distance to check for inspection points from search zone center.\nconst INSPECTION_CHECK_DISTANCE: float = 250.0"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 975,
      "cache_read_input_tokens": 106249,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 975,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 24,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "f39d95c8-b88f-4332-9ee8-39e076a7cfd0"
}
[2026-01-18T02:52:20.939Z] [INFO] {"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Vk1g6PKbZbsTSU8ScVyN8Y","type":"tool_result","content":"The file /tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   392‚Üí\n   393‚Üí## Whether this enemy is currently participating in an assault.\n   394‚Üívar _in_assault: bool = false\n   395‚Üí\n   396‚Üí## Distance threshold for \"close\" vs \"far\" from player.\n   397‚Üí## Used to determine if enemy can engage from current position or needs to pursue.\n   398‚Üíconst CLOSE_COMBAT_DISTANCE: float = 400.0\n   399‚Üí\n   400‚Üí## GOAP world state for goal-oriented planning.\n   401‚Üívar _goap_world_state: Dictionary = {}\n   402‚Üí\n   403‚Üí## --- Search/Investigation State (for when player escapes from view) ---\n   404‚Üí## Last known position where the player was seen before escaping view.\n   405‚Üívar _last_known_player_position: Vector2 = Vector2.ZERO\n   406‚Üí\n   407‚Üí## Whether a search zone is currently active.\n   408‚Üívar _search_zone_active: bool = false\n   409‚Üí\n   410‚Üí## Radius of the potential player zone (area where player might be hiding).\n   411‚Üíconst SEARCH_ZONE_RADIUS: float = 200.0\n   412‚Üí\n   413‚Üí## Timer for search timeout - enemy gives up searching after this time.\n   414‚Üívar _search_timer: float = 0.0\n   415‚Üí\n   416‚Üí## Maximum time to spend searching before giving up (seconds).\n   417‚Üíconst SEARCH_MAX_DURATION: float = 15.0\n   418‚Üí\n   419‚Üí## Inspection points within the search zone (hiding spots behind covers and corners).\n   420‚Üívar _inspection_points: Array[Vector2] = []\n   421‚Üí\n   422‚Üí## Index of current inspection point being checked.\n   423‚Üívar _current_inspection_index: int = 0\n   424‚Üí\n   425‚Üí## Timer for waiting at each inspection point (looking around).\n   426‚Üívar _inspection_wait_timer: float = 0.0\n   427‚Üí\n   428‚Üí## Duration to wait at each inspection point (seconds).\n   429‚Üíconst INSPECTION_WAIT_DURATION: float = 1.5\n   430‚Üí\n   431‚Üí## Whether currently waiting at an inspection point.\n   432‚Üívar _inspecting_point: bool = false\n   433‚Üí\n   434‚Üí## Number of raycasts for detecting inspection points (corners/hiding spots).\n   435‚Üíconst INSPECTION_POINT_CHECK_COUNT: int = 24\n   436‚Üí\n   437‚Üí## Distance to check for inspection points from search zone center.\n   438‚Üíconst INSPECTION_CHECK_DISTANCE: float = 250.0\n   439‚Üí\n   440‚Üí## Detection delay timer - tracks time since entering combat.\n   441‚Üívar _detection_timer: float = 0.0\n   442‚Üí"}]},"parent_tool_use_id":null,"session_id":"797fbac8-f5e6-4339-8fd2-77453410db49","uuid":"d526728a-522b-4cae-b64a-7b293b5c197b","tool_use_result":{"filePath":"/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd","oldString":"## Distance threshold for \"close\" vs \"far\" from player.\n## Used to determine if enemy can engage from current position or needs to pursue.\nconst CLOSE_COMBAT_DISTANCE: float = 400.0\n\n## GOAP world state for goal-oriented planning.\nvar _goap_world_state: Dictionary = {}","newString":"## Distance threshold for \"close\" vs \"far\" from player.\n## Used to determine if enemy can engage from current position or needs to pursue.\nconst CLOSE_COMBAT_DISTANCE: float = 400.0\n\n## GOAP world state for goal-oriented planning.\nvar _goap_world_state: Dictionary = {}\n\n## --- Search/Investigation State (for when player escapes from view) ---\n## Last known position where the player was seen before escaping view.\nvar _last_known_player_position: Vector2 = Vector2.ZERO\n\n## Whether a search zone is currently active.\nvar _search_zone_active: bool = false\n\n## Radius of the potential player zone (area where player might be hiding).\nconst SEARCH_ZONE_RADIUS: float = 200.0\n\n## Timer for search timeout - enemy gives up searching after this time.\nvar _search_timer: float = 0.0\n\n## Maximum time to spend searching before giving up (seconds).\nconst SEARCH_MAX_DURATION: float = 15.0\n\n## Inspection points within the search zone (hiding spots behind covers and corners).\nvar _inspection_points: Array[Vector2] = []\n\n## Index of current inspection point being checked.\nvar _current_inspection_index: int = 0\n\n## Timer for waiting at each inspection point (looking around).\nvar _inspection_wait_timer: float = 0.0\n\n## Duration to wait at each inspection point (seconds).\nconst INSPECTION_WAIT_DURATION: float = 1.5\n\n## Whether currently waiting at an inspection point.\nvar _inspecting_point: bool = false\n\n## Number of raycasts for detecting inspection points (corners/hiding spots).\nconst INSPECTION_POINT_CHECK_COUNT: int = 24\n\n## Distance to check for inspection points from search zone center.\nconst INSPECTION_CHECK_DISTANCE: float = 250.0","originalFile":"extends CharacterBody2D\n## Enemy AI with tactical behaviors including patrol, guard, cover, and flanking.\n##\n## Supports multiple behavior modes:\n## - PATROL: Moves between patrol points\n## - GUARD: Stands in place watching for the player\n##\n## Tactical features:\n## - Uses cover when under fire (suppression)\n## - Attempts to flank the player from the sides\n## - Coordinates with other enemies (optional)\n## - GOAP foundation for goal-oriented planning\n\n## AI States for tactical behavior.\nenum AIState {\n\tIDLE,       ## Default idle state (patrol or guard)\n\tCOMBAT,     ## Actively engaging the player (coming out of cover, shooting 2-3s, returning)\n\tSEEKING_COVER,  ## Moving to cover position\n\tIN_COVER,   ## Taking cover from player fire\n\tFLANKING,   ## Attempting to flank the player\n\tSUPPRESSED, ## Under fire, staying in cover\n\tRETREATING, ## Retreating to cover while possibly shooting\n\tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n\tASSAULT,    ## Coordinated multi-enemy assault (rush player after 5s wait)\n\tSEARCHING   ## Searching for player at last-known-position zone\n}\n\n## Retreat behavior modes based on damage taken.\nenum RetreatMode {\n\tFULL_HP,        ## No damage - retreat backwards while shooting, periodically turn to cover\n\tONE_HIT,        ## One hit taken - quick burst then retreat without shooting\n\tMULTIPLE_HITS   ## Multiple hits - quick burst then retreat without shooting (same as ONE_HIT)\n}\n\n## Behavior modes for the enemy.\nenum BehaviorMode {\n\tPATROL,  ## Moves between patrol points\n\tGUARD    ## Stands in one place\n}\n\n## Current behavior mode.\n@export var behavior_mode: BehaviorMode = BehaviorMode.GUARD\n\n## Maximum movement speed in pixels per second.\n@export var move_speed: float = 220.0\n\n## Combat movement speed (faster when flanking/seeking cover).\n@export var combat_move_speed: float = 320.0\n\n## Rotation speed in radians per second for gradual turning.\n## Default is 15 rad/sec for challenging but fair combat.\n@export var rotation_speed: float = 15.0\n\n## Detection range for spotting the player.\n## Set to 0 or negative to allow unlimited detection range (line-of-sight only).\n## This allows enemies to see the player even outside the viewport if no obstacles block view.\n@export var detection_range: float = 0.0\n\n## Time between shots in seconds.\n## Default matches assault rifle fire rate (10 shots/second = 0.1s cooldown).\n@export var shoot_cooldown: float = 0.1\n\n## Bullet scene to instantiate when shooting.\n@export var bullet_scene: PackedScene\n\n## Offset from enemy center for bullet spawn position.\n@export var bullet_spawn_offset: float = 30.0\n\n## Patrol points as offsets from the initial position.\n## Only used when behavior_mode is PATROL.\n@export var patrol_offsets: Array[Vector2] = [Vector2(100, 0), Vector2(-100, 0)]\n\n## Wait time at each patrol point in seconds.\n@export var patrol_wait_time: float = 1.5\n\n## Color when at full health.\n@export var full_health_color: Color = Color(0.9, 0.2, 0.2, 1.0)\n\n## Color when at low health (interpolates based on health percentage).\n@export var low_health_color: Color = Color(0.3, 0.1, 0.1, 1.0)\n\n## Color to flash when hit.\n@export var hit_flash_color: Color = Color(1.0, 1.0, 1.0, 1.0)\n\n## Duration of hit flash effect in seconds.\n@export var hit_flash_duration: float = 0.1\n\n## Whether to destroy the enemy after death.\n@export var destroy_on_death: bool = false\n\n## Delay before respawning or destroying (in seconds).\n@export var respawn_delay: float = 2.0\n\n## Minimum random health.\n@export var min_health: int = 2\n\n## Maximum random health.\n@export var max_health: int = 4\n\n## Threat sphere radius - bullets within this radius trigger suppression.\n@export var threat_sphere_radius: float = 100.0\n\n## Time to stay suppressed after bullets leave threat sphere.\n@export var suppression_cooldown: float = 2.0\n\n## Delay (in seconds) before reacting to bullets in the threat sphere.\n## This prevents instant reactions to nearby gunfire, giving the player more time.\n@export var threat_reaction_delay: float = 0.2\n\n## Flank angle from player's facing direction (radians).\n@export var flank_angle: float = PI / 3.0  # 60 degrees\n\n## Distance to maintain while flanking.\n@export var flank_distance: float = 200.0\n\n## Enable/disable flanking behavior.\n@export var enable_flanking: bool = true\n\n## Enable/disable cover behavior.\n@export var enable_cover: bool = true\n\n## Enable/disable debug logging.\n@export var debug_logging: bool = false\n\n## Enable/disable debug label above enemy showing current AI state.\n@export var debug_label_enabled: bool = false\n\n## Enable/disable friendly fire avoidance (don't shoot if other enemies are in the way).\n@export var enable_friendly_fire_avoidance: bool = true\n\n## Enable/disable lead prediction (shooting ahead of moving targets).\n@export var enable_lead_prediction: bool = true\n\n## Bullet speed for lead prediction calculation.\n## Should match the actual bullet speed (default is 2500 for assault rifle).\n@export var bullet_speed: float = 2500.0\n\n## Ammunition system - magazine size (bullets per magazine).\n@export var magazine_size: int = 30\n\n## Ammunition system - number of magazines the enemy carries.\n@export var total_magazines: int = 5\n\n## Ammunition system - time to reload in seconds.\n@export var reload_time: float = 3.0\n\n## Delay (in seconds) between spotting player and starting to shoot.\n## Gives player a brief reaction time when entering enemy line of sight.\n## This delay \"recharges\" each time the player breaks direct contact with the enemy.\n@export var detection_delay: float = 0.2\n\n## Minimum time (in seconds) the player must be continuously visible before\n## lead prediction is enabled. This prevents enemies from predicting player\n## position immediately when they emerge from cover.\n@export var lead_prediction_delay: float = 0.3\n\n## Minimum visibility ratio (0.0 to 1.0) of player body that must be visible\n## before lead prediction is enabled. At 1.0, the player's entire body must be\n## visible. At 0.5, at least half of the check points must be visible.\n## This prevents pre-firing at players who are at cover edges.\n@export var lead_prediction_visibility_threshold: float = 0.6\n\n## Signal emitted when the enemy is hit.\nsignal hit\n\n## Signal emitted when the enemy dies.\nsignal died\n\n## Signal emitted when AI state changes.\nsignal state_changed(new_state: AIState)\n\n## Signal emitted when ammunition changes.\nsignal ammo_changed(current_ammo: int, reserve_ammo: int)\n\n## Signal emitted when reloading starts.\nsignal reload_started\n\n## Signal emitted when reloading finishes.\nsignal reload_finished\n\n## Signal emitted when all ammunition is depleted.\nsignal ammo_depleted\n\n## Reference to the sprite for color changes.\n@onready var _sprite: Sprite2D = $Sprite2D\n\n## RayCast2D for line of sight detection.\n@onready var _raycast: RayCast2D = $RayCast2D\n\n## Debug label for showing current AI state above the enemy.\n@onready var _debug_label: Label = $DebugLabel\n\n## Wall detection raycasts for obstacle avoidance (created at runtime).\nvar _wall_raycasts: Array[RayCast2D] = []\n\n## Distance to check for walls ahead.\nconst WALL_CHECK_DISTANCE: float = 40.0\n\n## Number of raycasts for wall detection (spread around the enemy).\nconst WALL_CHECK_COUNT: int = 3\n\n## Cover detection raycasts (created at runtime).\nvar _cover_raycasts: Array[RayCast2D] = []\n\n## Number of raycasts for cover detection.\nconst COVER_CHECK_COUNT: int = 16\n\n## Distance to check for cover.\nconst COVER_CHECK_DISTANCE: float = 300.0\n\n## Current health of the enemy.\nvar _current_health: int = 0\n\n## Maximum health of the enemy (set at spawn).\nvar _max_health: int = 0\n\n## Whether the enemy is alive.\nvar _is_alive: bool = true\n\n## Reference to the player (found at runtime).\nvar _player: Node2D = null\n\n## Time since last shot.\nvar _shoot_timer: float = 0.0\n\n## Current ammo in the magazine.\nvar _current_ammo: int = 0\n\n## Reserve ammo (ammo in remaining magazines).\nvar _reserve_ammo: int = 0\n\n## Whether the enemy is currently reloading.\nvar _is_reloading: bool = false\n\n## Timer for reload progress.\nvar _reload_timer: float = 0.0\n\n## Patrol state variables.\nvar _patrol_points: Array[Vector2] = []\nvar _current_patrol_index: int = 0\nvar _is_waiting_at_patrol_point: bool = false\nvar _patrol_wait_timer: float = 0.0\nvar _initial_position: Vector2\n\n## Whether the enemy can currently see the player.\nvar _can_see_player: bool = false\n\n## Current AI state.\nvar _current_state: AIState = AIState.IDLE\n\n## Current cover position (if any).\nvar _cover_position: Vector2 = Vector2.ZERO\n\n## Is currently in a valid cover position.\nvar _has_valid_cover: bool = false\n\n## Timer for suppression cooldown.\nvar _suppression_timer: float = 0.0\n\n## Whether enemy is currently under fire (bullets in threat sphere).\nvar _under_fire: bool = false\n\n## Flank target position.\nvar _flank_target: Vector2 = Vector2.ZERO\n\n## Threat sphere Area2D for detecting nearby bullets.\nvar _threat_sphere: Area2D = null\n\n## Bullets currently in threat sphere.\nvar _bullets_in_threat_sphere: Array = []\n\n## Timer for threat reaction delay - time since first bullet entered threat sphere.\nvar _threat_reaction_timer: float = 0.0\n\n## Whether the threat reaction delay has elapsed (enemy can react to bullets).\nvar _threat_reaction_delay_elapsed: bool = false\n\n## Memory of bullets that have passed through the threat sphere recently.\n## This allows the enemy to react even after fast-moving bullets have exited.\nvar _threat_memory_timer: float = 0.0\n\n## Duration to remember that a bullet passed through the threat sphere.\n## This should be longer than the reaction delay to ensure enemies can complete\n## their reaction even after bullets have passed through quickly.\nconst THREAT_MEMORY_DURATION: float = 0.5\n\n## Current retreat mode determined by damage taken.\nvar _retreat_mode: RetreatMode = RetreatMode.FULL_HP\n\n## Number of hits taken during the current retreat/combat encounter.\n## Resets when enemy enters IDLE state or finishes retreating.\nvar _hits_taken_in_encounter: int = 0\n\n## Timer for periodic turning to cover during FULL_HP retreat.\nvar _retreat_turn_timer: float = 0.0\n\n## Duration to face cover during FULL_HP retreat turn (seconds).\nconst RETREAT_TURN_DURATION: float = 0.8\n\n## Interval between turns toward cover in FULL_HP retreat (seconds).\nconst RETREAT_TURN_INTERVAL: float = 1.5\n\n## Whether currently in the \"turn to cover\" phase of FULL_HP retreat.\nvar _retreat_turning_to_cover: bool = false\n\n## Burst fire counter for ONE_HIT retreat mode.\nvar _retreat_burst_remaining: int = 0\n\n## Timer for burst fire cooldown in ONE_HIT retreat.\nvar _retreat_burst_timer: float = 0.0\n\n## Fast cooldown between burst shots (seconds).\nconst RETREAT_BURST_COOLDOWN: float = 0.06\n\n## Whether burst fire phase is complete in ONE_HIT retreat.\nvar _retreat_burst_complete: bool = false\n\n## Accuracy reduction during retreat (multiplier for inaccuracy angle spread).\nconst RETREAT_INACCURACY_SPREAD: float = 0.15\n\n## Arc spread for ONE_HIT burst fire (radians, total spread).\nconst RETREAT_BURST_ARC: float = 0.4\n\n## Current angle offset within burst arc.\nvar _retreat_burst_angle_offset: float = 0.0\n\n## Whether enemy is in \"alarm\" mode (was suppressed/retreating and hasn't calmed down).\n## This persists until the enemy reaches safety in cover or returns to idle.\nvar _in_alarm_mode: bool = false\n\n## Whether the enemy needs to fire a cover burst (when leaving cover while in alarm).\nvar _cover_burst_pending: bool = false\n\n## --- Combat Cover Cycling (come out, shoot 2-3s, go back) ---\n## Timer for how long the enemy has been shooting while out of cover.\nvar _combat_shoot_timer: float = 0.0\n\n## Duration to shoot while out of cover (2-3 seconds, randomized).\nvar _combat_shoot_duration: float = 2.5\n\n## Whether the enemy is currently in the \"exposed shooting\" phase of combat.\nvar _combat_exposed: bool = false\n\n## Whether the enemy is in the \"approaching player\" phase of combat.\n## In this phase, the enemy moves toward the player to get into direct contact.\nvar _combat_approaching: bool = false\n\n## Timer for the approach phase of combat.\nvar _combat_approach_timer: float = 0.0\n\n## Maximum time to spend approaching player before starting to shoot (seconds).\nconst COMBAT_APPROACH_MAX_TIME: float = 2.0\n\n## Distance at which enemy is considered \"close enough\" to start shooting phase.\nconst COMBAT_DIRECT_CONTACT_DISTANCE: float = 250.0\n\n## --- Pursuit State (cover-to-cover movement) ---\n## Timer for waiting at cover during pursuit.\nvar _pursuit_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during pursuit (1-2 seconds, reduced for faster pursuit).\nconst PURSUIT_COVER_WAIT_DURATION: float = 1.5\n\n## Current pursuit target cover position.\nvar _pursuit_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid pursuit cover target.\nvar _has_pursuit_cover: bool = false\n\n## --- Flanking State (cover-to-cover movement toward flank target) ---\n## Timer for waiting at cover during flanking.\nvar _flank_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during flanking (seconds).\nconst FLANK_COVER_WAIT_DURATION: float = 0.8\n\n## Current flank cover position to move to.\nvar _flank_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid flank cover target.\nvar _has_flank_cover: bool = false\n\n## --- Assault State (coordinated multi-enemy rush) ---\n## Timer for assault wait period (5 seconds before rushing).\nvar _assault_wait_timer: float = 0.0\n\n## Duration to wait at cover before assault (5 seconds).\nconst ASSAULT_WAIT_DURATION: float = 5.0\n\n## Whether the assault wait period is complete.\nvar _assault_ready: bool = false\n\n## Whether this enemy is currently participating in an assault.\nvar _in_assault: bool = false\n\n## Distance threshold for \"close\" vs \"far\" from player.\n## Used to determine if enemy can engage from current position or needs to pursue.\nconst CLOSE_COMBAT_DISTANCE: float = 400.0\n\n## GOAP world state for goal-oriented planning.\nvar _goap_world_state: Dictionary = {}\n\n## Detection delay timer - tracks time since entering combat.\nvar _detection_timer: float = 0.0\n\n## Whether the detection delay has elapsed.\nvar _detection_delay_elapsed: bool = false\n\n## Continuous visibility timer - tracks how long the player has been continuously visible.\n## Resets when line of sight is lost.\nvar _continuous_visibility_timer: float = 0.0\n\n## Current visibility ratio of the player (0.0 to 1.0).\n## Represents what fraction of the player's body is visible to the enemy.\n## Used to determine if lead prediction should be enabled.\nvar _player_visibility_ratio: float = 0.0\n\n## --- Clear Shot Movement (move out from cover to get clear shot) ---\n## Target position to move to for getting a clear shot.\nvar _clear_shot_target: Vector2 = Vector2.ZERO\n\n## Whether we're currently moving to find a clear shot position.\nvar _seeking_clear_shot: bool = false\n\n## Timer for how long we've been trying to find a clear shot.\nvar _clear_shot_timer: float = 0.0\n\n## Maximum time to spend finding a clear shot before giving up (seconds).\nconst CLEAR_SHOT_MAX_TIME: float = 3.0\n\n## Distance to move when exiting cover to find a clear shot.\nconst CLEAR_SHOT_EXIT_DISTANCE: float = 60.0\n\n\n\nfunc _ready() -> void:\n\t_initial_position = global_position\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_setup_patrol_points()\n\t_find_player()\n\t_setup_wall_detection()\n\t_setup_cover_detection()\n\t_setup_threat_sphere()\n\t_initialize_goap_state()\n\t_connect_debug_mode_signal()\n\t_update_debug_label()\n\n\t# Log that this enemy is ready (use call_deferred to ensure FileLogger is loaded)\n\tcall_deferred(\"_log_spawn_info\")\n\n\t# Preload bullet scene if not set in inspector\n\tif bullet_scene == null:\n\t\tbullet_scene = preload(\"res://scenes/projectiles/Bullet.tscn\")\n\n\n## Initialize health with random value between min and max.\nfunc _initialize_health() -> void:\n\t_max_health = randi_range(min_health, max_health)\n\t_current_health = _max_health\n\t_is_alive = true\n\n\n## Initialize ammunition with full magazine and reserve ammo.\nfunc _initialize_ammo() -> void:\n\t_current_ammo = magazine_size\n\t# Reserve ammo is (total_magazines - 1) * magazine_size since one magazine is loaded\n\t_reserve_ammo = (total_magazines - 1) * magazine_size\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\n## Setup patrol points based on patrol offsets from initial position.\nfunc _setup_patrol_points() -> void:\n\t_patrol_points.clear()\n\t_patrol_points.append(_initial_position)\n\tfor offset in patrol_offsets:\n\t\t_patrol_points.append(_initial_position + offset)\n\n\n## Setup wall detection raycasts for obstacle avoidance.\nfunc _setup_wall_detection() -> void:\n\t# Create multiple raycasts spread
[2026-01-18T02:52:20.942Z] [INFO]  in front of the enemy\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_wall_raycasts.append(raycast)\n\n\n## Setup cover detection raycasts for finding cover positions.\nfunc _setup_cover_detection() -> void:\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_cover_raycasts.append(raycast)\n\n\n## Setup threat sphere for detecting nearby bullets.\nfunc _setup_threat_sphere() -> void:\n\t_threat_sphere = Area2D.new()\n\t_threat_sphere.name = \"ThreatSphere\"\n\t_threat_sphere.collision_layer = 0\n\t_threat_sphere.collision_mask = 16  # Detect projectiles (layer 5)\n\n\tvar collision_shape := CollisionShape2D.new()\n\tvar circle_shape := CircleShape2D.new()\n\tcircle_shape.radius = threat_sphere_radius\n\tcollision_shape.shape = circle_shape\n\t_threat_sphere.add_child(collision_shape)\n\n\tadd_child(_threat_sphere)\n\n\t# Connect signals\n\t_threat_sphere.area_entered.connect(_on_threat_area_entered)\n\t_threat_sphere.area_exited.connect(_on_threat_area_exited)\n\n\n## Initialize GOAP world state.\nfunc _initialize_goap_state() -> void:\n\t_goap_world_state = {\n\t\t\"player_visible\": false,\n\t\t\"has_cover\": false,\n\t\t\"in_cover\": false,\n\t\t\"under_fire\": false,\n\t\t\"health_low\": false,\n\t\t\"can_flank\": false,\n\t\t\"at_flank_position\": false,\n\t\t\"is_retreating\": false,\n\t\t\"hits_taken\": 0,\n\t\t\"is_pursuing\": false,\n\t\t\"is_assaulting\": false,\n\t\t\"can_hit_from_cover\": false,\n\t\t\"player_close\": false,\n\t\t\"enemies_in_combat\": 0\n\t}\n\n\n## Connect to GameManager's debug mode signal for F7 toggle.\nfunc _connect_debug_mode_signal() -> void:\n\tvar game_manager: Node = get_node_or_null(\"/root/GameManager\")\n\tif game_manager:\n\t\t# Connect to debug mode toggle signal\n\t\tif game_manager.has_signal(\"debug_mode_toggled\"):\n\t\t\tgame_manager.debug_mode_toggled.connect(_on_debug_mode_toggled)\n\t\t# Sync with current debug mode state\n\t\tif game_manager.has_method(\"is_debug_mode_enabled\"):\n\t\t\tdebug_label_enabled = game_manager.is_debug_mode_enabled()\n\n\n## Called when debug mode is toggled via F7 key.\nfunc _on_debug_mode_toggled(enabled: bool) -> void:\n\tdebug_label_enabled = enabled\n\t_update_debug_label()\n\n\n## Find the player node in the scene tree.\nfunc _find_player() -> void:\n\t# Try to find the player by group first\n\tvar players := get_tree().get_nodes_in_group(\"player\")\n\tif players.size() > 0:\n\t\t_player = players[0]\n\t\treturn\n\n\t# Fallback: search for player by node name or type\n\tvar root := get_tree().current_scene\n\tif root:\n\t\t_player = _find_player_recursive(root)\n\n\n## Recursively search for a player node.\nfunc _find_player_recursive(node: Node) -> Node2D:\n\tif node.name == \"Player\" and node is Node2D:\n\t\treturn node\n\tfor child in node.get_children():\n\t\tvar result := _find_player_recursive(child)\n\t\tif result:\n\t\t\treturn result\n\treturn null\n\n\nfunc _physics_process(delta: float) -> void:\n\tif not _is_alive:\n\t\treturn\n\n\t# Update shoot cooldown timer\n\t_shoot_timer += delta\n\n\t# Update reload timer\n\t_update_reload(delta)\n\n\t# Check for player visibility and try to find player if not found\n\tif _player == null:\n\t\t_find_player()\n\n\t_check_player_visibility()\n\t_update_goap_state()\n\t_update_suppression(delta)\n\n\t# Process AI state machine\n\t_process_ai_state(delta)\n\n\t# Update debug label if enabled\n\t_update_debug_label()\n\n\t# Request redraw for debug visualization\n\tif debug_label_enabled:\n\t\tqueue_redraw()\n\n\tmove_and_slide()\n\n\n## Update GOAP world state based on current conditions.\nfunc _update_goap_state() -> void:\n\t_goap_world_state[\"player_visible\"] = _can_see_player\n\t_goap_world_state[\"under_fire\"] = _under_fire\n\t_goap_world_state[\"health_low\"] = _get_health_percent() < 0.5\n\t_goap_world_state[\"in_cover\"] = _current_state == AIState.IN_COVER\n\t_goap_world_state[\"has_cover\"] = _has_valid_cover\n\t_goap_world_state[\"is_retreating\"] = _current_state == AIState.RETREATING\n\t_goap_world_state[\"hits_taken\"] = _hits_taken_in_encounter\n\t_goap_world_state[\"is_pursuing\"] = _current_state == AIState.PURSUING\n\t_goap_world_state[\"is_assaulting\"] = _current_state == AIState.ASSAULT\n\t_goap_world_state[\"player_close\"] = _is_player_close()\n\t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n\t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()\n\n\n## Update suppression state.\nfunc _update_suppression(delta: float) -> void:\n\t# Clean up destroyed bullets from tracking\n\t_bullets_in_threat_sphere = _bullets_in_threat_sphere.filter(func(b): return is_instance_valid(b))\n\n\t# Determine if there's an active threat (bullets in sphere OR recent threat memory)\n\tvar has_active_threat := not _bullets_in_threat_sphere.is_empty() or _threat_memory_timer > 0.0\n\n\tif not has_active_threat:\n\t\tif _under_fire:\n\t\t\t_suppression_timer += delta\n\t\t\tif _suppression_timer >= suppression_cooldown:\n\t\t\t\t_under_fire = false\n\t\t\t\t_suppression_timer = 0.0\n\t\t\t\t_log_debug(\"Suppression ended\")\n\t\t# Reset threat reaction timer when no bullets are in threat sphere and no threat memory\n\t\t_threat_reaction_timer = 0.0\n\t\t_threat_reaction_delay_elapsed = false\n\telse:\n\t\t# Decrement threat memory timer if no bullets currently in sphere\n\t\tif _bullets_in_threat_sphere.is_empty() and _threat_memory_timer > 0.0:\n\t\t\t_threat_memory_timer -= delta\n\n\t\t# Update threat reaction timer\n\t\tif not _threat_reaction_delay_elapsed:\n\t\t\t_threat_reaction_timer += delta\n\t\t\tif _threat_reaction_timer >= threat_reaction_delay:\n\t\t\t\t_threat_reaction_delay_elapsed = true\n\t\t\t\t_log_debug(\"Threat reaction delay elapsed, now reacting to bullets\")\n\n\t\t# Only set under_fire after the reaction delay has elapsed\n\t\tif _threat_reaction_delay_elapsed:\n\t\t\t_under_fire = true\n\t\t\t_suppression_timer = 0.0\n\n\n## Update reload state.\nfunc _update_reload(delta: float) -> void:\n\tif not _is_reloading:\n\t\treturn\n\n\t_reload_timer += delta\n\tif _reload_timer >= reload_time:\n\t\t_finish_reload()\n\n\n## Start reloading the weapon.\nfunc _start_reload() -> void:\n\t# Can't reload if already reloading or no reserve ammo\n\tif _is_reloading or _reserve_ammo <= 0:\n\t\treturn\n\n\t_is_reloading = true\n\t_reload_timer = 0.0\n\treload_started.emit()\n\t_log_debug(\"Reloading... (%d reserve ammo)\" % _reserve_ammo)\n\n\n## Finish the reload process.\nfunc _finish_reload() -> void:\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\t# Calculate how many rounds to load\n\tvar ammo_needed := magazine_size - _current_ammo\n\tvar ammo_to_load := mini(ammo_needed, _reserve_ammo)\n\n\t_reserve_ammo -= ammo_to_load\n\t_current_ammo += ammo_to_load\n\n\treload_finished.emit()\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\t_log_debug(\"Reload complete. Magazine: %d/%d, Reserve: %d\" % [_current_ammo, magazine_size, _reserve_ammo])\n\n\n## Check if the enemy can shoot (has ammo and not reloading).\nfunc _can_shoot() -> bool:\n\t# Can't shoot if reloading\n\tif _is_reloading:\n\t\treturn false\n\n\t# Can't shoot if no ammo in magazine\n\tif _current_ammo <= 0:\n\t\t# Try to start reload if we have reserve ammo\n\t\tif _reserve_ammo > 0:\n\t\t\t_start_reload()\n\t\telse:\n\t\t\t# No ammo at all - emit depleted signal once\n\t\t\tif not _goap_world_state.get(\"ammo_depleted\", false):\n\t\t\t\t_goap_world_state[\"ammo_depleted\"] = true\n\t\t\t\tammo_depleted.emit()\n\t\t\t\t_log_debug(\"All ammunition depleted!\")\n\t\treturn false\n\n\treturn true\n\n\n## Process the AI state machine.\nfunc _process_ai_state(delta: float) -> void:\n\tvar previous_state := _current_state\n\n\t# State transitions based on conditions\n\tmatch _current_state:\n\t\tAIState.IDLE:\n\t\t\t_process_idle_state(delta)\n\t\tAIState.COMBAT:\n\t\t\t_process_combat_state(delta)\n\t\tAIState.SEEKING_COVER:\n\t\t\t_process_seeking_cover_state(delta)\n\t\tAIState.IN_COVER:\n\t\t\t_process_in_cover_state(delta)\n\t\tAIState.FLANKING:\n\t\t\t_process_flanking_state(delta)\n\t\tAIState.SUPPRESSED:\n\t\t\t_process_suppressed_state(delta)\n\t\tAIState.RETREATING:\n\t\t\t_process_retreating_state(delta)\n\t\tAIState.PURSUING:\n\t\t\t_process_pursuing_state(delta)\n\t\tAIState.ASSAULT:\n\t\t\t_process_assault_state(delta)\n\n\tif previous_state != _current_state:\n\t\tstate_changed.emit(_current_state)\n\t\t_log_debug(\"State changed: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\t\t# Also log to file for exported build debugging\n\t\t_log_to_file(\"State: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\n\n## Process IDLE state - patrol or guard behavior.\nfunc _process_idle_state(delta: float) -> void:\n\t# Transition to combat if player is visible\n\tif _can_see_player and _player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Execute idle behavior\n\tmatch behavior_mode:\n\t\tBehaviorMode.PATROL:\n\t\t\t_process_patrol(delta)\n\t\tBehaviorMode.GUARD:\n\t\t\t_process_guard(delta)\n\n\n## Process COMBAT state - approach player for direct contact, shoot for 2-3 seconds, return to cover.\n## Implements the combat cycling behavior: exit cover -> exposed shooting -> return to cover.\n## Phase 0 (seeking clear shot): If bullet spawn blocked, move out from cover to find clear shot.\n## Phase 1 (approaching): Move toward player to get into direct contact range.\n## Phase 2 (exposed): Stand and shoot for 2-3 seconds.\n## Phase 3: Return to cover via SEEKING_COVER state.\nfunc _process_combat_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies in combat (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can't see player, pursue them (move cover-to-cover toward player)\n\tif not _can_see_player:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\t\treturn\n\n\t# Update detection delay timer\n\tif not _detection_delay_elapsed:\n\t\t_detection_timer += delta\n\t\tif _detection_timer >= detection_delay:\n\t\t\t_detection_delay_elapsed = true\n\n\t# If we don't have cover, find some first (needed for returning later)\n\tif not _has_valid_cover and enable_cover:\n\t\t_find_cover_position()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found cover at %s for combat cycling\" % _cover_position)\n\n\t# Check player distance for approach/exposed phase decisions\n\tvar distance_to_player := INF\n\tif _player:\n\t\tdistance_to_player = global_position.distance_to(_player.global_position)\n\n\t# Check if we have a clear shot (no wall blocking bullet spawn)\n\tvar direction_to_player := Vector2.ZERO\n\tvar has_clear_shot := true\n\tif _player:\n\t\tdirection_to_player = (_player.global_position - global_position).normalized()\n\t\thas_clear_shot = _is_bullet_spawn_clear(direction_to_player)\n\n\t# If already exposed (shooting phase), handle shooting and timer\n\tif _combat_exposed:\n\t\t_combat_shoot_timer += delta\n\n\t\t# Check if exposure time is complete - go back to cover\n\t\tif _combat_shoot_timer >= _combat_shoot_duration and _has_valid_cover:\n\t\t\t_log_debug(\"Combat exposure time complete (%.1fs), returning to cover\" % _combat_shoot_duration)\n\t\t\t_combat_exposed = false\n\t\t\t_combat_approaching = false\n\t\t\t_combat_shoot_timer = 0.0\n\t\t\t_transition_to_seeking_cover()\n\t\t\treturn\n\n\t\t# Check if we still have a clear shot - if not, move sideways to find one\n\t\tif _player and not has_clear_shot:\n\t\t\t# Bullet spawn is blocked - move sideways to find a clear shot position\n\t\t\tvar sidestep_dir := _find_sidestep_direction_for_clear_shot(direction_to_player)\n\t\t\tif sidestep_dir != Vector2.ZERO:\n\t\t\t\tvelocity = sidestep_dir * combat_move_speed * 0.7\n\t\t\t\trotation = direction_to_player.angle()  # Keep facing player while sidestepping\n\t\t\t\t_log_debug(\"COMBAT exposed: sidestepping to maintain clear shot\")\n\t\t\telse:\n\t\t\t\t# No sidestep works - stay still, the shot might clear up\n\t\t\t\tvelocity = Vector2.ZERO\n\t\t\treturn\n\n\t\t# In exposed phase with clear shot, stand still and shoot\n\t\tvelocity = Vector2.ZERO\n\n\t\t# Aim and shoot at player (only shoot after detection delay)\n\t\tif _player:\n\t\t\t_aim_at_player()\n\t\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot()\n\t\t\t\t_shoot_timer = 0.0\n\t\treturn\n\n\t# --- CLEAR SHOT SEEKING PHASE ---\n\t# If bullet spawn is blocked and we're not already exposed, we need to move out from cover\n\tif not has_clear_shot and _player:\n\t\t# Start seeking clear shot if not already doing so\n\t\tif not _seeking_clear_shot:\n\t\t\t_seeking_clear_shot = true\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Calculate target position: move perpendicular to player direction (around cover edge)\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\t_log_debug(\"COMBAT: bullet spawn blocked, seeking clear shot at %s\" % _clear_shot_target)\n\n\t\t_clear_shot_timer += delta\n\n\t\t# Check if we've exceeded the max time trying to find a clear shot\n\t\tif _clear_shot_timer >= CLEAR_SHOT_MAX_TIME:\n\t\t\t_log_debug(\"COMBAT: clear shot timeout, trying flanking\")\n\t\t\t_seeking_clear_shot = false\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Try flanking to get around the obstacle\n\t\t\tif enable_flanking:\n\t\t\t\t_transition_to_flanking()\n\t\t\telse:\n\t\t\t\t_transition_to_pursuing()\n\t\t\treturn\n\n\t\t# Move toward the clear shot target position\n\t\tvar distance_to_target := global_position.distance_to(_clear_shot_target)\n\t\tif distance_to_target > 15.0:\n\t\t\tvar move_direction := (_clear_shot_target - global_position).normalized()\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed\n\t\t\trotation = direction_to_player.angle()  # Keep facing player\n\n\t\t\t# Check if the new position now has a clear shot\n\t\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\t\t_log_debug(\"COMBAT: found clear shot position while moving\")\n\t\t\t\t_seeking_clear_shot = false\n\t\t\t\t_clear_shot_timer = 0.0\n\t\t\t\t# Continue to exposed phase check below\n\t\t\telse:\n\t\t\t\treturn  # Keep moving toward target\n\t\telse:\n\t\t\t# Reached target but still no clear shot - recalculate target\n\t\t\t_log_debug(\"COMBAT: reached target but no clear shot, recalculating\")\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\treturn\n\n\t# Reset seeking state if we now have a clear shot\n\tif _seeking_clear_shot and has_clear_shot:\n\t\t_log_debug(\"COMBAT: clear shot acquired\")\n\t\t_seeking_clear_shot = false\n\t\t_clear_shot_timer = 0.0\n\n\t# Determine if we should be in approach phase or exposed shooting phase\n\tvar in_direct_contact := distance_to_player <= COMBAT_DIRECT_CONTACT_DISTANCE\n\n\t# Enter exposed phase if we have a clear shot and are either close enough or have approached long enough\n\tif has_clear_shot and (in_direct_contact or _combat_approach_timer >= COMBAT_APPROACH_MAX_TIME):\n\t\t# Close enough AND have clear shot - start exposed shooting phase\n\t\t_combat_exposed = true\n\t\t_combat_approaching = false\n\t\t_combat_shoot_timer = 0.0\n\t\t_combat_approach_timer = 0.0\n\t\t# Randomize exposure duration between 2-3 seconds\n\t\t_combat_shoot_duration = randf_range(2.0, 3.0)\n\t\t_log_debug(\"COMBAT exposed phase started (distance: %.0f), will shoot for %.1fs\" % [distance_to_player, _combat_shoot_duration])\n\t\treturn\n\n\t# Need to approach player - move toward them\n\tif not _combat_approaching:\n\t\t_combat_approaching = true\n\t\t_combat_approach_timer = 0.0\n\t\t_log_debug(\"COMBAT approach phase started, moving toward player\")\n\n\t_combat_approach_timer += delta\n\n\t# Move toward player while approaching\n\tif _player:\n\t\tvar move_direction := direction_to_player\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = move_direction * combat_move_speed\n\t\trotation = direction_to_player.angle()  # Always face player\n\n\t\t# Can shoot while approaching (only after detection delay and if have clear shot)\n\t\tif has_clear_shot and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\n## Calculate a target position to exit cover and get a clear shot.\n## Returns a position that should allow the bullet spawn point to be unobstructed.\nfunc _calculate_clear_shot_exit_position(direction_to_player: Vector2) -> Vector2:\n\t# Calculate perpendicular directions to the player\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Try both perpendicular directions and pick the one that's more likely to work\n\t# Also blend with forward movement toward player to help navigate around cover\n\tvar best_position := global_position\n\tvar best_score := -1.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\t\t# Blend sidestep with forward movement for better cover navigation\n\t\tvar exit_dir: Vector2 = (sidestep_dir * 0.7 + direction_to_player * 0.3).normalized()\n\t\tvar test_position: Vector2 = global_position + exit_dir * CLEAR_SHOT_EXIT_DISTANCE\n\n\t\t# Score this position based on:\n\t\t# 1. Does it have a clear path? (no walls in the way)\n\t\t# 2. Would the bullet spawn be clear from there?\n\t\tvar score: float = 0.0\n\n\t\t# Check if we can move to this position\n\t\tif _has_clear_path_to(test_position):\n\t\t\tscore += 1.0\n\n\t\t# Check if bullet spawn would be clear from this position\n\t\t# This is a rough estimate - we check from the test position toward player\n\t\tvar world_2d := get_world_2d()\n\t\tif world_2d != null:\n\t\t\tvar space_state := world_2d.direct_space_state\n\t\t\tif space_state != null:\n\t\t\t\tvar check_distance := bullet_spawn_offset + 5.0\n\t\t\t\tvar query := PhysicsRayQueryParameters2D.new()\n\t\t\t\tquery.from = test_position\n\t\t\t\tquery.to = test_position + direction_to_player * check_distance\n\t\t\t\tquery.collision_mask = 4  # Only check obstacles\n\t\t\t\tquery.exclude = [get_rid()]\n\t\t\t\tvar result := space_state.intersect_ray(query)\n\t\t\t\tif result.is_empty():\n\t\t\t\t\tscore += 2.0  # Higher score for clear bullet spawn\n\n\t\tif score > best_score:\n\t\t\tbest_score = score\n\t\t\tbest_position = test_position\n\n\t# If no good position found, just move forward toward player\n\tif best_score < 0.5:\n\t\tbest_position = global_position + direction_to_player * CLEAR_SHOT_EXIT_DISTANCE\n\n\treturn best_position\n\n\n## Process SEEKING_COVER state - moving to cover position.\nfunc _process_seeking_cover_state(_delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, stay in combat\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're already hidden from the player (the main goal)\n\tif not _is_visible_from_player():\n\t\t_transition_to_in_cover()\n\t\t_log_debug(\"Hidden from player, entering cover state\")\n\t\treturn\n\n\t# Move towards cover\n\tvar direction := (_cover_position - global_position).normalized()\n\tvar distance := global_position.distance_to(_cover_position)\n\n\tif distance < 10.0:\n\t\t# Reached the cover position, but still visible - try to find better cover\n\t\tif _is_visible_from_player():\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\t# No better cover found, stay in combat\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\n\t# Apply wall avoidance\n\tvar avoidance := _check_wall_ahead(direction)\n\tif avoidance != Vector2.ZERO:\n\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\tvelocity = direction * combat_move_speed\n\trotation = direction.angle()\n\n\t# Can still shoot while moving to cover (only after detection delay)\n\tif _can_see_player and _player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t_aim_at_player()\n\t\t_shoot()\n\t\t_shoot_timer = 0.0\n\n\n## Process IN_COVER state - taking cover from enemy fire.\n## Decides next action based on:\n## 1. If under fire -> suppressed\n## 2. If player is close (can exit cover for direct contact) -> COMBAT\n## 3. If player is far but can hit from current position -> COMBAT (stay and shoot)\n## 4. If player is far and can't hit -> PURSUING (move cover-to-cover)\nfunc _process_in_cover_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# If still under fire, stay suppressed\n\tif _under_fire:\n\t\t_transition_to_suppressed()\n\t\treturn\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover\n\tif _is_visible_from_player():\n\t\t# If in alarm mode and can see player, fire a burst before escaping\n\t\tif _in_alarm_mode and _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"IN_COVER alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay in cover while firing burst\n\n\t\t# Burst complete or not in alarm mode, seek new cover\n\t\t_log_debug(\"Player flanked our cover position, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# Decision making based on player distance and visibility\n\tif _player:\n\t\tvar player_close := _is_player_close()\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\n\t\tif _can_see_player:\n\t\t\tif player_close:\n\t\t\t\t# Player is close - engage in combat (come out, shoot, go back)\n\t\t\t\t_log_debug(\"Player is close, transitioning to COMBAT\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\t# Player is far\n\t\t\t\tif can_hit:\n\t\t\t\t\t# Can hit from current position - come out and shoot\n\t\t\t\t\t# (Don't pursue, just transition to combat which will handle the cycling)\n\t\t\t\t\t_log_debug(\"Player is far but can hit from here, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\telse:\n\t\t\t\t\t# Can't hit from here - need to pursue (move cover-to-cover)\n\t\t\t\t\t_log_debug(\"Player is far and can't hit, transitioning to PURSUING\")\n\t\t\t\t\t_transition_to_pursuing()\n\t\t\t\t\treturn\n\n\t# If not under fire and can see player, engage (only shoot after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If player is no longer visible and not under fire, try pursuing\n\tif not _can_see_player and not _under_fire:\n\t\t_log_debug(\"Lost sight of player from cover, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\n\n## Process FLANKING state - attempting to flank the player using cover-to-cover movement.\n## Uses intermediate cover positions to navigate around obstacles instead of walking\n## directly toward the flank target.\nfunc _process_flanking_state(delta: float) -> void:\n\t# If under fire, retreat with shooting behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# If can see player, engage in combat\n\tif _can_see_player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\tif _player == null:\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# Recalculate flank position (player may have moved)\n\t_calculate_flank_position()\n\n\tvar distance_to_flank := global_position.distance_to(_flank_target)\n\n\t# Check if we've reached the flank target\n\tif distance_to_flank < 30.0:\n\t\t_log_debug(\"Reached flank position, engaging\")\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Check if we have direct line of sight to flank target (no obstacles)\n\tif _has_clear_path_to(_flank_target):\n\t\t# Direct path is clear - move directly toward flank target\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\t_has_flank_cover = false\n\t\treturn\n\n\t# Path is blocked - use cover-to-cover movement\n\n\t# If we're at a cover position, wait briefly before moving to next\n\tif _has_valid_cover and not _has_flank_cover:\n\t\t_flank_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _flank_cover_wait_timer >= FLANK_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover toward flank target\n\t\t\t_find_flank_cover_toward_target()\n\t\t\tif not _has_flank_cover:\n\t\t\t\t_log_debug(\"No flank cover found, attempting direct movement\")\n\t\t\t\t# No cover found - try direct movement with enhanced wall avoidance\n\t\t\t\tvar direction := (_flank_target - global_position).normalized()\n\t\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\t\tvelocity = direction * combat_move_speed\n\t\t\t\trotation = direction.angle()\n\t\t\t\t# Invalidate current cover to trigger new search next frame\n\t\t\t\t_has_valid_cover = false\n\t\treturn\n\n\t# If we have a flank cover target, move toward it\n\tif _has_flank_cover:\n\t\tvar direction := (_flank_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_flank_next_cover)\n\n\t\t# Check if we've reached the flank cover\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached flank cover at distance %.1f\" % distance)\n\t\t\t_has_flank_cover = false\n\t\t\t_flank_cover_wait_timer = 0.0\n\t\t\t_cover_position = _flank_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no flank cover target - find initial flank cover\n\t_find_flank_cover_toward_target()\n\tif not _has_flank_cover:\n\t\t# Can't find cover, try direct movement with wall avoidance\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\n\n## Process SUPPRESSED state - staying in cover under fire.\nfunc _process_suppressed_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover even while suppressed\n\tif _is_visible_from_player():\n\t\t# In suppressed state we're always in alarm mode - fire a burst before escaping if we can see player\n\t\tif _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"SUPPRESSED alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay suppressed while firing burst\n\n\t\t# Burst complete or can't see player, seek new cover\n\t\t_log_debug(\"Player flanked our cover position while suppressed, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Can still shoot while suppressed (only after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If no longer under fire, exit suppression\n\tif not _under_fire:\n\t\t_transition_to_in_cover()\n\n\n## Process RETREATING state - moving to cover with behavior based on damage taken.\nfunc _process_retreating_state(delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, transition to combat or suppressed\n\t\t\tif _under_fire:\n\t\t\t\t_transition_to_suppressed()\n\t\t\telse:\n\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we've reached cover and are hidden from player\n\tif not _is_visible_from_player():\n\t\t_log_debug(\"Reached cover during retreat\")\n\t\t# Reset encounter hits when successfully reaching cover\n\t\t_hits_taken_in_encounter = 0\n\t\t_transition_to_in_cover()\n\t\treturn\n\n\t# Calculate direction to cover\n\tvar direction_to_cover := (_cover_position - global_position).normalized()\n\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\n\t# Check if reached cover position\n\tif distance_to_cover < 10.0:\n\t\tif _is_visible_from_player():\n\t\t\t# Still visible, find better cover\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\tif _under_fire:\n\t\t\t\t\t_transition_to_suppressed()\n\t\t\t\telse:\n\t\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Apply retreat behavior based on mode\n\tmatch _retreat_mode:\n\t\tRetreatMode.FULL_HP:\n\t\t\t_process_retreat_full_hp(delta, direction_to_cover)\n\t\tRetreatMode.ONE_HIT:\n\t\t\t_process_retreat_one_hit(delta, direction_to_cover)\n\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t_process_retreat_multiple_hits(delta, direction_to_cover)\n\n\n## Process FULL_HP retreat: walk backwards facing player, shoot with reduced accuracy,\n## periodically turn toward cover.\nfunc _process_retreat_full_hp(delta: float, direction_to_cover: Vector2) -> void:\n\t_retreat_turn_timer += delta\n\n\tif _retreat_turning_to_cover:\n\t\t# Turning to face cover, don't shoot\n\t\tif _retreat_turn_timer >= RETREAT_TURN_DURATION:\n\t\t\t_retreat_turning_to_cover = false\n\t\t\t_retreat_turn_timer = 0.0\n\n\t\t# Face cover and move toward it\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\telse:\n\t\t# Face player and back up (walk backwards)\n\t\tif _retreat_turn_timer >= RETREAT_TURN_INTERVAL:\n\t\t\t_retreat_turning_to_cover = true\n\t\t\t_retreat_turn_timer = 0.0\n\t\t\t_log_debug(\"FULL_HP retreat: turning to check cover\")\n\n\t\tif _player:\n\t\t\t# Face the player\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\t_aim_at_player()\n\n\t\t\t# Move backwards (opposite of player direction = toward cover generally)\n\t\t\t# Use the negative of the direction we're facing for \"backing up\"\n\t\t\tvar move_direction := -direction_to_player\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed * 0.7  # Slower when backing up\n\n\t\t\t# Shoot with reduced accuracy (only after detection delay)\n\t\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot_with_inaccuracy()\n\t\t\t\t_shoot_timer = 0.0\n\n\n## Process ONE_HIT retreat: quick burst of 2-4 shots in an arc while turning, then face cover.\nfunc _process_retreat_one_hit(delta: float, direction_to_cover: Vector2) -> void:\n\tif not _retreat_burst_complete:\n\t\t# During burst phase\n\t\t_retreat_burst_timer += delta\n\n\t\tif _player and _retreat_burst_remaining > 0 and _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t# Fire a burst shot with arc spread\n\t\t\t_shoot_burst_shot()\n\t\t\t_retreat_burst_remaining -= 1\n\t\t\t_retreat_burst_timer = 0.0\n\n\t\t\t# Progress through the arc\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0  # Spread across 4 shots max\n\n\t\t# Gradually turn from player to cover during burst\n\t\tif _player:\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\tvar target_angle: float\n\n\t\t\t# Interpolate rotation from player direction to cover direction\n\t\t\tvar burst_progress := 1.0 - (float(_retreat_burst_remaining) / 4.0)\n\t\t\tvar player_angle := direction_to_player.angle()\n\t\t\tvar cover_angle := direction_to_cover.angle()\n\t\t\ttarget_angle = lerp_angle(player_angle, cover_angle, burst_progress * 0.7)\n\t\t\trotation = target_angle\n\n\t\t# Move toward cover (slower during burst)\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed * 0.5\n\n\t\t# Check if burst is complete\n\t\tif _retreat_burst_remaining <= 0:\n\t\t\t_retreat_burst_complete = true\n\t\t\t_log_debug(\"ONE_HIT retreat: burst complete, now running to cover\")\n\telse:\n\t\t# After burst, run to cover without shooting\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\n\n## Process MULTIPLE_HITS retreat: quick burst of 2-4 shots then run to cover (same as ONE_HIT).\nfunc _process_retreat_multiple_hits(delta: float, direction_to_cover: Vector2) -> void:\n\t# Same behavior as ONE_HIT - quick burst then escape\n\t_process_retreat_one_hit(delta, direction_to_cover)\n\n\n## Process PURSUING state - move cover-to-cover toward player.\n## Enemy moves between covers, waiting 1-2 seconds at each cover,\n## until they can see and hit the player.\nfunc _process_pursuing_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected during pursuit (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can see player and can hit them from current position, engage\n\tif _can_see_player and _player:\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\t\tif can_hit:\n\t\t\t_log_debug(\"Can see and hit player from pursuit, transitioning to COMBAT\")\n\t\t\t_has_pursuit_cover = false\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're waiting at cover\n\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t# Currently at cover, wait for 1-2 seconds before moving to next cover\n\t\t_pursuit_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _pursuit_cover_wait_timer >= PURSUIT_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover closer to player\n\t\t\t_log_debug(\"Pursuit wait complete, finding next cover\")\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_find_pursuit_cover_toward_player()\n\t\t\tif _has_pursuit_cover:\n\t\t\t\t_log_debug(\"Found pursuit cover at %s\" % _pursuit_next_cover)\n\t\t\telse:\n\t\t\t\t# No pursuit cover found - fallback behavior\n\t\t\t\t_log_debug(\"No pursuit cover found, checking fallback options\")\n\t\t\t\t# If we can now see the player, engage directly\n\t\t\t\tif _can_see_player:\n\t\t\t\t\t_log_debug(\"Can see player, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\t# Try flanking\n\t\t\t\tif enable_flanking and _player:\n\t\t\t\t\t_log_debug(\"Attempting flanking maneuver\")\n\t\t\t\t\t_transition_to_flanking()\n\t\t\t\t\treturn\n\t\t\t\t# Last resort: move directly toward player\n\t\t\t\t_log_debug(\"No cover options, moving directly toward player\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\treturn\n\n\t# If we have a pursuit cover target, move toward it\n\tif _has_pursuit_cover:\n\t\tvar direction := (_pursuit_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_pursuit_next_cover)\n\n\t\t# Check if we've reached the pursuit cover\n\t\t# Note: We only check distance here, NOT visibility from player.\n\t\t# If we checked visibility, the enemy would immediately consider themselves\n\t\t# \"at cover\" even before moving, since they start hidden from player.\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached pursuit cover at distance %.1f\" % distance)\n\t\t\t_has_pursuit_cover = false\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_cover_position = _pursuit_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no pursuit target - find initial pursuit cover\n\t_find_pursuit_cover_toward_player()\n\tif not _has_pursuit_cover:\n\t\t# Can't find cover to pursue, try flanking or combat\n\t\tif enable_flanking and _player:\n\t\t\t_transition_to_flanking()\n\t\telse:\n\t\t\t_transition_to_combat()\n\n\n## Process ASSAULT state - coordinated multi-enemy rush.\n## Wait at cover for 5 seconds, then all enemies rush the player simultaneously.\nfunc _process_assault_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover and not _assault_ready:\n\t\t_in_assault = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if we're the only enemy left in assault - switch back to combat\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat < 2 and not _assault_ready:\n\t\t_log_debug(\"Not enough enemies for assault, switching to COMBAT\")\n\t\t_in_assault = false\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Find closest cover to player if we don't have one\n\tif not _has_valid_cover:\n\t\t_find_cover_closest_to_player()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found assault cover at %s\" % _cover_position)\n\n\t# Move to cover position first\n\tif _has_valid_cover and not _in_assault:\n\t\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\t\tif distance_to_cover > 15.0 and _is_visible_from_player():\n\t\t\t# Still need to reach cover\n\t\t\tvar direction := (_cover_position - global_position).normalized()\n\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\tvelocity = direction * combat_move_speed\n\t\t\trotation = direction.angle()\n\t\t\treturn\n\n\t# At cover, wait for assault timer\n\tif not _assault_ready:\n\t\tvelocity = Vector2.ZERO\n\t\t_assault_wait_timer += delta\n\n\t\t# Check if all assault enemies are ready (synchronized assault)\n\t\tif _assault_wait_timer >= ASSAULT_WAIT_DURATION:\n\t\t\t# Check if situation has changed - player might have moved\n\t\t\tif _player and _is_player_close():\n\t\t\t\t_assault_ready = true\n\t\t\t\t_in_assault = true\n\t\t\t\t_log_debug(\"ASSAULT ready - rushing player!\")\n\t\t\telse:\n\t\t\t\t# Player moved away, reset timer and check if we should pursue\n\t\t\t\t_log_debug(\"Player moved away during assault wait, resetting\")\n\t\t\t\t_assault_wait_timer = 0.0\n\t\t\t\t_in_assault = false\n\t\t\t\t_transition_to_pursuing()\n\t\t\t\treturn\n\t\treturn\n\n\t# Assault phase - rush the player while shooting\n\tif _assault_ready and _player:\n\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction_to_player)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_player = (direction_to_player * 0.5 + avoidance * 0.5).normalized()\n\n\t\t# Rush at full speed\n\t\tvelocity = direction_to_player * combat_move_speed\n\t\trotation = direction_to_player.angle()\n\n\t\t# Update detection delay timer\n\t\tif not _detection_delay_elapsed:\n\t\t\t_detection_timer += delta\n\t\t\tif _detection_timer >= detection_delay:\n\t\t\t\t_detection_delay_elapsed = true\n\n\t\t# Shoot while rushing (only after detection delay)\n\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t\t# If very close to player, stay in combat\n\t\tif distance_to_player < 50.0:\n\t\t\t_log_debug(\"Assault complete - reached player\")\n\t\t\t_assault_ready = false\n\t\t\t_in_assault = false\n\t\t\t_transition_to_combat()\n\n\n## Shoot with reduced accuracy for retreat mode.\nfunc _shoot_with_inaccuracy() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Check if the shot should be taken\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Add inaccuracy spread\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD, RETREAT_INACCURACY_SPREAD)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the inaccurate shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Inaccurate shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Shoot a burst shot with arc spread for ONE_HIT retreat.\nfunc _shoot_burst_shot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Apply arc offset for burst spread\n\tdirection = direction.rotated(_retreat_burst_angle_offset)\n\n\t# Also add some random inaccuracy on top of the arc\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD * 0.5, RETREAT_INACCURACY_SPREAD * 0.5)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the burst shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Burst shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Transition to IDLE state.\nfunc _transition_to_idle() -> void:\n\t_current_state = AIState.IDLE\n\t# Reset encounter hit tracking when returning to idle\n\t_hits_taken_in_encounter = 0\n\t# Reset alarm mode when returning to idle\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\n\n## Transition to COMBAT state.\nfunc _transition_to_combat() -> void:\n\t_current_state = AIState.COMBAT\n\t# Reset detection delay timer when entering combat\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Reset combat phase variables\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_shoot_timer = 0.0\n\t_combat_approach_timer = 0.0\n\t# Reset clear shot seeking variables\n\t_seeking_clear_shot = false\n\t_clear_shot_timer = 0.0\n\t_clear_shot_target = Vector2.ZERO\n\n\n## Transition to SEEKING_COVER state.\nfunc _transition_to_seeking_cover() -> void:\n\t_current_state = AIState.SEEKING_COVER\n\t_find_cover_position()\n\n\n## Transition to IN_COVER state.\nfunc _transition_to_in_cover() -> void:\n\t_current_state = AIState.IN_COVER\n\n\n## Transition to FLANKING state.\nfunc _transition_to_flanking() -> void:\n\t_current_state = AIState.FLANKING\n\t_calculate_flank_position()\n\t_flank_cover_wait_timer = 0.0\n\t_has_flank_cover = false\n\t_has_valid_cover = false\n\n\n## Transition to SUPPRESSED state.\nfunc _transition_to_suppressed() -> void:\n\t_current_state = AIState.SUPPRESSED\n\t# Enter alarm mode when suppressed\n\t_in_alarm_mode = true\n\n\n## Transition to PURSUING state.\nfunc _transition_to_pursuing() -> void:\n\t_current_state = AIState.PURSUING\n\t_pursuit_cover_wait_timer = 0.0\n\t_has_pursuit_cover = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\n\n## Transition to ASSAULT state.\nfunc _transition_to_assault() -> void:\n\t_current_state = AIState.ASSAULT\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Find closest cover to player for assault position\n\t_find_cover_closest_to_player()\n\n\n## Transition to RETREATING state with appropriate retreat mode.\nfunc _transition_to_retreating() -> void:\n\t_current_state = AIState.RETREATING\n\t# Enter alarm mode when retreating\n\t_in_alarm_mode = true\n\n\t# Determine retreat mode based on hits taken\n\tif _hits_taken_in_encounter == 0:\n\t\t_retreat_mode = RetreatMode.FULL_HP\n\t\t_retreat_turn_timer = 0.0\n\t\t_retreat_turning_to_cover = false\n\t\t_log_debug(\"Entering RETREATING state: FULL_HP mode (shoot while backing up)\")\n\telif _hits_taken_in_encounter == 1:\n\t\t_retreat_mode = RetreatMode.ONE_HIT\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t# Calculate arc spread: shots will be distributed across the arc\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: ONE_HIT mode (burst of %d shots)\" % _retreat_burst_remaining)\n\telse:\n\t\t_retreat_mode = RetreatMode.MULTIPLE_HITS\n\t\t# Multiple hits also gets burst fire (same as ONE_HIT)\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: MULTIPLE_HITS mode (burst of %d shots)\" % _retreat_burst_remaining)\n\n\t# Find cover position for retreating\n\t_find_cover_position()\n\n\n## Check if the enemy is visible from the player's position.\n## Uses raycasting from player to enemy to determine if there are obstacles blocking line of sight.\n## This is the inverse of _can_see_player - it checks if the PLAYER can see the ENEMY.\n## Checks multiple points on the enemy body (center and corners) to account for enemy size.\nfunc _is_visible_from_player() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check visibility to multiple points on the enemy body\n\t# This accounts for the enemy's size - corners can stick out from cover\n\tvar check_points := _get_enemy_check_points(global_position)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Get multiple check points on the enemy body for visibility testing.\n## Returns center and 4 corner points offset by the enemy's radius.\nfunc _get_enemy_check_points(center: Vector2) -> Array[Vector2]:\n\t# Enemy collision radius is 24, sprite is 48x48\n\t# Use a slightly smaller radius to avoid edge cases\n\tconst ENEMY_RADIUS: float = 22.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := ENEMY_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point is visible from the player's position.\nfunc _is_point_visible_from_player(point: Vector2) -> bool:\n\tif _player == null:\n\t\treturn false\n\n\tvar player_pos := _player.global_position\n\tvar distance := player_pos.distance_to(point)\n\n\t# Use direct space state to check line of sight from player to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = player_pos\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = []\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between player and point - point is visible\n\t\treturn true\n\telse:\n\t\t# Check if we hit an obstacle before reaching the point\n\t\tvar hit_position: Vector2 = result[\"position\"]\n\t\tvar distance_to_hit := player_pos.distance_to(hit_position)\n\n\t\t# If we hit something closer than the point, the point is hidden\n\t\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t\treturn false\n\t\telse:\n\t\t\treturn true\n\n\n## Check if a specific position would make the enemy visible from the player's position.\n## Checks all enemy body points (center and corners) to account for enemy size.\n## Used to validate cover positions before moving to them.\nfunc _is_position_visible_from_player(pos: Vector2) -> bool:\n\tif _player == null:\n\t\treturn true  # Assume visible if no player\n\n\t# Check visibility for all enemy body points at the given position\n\tvar check_points := _get_enemy_check_points(pos)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Check if a target position is visible from the enemy's perspective.\n## Uses raycast to verify there are no obstacles between enemy and the target position.\n## This is used to validate lead prediction targets - enemies should only aim at\n## positions they can actually see.\nfunc _is_position_visible_to_enemy(target_pos: Vector2) -> bool:\n\tvar distance := global_position.distance_to(target_pos)\n\n\t# Use direct space state to check line of sight from enemy to target\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = target_pos\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and target - position is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t# Hit obstacle before target - position is NOT visible\n\t\t_log_debug(\"Position %s blocked by obstacle at distance %.1f (target at %.1f)\" % [target_pos, distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Get multiple check points on the player's body for visibility testing.\n## Returns center and 4 corner points offset by the player's radius.\n## The player has a collision radius of 16 pixels (from Player.tscn).\nfunc _get_player_check_points(center: Vector2) -> Array[Vector2]:\n\t# Player collision radius is 16, sprite is 32x32\n\t# Use a slightly smaller radius to be conservative\n\tconst PLAYER_RADIUS: float = 14.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := PLAYER_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point on the player is visible from the enemy's position.\n## Uses direct space state query to check for obstacles blocking line of sight.\nfunc _is_player_point_visible_to_enemy(point: Vector2) -> bool:\n\tvar distance := global_position.distance_to(point)\n\n\t# Use direct space state to check line of sight from enemy to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and point - point is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the point\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\t# If we hit something before the point, the point is blocked\n\tif distance_to_hit < distance - 5.0:  # 5 pixel tolerance\n\t\treturn false\n\n\treturn true\n\n\n## Calculate what fraction of the player's body is visible to the enemy.\n## Returns a value from 0.0 (completely hidden) to 1.0 (fully visible).\n## Checks multiple points on the player's body (center + corners).\nfunc _calculate_player_visibility_ratio() -> float:\n\tif _player == null:\n\t\treturn 0.0\n\n\tvar check_points := _get_player_check_points(_player.global_position)\n\tvar visible_count := 0\n\n\tfor point in check_points:\n\t\tif _is_player_point_visible_to_enemy(point):\n\t\t\tvisible_count += 1\n\n\treturn float(visible_count) / float(check_points.size())\n\n\n## Check if the line of fire to the target position is clear of other enemies.\n## Returns true if no other enemies would be hit by a bullet traveling to the target.\nfunc _is_firing_line_clear_of_friendlies(target_position: Vector2) -> bool:\n\tif not enable_friendly_fire_avoidance:\n\t\treturn true\n\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if any enemies are in the firing line\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 2  # Only check enemies (layer 2)\n\tquery.exclude = [get_rid()]  # Exclude self using RID\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No enemies in the way\n\n\t# Check if the hit position is before the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 20.0:  # 20 pixel tolerance\n\t\t_log_debug(\"Friendly in firing line at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if a bullet fired at the target position would be blocked by cover/obstacles.\n## Returns true if the shot would likely hit the target, false if blocked by cover.\nfunc _is_shot_clear_of_cover(target_position: Vector2) -> bool:\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if obstacles block the shot\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No obstacles in the way\n\n\t# Check if the obstacle is before the target position\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t_log_debug(\"Shot blocked by cover at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if there's an obstacle immediately in front of the enemy that would block bullets.\n## This prevents shooting into walls that the enemy is flush against or very close to.\n## Uses a single raycast from enemy center to the bullet spawn position.\nfunc _is_bullet_spawn_clear(direction: Vector2) -> bool:\n\t# Fail-open: allow shooting if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn true\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn true\n\n\t# Check from enemy center to bullet spawn position plus a small buffer\n\tvar check_distance := bullet_spawn_offset + 5.0\n\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = global_position + direction * check_distance\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]\n\n\tvar result := space_state.intersect_ray(query)\n\tif not result.is_empty():\n\t\t_log_debug(\"Bullet spawn blocked: wall at distance %.1f\" % [\n\t\t\tglobal_position.distance_to(result[\"position\"])])\n\t\treturn false\n\n\treturn true\n\n\n## Find a sidestep direction that would lead to a clear shot position.\n## Checks perpendicular directions to the player and returns the first one\n## that would allow the bullet spawn point to be clear.\n## Returns Vector2.ZERO if no clear direction is found.\nfunc _find_sidestep_direction_for_clear_shot(direction_to_player: Vector2) -> Vector2:\n\t# Fail-safe: allow normal behavior if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn Vector2.ZERO\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn Vector2.ZERO\n\n\t# Check perpendicular directions (left and right of the player direction)\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Check both sidestep directions and pick the one that leads to clear shot faster\n\tvar check_distance := 50.0  # Check if moving 50 pixels in this direction would help\n\tvar bullet_check_distance := bullet_spawn_offset + 5.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:  # Try both sides\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\n\t\t# First check if we can actually move in this direction (no wall blocking movement)\n\t\tvar move_query := PhysicsRayQueryParameters2D.new()\n\t\tmove_query.from = global_position\n\t\tmove_query.to = global_position + sidestep_dir * 30.0\n\t\tmove_query.collision_mask = 4  # Only check obstacles\n\t\tmove_query.exclude = [get_rid()]\n\n\t\tvar move_result := space_state.intersect_ray(move_query)\n\t\tif not move_result.is_empty():\n\t\t\tcontinue  # Can't move this way, wall is blocking\n\n\t\t# Check if after sidestepping, we'd have a clear shot\n\t\tvar test_position: Vector2 = global_position + sidestep_dir * check_distance\n\t\tvar shot_query := PhysicsRayQueryParameters2D.new()\n\t\tshot_query.from = test_position\n\t\tshot_query.to = test_position + direction_to_player * bullet_check_distance\n\t\tshot_query.collision_mask = 4\n\t\tshot_query.exclude = [get_rid()]\n\n\t\tvar shot_result := space_state.intersect_ray(shot_query)\n\t\tif shot_result.is_empty():\n\t\t\t# Found a direction that leads to a clear shot\n\t\t\t_log_debug(\"Found sidestep direction: %s\" % sidestep_dir)\n\t\t\treturn sidestep_dir\n\n\treturn Vector2.ZERO  # No clear sidestep direction found\n\n\n## Check if the enemy should shoot at the current target.\n## Validates bullet spawn clearance, friendly fire avoidance, and cover blocking.\nfunc _should_shoot_at_target(target_position: Vector2) -> bool:\n\t# Check if the immediate path to bullet spawn is clear\n\t# This prevents shooting into walls the enemy is flush against\n\tvar direction := (target_position - global_position).normalized()\n\tif not _is_bullet_spawn_clear(direction):\n\t\treturn false\n\n\t# Check if friendlies are in the way\n\tif not _is_firing_line_clear_of_friendlies(target_position):\n\t\treturn false\n\n\t# Check if cover blocks the shot\n\tif not _is_shot_clear_of_cover(target_position):\n\t\treturn false\n\n\treturn true\n\n\n## Check if the player is \"close\" (within CLOSE_COMBAT_DISTANCE).\n## Used to determine if the enemy should engage directly or pursue.\nfunc _is_player_close() -> bool:\n\tif _player == null:\n\t\treturn false\n\treturn global_position.distance_to(_player.global_position) <= CLOSE_COMBAT_DISTANCE\n\n\n## Check if the enemy can hit the player from their current position.\n## Returns true if there's a clear line of fire to the player.\nfunc _can_hit_player_from_current_position() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check if we can see the player\n\tif not _can_see_player:\n\t\treturn false\n\n\t# Check if the shot would be blocked by cover\n\treturn _is_shot_clear_of_cover(
[2026-01-18T02:52:20.945Z] [INFO] _player.global_position)\n\n\n## Count the number of enemies currently in combat-related states.\n## Includes COMBAT, PURSUING, ASSAULT, IN_COVER (if can see player).\n## Used to determine if multi-enemy assault should be triggered.\nfunc _count_enemies_in_combat() -> int:\n\tvar count := 0\n\tvar enemies := get_tree().get_nodes_in_group(\"enemies\")\n\n\tfor enemy in enemies:\n\t\tif enemy == self:\n\t\t\tcontinue\n\t\tif not enemy.has_method(\"get_current_state\"):\n\t\t\tcontinue\n\n\t\tvar state: AIState = enemy.get_current_state()\n\t\t# Count enemies in combat-related states\n\t\tif state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\t\t# For IN_COVER, only count if they can see the player\n\t\t\tif state == AIState.IN_COVER:\n\t\t\t\tif enemy.has_method(\"is_in_combat_engagement\") and enemy.is_in_combat_engagement():\n\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tcount += 1\n\n\t# Count self if in a combat-related state\n\tif _current_state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\tcount += 1\n\n\treturn count\n\n\n## Check if this enemy is engaged in combat (can see player and in combat state).\nfunc is_in_combat_engagement() -> bool:\n\treturn _can_see_player and _current_state in [AIState.COMBAT, AIState.IN_COVER, AIState.ASSAULT]\n\n\n## Find cover position closer to the player for pursuit.\n## Used during PURSUING state to move cover-to-cover toward the player.\nfunc _find_pursuit_cover_toward_player() -> void:\n\tif _player == null:\n\t\t_has_pursuit_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For pursuit, we want cover that is:\n\t\t\t# 1. Closer to the player than we currently are\n\t\t\t# 2. Hidden from the player (or mostly hidden)\n\t\t\t# 3. Not too far from our current position\n\n\t\t\tvar my_distance_to_player := global_position.distance_to(player_pos)\n\t\t\tvar cover_distance_to_player := cover_pos.distance_to(player_pos)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to player\n\t\t\tif cover_distance_to_player >= my_distance_to_player:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if this position is hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Hidden from player (priority)\n\t\t\t# - Closer to player\n\t\t\t# - Not too far from current position\n\t\t\tvar hidden_score: float = 5.0 if is_hidden else 0.0\n\t\t\tvar approach_score: float = (my_distance_to_player - cover_distance_to_player) / CLOSE_COMBAT_DISTANCE\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = hidden_score + approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_pursuit_next_cover = best_cover\n\t\t_has_pursuit_cover = true\n\t\t_log_debug(\"Found pursuit cover at %s (score: %.2f)\" % [_pursuit_next_cover, best_score])\n\telse:\n\t\t_has_pursuit_cover = false\n\n\n## Find cover position closest to the player for assault positioning.\n## Used during ASSAULT state to take the nearest safe cover to the player.\nfunc _find_cover_closest_to_player() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_distance: float = INF\n\tvar found_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# Check if this position is hidden from player (safe cover)\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\tif is_hidden:\n\t\t\t\t# Calculate distance from this cover to the player\n\t\t\t\tvar distance_to_player := cover_pos.distance_to(player_pos)\n\n\t\t\t\t# We want the cover closest to the player\n\t\t\t\tif distance_to_player < best_distance:\n\t\t\t\t\tbest_distance = distance_to_player\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\t\tfound_cover = true\n\n\tif found_cover:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found assault cover at %s (distance to player: %.1f)\" % [_cover_position, best_distance])\n\telse:\n\t\t# Fall back to normal cover finding\n\t\t_find_cover_position()\n\n\n## Find a valid cover position relative to the player.\n## The cover position must be hidden from the player's line of sight.\nfunc _find_cover_position() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_hidden_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is on the opposite side of the obstacle from player\n\t\t\tvar direction_from_player := (collision_point - player_pos).normalized()\n\n\t\t\t# Position behind cover (offset from collision point along normal)\n\t\t\t# Offset must be large enough to hide the entire enemy body (radius ~24 pixels)\n\t\t\t# Using 35 pixels to provide some margin for the enemy's collision shape\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# First priority: Check if this position is actually hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Only consider hidden positions unless we have no choice\n\t\t\tif is_hidden or not found_hidden_cover:\n\t\t\t\t# Score based on:\n\t\t\t\t# 1. Whether position is hidden (highest priority)\n\t\t\t\t# 2. Distance from enemy (closer is better)\n\t\t\t\t# 3. Position relative to player (behind cover from player's view)\n\t\t\t\tvar hidden_score: float = 10.0 if is_hidden else 0.0  # Heavy weight for hidden positions\n\n\t\t\t\tvar distance_score := 1.0 - (global_position.distance_to(cover_pos) / COVER_CHECK_DISTANCE)\n\n\t\t\t\t# Check if this position is on the far side of obstacle from player\n\t\t\t\tvar cover_direction := (cover_pos - player_pos).normalized()\n\t\t\t\tvar dot_product := direction_from_player.dot(cover_direction)\n\t\t\t\tvar blocking_score: float = maxf(0.0, dot_product)\n\n\t\t\t\tvar total_score: float = hidden_score + distance_score * 0.3 + blocking_score * 0.7\n\n\t\t\t\t# If we find a hidden position, only accept other hidden positions\n\t\t\t\tif is_hidden and not found_hidden_cover:\n\t\t\t\t\tfound_hidden_cover = true\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\telif (is_hidden or not found_hidden_cover) and total_score > best_score:\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\n\tif best_score > 0:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found cover at: %s (hidden: %s)\" % [_cover_position, found_hidden_cover])\n\telse:\n\t\t_has_valid_cover = false\n\n\n## Calculate flank position based on player location.\nfunc _calculate_flank_position() -> void:\n\tif _player == null:\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar player_to_enemy := (global_position - player_pos).normalized()\n\n\t# Choose left or right flank based on current position\n\tvar flank_side := 1.0 if randf() > 0.5 else -1.0\n\tvar flank_direction := player_to_enemy.rotated(flank_angle * flank_side)\n\n\t_flank_target = player_pos + flank_direction * flank_distance\n\t_log_debug(\"Flank target: %s\" % _flank_target)\n\n\n## Check if there's a clear path (no obstacles) to the target position.\n## Uses a raycast to check for walls/obstacles between current position and target.\nfunc _has_clear_path_to(target: Vector2) -> bool:\n\tif _raycast == null:\n\t\treturn true  # Assume clear if no raycast available\n\n\tvar direction := (target - global_position).normalized()\n\tvar distance := global_position.distance_to(target)\n\n\t_raycast.target_position = direction * distance\n\t_raycast.force_raycast_update()\n\n\t# If we hit something, path is blocked\n\tif _raycast.is_colliding():\n\t\tvar collision_point := _raycast.get_collision_point()\n\t\tvar collision_distance := global_position.distance_to(collision_point)\n\t\t# Only consider it blocked if the collision is before the target\n\t\treturn collision_distance >= distance - 10.0\n\n\treturn true\n\n\n## Find cover position closer to the flank target.\n## Used during FLANKING state to move cover-to-cover toward the flank position.\nfunc _find_flank_cover_toward_target() -> void:\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For flanking, we want cover that is:\n\t\t\t# 1. Closer to the flank target than we currently are\n\t\t\t# 2. Not too far from our current position\n\t\t\t# 3. Reachable (has clear path)\n\n\t\t\tvar my_distance_to_target := global_position.distance_to(_flank_target)\n\t\t\tvar cover_distance_to_target := cover_pos.distance_to(_flank_target)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to flank target\n\t\t\tif cover_distance_to_target >= my_distance_to_target:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if we can reach this cover (has clear path)\n\t\t\tif not _has_clear_path_to(cover_pos):\n\t\t\t\t# Even if direct path is blocked, we might be able to reach\n\t\t\t\t# via another intermediate cover, but skip for now\n\t\t\t\tcontinue\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Closer to flank target (priority)\n\t\t\t# - Not too far from current position\n\t\t\tvar approach_score: float = (my_distance_to_target - cover_distance_to_target) / flank_distance\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_flank_next_cover = best_cover\n\t\t_has_flank_cover = true\n\t\t_log_debug(\"Found flank cover at %s (score: %.2f)\" % [_flank_next_cover, best_score])\n\telse:\n\t\t_has_flank_cover = false\n\n\n## Check if there's a wall ahead in the given direction and return avoidance direction.\n## Returns Vector2.ZERO if no wall detected, otherwise returns a vector to avoid the wall.\nfunc _check_wall_ahead(direction: Vector2) -> Vector2:\n\tif _wall_raycasts.is_empty():\n\t\treturn Vector2.ZERO\n\n\tvar avoidance := Vector2.ZERO\n\tvar perpendicular := Vector2(-direction.y, direction.x)  # 90 degrees rotation\n\n\t# Check center, left, and right raycasts\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar angle_offset := (i - 1) * 0.5  # -0.5, 0, 0.5 radians (~-28, 0, 28 degrees)\n\t\tvar check_direction := direction.rotated(angle_offset)\n\n\t\tvar raycast := _wall_raycasts[i]\n\t\traycast.target_position = check_direction * WALL_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\t# Calculate avoidance based on which raycast hit\n\t\t\tif i == 0:  # Left raycast hit\n\t\t\t\tavoidance += perpendicular  # Steer right\n\t\t\telif i == 1:  # Center raycast hit\n\t\t\t\tavoidance += perpendicular if randf() > 0.5 else -perpendicular  # Random steer\n\t\t\telif i == 2:  # Right raycast hit\n\t\t\t\tavoidance -= perpendicular  # Steer left\n\n\treturn avoidance.normalized() if avoidance.length() > 0 else Vector2.ZERO\n\n\n## Check if the player is visible using raycast.\n## If detection_range is 0 or negative, uses unlimited detection range (line-of-sight only).\n## This allows the enemy to see the player even outside the viewport if there's no obstacle.\n## Also updates the continuous visibility timer and visibility ratio for lead prediction control.\nfunc _check_player_visibility() -> void:\n\tvar was_visible := _can_see_player\n\t_can_see_player = false\n\t_player_visibility_ratio = 0.0\n\n\tif _player == null or not _raycast:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t# Check if player is within detection range (only if detection_range is positive)\n\t# If detection_range <= 0, detection is unlimited (line-of-sight only)\n\tif detection_range > 0 and distance_to_player > detection_range:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\t# Point raycast at player - use actual distance to player for the raycast length\n\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\tvar raycast_length := distance_to_player + 10.0  # Add small buffer to ensure we reach player\n\t_raycast.target_position = direction_to_player * raycast_length\n\t_raycast.force_raycast_update()\n\n\t# Check if raycast hit something\n\tif _raycast.is_colliding():\n\t\tvar collider := _raycast.get_collider()\n\t\t# If we hit the player, we can see them\n\t\tif collider == _player:\n\t\t\t_can_see_player = true\n\t\t# If we hit a wall/obstacle before the player, we can't see them\n\telse:\n\t\t# No collision between us and player - we have clear line of sight\n\t\t_can_see_player = true\n\n\t# Update continuous visibility timer and visibility ratio\n\tif _can_see_player:\n\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n\t\t# Calculate what fraction of the player's body is visible\n\t\t# This is used to determine if lead prediction should be enabled\n\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n\telse:\n\t\t# Lost line of sight - reset the timer and visibility ratio\n\t\t_continuous_visibility_timer = 0.0\n\t\t_player_visibility_ratio = 0.0\n\n\n## Aim the enemy sprite/direction at the player using gradual rotation.\nfunc _aim_at_player() -> void:\n\tif _player == null:\n\t\treturn\n\tvar direction := (_player.global_position - global_position).normalized()\n\tvar target_angle := direction.angle()\n\n\t# Calculate the shortest rotation direction\n\tvar angle_diff := wrapf(target_angle - rotation, -PI, PI)\n\n\t# Get the delta time from the current physics process\n\tvar delta := get_physics_process_delta_time()\n\n\t# Apply gradual rotation based on rotation_speed\n\tif abs(angle_diff) <= rotation_speed * delta:\n\t\t# Close enough to snap to target\n\t\trotation = target_angle\n\telif angle_diff > 0:\n\t\trotation += rotation_speed * delta\n\telse:\n\t\trotation -= rotation_speed * delta\n\n\n## Shoot a bullet towards the player.\nfunc _shoot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\t# Check if we can shoot (have ammo and not reloading)\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Apply lead prediction if enabled\n\tif enable_lead_prediction:\n\t\ttarget_position = _calculate_lead_prediction()\n\n\t# Check if the shot should be taken (friendly fire and cover checks)\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Create bullet instance\n\tvar bullet := bullet_scene.instantiate()\n\n\t# Set bullet position with offset in shoot direction\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\n\t# Set bullet direction\n\tbullet.direction = direction\n\n\t# Set shooter ID to identify this enemy as the source\n\t# This prevents enemies from detecting their own bullets in the threat sphere\n\tbullet.shooter_id = get_instance_id()\n\n\t# Add bullet to the scene tree\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play shooting sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\n\t# Play shell casing sound with a small delay\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\t# Auto-reload when magazine is empty\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Play shell casing sound with a delay to simulate the casing hitting the ground.\nfunc _play_delayed_shell_sound() -> void:\n\tawait get_tree().create_timer(0.15).timeout\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_shell_rifle\"):\n\t\taudio_manager.play_shell_rifle(global_position)\n\n\n## Calculate lead prediction - aims where the player will be, not where they are.\n## Uses iterative approach for better accuracy with moving targets.\n## Only applies lead prediction if:\n## 1. The player has been continuously visible for at least lead_prediction_delay seconds\n## 2. At least lead_prediction_visibility_threshold of the player's body is visible\n## 3. The predicted position is also visible to the enemy (not behind cover)\n## This prevents enemies from \"knowing\" where the player will emerge from cover.\nfunc _calculate_lead_prediction() -> Vector2:\n\tif _player == null:\n\t\treturn global_position\n\n\tvar player_pos := _player.global_position\n\n\t# Only use lead prediction if the player has been continuously visible\n\t# for long enough. This prevents enemies from predicting player position\n\t# immediately when they emerge from cover.\n\tif _continuous_visibility_timer < lead_prediction_delay:\n\t\t_log_debug(\"Lead prediction disabled: visibility time %.2fs < %.2fs required\" % [_continuous_visibility_timer, lead_prediction_delay])\n\t\treturn player_pos\n\n\t# Only use lead prediction if enough of the player's body is visible.\n\t# This prevents pre-firing when the player is at the edge of cover with only\n\t# a small part of their body visible. The player must be significantly exposed\n\t# before the enemy can predict their movement.\n\tif _player_visibility_ratio < lead_prediction_visibility_threshold:\n\t\t_log_debug(\"Lead prediction disabled: visibility ratio %.2f < %.2f required (player at cover edge)\" % [_player_visibility_ratio, lead_prediction_visibility_threshold])\n\t\treturn player_pos\n\n\tvar player_velocity := Vector2.ZERO\n\n\t# Get player velocity if they are a CharacterBody2D\n\tif _player is CharacterBody2D:\n\t\tplayer_velocity = _player.velocity\n\n\t# If player is stationary, no need for prediction\n\tif player_velocity.length_squared() < 1.0:\n\t\treturn player_pos\n\n\t# Iterative lead prediction for better accuracy\n\t# Start with player's current position\n\tvar predicted_pos := player_pos\n\tvar distance := global_position.distance_to(predicted_pos)\n\n\t# Iterate 2-3 times for convergence\n\tfor i in range(3):\n\t\t# Time for bullet to reach the predicted position\n\t\tvar time_to_target := distance / bullet_speed\n\n\t\t# Predict where player will be at that time\n\t\tpredicted_pos = player_pos + player_velocity * time_to_target\n\n\t\t# Update distance for next iteration\n\t\tdistance = global_position.distance_to(predicted_pos)\n\n\t# CRITICAL: Validate that the predicted position is actually visible to the enemy.\n\t# If the predicted position is behind cover (e.g., player is running toward cover exit),\n\t# we should NOT aim there - it would feel like the enemy is \"cheating\" by knowing\n\t# where the player will emerge. Fall back to player's current visible position.\n\tif not _is_position_visible_to_enemy(predicted_pos):\n\t\t_log_debug(\"Lead prediction blocked: predicted position %s is not visible, using current position %s\" % [predicted_pos, player_pos])\n\t\treturn player_pos\n\n\t_log_debug(\"Lead prediction: player at %s moving %s, aiming at %s\" % [player_pos, player_velocity, predicted_pos])\n\n\treturn predicted_pos\n\n\n## Process patrol behavior - move between patrol points.\nfunc _process_patrol(delta: float) -> void:\n\tif _patrol_points.is_empty():\n\t\treturn\n\n\t# Handle waiting at patrol point\n\tif _is_waiting_at_patrol_point:\n\t\t_patrol_wait_timer += delta\n\t\tif _patrol_wait_timer >= patrol_wait_time:\n\t\t\t_is_waiting_at_patrol_point = false\n\t\t\t_patrol_wait_timer = 0.0\n\t\t\t_current_patrol_index = (_current_patrol_index + 1) % _patrol_points.size()\n\t\tvelocity = Vector2.ZERO\n\t\treturn\n\n\t# Move towards current patrol point\n\tvar target_point := _patrol_points[_current_patrol_index]\n\tvar direction := (target_point - global_position).normalized()\n\tvar distance := global_position.distance_to(target_point)\n\n\tif distance < 5.0:\n\t\t# Reached patrol point, start waiting\n\t\t_is_waiting_at_patrol_point = true\n\t\tvelocity = Vector2.ZERO\n\telse:\n\t\t# Check for walls and apply avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\t# Blend movement direction with avoidance\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * move_speed\n\t\t# Face movement direction when patrolling\n\t\trotation = direction.angle()\n\n\n## Process guard behavior - stand still and look around.\nfunc _process_guard(_delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\t# In guard mode, enemy doesn't move but can still aim at player when visible\n\n\n## Called when a bullet enters the threat sphere.\nfunc _on_threat_area_entered(area: Area2D) -> void:\n\t# Check if bullet has shooter_id property and if it's from this enemy\n\t# This prevents enemies from being suppressed by their own bullets\n\tif \"shooter_id\" in area and area.shooter_id == get_instance_id():\n\t\treturn  # Ignore own bullets\n\n\t_bullets_in_threat_sphere.append(area)\n\t# Set threat memory timer so enemy can react even after fast bullets exit\n\t# This allows the reaction delay to complete even if bullets pass through quickly\n\t_threat_memory_timer = THREAT_MEMORY_DURATION\n\t# Note: _under_fire is now set in _update_suppression after threat_reaction_delay\n\t# This gives the player more time before the enemy reacts to nearby gunfire\n\t_log_debug(\"Bullet entered threat sphere, starting reaction delay...\")\n\n\n## Called when a bullet exits the threat sphere.\nfunc _on_threat_area_exited(area: Area2D) -> void:\n\t_bullets_in_threat_sphere.erase(area)\n\n\n## Called when the enemy is hit (by bullet.gd).\nfunc on_hit() -> void:\n\tif not _is_alive:\n\t\treturn\n\n\thit.emit()\n\n\t# Track hits for retreat behavior\n\t_hits_taken_in_encounter += 1\n\t_log_debug(\"Hit taken! Total hits in encounter: %d\" % _hits_taken_in_encounter)\n\t_log_to_file(\"Hit taken, health: %d/%d\" % [_current_health - 1, _max_health])\n\n\t# Show hit flash effect\n\t_show_hit_flash()\n\n\t# Apply damage\n\t_current_health -= 1\n\n\t# Play appropriate hit sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif _current_health <= 0:\n\t\t# Play lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_lethal\"):\n\t\t\taudio_manager.play_hit_lethal(global_position)\n\t\t_on_death()\n\telse:\n\t\t# Play non-lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_non_lethal\"):\n\t\t\taudio_manager.play_hit_non_lethal(global_position)\n\t\t_update_health_visual()\n\n\n## Shows a brief flash effect when hit.\nfunc _show_hit_flash() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t_sprite.modulate = hit_flash_color\n\n\tawait get_tree().create_timer(hit_flash_duration).timeout\n\n\t# Restore color based on current health (if still alive)\n\tif _is_alive:\n\t\t_update_health_visual()\n\n\n## Updates the sprite color based on current health percentage.\nfunc _update_health_visual() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t# Interpolate color based on health percentage\n\tvar health_percent := _get_health_percent()\n\t_sprite.modulate = full_health_color.lerp(low_health_color, 1.0 - health_percent)\n\n\n## Returns the current health as a percentage (0.0 to 1.0).\nfunc _get_health_percent() -> float:\n\tif _max_health <= 0:\n\t\treturn 0.0\n\treturn float(_current_health) / float(_max_health)\n\n\n## Called when the enemy dies.\nfunc _on_death() -> void:\n\t_is_alive = false\n\t_log_to_file(\"Enemy died\")\n\tdied.emit()\n\n\tif destroy_on_death:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\tqueue_free()\n\telse:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\t_reset()\n\n\n## Resets the enemy to its initial state.\nfunc _reset() -> void:\n\tglobal_position = _initial_position\n\trotation = 0.0\n\t_current_patrol_index = 0\n\t_is_waiting_at_patrol_point = false\n\t_patrol_wait_timer = 0.0\n\t_current_state = AIState.IDLE\n\t_has_valid_cover = false\n\t_under_fire = false\n\t_suppression_timer = 0.0\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t_continuous_visibility_timer = 0.0\n\t_player_visibility_ratio = 0.0\n\t_threat_reaction_timer = 0.0\n\t_threat_reaction_delay_elapsed = false\n\t_threat_memory_timer = 0.0\n\t_bullets_in_threat_sphere.clear()\n\t# Reset retreat state variables\n\t_hits_taken_in_encounter = 0\n\t_retreat_mode = RetreatMode.FULL_HP\n\t_retreat_turn_timer = 0.0\n\t_retreat_turning_to_cover = false\n\t_retreat_burst_remaining = 0\n\t_retreat_burst_timer = 0.0\n\t_retreat_burst_complete = false\n\t_retreat_burst_angle_offset = 0.0\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\t# Reset combat state variables\n\t_combat_shoot_timer = 0.0\n\t_combat_shoot_duration = 2.5\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_approach_timer = 0.0\n\t# Reset pursuit state variables\n\t_pursuit_cover_wait_timer = 0.0\n\t_pursuit_next_cover = Vector2.ZERO\n\t_has_pursuit_cover = false\n\t# Reset assault state variables\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset flank state variables\n\t_flank_cover_wait_timer = 0.0\n\t_flank_next_cover = Vector2.ZERO\n\t_has_flank_cover = false\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_initialize_goap_state()\n\n\n## Log debug message if debug_logging is enabled.\nfunc _log_debug(message: String) -> void:\n\tif debug_logging:\n\t\tprint(\"[Enemy %s] %s\" % [name, message])\n\n\n## Log a message to the file logger (always logs, regardless of debug_logging setting).\n## Use for important events like spawning, dying, or critical state changes.\nfunc _log_to_file(message: String) -> void:\n\tif not is_inside_tree():\n\t\treturn\n\tvar file_logger: Node = get_node_or_null(\"/root/FileLogger\")\n\tif file_logger and file_logger.has_method(\"log_enemy\"):\n\t\tfile_logger.log_enemy(name, message)\n\n\n## Log spawn info (called via call_deferred to ensure FileLogger is loaded).\nfunc _log_spawn_info() -> void:\n\t_log_to_file(\"Enemy spawned at %s, health: %d, behavior: %s, player_found: %s\" % [\n\t\tglobal_position, _max_health, BehaviorMode.keys()[behavior_mode],\n\t\t\"yes\" if _player != null else \"no\"])\n\n\n## Get AI state name as a human-readable string.\nfunc _get_state_name(state: AIState) -> String:\n\tmatch state:\n\t\tAIState.IDLE:\n\t\t\treturn \"IDLE\"\n\t\tAIState.COMBAT:\n\t\t\treturn \"COMBAT\"\n\t\tAIState.SEEKING_COVER:\n\t\t\treturn \"SEEKING_COVER\"\n\t\tAIState.IN_COVER:\n\t\t\treturn \"IN_COVER\"\n\t\tAIState.FLANKING:\n\t\t\treturn \"FLANKING\"\n\t\tAIState.SUPPRESSED:\n\t\t\treturn \"SUPPRESSED\"\n\t\tAIState.RETREATING:\n\t\t\treturn \"RETREATING\"\n\t\tAIState.PURSUING:\n\t\t\treturn \"PURSUING\"\n\t\tAIState.ASSAULT:\n\t\t\treturn \"ASSAULT\"\n\t\t_:\n\t\t\treturn \"UNKNOWN\"\n\n\n## Update the debug label with current AI state.\nfunc _update_debug_label() -> void:\n\tif _debug_label == null:\n\t\treturn\n\n\t_debug_label.visible = debug_label_enabled\n\tif not debug_label_enabled:\n\t\treturn\n\n\tvar state_text := _get_state_name(_current_state)\n\n\t# Add retreat mode info if retreating\n\tif _current_state == AIState.RETREATING:\n\t\tmatch _retreat_mode:\n\t\t\tRetreatMode.FULL_HP:\n\t\t\t\tstate_text += \"\\n(FULL_HP)\"\n\t\t\tRetreatMode.ONE_HIT:\n\t\t\t\tstate_text += \"\\n(ONE_HIT)\"\n\t\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t\tstate_text += \"\\n(MULTI_HITS)\"\n\n\t# Add assault timer info if in assault state\n\tif _current_state == AIState.ASSAULT:\n\t\tif _assault_ready:\n\t\t\tstate_text += \"\\n(RUSHING)\"\n\t\telse:\n\t\t\tvar time_left := ASSAULT_WAIT_DURATION - _assault_wait_timer\n\t\t\tstate_text += \"\\n(%.1fs)\" % time_left\n\n\t# Add combat phase info if in combat\n\tif _current_state == AIState.COMBAT:\n\t\tif _combat_exposed:\n\t\t\tvar time_left := _combat_shoot_duration - _combat_shoot_timer\n\t\t\tstate_text += \"\\n(EXPOSED %.1fs)\" % time_left\n\t\telif _seeking_clear_shot:\n\t\t\tvar time_left := CLEAR_SHOT_MAX_TIME - _clear_shot_timer\n\t\t\tstate_text += \"\\n(SEEK SHOT %.1fs)\" % time_left\n\t\telif _combat_approaching:\n\t\t\tstate_text += \"\\n(APPROACH)\"\n\n\t# Add pursuit timer info if pursuing and waiting at cover\n\tif _current_state == AIState.PURSUING:\n\t\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t\tvar time_left := PURSUIT_COVER_WAIT_DURATION - _pursuit_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_pursuit_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\n\t# Add flanking phase info if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_valid_cover and not _has_flank_cover:\n\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_flank_co
[2026-01-18T02:52:20.966Z] [INFO] ver:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\t\telse:\n\t\t\tstate_text += \"\\n(DIRECT)\"\n\n\t_debug_label.text = state_text\n\n\n## Get current AI state (for external access/debugging).\nfunc get_current_state() -> AIState:\n\treturn _current_state\n\n\n## Get GOAP world state (for GOAP planner).\nfunc get_goap_world_state() -> Dictionary:\n\treturn _goap_world_state.duplicate()\n\n\n## Check if enemy is currently under fire.\nfunc is_under_fire() -> bool:\n\treturn _under_fire\n\n\n## Check if enemy is in cover.\nfunc is_in_cover() -> bool:\n\treturn _current_state == AIState.IN_COVER or _current_state == AIState.SUPPRESSED\n\n\n## Get current ammo in magazine.\nfunc get_current_ammo() -> int:\n\treturn _current_ammo\n\n\n## Get reserve ammo.\nfunc get_reserve_ammo() -> int:\n\treturn _reserve_ammo\n\n\n## Get total ammo (current + reserve).\nfunc get_total_ammo() -> int:\n\treturn _current_ammo + _reserve_ammo\n\n\n## Check if enemy is currently reloading.\nfunc is_reloading() -> bool:\n\treturn _is_reloading\n\n\n## Check if enemy has any ammo left.\nfunc has_ammo() -> bool:\n\treturn _current_ammo > 0 or _reserve_ammo > 0\n\n\n## Get current player visibility ratio (for debugging).\n## Returns 0.0 if player is completely hidden, 1.0 if fully visible.\nfunc get_player_visibility_ratio() -> float:\n\treturn _player_visibility_ratio\n\n\n## Draw debug visualization when debug mode is enabled.\n## Shows: line to target (cover, clear shot, player), bullet spawn point status.\nfunc _draw() -> void:\n\tif not debug_label_enabled:\n\t\treturn\n\n\t# Colors for different debug elements\n\tvar color_to_cover := Color.CYAN  # Line to cover position\n\tvar color_to_player := Color.RED  # Line to player (when visible)\n\tvar color_clear_shot := Color.YELLOW  # Line to clear shot target\n\tvar color_pursuit := Color.ORANGE  # Line to pursuit cover\n\tvar color_flank := Color.MAGENTA  # Line to flank position\n\tvar color_bullet_spawn := Color.GREEN  # Bullet spawn point ind
[2026-01-18T02:52:20.969Z] [INFO] icator\n\tvar color_blocked := Color.RED  # Blocked path indicator\n\n\t# Draw line to player if visible\n\tif _can_see_player and _player:\n\t\tvar to_player := _player.global_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_player, color_to_player, 1.5)\n\n\t\t# Draw bullet spawn point and check if blocked\n\t\tvar direction_to_player := to_player.normalized()\n\t\tvar spawn_point := direction_to_player * bullet_spawn_offset\n\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\tdraw_circle(spawn_point, 5.0, color_bullet_spawn)\n\t\telse:\n\t\t\t# Draw X for blocked spawn point\n\t\t\tdraw_line(spawn_point + Vector2(-5, -5), spawn_point + Vector2(5, 5), color_blocked, 2.0)\n\t\t\tdraw_line(spawn_point + Vector2(-5, 5), spawn_point + Vector2(5, -5), color_blocked, 2.0)\n\n\t# Draw line to cover position if we have one\n\tif _has_valid_cover:\n\t\tvar to_cover := _cover_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_cover, color_to_cover, 1.5)\n\t\t# Draw small circle at cover position\n\t\tdraw_circle(to_cover, 8.0, color_to_cover)\n\n\t# Draw line to clear shot target if seeking clear shot\n\tif _seeking_clear_shot and _clear_shot_target != Vector2.ZERO:\n\t\tvar to_target := _clear_shot_target - global_position\n\t\tdraw_line(Vector2.ZERO, to_target, color_clear_shot, 2.0)\n\t\t# Draw triangle at target position\n\t\tvar target_pos := to_target\n\t\tdraw_line(target_pos + Vector2(-6, 6), target_pos + Vector2(6, 6), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(6, 6), target_pos + Vector2(0, -8), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(0, -8), target_pos + Vector2(-6, 6), color_clear_shot, 2.0)\n\n\t# Draw line to pursuit cover if pursuing\n\tif _current_state == AIState.PURSUING and _has_pursuit_cover:\n\t\tvar to_pursuit := _pursuit_next_cover - global_position\n\t\tdraw_line(Vector2.ZERO, to_pursuit, color_pursuit, 2.0)\n\t\tdraw_circle(to_pursuit, 8.0, color_pursuit)\n\n\t# Draw line to flank target if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_flank_cover:\n\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n\t\telif _flank_target != Vector2.ZERO:\n\t\t\tvar to_flank := _flank_target - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n\t\t\t# Draw diamond at flank target\n\t\t\tvar flank_pos := to_flank\n\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)\n","structuredPatch":[{"oldStart":400,"oldLines":6,"newStart":400,"newLines":43,"lines":[" ## GOAP world state for goal-oriented planning."," var _goap_world_state: Dictionary = {}"," ","+## --- Search/Investigation State (for when player escapes from view) ---","+## Last known position where the player was seen before escaping view.","+var _last_known_player_position: Vector2 = Vector2.ZERO","+","+## Whether a search zone is currently active.","+var _search_zone_active: bool = false","+","+## Radius of the potential player zone (area where player might be hiding).","+const SEARCH_ZONE_RADIUS: float = 200.0","+","+## Timer for search timeout - enemy gives up searching after this time.","+var _search_timer: float = 0.0","+","+## Maximum time to spend searching before giving up (seconds).","+const SEARCH_MAX_DURATION: float = 15.0","+","+## Inspection points within the search zone (hiding spots behind covers and corners).","+var _inspection_points: Array[Vector2] = []","+","+## Index of current inspection point being checked.","+var _current_inspection_index: int = 0","+","+## Timer for waiting at each inspection point (looking around).","+var _inspection_wait_timer: float = 0.0","+","+## Duration to wait at each inspection point (seconds).","+const INSPECTION_WAIT_DURATION: float = 1.5","+","+## Whether currently waiting at an inspection point.","+var _inspecting_point: bool = false","+","+## Number of raycasts for detecting inspection points (corners/hiding spots).","+const INSPECTION_POINT_CHECK_COUNT: int = 24","+","+## Distance to check for inspection points from search zone center.","+const INSPECTION_CHECK_DISTANCE: float = 250.0","+"," ## Detection delay timer - tracks time since entering combat."," var _detection_timer: float = 0.0"," "]}],"userModified":false,"replaceAll":false}}
[2026-01-18T02:52:23.403Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01UZpD92asQF3rDtAP9kebbv",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now I need to update the GOAP state initialization and update functions:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 1348,
      "cache_read_input_tokens": 107224,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1348,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "aa15a815-957d-4e0d-b151-712ba0edc03e"
}
[2026-01-18T02:52:27.969Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01UZpD92asQF3rDtAP9kebbv",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_016Ugqqa5Xm1mLzNZvFnGRX3",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "old_string": "## Initialize GOAP world state.\nfunc _initialize_goap_state() -> void:\n\t_goap_world_state = {\n\t\t\"player_visible\": false,\n\t\t\"has_cover\": false,\n\t\t\"in_cover\": false,\n\t\t\"under_fire\": false,\n\t\t\"health_low\": false,\n\t\t\"can_flank\": false,\n\t\t\"at_flank_position\": false,\n\t\t\"is_retreating\": false,\n\t\t\"hits_taken\": 0,\n\t\t\"is_pursuing\": false,\n\t\t\"is_assaulting\": false,\n\t\t\"can_hit_from_cover\": false,\n\t\t\"player_close\": false,\n\t\t\"enemies_in_combat\": 0\n\t}",
          "new_string": "## Initialize GOAP world state.\nfunc _initialize_goap_state() -> void:\n\t_goap_world_state = {\n\t\t\"player_visible\": false,\n\t\t\"has_cover\": false,\n\t\t\"in_cover\": false,\n\t\t\"under_fire\": false,\n\t\t\"health_low\": false,\n\t\t\"can_flank\": false,\n\t\t\"at_flank_position\": false,\n\t\t\"is_retreating\": false,\n\t\t\"hits_taken\": 0,\n\t\t\"is_pursuing\": false,\n\t\t\"is_assaulting\": false,\n\t\t\"can_hit_from_cover\": false,\n\t\t\"player_close\": false,\n\t\t\"enemies_in_combat\": 0,\n\t\t\"has_search_zone\": false,\n\t\t\"search_zone_cleared\": false,\n\t\t\"inspection_points_remaining\": 0,\n\t\t\"is_searching\": false\n\t}"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 1348,
      "cache_read_input_tokens": 107224,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1348,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "faf8ffad-58dd-44a4-8240-ad88bb7f5579"
}
[2026-01-18T02:52:28.013Z] [INFO] {"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016Ugqqa5Xm1mLzNZvFnGRX3","type":"tool_result","content":"The file /tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   558‚Üí\t_threat_sphere.area_entered.connect(_on_threat_area_entered)\n   559‚Üí\t_threat_sphere.area_exited.connect(_on_threat_area_exited)\n   560‚Üí\n   561‚Üí\n   562‚Üí## Initialize GOAP world state.\n   563‚Üífunc _initialize_goap_state() -> void:\n   564‚Üí\t_goap_world_state = {\n   565‚Üí\t\t\"player_visible\": false,\n   566‚Üí\t\t\"has_cover\": false,\n   567‚Üí\t\t\"in_cover\": false,\n   568‚Üí\t\t\"under_fire\": false,\n   569‚Üí\t\t\"health_low\": false,\n   570‚Üí\t\t\"can_flank\": false,\n   571‚Üí\t\t\"at_flank_position\": false,\n   572‚Üí\t\t\"is_retreating\": false,\n   573‚Üí\t\t\"hits_taken\": 0,\n   574‚Üí\t\t\"is_pursuing\": false,\n   575‚Üí\t\t\"is_assaulting\": false,\n   576‚Üí\t\t\"can_hit_from_cover\": false,\n   577‚Üí\t\t\"player_close\": false,\n   578‚Üí\t\t\"enemies_in_combat\": 0,\n   579‚Üí\t\t\"has_search_zone\": false,\n   580‚Üí\t\t\"search_zone_cleared\": false,\n   581‚Üí\t\t\"inspection_points_remaining\": 0,\n   582‚Üí\t\t\"is_searching\": false\n   583‚Üí\t}\n   584‚Üí\n   585‚Üí\n   586‚Üí## Connect to GameManager's debug mode signal for F7 toggle.\n   587‚Üífunc _connect_debug_mode_signal() -> void:"}]},"parent_tool_use_id":null,"session_id":"797fbac8-f5e6-4339-8fd2-77453410db49","uuid":"6f2c647f-850e-4089-8f18-e3245eb15fa2","tool_use_result":{"filePath":"/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd","oldString":"## Initialize GOAP world state.\nfunc _initialize_goap_state() -> void:\n\t_goap_world_state = {\n\t\t\"player_visible\": false,\n\t\t\"has_cover\": false,\n\t\t\"in_cover\": false,\n\t\t\"under_fire\": false,\n\t\t\"health_low\": false,\n\t\t\"can_flank\": false,\n\t\t\"at_flank_position\": false,\n\t\t\"is_retreating\": false,\n\t\t\"hits_taken\": 0,\n\t\t\"is_pursuing\": false,\n\t\t\"is_assaulting\": false,\n\t\t\"can_hit_from_cover\": false,\n\t\t\"player_close\": false,\n\t\t\"enemies_in_combat\": 0\n\t}","newString":"## Initialize GOAP world state.\nfunc _initialize_goap_state() -> void:\n\t_goap_world_state = {\n\t\t\"player_visible\": false,\n\t\t\"has_cover\": false,\n\t\t\"in_cover\": false,\n\t\t\"under_fire\": false,\n\t\t\"health_low\": false,\n\t\t\"can_flank\": false,\n\t\t\"at_flank_position\": false,\n\t\t\"is_retreating\": false,\n\t\t\"hits_taken\": 0,\n\t\t\"is_pursuing\": false,\n\t\t\"is_assaulting\": false,\n\t\t\"can_hit_from_cover\": false,\n\t\t\"player_close\": false,\n\t\t\"enemies_in_combat\": 0,\n\t\t\"has_search_zone\": false,\n\t\t\"search_zone_cleared\": false,\n\t\t\"inspection_points_remaining\": 0,\n\t\t\"is_searching\": false\n\t}","originalFile":"extends CharacterBody2D\n## Enemy AI with tactical behaviors including patrol, guard, cover, and flanking.\n##\n## Supports multiple behavior modes:\n## - PATROL: Moves between patrol points\n## - GUARD: Stands in place watching for the player\n##\n## Tactical features:\n## - Uses cover when under fire (suppression)\n## - Attempts to flank the player from the sides\n## - Coordinates with other enemies (optional)\n## - GOAP foundation for goal-oriented planning\n\n## AI States for tactical behavior.\nenum AIState {\n\tIDLE,       ## Default idle state (patrol or guard)\n\tCOMBAT,     ## Actively engaging the player (coming out of cover, shooting 2-3s, returning)\n\tSEEKING_COVER,  ## Moving to cover position\n\tIN_COVER,   ## Taking cover from player fire\n\tFLANKING,   ## Attempting to flank the player\n\tSUPPRESSED, ## Under fire, staying in cover\n\tRETREATING, ## Retreating to cover while possibly shooting\n\tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n\tASSAULT,    ## Coordinated multi-enemy assault (rush player after 5s wait)\n\tSEARCHING   ## Searching for player at last-known-position zone\n}\n\n## Retreat behavior modes based on damage taken.\nenum RetreatMode {\n\tFULL_HP,        ## No damage - retreat backwards while shooting, periodically turn to cover\n\tONE_HIT,        ## One hit taken - quick burst then retreat without shooting\n\tMULTIPLE_HITS   ## Multiple hits - quick burst then retreat without shooting (same as ONE_HIT)\n}\n\n## Behavior modes for the enemy.\nenum BehaviorMode {\n\tPATROL,  ## Moves between patrol points\n\tGUARD    ## Stands in one place\n}\n\n## Current behavior mode.\n@export var behavior_mode: BehaviorMode = BehaviorMode.GUARD\n\n## Maximum movement speed in pixels per second.\n@export var move_speed: float = 220.0\n\n## Combat movement speed (faster when flanking/seeking cover).\n@export var combat_move_speed: float = 320.0\n\n## Rotation speed in radians per second for gradual turning.\n## Default is 15 rad/sec for challenging but fair combat.\n@export var rotation_speed: float = 15.0\n\n## Detection range for spotting the player.\n## Set to 0 or negative to allow unlimited detection range (line-of-sight only).\n## This allows enemies to see the player even outside the viewport if no obstacles block view.\n@export var detection_range: float = 0.0\n\n## Time between shots in seconds.\n## Default matches assault rifle fire rate (10 shots/second = 0.1s cooldown).\n@export var shoot_cooldown: float = 0.1\n\n## Bullet scene to instantiate when shooting.\n@export var bullet_scene: PackedScene\n\n## Offset from enemy center for bullet spawn position.\n@export var bullet_spawn_offset: float = 30.0\n\n## Patrol points as offsets from the initial position.\n## Only used when behavior_mode is PATROL.\n@export var patrol_offsets: Array[Vector2] = [Vector2(100, 0), Vector2(-100, 0)]\n\n## Wait time at each patrol point in seconds.\n@export var patrol_wait_time: float = 1.5\n\n## Color when at full health.\n@export var full_health_color: Color = Color(0.9, 0.2, 0.2, 1.0)\n\n## Color when at low health (interpolates based on health percentage).\n@export var low_health_color: Color = Color(0.3, 0.1, 0.1, 1.0)\n\n## Color to flash when hit.\n@export var hit_flash_color: Color = Color(1.0, 1.0, 1.0, 1.0)\n\n## Duration of hit flash effect in seconds.\n@export var hit_flash_duration: float = 0.1\n\n## Whether to destroy the enemy after death.\n@export var destroy_on_death: bool = false\n\n## Delay before respawning or destroying (in seconds).\n@export var respawn_delay: float = 2.0\n\n## Minimum random health.\n@export var min_health: int = 2\n\n## Maximum random health.\n@export var max_health: int = 4\n\n## Threat sphere radius - bullets within this radius trigger suppression.\n@export var threat_sphere_radius: float = 100.0\n\n## Time to stay suppressed after bullets leave threat sphere.\n@export var suppression_cooldown: float = 2.0\n\n## Delay (in seconds) before reacting to bullets in the threat sphere.\n## This prevents instant reactions to nearby gunfire, giving the player more time.\n@export var threat_reaction_delay: float = 0.2\n\n## Flank angle from player's facing direction (radians).\n@export var flank_angle: float = PI / 3.0  # 60 degrees\n\n## Distance to maintain while flanking.\n@export var flank_distance: float = 200.0\n\n## Enable/disable flanking behavior.\n@export var enable_flanking: bool = true\n\n## Enable/disable cover behavior.\n@export var enable_cover: bool = true\n\n## Enable/disable debug logging.\n@export var debug_logging: bool = false\n\n## Enable/disable debug label above enemy showing current AI state.\n@export var debug_label_enabled: bool = false\n\n## Enable/disable friendly fire avoidance (don't shoot if other enemies are in the way).\n@export var enable_friendly_fire_avoidance: bool = true\n\n## Enable/disable lead prediction (shooting ahead of moving targets).\n@export var enable_lead_prediction: bool = true\n\n## Bullet speed for lead prediction calculation.\n## Should match the actual bullet speed (default is 2500 for assault rifle).\n@export var bullet_speed: float = 2500.0\n\n## Ammunition system - magazine size (bullets per magazine).\n@export var magazine_size: int = 30\n\n## Ammunition system - number of magazines the enemy carries.\n@export var total_magazines: int = 5\n\n## Ammunition system - time to reload in seconds.\n@export var reload_time: float = 3.0\n\n## Delay (in seconds) between spotting player and starting to shoot.\n## Gives player a brief reaction time when entering enemy line of sight.\n## This delay \"recharges\" each time the player breaks direct contact with the enemy.\n@export var detection_delay: float = 0.2\n\n## Minimum time (in seconds) the player must be continuously visible before\n## lead prediction is enabled. This prevents enemies from predicting player\n## position immediately when they emerge from cover.\n@export var lead_prediction_delay: float = 0.3\n\n## Minimum visibility ratio (0.0 to 1.0) of player body that must be visible\n## before lead prediction is enabled. At 1.0, the player's entire body must be\n## visible. At 0.5, at least half of the check points must be visible.\n## This prevents pre-firing at players who are at cover edges.\n@export var lead_prediction_visibility_threshold: float = 0.6\n\n## Signal emitted when the enemy is hit.\nsignal hit\n\n## Signal emitted when the enemy dies.\nsignal died\n\n## Signal emitted when AI state changes.\nsignal state_changed(new_state: AIState)\n\n## Signal emitted when ammunition changes.\nsignal ammo_changed(current_ammo: int, reserve_ammo: int)\n\n## Signal emitted when reloading starts.\nsignal reload_started\n\n## Signal emitted when reloading finishes.\nsignal reload_finished\n\n## Signal emitted when all ammunition is depleted.\nsignal ammo_depleted\n\n## Reference to the sprite for color changes.\n@onready var _sprite: Sprite2D = $Sprite2D\n\n## RayCast2D for line of sight detection.\n@onready var _raycast: RayCast2D = $RayCast2D\n\n## Debug label for showing current AI state above the enemy.\n@onready var _debug_label: Label = $DebugLabel\n\n## Wall detection raycasts for obstacle avoidance (created at runtime).\nvar _wall_raycasts: Array[RayCast2D] = []\n\n## Distance to check for walls ahead.\nconst WALL_CHECK_DISTANCE: float = 40.0\n\n## Number of raycasts for wall detection (spread around the enemy).\nconst WALL_CHECK_COUNT: int = 3\n\n## Cover detection raycasts (created at runtime).\nvar _cover_raycasts: Array[RayCast2D] = []\n\n## Number of raycasts for cover detection.\nconst COVER_CHECK_COUNT: int = 16\n\n## Distance to check for cover.\nconst COVER_CHECK_DISTANCE: float = 300.0\n\n## Current health of the enemy.\nvar _current_health: int = 0\n\n## Maximum health of the enemy (set at spawn).\nvar _max_health: int = 0\n\n## Whether the enemy is alive.\nvar _is_alive: bool = true\n\n## Reference to the player (found at runtime).\nvar _player: Node2D = null\n\n## Time since last shot.\nvar _shoot_timer: float = 0.0\n\n## Current ammo in the magazine.\nvar _current_ammo: int = 0\n\n## Reserve ammo (ammo in remaining magazines).\nvar _reserve_ammo: int = 0\n\n## Whether the enemy is currently reloading.\nvar _is_reloading: bool = false\n\n## Timer for reload progress.\nvar _reload_timer: float = 0.0\n\n## Patrol state variables.\nvar _patrol_points: Array[Vector2] = []\nvar _current_patrol_index: int = 0\nvar _is_waiting_at_patrol_point: bool = false\nvar _patrol_wait_timer: float = 0.0\nvar _initial_position: Vector2\n\n## Whether the enemy can currently see the player.\nvar _can_see_player: bool = false\n\n## Current AI state.\nvar _current_state: AIState = AIState.IDLE\n\n## Current cover position (if any).\nvar _cover_position: Vector2 = Vector2.ZERO\n\n## Is currently in a valid cover position.\nvar _has_valid_cover: bool = false\n\n## Timer for suppression cooldown.\nvar _suppression_timer: float = 0.0\n\n## Whether enemy is currently under fire (bullets in threat sphere).\nvar _under_fire: bool = false\n\n## Flank target position.\nvar _flank_target: Vector2 = Vector2.ZERO\n\n## Threat sphere Area2D for detecting nearby bullets.\nvar _threat_sphere: Area2D = null\n\n## Bullets currently in threat sphere.\nvar _bullets_in_threat_sphere: Array = []\n\n## Timer for threat reaction delay - time since first bullet entered threat sphere.\nvar _threat_reaction_timer: float = 0.0\n\n## Whether the threat reaction delay has elapsed (enemy can react to bullets).\nvar _threat_reaction_delay_elapsed: bool = false\n\n## Memory of bullets that have passed through the threat sphere recently.\n## This allows the enemy to react even after fast-moving bullets have exited.\nvar _threat_memory_timer: float = 0.0\n\n## Duration to remember that a bullet passed through the threat sphere.\n## This should be longer than the reaction delay to ensure enemies can complete\n## their reaction even after bullets have passed through quickly.\nconst THREAT_MEMORY_DURATION: float = 0.5\n\n## Current retreat mode determined by damage taken.\nvar _retreat_mode: RetreatMode = RetreatMode.FULL_HP\n\n## Number of hits taken during the current retreat/combat encounter.\n## Resets when enemy enters IDLE state or finishes retreating.\nvar _hits_taken_in_encounter: int = 0\n\n## Timer for periodic turning to cover during FULL_HP retreat.\nvar _retreat_turn_timer: float = 0.0\n\n## Duration to face cover during FULL_HP retreat turn (seconds).\nconst RETREAT_TURN_DURATION: float = 0.8\n\n## Interval between turns toward cover in FULL_HP retreat (seconds).\nconst RETREAT_TURN_INTERVAL: float = 1.5\n\n## Whether currently in the \"turn to cover\" phase of FULL_HP retreat.\nvar _retreat_turning_to_cover: bool = false\n\n## Burst fire counter for ONE_HIT retreat mode.\nvar _retreat_burst_remaining: int = 0\n\n## Timer for burst fire cooldown in ONE_HIT retreat.\nvar _retreat_burst_timer: float = 0.0\n\n## Fast cooldown between burst shots (seconds).\nconst RETREAT_BURST_COOLDOWN: float = 0.06\n\n## Whether burst fire phase is complete in ONE_HIT retreat.\nvar _retreat_burst_complete: bool = false\n\n## Accuracy reduction during retreat (multiplier for inaccuracy angle spread).\nconst RETREAT_INACCURACY_SPREAD: float = 0.15\n\n## Arc spread for ONE_HIT burst fire (radians, total spread).\nconst RETREAT_BURST_ARC: float = 0.4\n\n## Current angle offset within burst arc.\nvar _retreat_burst_angle_offset: float = 0.0\n\n## Whether enemy is in \"alarm\" mode (was suppressed/retreating and hasn't calmed down).\n## This persists until the enemy reaches safety in cover or returns to idle.\nvar _in_alarm_mode: bool = false\n\n## Whether the enemy needs to fire a cover burst (when leaving cover while in alarm).\nvar _cover_burst_pending: bool = false\n\n## --- Combat Cover Cycling (come out, shoot 2-3s, go back) ---\n## Timer for how long the enemy has been shooting while out of cover.\nvar _combat_shoot_timer: float = 0.0\n\n## Duration to shoot while out of cover (2-3 seconds, randomized).\nvar _combat_shoot_duration: float = 2.5\n\n## Whether the enemy is currently in the \"exposed shooting\" phase of combat.\nvar _combat_exposed: bool = false\n\n## Whether the enemy is in the \"approaching player\" phase of combat.\n## In this phase, the enemy moves toward the player to get into direct contact.\nvar _combat_approaching: bool = false\n\n## Timer for the approach phase of combat.\nvar _combat_approach_timer: float = 0.0\n\n## Maximum time to spend approaching player before starting to shoot (seconds).\nconst COMBAT_APPROACH_MAX_TIME: float = 2.0\n\n## Distance at which enemy is considered \"close enough\" to start shooting phase.\nconst COMBAT_DIRECT_CONTACT_DISTANCE: float = 250.0\n\n## --- Pursuit State (cover-to-cover movement) ---\n## Timer for waiting at cover during pursuit.\nvar _pursuit_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during pursuit (1-2 seconds, reduced for faster pursuit).\nconst PURSUIT_COVER_WAIT_DURATION: float = 1.5\n\n## Current pursuit target cover position.\nvar _pursuit_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid pursuit cover target.\nvar _has_pursuit_cover: bool = false\n\n## --- Flanking State (cover-to-cover movement toward flank target) ---\n## Timer for waiting at cover during flanking.\nvar _flank_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during flanking (seconds).\nconst FLANK_COVER_WAIT_DURATION: float = 0.8\n\n## Current flank cover position to move to.\nvar _flank_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid flank cover target.\nvar _has_flank_cover: bool = false\n\n## --- Assault State (coordinated multi-enemy rush) ---\n## Timer for assault wait period (5 seconds before rushing).\nvar _assault_wait_timer: float = 0.0\n\n## Duration to wait at cover before assault (5 seconds).\nconst ASSAULT_WAIT_DURATION: float = 5.0\n\n## Whether the assault wait period is complete.\nvar _assault_ready: bool = false\n\n## Whether this enemy is currently participating in an assault.\nvar _in_assault: bool = false\n\n## Distance threshold for \"close\" vs \"far\" from player.\n## Used to determine if enemy can engage from current position or needs to pursue.\nconst CLOSE_COMBAT_DISTANCE: float = 400.0\n\n## GOAP world state for goal-oriented planning.\nvar _goap_world_state: Dictionary = {}\n\n## --- Search/Investigation State (for when player escapes from view) ---\n## Last known position where the player was seen before escaping view.\nvar _last_known_player_position: Vector2 = Vector2.ZERO\n\n## Whether a search zone is currently active.\nvar _search_zone_active: bool = false\n\n## Radius of the potential player zone (area where player might be hiding).\nconst SEARCH_ZONE_RADIUS: float = 200.0\n\n## Timer for search timeout - enemy gives up searching after this time.\nvar _search_timer: float = 0.0\n\n## Maximum time to spend searching before giving up (seconds).\nconst SEARCH_MAX_DURATION: float = 15.0\n\n## Inspection points within the search zone (hiding spots behind covers and corners).\nvar _inspection_points: Array[Vector2] = []\n\n## Index of current inspection point being checked.\nvar _current_inspection_index: int = 0\n\n## Timer for waiting at each inspection point (looking around).\nvar _inspection_wait_timer: float = 0.0\n\n## Duration to wait at each inspection point (seconds).\nconst INSPECTION_WAIT_DURATION: float = 1.5\n\n## Whether currently waiting at an inspection point.\nvar _inspecting_point: bool = false\n\n## Number of raycasts for detecting inspection points (corners/hiding spots).\nconst INSPECTION_POINT_CHECK_COUNT: int = 24\n\n## Distance to check for inspection points from search zone center.\nconst INSPECTION_CHECK_DISTANCE: float = 250.0\n\n## Detection delay timer - tracks time since entering combat.\nvar _detection_timer: float = 0.0\n\n## Whether the detection delay has elapsed.\nvar _detection_delay_elapsed: bool = false\n\n## Continuous visibility timer - tracks how long the player has been continuously visible.\n## Resets when line of sight is lost.\nvar _continuous_visibility_timer: float = 0.0\n\n## Current visibility ratio of the player (0.0 to 1.0).\n## Represents what fraction of the player's body is visible to the enemy.\n## Used to determine if lead prediction should be enabled.\nvar _player_visibility_ratio: float = 0.0\n\n## --- Clear Shot Movement (move out from cover to get clear shot) ---\n## Target position to move to for getting a clear shot.\nvar _clear_shot_target: Vector2 = Vector2.ZERO\n\n## Whether we're currently moving to find a clear shot position.\nvar _seeking_clear_shot: bool = false\n\n## Timer for how long we've been trying to find a clear shot.\nvar _clear_shot_timer: float = 0.0\n\n## Maximum time to spend finding a clear shot before giving up (seconds).\nconst CLEAR_SHOT_MAX_TIME: float = 3.0\n\n## Distance to move when exiting cover to find a clear shot.\nconst CLEAR_SHOT_EXIT_DISTANCE: float = 60.0\n\n\n\nfunc _ready() -> void:\n\t_initial_position = global_position\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_setup_patrol_points()\n\t_find_player()\n\t_setup_wall_detection()\n\t_setup_cover_detection()\n\t_setup_threat_sphere()\n\t_initialize_goap_state()\n\t_connect_debug_mode_signal()\n\t_update_debug_label()\n\n\t# Log that this enemy is ready (use call_deferred to ensure FileLogger is loaded)\n\tcall_deferred(\"_log_spawn_info\")\n\n\t# Preload bullet scene if not set in inspector\n\tif bullet_scene == null:\n\t\tbullet_scene = preload(\"res://scenes/projectiles/Bullet.tscn\")\n\n\n## Initialize health with random value between min and max.\nfunc _initialize_health() -> void:\n\t_max_health = randi_range(min_health, max_health)\n\t_current_health = _max_health\n\t_is_alive = true\n\n\n## Initialize ammunition with full magazine and reserve ammo.\nfunc _initialize_ammo() -> void:\n\t_current_ammo = magazine_size\n\t# Reserve ammo is (total_magazines - 1) * magazine_size since one magazine is loaded\n\t_reserve_ammo = (total_magazines - 1) * magazine_size\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\n## Setup patrol points based on patrol offsets from initial position.\nfunc _setup_patrol_points() -> void:\n\t_patrol_points.clear()\n\t_patrol_points.append(_initial_position)\n\tfor offset in patrol_offsets:\n\t\t_patrol_points.append(_initial_position + offset)\n\n\n## Setup wall detection raycasts for obstacle avoidance.\nfunc _setup_wall_detection() -> void:\n\t# Create multiple raycasts spread in front of the enemy\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_wall_raycasts.append(raycast)\n\n\n## Setup cover detection raycasts for finding cover positions.\nfunc _setup_cover_detection() -> void:\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_cover_raycasts.append(raycast)\n\n\n## Setup threat sphere for detecting nearby bullets.\nfunc _setup_threat_sphere() -> void:\n\t_threat_sphere = Area2D.new()\n\t_threat_sphere.name = \"ThreatSphere\"\n\t_threat_sphere.collision_layer = 0\n\t_threat_sphere.collision_mask = 16  # Detect projectiles (layer 5)\n\n\tvar collision_shape := CollisionShape2D.new()\n\tvar circle_shape := CircleShape2D.new()\n\tcircle_shape.radius = threat_sphere_radius\n\tcollision_shape.shape = circle_shape\n\t_threat_sphere.add_child(collision_shape)\n\n\tadd_child(_threat_sphere)\n\n\t# Connect signals\n\t_threat_sphere.area_entered.connect(_on_threat_area_entered)\n\t_threat_sphere.area_exited.connect(_on_threat_area_exited)\n\n\n## Initialize GOAP world state.\nfunc _initialize_goap_state() -> void:\n\t_goap_world_state = {\n\t\t\"player_visible\": false,\n\t\t\"has_cover\": false,\n\t\t\"in_cover\": false,\n\t\t\"under_fire\": false,\n\t\t\"health_low\": false,\n\t\t\"can_flank\": false,\n\t\t\"at_flank_position\": false,\n\t\t\"is_retreating\": false,\n\t\t\"hits_taken\": 0,\n\t\t\"is_pursuing\": false,\n\t\t\"is_assaulting\": false,\n\t\t\"can_hit_from_cover\": false,\n\t\t\"player_close\": false,\n\t\t\"enemies_in_combat\": 0\n\t}\n\n\n## Connect to GameManager's debug mode signal for F7 toggle.\nfunc _connect_debug_mode_signal() -> void:\n\tvar game_manager: Node = get_node_or_null(\"/root/GameManager\")\n\tif game_manager:\n\t\t# Connect to debug mode toggle signal\n\t\tif game_manager.has_signal(\"debug_mode_toggled\"):\n\t\t\tgame_manager.debug_mode_toggled.connect(_on_debug_mode_toggled)\n\t\t# Sync with current debug mode state\n\t\tif game_manager.has_method(\"is_debug_mode_enabled\"):\n\t\t\tdebug_label_enabled = game_manager.is_debug_mode_enabled()\n\n\n## Called when debug mode is toggled via F7 key.\nfunc _on_debug_mode_toggled(enabled: bool) -> void:\n\tdebug_label_enabled = enabled\n\t_update_debug_label()\n\n\n## Find the player node in the scene tree.\nfunc _find_player() -> void:\n\t# Try to find the player by group first\n\tvar players := get_tree().get_nodes_in_group(\"player\")\n\tif players.size() > 0:\n\t\t_player = players[0]\n\t\treturn\n\n\t# Fallback: search for player by node name or type\n\tvar root := get_tree().current_scene\n\tif root:\n\t\t_player = _find_player_recursive(root)\n\n\n## Recursively search for a player node.\nfunc _find_player_recursive(node: Node) -> Node2D:\n\tif node.name == \"Player\" and node is Node2D:\n\t\treturn node\n\tfor child in node.get_children():\n\t\tvar result := _find_player_recursive(child)\n\t\tif result:\n\t\t\treturn result\n\treturn null\n\n\nfunc _physics_process(delta: float) -> void:\n\tif not _is_alive:\n\t\treturn\n\n\t# Update shoot cooldown timer\n\t_shoot_timer += delta\n\n\t# Update reload timer\n\t_update_reload(delta)\n\n\t# Check for player visibility and try to find player if not found\n\tif _player == null:\n\t\t_find_player()\n\n\t_check_player_visibility()\n\t_update_goap_state()\n\t_update_suppression(delta)\n\n\t# Process AI state machine\n\t_process_ai_state(delta)\n\n\t# Update debug label if enabled\n\t_update_debug_label()\n\n\t# Request redraw for debug visualization\n\tif debug_label_enabled:\n\t\tqueue_redraw()\n\n\tmove_and_slide()\n\n\n## Update GOAP world state based on current conditions.\nfunc _update_goap_state() -> void:\n\t_goap_world_state[\"player_visible\"] = _can_see_player\n\t_goap_world_state[\"under_fire\"] = _under_fire\n\t_goap_world_state[\"health_low\"] = _get_health_percent() < 0.5\n\t_goap_world_state[\"in_cover\"] = _current_state == AIState.IN_COVER\n\t_goap_world_state[\"has_cover\"] = _has_valid_cover\n\t_goap_world_state[\"is_retreating\"] = _current_state == AIState.RETREATING\n\t_goap_world_state[\"hits_taken\"] = _hits_taken_in_encounter\n\t_goap_world_state[\"is_pursuing\"] = _current_state == AIState.PURSUING\n\t_goa
[2026-01-18T02:52:28.016Z] [INFO] p_world_state[\"is_assaulting\"] = _current_state == AIState.ASSAULT\n\t_goap_world_state[\"player_close\"] = _is_player_close()\n\t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n\t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()\n\n\n## Update suppression state.\nfunc _update_suppression(delta: float) -> void:\n\t# Clean up destroyed bullets from tracking\n\t_bullets_in_threat_sphere = _bullets_in_threat_sphere.filter(func(b): return is_instance_valid(b))\n\n\t# Determine if there's an active threat (bullets in sphere OR recent threat memory)\n\tvar has_active_threat := not _bullets_in_threat_sphere.is_empty() or _threat_memory_timer > 0.0\n\n\tif not has_active_threat:\n\t\tif _under_fire:\n\t\t\t_suppression_timer += delta\n\t\t\tif _suppression_timer >= suppression_cooldown:\n\t\t\t\t_under_fire = false\n\t\t\t\t_suppression_timer = 0.0\n\t\t\t\t_log_debug(\"Suppression ended\")\n\t\t# Reset threat reaction timer when no bullets are in threat sphere and no threat memory\n\t\t_threat_reaction_timer = 0.0\n\t\t_threat_reaction_delay_elapsed = false\n\telse:\n\t\t# Decrement threat memory timer if no bullets currently in sphere\n\t\tif _bullets_in_threat_sphere.is_empty() and _threat_memory_timer > 0.0:\n\t\t\t_threat_memory_timer -= delta\n\n\t\t# Update threat reaction timer\n\t\tif not _threat_reaction_delay_elapsed:\n\t\t\t_threat_reaction_timer += delta\n\t\t\tif _threat_reaction_timer >= threat_reaction_delay:\n\t\t\t\t_threat_reaction_delay_elapsed = true\n\t\t\t\t_log_debug(\"Threat reaction delay elapsed, now reacting to bullets\")\n\n\t\t# Only set under_fire after the reaction delay has elapsed\n\t\tif _threat_reaction_delay_elapsed:\n\t\t\t_under_fire = true\n\t\t\t_suppression_timer = 0.0\n\n\n## Update reload state.\nfunc _update_reload(delta: float) -> void:\n\tif not _is_reloading:\n\t\treturn\n\n\t_reload_timer += delta\n\tif _reload_timer >= reload_time:\n\t\t_finish_reload()\n\n\n## Start reloading the weapon.\nfunc _start_reload() -> void:\n\t# Can't reload if already reloading or no reserve ammo\n\tif _is_reloading or _reserve_ammo <= 0:\n\t\treturn\n\n\t_is_reloading = true\n\t_reload_timer = 0.0\n\treload_started.emit()\n\t_log_debug(\"Reloading... (%d reserve ammo)\" % _reserve_ammo)\n\n\n## Finish the reload process.\nfunc _finish_reload() -> void:\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\t# Calculate how many rounds to load\n\tvar ammo_needed := magazine_size - _current_ammo\n\tvar ammo_to_load := mini(ammo_needed, _reserve_ammo)\n\n\t_reserve_ammo -= ammo_to_load\n\t_current_ammo += ammo_to_load\n\n\treload_finished.emit()\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\t_log_debug(\"Reload complete. Magazine: %d/%d, Reserve: %d\" % [_current_ammo, magazine_size, _reserve_ammo])\n\n\n## Check if the enemy can shoot (has ammo and not reloading).\nfunc _can_shoot() -> bool:\n\t# Can't shoot if reloading\n\tif _is_reloading:\n\t\treturn false\n\n\t# Can't shoot if no ammo in magazine\n\tif _current_ammo <= 0:\n\t\t# Try to start reload if we have reserve ammo\n\t\tif _reserve_ammo > 0:\n\t\t\t_start_reload()\n\t\telse:\n\t\t\t# No ammo at all - emit depleted signal once\n\t\t\tif not _goap_world_state.get(\"ammo_depleted\", false):\n\t\t\t\t_goap_world_state[\"ammo_depleted\"] = true\n\t\t\t\tammo_depleted.emit()\n\t\t\t\t_log_debug(\"All ammunition depleted!\")\n\t\treturn false\n\n\treturn true\n\n\n## Process the AI state machine.\nfunc _process_ai_state(delta: float) -> void:\n\tvar previous_state := _current_state\n\n\t# State transitions based on conditions\n\tmatch _current_state:\n\t\tAIState.IDLE:\n\t\t\t_process_idle_state(delta)\n\t\tAIState.COMBAT:\n\t\t\t_process_combat_state(delta)\n\t\tAIState.SEEKING_COVER:\n\t\t\t_process_seeking_cover_state(delta)\n\t\tAIState.IN_COVER:\n\t\t\t_process_in_cover_state(delta)\n\t\tAIState.FLANKING:\n\t\t\t_process_flanking_state(delta)\n\t\tAIState.SUPPRESSED:\n\t\t\t_process_suppressed_state(delta)\n\t\tAIState.RETREATING:\n\t\t\t_process_retreating_state(delta)\n\t\tAIState.PURSUING:\n\t\t\t_process_pursuing_state(delta)\n\t\tAIState.ASSAULT:\n\t\t\t_process_assault_state(delta)\n\n\tif previous_state != _current_state:\n\t\tstate_changed.emit(_current_state)\n\t\t_log_debug(\"State changed: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\t\t# Also log to file for exported build debugging\n\t\t_log_to_file(\"State: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\n\n## Process IDLE state - patrol or guard behavior.\nfunc _process_idle_state(delta: float) -> void:\n\t# Transition to combat if player is visible\n\tif _can_see_player and _player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Execute idle behavior\n\tmatch behavior_mode:\n\t\tBehaviorMode.PATROL:\n\t\t\t_process_patrol(delta)\n\t\tBehaviorMode.GUARD:\n\t\t\t_process_guard(delta)\n\n\n## Process COMBAT state - approach player for direct contact, shoot for 2-3 seconds, return to cover.\n## Implements the combat cycling behavior: exit cover -> exposed shooting -> return to cover.\n## Phase 0 (seeking clear shot): If bullet spawn blocked, move out from cover to find clear shot.\n## Phase 1 (approaching): Move toward player to get into direct contact range.\n## Phase 2 (exposed): Stand and shoot for 2-3 seconds.\n## Phase 3: Return to cover via SEEKING_COVER state.\nfunc _process_combat_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies in combat (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can't see player, pursue them (move cover-to-cover toward player)\n\tif not _can_see_player:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\t\treturn\n\n\t# Update detection delay timer\n\tif not _detection_delay_elapsed:\n\t\t_detection_timer += delta\n\t\tif _detection_timer >= detection_delay:\n\t\t\t_detection_delay_elapsed = true\n\n\t# If we don't have cover, find some first (needed for returning later)\n\tif not _has_valid_cover and enable_cover:\n\t\t_find_cover_position()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found cover at %s for combat cycling\" % _cover_position)\n\n\t# Check player distance for approach/exposed phase decisions\n\tvar distance_to_player := INF\n\tif _player:\n\t\tdistance_to_player = global_position.distance_to(_player.global_position)\n\n\t# Check if we have a clear shot (no wall blocking bullet spawn)\n\tvar direction_to_player := Vector2.ZERO\n\tvar has_clear_shot := true\n\tif _player:\n\t\tdirection_to_player = (_player.global_position - global_position).normalized()\n\t\thas_clear_shot = _is_bullet_spawn_clear(direction_to_player)\n\n\t# If already exposed (shooting phase), handle shooting and timer\n\tif _combat_exposed:\n\t\t_combat_shoot_timer += delta\n\n\t\t# Check if exposure time is complete - go back to cover\n\t\tif _combat_shoot_timer >= _combat_shoot_duration and _has_valid_cover:\n\t\t\t_log_debug(\"Combat exposure time complete (%.1fs), returning to cover\" % _combat_shoot_duration)\n\t\t\t_combat_exposed = false\n\t\t\t_combat_approaching = false\n\t\t\t_combat_shoot_timer = 0.0\n\t\t\t_transition_to_seeking_cover()\n\t\t\treturn\n\n\t\t# Check if we still have a clear shot - if not, move sideways to find one\n\t\tif _player and not has_clear_shot:\n\t\t\t# Bullet spawn is blocked - move sideways to find a clear shot position\n\t\t\tvar sidestep_dir := _find_sidestep_direction_for_clear_shot(direction_to_player)\n\t\t\tif sidestep_dir != Vector2.ZERO:\n\t\t\t\tvelocity = sidestep_dir * combat_move_speed * 0.7\n\t\t\t\trotation = direction_to_player.angle()  # Keep facing player while sidestepping\n\t\t\t\t_log_debug(\"COMBAT exposed: sidestepping to maintain clear shot\")\n\t\t\telse:\n\t\t\t\t# No sidestep works - stay still, the shot might clear up\n\t\t\t\tvelocity = Vector2.ZERO\n\t\t\treturn\n\n\t\t# In exposed phase with clear shot, stand still and shoot\n\t\tvelocity = Vector2.ZERO\n\n\t\t# Aim and shoot at player (only shoot after detection delay)\n\t\tif _player:\n\t\t\t_aim_at_player()\n\t\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot()\n\t\t\t\t_shoot_timer = 0.0\n\t\treturn\n\n\t# --- CLEAR SHOT SEEKING PHASE ---\n\t# If bullet spawn is blocked and we're not already exposed, we need to move out from cover\n\tif not has_clear_shot and _player:\n\t\t# Start seeking clear shot if not already doing so\n\t\tif not _seeking_clear_shot:\n\t\t\t_seeking_clear_shot = true\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Calculate target position: move perpendicular to player direction (around cover edge)\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\t_log_debug(\"COMBAT: bullet spawn blocked, seeking clear shot at %s\" % _clear_shot_target)\n\n\t\t_clear_shot_timer += delta\n\n\t\t# Check if we've exceeded the max time trying to find a clear shot\n\t\tif _clear_shot_timer >= CLEAR_SHOT_MAX_TIME:\n\t\t\t_log_debug(\"COMBAT: clear shot timeout, trying flanking\")\n\t\t\t_seeking_clear_shot = false\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Try flanking to get around the obstacle\n\t\t\tif enable_flanking:\n\t\t\t\t_transition_to_flanking()\n\t\t\telse:\n\t\t\t\t_transition_to_pursuing()\n\t\t\treturn\n\n\t\t# Move toward the clear shot target position\n\t\tvar distance_to_target := global_position.distance_to(_clear_shot_target)\n\t\tif distance_to_target > 15.0:\n\t\t\tvar move_direction := (_clear_shot_target - global_position).normalized()\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed\n\t\t\trotation = direction_to_player.angle()  # Keep facing player\n\n\t\t\t# Check if the new position now has a clear shot\n\t\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\t\t_log_debug(\"COMBAT: found clear shot position while moving\")\n\t\t\t\t_seeking_clear_shot = false\n\t\t\t\t_clear_shot_timer = 0.0\n\t\t\t\t# Continue to exposed phase check below\n\t\t\telse:\n\t\t\t\treturn  # Keep moving toward target\n\t\telse:\n\t\t\t# Reached target but still no clear shot - recalculate target\n\t\t\t_log_debug(\"COMBAT: reached target but no clear shot, recalculating\")\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\treturn\n\n\t# Reset seeking state if we now have a clear shot\n\tif _seeking_clear_shot and has_clear_shot:\n\t\t_log_debug(\"COMBAT: clear shot acquired\")\n\t\t_seeking_clear_shot = false\n\t\t_clear_shot_timer = 0.0\n\n\t# Determine if we should be in approach phase or exposed shooting phase\n\tvar in_direct_contact := distance_to_player <= COMBAT_DIRECT_CONTACT_DISTANCE\n\n\t# Enter exposed phase if we have a clear shot and are either close enough or have approached long enough\n\tif has_clear_shot and (in_direct_contact or _combat_approach_timer >= COMBAT_APPROACH_MAX_TIME):\n\t\t# Close enough AND have clear shot - start exposed shooting phase\n\t\t_combat_exposed = true\n\t\t_combat_approaching = false\n\t\t_combat_shoot_timer = 0.0\n\t\t_combat_approach_timer = 0.0\n\t\t# Randomize exposure duration between 2-3 seconds\n\t\t_combat_shoot_duration = randf_range(2.0, 3.0)\n\t\t_log_debug(\"COMBAT exposed phase started (distance: %.0f), will shoot for %.1fs\" % [distance_to_player, _combat_shoot_duration])\n\t\treturn\n\n\t# Need to approach player - move toward them\n\tif not _combat_approaching:\n\t\t_combat_approaching = true\n\t\t_combat_approach_timer = 0.0\n\t\t_log_debug(\"COMBAT approach phase started, moving toward player\")\n\n\t_combat_approach_timer += delta\n\n\t# Move toward player while approaching\n\tif _player:\n\t\tvar move_direction := direction_to_player\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = move_direction * combat_move_speed\n\t\trotation = direction_to_player.angle()  # Always face player\n\n\t\t# Can shoot while approaching (only after detection delay and if have clear shot)\n\t\tif has_clear_shot and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\n## Calculate a target position to exit cover and get a clear shot.\n## Returns a position that should allow the bullet spawn point to be unobstructed.\nfunc _calculate_clear_shot_exit_position(direction_to_player: Vector2) -> Vector2:\n\t# Calculate perpendicular directions to the player\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Try both perpendicular directions and pick the one that's more likely to work\n\t# Also blend with forward movement toward player to help navigate around cover\n\tvar best_position := global_position\n\tvar best_score := -1.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\t\t# Blend sidestep with forward movement for better cover navigation\n\t\tvar exit_dir: Vector2 = (sidestep_dir * 0.7 + direction_to_player * 0.3).normalized()\n\t\tvar test_position: Vector2 = global_position + exit_dir * CLEAR_SHOT_EXIT_DISTANCE\n\n\t\t# Score this position based on:\n\t\t# 1. Does it have a clear path? (no walls in the way)\n\t\t# 2. Would the bullet spawn be clear from there?\n\t\tvar score: float = 0.0\n\n\t\t# Check if we can move to this position\n\t\tif _has_clear_path_to(test_position):\n\t\t\tscore += 1.0\n\n\t\t# Check if bullet spawn would be clear from this position\n\t\t# This is a rough estimate - we check from the test position toward player\n\t\tvar world_2d := get_world_2d()\n\t\tif world_2d != null:\n\t\t\tvar space_state := world_2d.direct_space_state\n\t\t\tif space_state != null:\n\t\t\t\tvar check_distance := bullet_spawn_offset + 5.0\n\t\t\t\tvar query := PhysicsRayQueryParameters2D.new()\n\t\t\t\tquery.from = test_position\n\t\t\t\tquery.to = test_position + direction_to_player * check_distance\n\t\t\t\tquery.collision_mask = 4  # Only check obstacles\n\t\t\t\tquery.exclude = [get_rid()]\n\t\t\t\tvar result := space_state.intersect_ray(query)\n\t\t\t\tif result.is_empty():\n\t\t\t\t\tscore += 2.0  # Higher score for clear bullet spawn\n\n\t\tif score > best_score:\n\t\t\tbest_score = score\n\t\t\tbest_position = test_position\n\n\t# If no good position found, just move forward toward player\n\tif best_score < 0.5:\n\t\tbest_position = global_position + direction_to_player * CLEAR_SHOT_EXIT_DISTANCE\n\n\treturn best_position\n\n\n## Process SEEKING_COVER state - moving to cover position.\nfunc _process_seeking_cover_state(_delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, stay in combat\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're already hidden from the player (the main goal)\n\tif not _is_visible_from_player():\n\t\t_transition_to_in_cover()\n\t\t_log_debug(\"Hidden from player, entering cover state\")\n\t\treturn\n\n\t# Move towards cover\n\tvar direction := (_cover_position - global_position).normalized()\n\tvar distance := global_position.distance_to(_cover_position)\n\n\tif distance < 10.0:\n\t\t# Reached the cover position, but still visible - try to find better cover\n\t\tif _is_visible_from_player():\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\t# No better cover found, stay in combat\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\n\t# Apply wall avoidance\n\tvar avoidance := _check_wall_ahead(direction)\n\tif avoidance != Vector2.ZERO:\n\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\tvelocity = direction * combat_move_speed\n\trotation = direction.angle()\n\n\t# Can still shoot while moving to cover (only after detection delay)\n\tif _can_see_player and _player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t_aim_at_player()\n\t\t_shoot()\n\t\t_shoot_timer = 0.0\n\n\n## Process IN_COVER state - taking cover from enemy fire.\n## Decides next action based on:\n## 1. If under fire -> suppressed\n## 2. If player is close (can exit cover for direct contact) -> COMBAT\n## 3. If player is far but can hit from current position -> COMBAT (stay and shoot)\n## 4. If player is far and can't hit -> PURSUING (move cover-to-cover)\nfunc _process_in_cover_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# If still under fire, stay suppressed\n\tif _under_fire:\n\t\t_transition_to_suppressed()\n\t\treturn\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover\n\tif _is_visible_from_player():\n\t\t# If in alarm mode and can see player, fire a burst before escaping\n\t\tif _in_alarm_mode and _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"IN_COVER alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay in cover while firing burst\n\n\t\t# Burst complete or not in alarm mode, seek new cover\n\t\t_log_debug(\"Player flanked our cover position, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# Decision making based on player distance and visibility\n\tif _player:\n\t\tvar player_close := _is_player_close()\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\n\t\tif _can_see_player:\n\t\t\tif player_close:\n\t\t\t\t# Player is close - engage in combat (come out, shoot, go back)\n\t\t\t\t_log_debug(\"Player is close, transitioning to COMBAT\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\t# Player is far\n\t\t\t\tif can_hit:\n\t\t\t\t\t# Can hit from current position - come out and shoot\n\t\t\t\t\t# (Don't pursue, just transition to combat which will handle the cycling)\n\t\t\t\t\t_log_debug(\"Player is far but can hit from here, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\telse:\n\t\t\t\t\t# Can't hit from here - need to pursue (move cover-to-cover)\n\t\t\t\t\t_log_debug(\"Player is far and can't hit, transitioning to PURSUING\")\n\t\t\t\t\t_transition_to_pursuing()\n\t\t\t\t\treturn\n\n\t# If not under fire and can see player, engage (only shoot after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If player is no longer visible and not under fire, try pursuing\n\tif not _can_see_player and not _under_fire:\n\t\t_log_debug(\"Lost sight of player from cover, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\n\n## Process FLANKING state - attempting to flank the player using cover-to-cover movement.\n## Uses intermediate cover positions to navigate around obstacles instead of walking\n## directly toward the flank target.\nfunc _process_flanking_state(delta: float) -> void:\n\t# If under fire, retreat with shooting behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# If can see player, engage in combat\n\tif _can_see_player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\tif _player == null:\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# Recalculate flank position (player may have moved)\n\t_calculate_flank_position()\n\n\tvar distance_to_flank := global_position.distance_to(_flank_target)\n\n\t# Check if we've reached the flank target\n\tif distance_to_flank < 30.0:\n\t\t_log_debug(\"Reached flank position, engaging\")\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Check if we have direct line of sight to flank target (no obstacles)\n\tif _has_clear_path_to(_flank_target):\n\t\t# Direct path is clear - move directly toward flank target\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\t_has_flank_cover = false\n\t\treturn\n\n\t# Path is blocked - use cover-to-cover movement\n\n\t# If we're at a cover position, wait briefly before moving to next\n\tif _has_valid_cover and not _has_flank_cover:\n\t\t_flank_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _flank_cover_wait_timer >= FLANK_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover toward flank target\n\t\t\t_find_flank_cover_toward_target()\n\t\t\tif not _has_flank_cover:\n\t\t\t\t_log_debug(\"No flank cover found, attempting direct movement\")\n\t\t\t\t# No cover found - try direct movement with enhanced wall avoidance\n\t\t\t\tvar direction := (_flank_target - global_position).normalized()\n\t\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\t\tvelocity = direction * combat_move_speed\n\t\t\t\trotation = direction.angle()\n\t\t\t\t# Invalidate current cover to trigger new search next frame\n\t\t\t\t_has_valid_cover = false\n\t\treturn\n\n\t# If we have a flank cover target, move toward it\n\tif _has_flank_cover:\n\t\tvar direction := (_flank_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_flank_next_cover)\n\n\t\t# Check if we've reached the flank cover\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached flank cover at distance %.1f\" % distance)\n\t\t\t_has_flank_cover = false\n\t\t\t_flank_cover_wait_timer = 0.0\n\t\t\t_cover_position = _flank_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no flank cover target - find initial flank cover\n\t_find_flank_cover_toward_target()\n\tif not _has_flank_cover:\n\t\t# Can't find cover, try direct movement with wall avoidance\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\n\n## Process SUPPRESSED state - staying in cover under fire.\nfunc _process_suppressed_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover even while suppressed\n\tif _is_visible_from_player():\n\t\t# In suppressed state we're always in alarm mode - fire a burst before escaping if we can see player\n\t\tif _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"SUPPRESSED alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay suppressed while firing burst\n\n\t\t# Burst complete or can't see player, seek new cover\n\t\t_log_debug(\"Player flanked our cover position while suppressed, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Can still shoot while suppressed (only after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If no longer under fire, exit suppression\n\tif not _under_fire:\n\t\t_transition_to_in_cover()\n\n\n## Process RETREATING state - moving to cover with behavior based on damage taken.\nfunc _process_retreating_state(delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, transition to combat or suppressed\n\t\t\tif _under_fire:\n\t\t\t\t_transition_to_suppressed()\n\t\t\telse:\n\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we've reached cover and are hidden from player\n\tif not _is_visible_from_player():\n\t\t_log_debug(\"Reached cover during retreat\")\n\t\t# Reset encounter hits when successfully reaching cover\n\t\t_hits_taken_in_encounter = 0\n\t\t_transition_to_in_cover()\n\t\treturn\n\n\t# Calculate direction to cover\n\tvar direction_to_cover := (_cover_position - global_position).normalized()\n\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\n\t# Check if reached cover position\n\tif distance_to_cover < 10.0:\n\t\tif _is_visible_from_player():\n\t\t\t# Still visible, find better cover\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\tif _under_fire:\n\t\t\t\t\t_transition_to_suppressed()\n\t\t\t\telse:\n\t\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Apply retreat behavior based on mode\n\tmatch _retreat_mode:\n\t\tRetreatMode.FULL_HP:\n\t\t\t_process_retreat_full_hp(delta, direction_to_cover)\n\t\tRetreatMode.ONE_HIT:\n\t\t\t_process_retreat_one_hit(delta, direction_to_cover)\n\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t_process_retreat_multiple_hits(delta, direction_to_cover)\n\n\n## Process FULL_HP retreat: walk backwards facing player, shoot with reduced accuracy,\n## periodically turn toward cover.\nfunc _process_retreat_full_hp(delta: float, direction_to_cover: Vector2) -> void:\n\t_retreat_turn_timer += delta\n\n\tif _retreat_turning_to_cover:\n\t\t# Turning to face cover, don't shoot\n\t\tif _retreat_turn_timer >= RETREAT_TURN_DURATION:\n\t\t\t_retreat_turning_to_cover = false\n\t\t\t_retreat_turn_timer = 0.0\n\n\t\t# Face cover and move toward it\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\telse:\n\t\t# Face player and back up (walk backwards)\n\t\tif _retreat_turn_timer >= RETREAT_TURN_INTERVAL:\n\t\t\t_retreat_turning_to_cover = true\n\t\t\t_retreat_turn_timer = 0.0\n\t\t\t_log_debug(\"FULL_HP retreat: turning to check cover\")\n\n\t\tif _player:\n\t\t\t# Face the player\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\t_aim_at_player()\n\n\t\t\t# Move backwards (opposite of player direction = toward cover generally)\n\t\t\t# Use the negative of the direction we're facing for \"backing up\"\n\t\t\tvar move_direction := -direction_to_player\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed * 0.7  # Slower when backing up\n\n\t\t\t# Shoot with reduced accuracy (only after detection delay)\n\t\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot_with_inaccuracy()\n\t\t\t\t_shoot_timer = 0.0\n\n\n## Process ONE_HIT retreat: quick burst of 2-4 shots in an arc while turning, then face cover.\nfunc _process_retreat_one_hit(delta: float, direction_to_cover: Vector2) -> void:\n\tif not _retreat_burst_complete:\n\t\t# During burst phase\n\t\t_retreat_burst_timer += delta\n\n\t\tif _player and _retreat_burst_remaining > 0 and _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t# Fire a burst shot with arc spread\n\t\t\t_shoot_burst_shot()\n\t\t\t_retreat_burst_remaining -= 1\n\t\t\t_retreat_burst_timer = 0.0\n\n\t\t\t# Progress through the arc\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0  # Spread across 4 shots max\n\n\t\t# Gradually turn from player to cover during burst\n\t\tif _player:\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\tvar target_angle: float\n\n\t\t\t# Interpolate rotation from player direction to cover direction\n\t\t\tvar burst_progress := 1.0 - (float(_retreat_burst_remaining) / 4.0)\n\t\t\tvar player_angle := direction_to_player.angle()\n\t\t\tvar cover_angle := direction_to_cover.angle()\n\t\t\ttarget_angle = lerp_angle(player_angle, cover_angle, burst_progress * 0.7)\n\t\t\trotation = target_angle\n\n\t\t# Move toward cover (slower during burst)\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed * 0.5\n\n\t\t# Check if burst is complete\n\t\tif _retreat_burst_remaining <= 0:\n\t\t\t_retreat_burst_complete = true\n\t\t\t_log_debug(\"ONE_HIT retreat: burst complete, now running to cover\")\n\telse:\n\t\t# After burst, run to cover without shooting\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\n\n## Process MULTIPLE_HITS retreat: quick burst of 2-4 shots then run to cover (same as ONE_HIT).\nfunc _process_retreat_multiple_hits(delta: float, direction_to_cover: Vector2) -> void:\n\t# Same behavior as ONE_HIT - quick burst then escape\n\t_process_retreat_one_hit(delta, direction_to_cover)\n\n\n## Process PURSUING state - move cover-to-cover toward player.\n## Enemy moves between covers, waiting 1-2 seconds at each cover,\n## until they can see and hit the player.\nfunc _process_pursuing_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected during pursuit (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can see player and can hit them from current position, engage\n\tif _can_see_player and _player:\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\t\tif can_hit:\n\t\t\t_log_debug(\"Can see and hit player from pursuit, transitioning to COMBAT\")\n\t\t\t_has_pursuit_cover = false\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're waiting at cover\n\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t# Currently at cover, wait for 1-2 seconds before moving to next cover\n\t\t_pursuit_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _pursuit_cover_wait_timer >= PURSUIT_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover closer to player\n\t\t\t_log_debug(\"Pursuit wait complete, finding next cover\")\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_find_pursuit_cover_toward_player()\n\t\t\tif _has_pursuit_cover:\n\t\t\t\t_log_debug(\"Found pursuit cover at %s\" % _pursuit_next_cover)\n\t\t\telse:\n\t\t\t\t# No pursuit cover found - fallback behavior\n\t\t\t\t_log_debug(\"No pursuit cover found, checking fallback options\")\n\t\t\t\t# If we can now see the player, engage directly\n\t\t\t\tif _can_see_player:\n\t\t\t\t\t_log_debug(\"Can see player, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\t# Try flanking\n\t\t\t\tif enable_flanking and _player:\n\t\t\t\t\t_log_debug(\"Attempting flanking maneuver\")\n\t\t\t\t\t_transition_to_flanking()\n\t\t\t\t\treturn\n\t\t\t\t# Last resort: move directly toward player\n\t\t\t\t_log_debug(\"No cover options, moving directly toward player\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\treturn\n\n\t# If we have a pursuit cover target, move toward it\n\tif _has_pursuit_cover:\n\t\tvar direction := (_pursuit_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_pursuit_next_cover)\n\n\t\t# Check if we've reached the pursuit cover\n\t\t# Note: We only check distance here, NOT visibility from player.\n\t\t# If we checked visibility, the enemy would immediately consider themselves\n\t\t# \"at cover\" even before moving, since they start hidden from player.\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached pursuit cover at distance %.1f\" % distance)\n\t\t\t_has_pursuit_cover = false\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_cover_position = _pursuit_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no pursuit target - find initial pursuit cover\n\t_find_pursuit_cover_toward_player()\n\tif not _has_pursuit_cover:\n\t\t# Can't find cover to pursue, try flanking or combat\n\t\tif enable_flanking and _player:\n\t\t\t_transition_to_flanking()\n\t\telse:\n\t\t\t_transition_to_combat()\n\n\n## Process ASSAULT state - coordinated multi-enemy rush.\n## Wait at cover for 5 seconds, then all enemies rush the player simultaneously.\nfunc _process_assault_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover and not _assault_ready:\n\t\t_in_assault = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if we're the only enemy left in assault - switch back to combat\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat < 2 and not _assault_ready:\n\t\t_log_debug(\"Not enough enemies for assault, switching to COMBAT\")\n\t\t_in_assault = false\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Find closest cover to player if we don't have one\n\tif not _has_valid_cover:\n\t\t_find_cover_closest_to_player()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found assault cover at %s\" % _cover_position)\n\n\t# Move to cover position first\n\tif _has_valid_cover and not _in_assault:\n\t\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\t\tif distance_to_cover > 15.0 and _is_visible_from_player():\n\t\t\t# Still need to reach cover\n\t\t\tvar direction := (_cover_position - global_position).normalized()\n\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\tvelocity = direction * combat_move_speed\n\t\t\trotation = direction.angle()\n\t\t\treturn\n\n\t# At cover, wait for assault timer\n\tif not _assault_ready:\n\t\tvelocity = Vector2.ZERO\n\t\t_assault_wait_timer += delta\n\n\t\t# Check if all assault enemies are ready (synchronized assault)\n\t\tif _assault_wait_timer >= ASSAULT_WAIT_DURATION:\n\t\t\t# Check if situation has changed - player might have moved\n\t\t\tif _player and _is_player_close():\n\t\t\t\t_assault_ready = true\n\t\t\t\t_in_assault = true\n\t\t\t\t_log_debug(\"ASSAULT ready - rushing player!\")\n\t\t\telse:\n\t\t\t\t# Player moved away, reset timer and check if we should pursue\n\t\t\t\t_log_debug(\"Player moved away during assault wait, resetting\")\n\t\t\t\t_assault_wait_timer = 0.0\n\t\t\t\t_in_assault = false\n\t\t\t\t_transition_to_pursuing()\n\t\t\t\treturn\n\t\treturn\n\n\t# Assault phase - rush the player while shooting\n\tif _assault_ready and _player:\n\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction_to_player)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_player = (direction_to_player * 0.5 + avoidance * 0.5).normalized()\n\n\t\t# Rush at full speed\n\t\tvelocity = direction_to_player * combat_move_speed\n\t\trotation = direction_to_player.angle()\n\n\t\t# Update detection delay timer\n\t\tif not _detection_delay_elapsed:\n\t\t\t_detection_timer += delta\n\t\t\tif _detection_timer >= detection_delay:\n\t\t\t\t_detection_delay_elapsed = true\n\n\t\t# Shoot while rushing (only after detection delay)\n\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t\t# If very close to player, stay in combat\n\t\tif distance_to_player < 50.0:\n\t\t\t_log_debug(\"Assault complete - reached player\")\n\t\t\t_assault_ready = false\n\t\t\t_in_assault = false\n\t\t\t_transition_to_combat()\n\n\n## Shoot with reduced accuracy for retreat mode.\nfunc _shoot_with_inaccuracy() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Check if the shot should be taken\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Add inaccuracy spread\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD, RETREAT_INACCURACY_SPREAD)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the inaccurate shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Inaccurate shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Shoot a burst shot with arc spread for ONE_HIT retreat.\nfunc _shoot_burst_shot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Apply arc offset for burst spread\n\tdirection = direction.rotated(_retreat_burst_angle_offset)\n\n\t# Also add some random inaccuracy on top of the arc\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD * 0.5, RETREAT_INACCURACY_SPREAD * 0.5)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the burst shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Burst shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Transition to IDLE state.\nfunc _transition_to_idle() -> void:\n\t_current_state = AIState.IDLE\n\t# Reset encounter hit tracking when returning to idle\n\t_hits_taken_in_encounter = 0\n\t# Reset alarm mode when returning to idle\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\n\n## Transition to COMBAT state.\nfunc _transition_to_combat() -> void:\n\t_current_state = AIState.COMBAT\n\t# Reset detection delay timer when entering combat\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Reset combat phase variables\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_shoot_timer = 0.0\n\t_combat_approach_timer = 0.0\n\t# Reset clear shot seeking variables\n\t_seeking_clear_shot = false\n\t_clear_shot_timer = 0.0\n\t_clear_shot_target = Vector2.ZERO\n\n\n## Transition to SEEKING_COVER state.\nfunc _transition_to_seeking_cover() -> void:\n\t_current_state = AIState.SEEKING_COVER\n\t_find_cover_position()\n\n\n## Transition to IN_COVER state.\nfunc _transition_to_in_cover() -> void:\n\t_current_state = AIState.IN_COVER\n\n\n## Transition to FLANKING state.\nfunc _transition_to_flanking() -> void:\n\t_current_state = AIState.FLANKING\n\t_calculate_flank_position()\n\t_flank_cover_wait_timer = 0.0\n\t_has_flank_cover = false\n\t_has_valid_cover = false\n\n\n## Transition to SUPPRESSED state.\nfunc _transition_to_suppressed() -> void:\n\t_current_state = AIState.SUPPRESSED\n\t# Enter alarm mode when suppressed\n\t_in_alarm_mode = true\n\n\n## Transition to PURSUING state.\nfunc _transition_to_pursuing() -> void:\n\t_current_state = AIState.PURSUING\n\t_pursuit_cover_wait_timer = 0.0\n\t_has_pursuit_cover = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\n\n## Transition to ASSAULT state.\nfunc _transition_to_assault() -> void:\n\t_current_state = AIState.ASSAULT\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Find closest cover to player for assault position\n\t_find_cover_closest_to_player()\n\n\n## Transition to RETREATING state with appropriate retreat mode.\nfunc _transition_to_retreating() -> void:\n\t_current_state = AIState.RETREATING\n\t# Enter alarm mode when retreating\n\t_in_alarm_mode = true\n\n\t# Determine retreat mode based on hits taken\n\tif _hits_taken_in_encounter == 0:\n\t\t_retreat_mode = RetreatMode.FULL_HP\n\t\t_retreat_turn_timer = 0.0\n\t\t_retreat_turning_to_cover = false\n\t\t_log_debug(\"Entering RETREATING state: FULL_HP mode (shoot while backing up)\")\n\telif _hits_taken_in_encounter == 1:\n\t\t_retreat_mode = RetreatMode.ONE_HIT\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t# Calculate arc spread: shots will be distributed across the arc\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: ONE_HIT mode (burst of %d shots)\" % _retreat_burst_remaining)\n\telse:\n\t\t_retreat_mode = RetreatMode.MULTIPLE_HITS\n\t\t# Multiple hits also gets burst fire (same as ONE_HIT)\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: MULTIPLE_HITS mode (burst of %d shots)\" % _retreat_burst_remaining)\n\n\t# Find cover position for retreating\n\t_find_cover_position()\n\n\n## Check if the enemy is visible from the player's position.\n## Uses raycasting from player to enemy to determine if there are obstacles blocking line of sight.\n## This is the inverse of _can_see_player - it checks if the PLAYER can see the ENEMY.\n## Checks multiple points on the enemy body (center and corners) to account for enemy size.\nfunc _is_visible_from_player() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check visibility to multiple points on the enemy body\n\t# This accounts for the enemy's size - corners can stick out from cover\n\tvar check_points := _get_enemy_check_points(global_position)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Get multiple check points on the enemy body for visibility testing.\n## Returns center and 4 corner points offset by the enemy's radius.\nfunc _get_enemy_check_points(center: Vector2) -> Array[Vector2]:\n\t# Enemy collision radius is 24, sprite is 48x48\n\t# Use a slightly smaller radius to avoid edge cases\n\tconst ENEMY_RADIUS: float = 22.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := ENEMY_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point is visible from the player's position.\nfunc _is_point_visible_from_player(point: Vector2) -> bool:\n\tif _player == null:\n\t\treturn false\n\n\tvar player_pos := _player.global_position\n\tvar distance := player_pos.distance_to(point)\n\n\t# Use direct space state to check line of sight from player to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = player_pos\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = []\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between player and point - point is visible\n\t\treturn true\n\telse:\n\t\t# Check if we hit an obstacle before reaching the point\n\t\tvar hit_position: Vector2 = result[\"position\"]\n\t\tvar distance_to_hit := player_pos.distance_to(hit_position)\n\n\t\t# If we hit something closer than the point, the point is hidden\n\t\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t\treturn false\n\t\telse:\n\t\t\treturn true\n\n\n## Check if a specific position would make the enemy visible from the player's position.\n## Checks all enemy body points (center and corners) to account for enemy size.\n## Used to validate cover positions before moving to them.\nfunc _is_position_visible_from_player(pos: Vector2) -> bool:\n\tif _player == null:\n\t\treturn true  # Assume visible if no player\n\n\t# Check visibility for all enemy body points at the given position\n\tvar check_points := _get_enemy_check_points(pos)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Check if a target position is visible from the enemy's perspective.\n## Uses raycast to verify there are no obstacles between enemy and the target position.\n## This is used to validate lead prediction targets - enemies should only aim at\n## positions they can actually see.\nfunc _is_position_visible_to_enemy(target_pos: Vector2) -> bool:\n\tvar distance := global_position.distance_to(target_pos)\n\n\t# Use direct space state to check line of sight from enemy to target\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = target_pos\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and target - position is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t# Hit obstacle before target - position is NOT visible\n\t\t_log_debug(\"Position %s blocked by obstacle at distance %.1f (target at %.1f)\" % [target_pos, distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Get multiple check points on the player's body for visibility testing.\n## Returns center and 4 corner points offset by the player's radius.\n## The player has a collision radius of 16 pixels (from Player.tscn).\nfunc _get_player_check_points(center: Vector2) -> Array[Vector2]:\n\t# Player collision radius is 16, sprite is 32x32\n\t# Use a slightly smaller radius to be conservative\n\tconst PLAYER_RADIUS: float = 14.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := PLAYER_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point on the player is visible from the enemy's position.\n## Uses direct space state query to check for obstacles blocking line of sight.\nfunc _is_player_point_visible_to_enemy(point: Vector2) -> bool:\n\tvar distance := global_position.distance_to(point)\n\n\t# Use direct space state to check line of sight from enemy to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and point - point is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the point\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\t# If we hit something before the point, the point is blocked\n\tif distance_to_hit < distance - 5.0:  # 5 pixel tolerance\n\t\treturn false\n\n\treturn true\n\n\n## Calculate what fraction of the player's body is visible to the enemy.\n## Returns a value from 0.0 (completely hidden) to 1.0 (fully visible).\n## Checks multiple points on the player's body (center + corners).\nfunc _calculate_player_visibility_ratio() -> float:\n\tif _player == null:\n\t\treturn 0.0\n\n\tvar check_points := _get_player_check_points(_player.global_position)\n\tvar visible_count := 0\n\n\tfor point in check_points:\n\t\tif _is_player_point_visible_to_enemy(point):\n\t\t\tvisible_count += 1\n\n\treturn float(visible_count) / float(check_points.size())\n\n\n## Check if the line of fire to the target position is clear of other enemies.\n## Returns true if no other enemies would be hit by a bullet traveling to the target.\nfunc _is_firing_line_clear_of_friendlies(target_position: Vector2) -> bool:\n\tif not enable_friendly_fire_avoidance:\n\t\treturn true\n\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if any enemies are in the firing line\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 2  # Only check enemies (layer 2)\n\tquery.exclude = [get_rid()]  # Exclude self using RID\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No enemies in the way\n\n\t# Check if the hit position is before the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 20.0:  # 20 pixel tolerance\n\t\t_log_debug(\"Friendly in firing line at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if a bullet fired at the target position would be blocked by cover/obstacles.\n## Returns true if the shot would likely hit the target, false if blocked by cover.\nfunc _is_shot_clear_of_cover(target_position: Vector2) -> bool:\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if obstacles block the shot\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No obstacles in the way\n\n\t# Check if the obstacle is before the target position\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t_log_debug(\"Shot blocked by cover at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if there's an obstacle immediately in front of the enemy that would block bullets.\n## This prevents shooting into walls that the enemy is flush against or very close to.\n## Uses a single raycast from enemy center to the bullet spawn position.\nfunc _is_bullet_spawn_clear(direction: Vector2) -> bool:\n\t# Fail-open: allow shooting if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn true\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn true\n\n\t# Check from enemy center to bullet spawn position plus a small buffer\n\tvar check_distance := bullet_spawn_offset + 5.0\n\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = global_position + direction * check_distance\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]\n\n\tvar result := space_state.intersect_ray(query)\n\tif not result.is_empty():\n\t\t_log_debug(\"Bullet spawn blocked: wall at distance %.1f\" % [\n\t\t\tglobal_position.distance_to(result[\"position\"])])\n\t\treturn false\n\n\treturn true\n\n\n## Find a sidestep direction that would lead to a clear shot position.\n## Checks perpendicular directions to the player and returns the first one\n## that would allow the bullet spawn point to be clear.\n## Returns Vector2.ZERO if no clear direction is found.\nfunc _find_sidestep_direction_for_clear_shot(direction_to_player: Vector2) -> Vector2:\n\t# Fail-safe: allow normal behavior if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn Vector2.ZERO\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn Vector2.ZERO\n\n\t# Check perpendicular directions (left and right of the player direction)\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Check both sidestep directions and pick the one that leads to clear shot faster\n\tvar check_distance := 50.0  # Check if moving 50 pixels in this direction would help\n\tvar bullet_check_distance := bullet_spawn_offset + 5.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:  # Try both sides\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\n\t\t# First check if we can actually move in this direction (no wall blocking movement)\n\t\tvar move_query := PhysicsRayQueryParameters2D.new()\n\t\tmove_query.from = global_position\n\t\tmove_query.to = global_position + sidestep_dir * 30.0\n\t\tmove_query.collision_mask = 4  # Only check obstacles\n\t\tmove_query.exclude = [get_rid()]\n\n\t\tvar move_result := space_state.intersect_ray(move_query)\n\t\tif not move_result.is_empty():\n\t\t\tcontinue  # Can't move this way, wall is blocking\n\n\t\t# Check if after sidestepping, we'd have a clear shot\n\t\tvar test_position: Vector2 = global_position + sidestep_dir * check_distance\n\t\tvar shot_query := PhysicsRayQueryParameters2D.new()\n\t\tshot_query.from = test_position\n\t\tshot_query.to = test_position + direction_to_player * bullet_check_distance\n\t\tshot_query.collision_mask = 4\n\t\tshot_query.exclude = [get_rid()]\n\n\t\tvar shot_result := space_state.intersect_ray(shot_query)\n\t\tif shot_result.is_empty():\n\t\t\t# Found a direction that leads to a clear shot\n\t\t\t_log_debug(\"Found sidestep direction: %s\" % sidestep_dir)\n\t\t\treturn sidestep_dir\n\n\treturn Vector2.ZERO  # No clear sidestep direction found\n\n\n## Check if the enemy should shoot at the current target.\n## Validates bullet spawn clearance, friendly fire avoidance, and cover blocking.\nfunc _should_shoot_at_target(target_position: Vector2) -> bool:\n\t# Check if the immediate path to bullet spawn is clear\n\t# This prevents shooting into walls the enemy is flush against\n\tvar direction := (target_position - global_position).normalized()\n\tif not _is_bullet_spawn_clear(direction):\n\t\treturn false\n\n\t# Check if friendlies are in the way\n\tif not _is_firing_line_clear_of_friendlies(target_position):\n\t\treturn false\n\n\t# Check if cover blocks the shot\n\tif not _is_shot_clear_of_cover(target_position):\n\t\treturn false\n\n\treturn true\n\n\n## Check if the player is \"close\" (within CLOSE_COMBAT_DISTANCE).\n## Used to determine if the enemy should engage directly or pursue.\nfunc _is_player_close() -> bool:\n\tif _player == null:\n\t\treturn false\n\treturn global_position.distance_to(_player.global_position) <= CLOSE_COMBAT_DISTANCE\n\n\n## Check if the enemy can hit the player from their current position.\n## Returns true if there's a clear line of fire to the player.\nfunc _can_hit_player_from_current_position() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check if we can see the player\n\tif not _can_see_player:\n\t\treturn false\n\n\t# Check if the shot would be blocked by cover\n\treturn _is_shot_clear_of_cover(_player.global_position)\n\n\n## Count the number of enemies currently in combat-related states.\n## Includes COMBAT, PURSUING, ASSAULT, IN_COVER (if can see player).\n## Used to determine if multi-enemy assault should be triggered.\nfunc _count_enemies_in_combat() -> int:\n\tvar count := 0\n\tvar enemies := get_tree().get_nodes_in_group(\"enemies\")\n\n\tfor enemy in enemies:\n\t\tif enemy == self:\n\t\t\tcontinue\n\t\tif not enemy.has_method(\"get_current_state\"):\n\t\t\tcontinue\n\n\t\tvar state: AIState = enemy.get_current_state()\n\t\t# Count enemies in combat-related states\n\t\tif state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\t\t# For IN_COVER, only count if they can see the player\n\t\t\tif state == AIState.IN_COVER:\n\t\t\t\tif enemy.has_method(\"is_in_combat_engagement\") and enemy.is_in_combat_engagement():\n\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tcount += 1\n\n\t# Count self if in a combat-related state\n\tif _current_state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\tcount += 1\n\n\treturn count\n\n\n## Check if this enemy is engaged in combat (can see player and in combat state).\nfunc is_in_combat_engagement() -> bool:\n\treturn _can_see_player and _current_state in [AIState.COMBAT, AIState.IN_COVER, AIState.ASSAULT]\n\n\n## Find cover position closer to the player for pursuit.\n## Used during PURSUING state to move cover-to-cover toward the player.\nfunc _find_pursuit_cover_toward_player() -> void:\n\tif _player == null:\n\t\t_has_pursuit_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For pursuit, we want cover that is:\n\t\t\t# 1. Closer to the player than we currently are\n\t\t\t# 2. Hidden from the player (or mostly hidden)\n\t\t\t# 3. Not too far from our current position\n\n\t\t\tvar my_distance_to_player := global_position.distance_to(player_pos)\n\t\t\tvar cover_distance_to_player := cover_pos.distance_to(player_pos)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to player\n\t\t\tif cover_distance_to_player >= my_distance_to_player:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if this position is hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Hidden from player (priority)\n\t\t\t# - Closer to player\n\t\t\t# - Not too far from current position\n\t\t\tvar hidden_score: float = 5.0 if is_hidden else 0.0\n\t\t\tvar approach_score: float = (my_distance_to_player - cover_distance_to_player) / CLOSE_COMBAT_DISTANCE\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = hidden_score + approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_pursuit_next_cover = best_cover\n\t\t_has_pursuit_cover = true\n\t\t_log_debug(\"Found pursuit cover at %s (score: %.2f)\" % [_pursuit_next_cover, best_score])\n\telse:\n\t\t_has_pursuit_cover = false\n\n\n## Find cover position closest to the player for assault positioning.\n## Used during ASSAULT state to take the nearest safe cover to the player.\nfunc _find_cover_closest_to_player() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.g
[2026-01-18T02:52:28.020Z] [INFO] lobal_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_distance: float = INF\n\tvar found_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# Check if this position is hidden from player (safe cover)\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\tif is_hidden:\n\t\t\t\t# Calculate distance from this cover to the player\n\t\t\t\tvar distance_to_player := cover_pos.distance_to(player_pos)\n\n\t\t\t\t# We want the cover closest to the player\n\t\t\t\tif distance_to_player < best_distance:\n\t\t\t\t\tbest_distance = distance_to_player\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\t\tfound_cover = true\n\n\tif found_cover:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found assault cover at %s (distance to player: %.1f)\" % [_cover_position, best_distance])\n\telse:\n\t\t# Fall back to normal cover finding\n\t\t_find_cover_position()\n\n\n## Find a valid cover position relative to the player.\n## The cover position must be hidden from the player's line of sight.\nfunc _find_cover_position() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_hidden_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is on the opposite side of the obstacle from player\n\t\t\tvar direction_from_player := (collision_point - player_pos).normalized()\n\n\t\t\t# Position behind cover (offset from collision point along normal)\n\t\t\t# Offset must be large enough to hide the entire enemy body (radius ~24 pixels)\n\t\t\t# Using 35 pixels to provide some margin for the enemy's collision shape\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# First priority: Check if this position is actually hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Only consider hidden positions unless we have no choice\n\t\t\tif is_hidden or not found_hidden_cover:\n\t\t\t\t# Score based on:\n\t\t\t\t# 1. Whether position is hidden (highest priority)\n\t\t\t\t# 2. Distance from enemy (closer is better)\n\t\t\t\t# 3. Position relative to player (behind cover from player's view)\n\t\t\t\tvar hidden_score: float = 10.0 if is_hidden else 0.0  # Heavy weight for hidden positions\n\n\t\t\t\tvar distance_score := 1.0 - (global_position.distance_to(cover_pos) / COVER_CHECK_DISTANCE)\n\n\t\t\t\t# Check if this position is on the far side of obstacle from player\n\t\t\t\tvar cover_direction := (cover_pos - player_pos).normalized()\n\t\t\t\tvar dot_product := direction_from_player.dot(cover_direction)\n\t\t\t\tvar blocking_score: float = maxf(0.0, dot_product)\n\n\t\t\t\tvar total_score: float = hidden_score + distance_score * 0.3 + blocking_score * 0.7\n\n\t\t\t\t# If we find a hidden position, only accept other hidden positions\n\t\t\t\tif is_hidden and not found_hidden_cover:\n\t\t\t\t\tfound_hidden_cover = true\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\telif (is_hidden or not found_hidden_cover) and total_score > best_score:\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\n\tif best_score > 0:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found cover at: %s (hidden: %s)\" % [_cover_position, found_hidden_cover])\n\telse:\n\t\t_has_valid_cover = false\n\n\n## Calculate flank position based on player location.\nfunc _calculate_flank_position() -> void:\n\tif _player == null:\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar player_to_enemy := (global_position - player_pos).normalized()\n\n\t# Choose left or right flank based on current position\n\tvar flank_side := 1.0 if randf() > 0.5 else -1.0\n\tvar flank_direction := player_to_enemy.rotated(flank_angle * flank_side)\n\n\t_flank_target = player_pos + flank_direction * flank_distance\n\t_log_debug(\"Flank target: %s\" % _flank_target)\n\n\n## Check if there's a clear path (no obstacles) to the target position.\n## Uses a raycast to check for walls/obstacles between current position and target.\nfunc _has_clear_path_to(target: Vector2) -> bool:\n\tif _raycast == null:\n\t\treturn true  # Assume clear if no raycast available\n\n\tvar direction := (target - global_position).normalized()\n\tvar distance := global_position.distance_to(target)\n\n\t_raycast.target_position = direction * distance\n\t_raycast.force_raycast_update()\n\n\t# If we hit something, path is blocked\n\tif _raycast.is_colliding():\n\t\tvar collision_point := _raycast.get_collision_point()\n\t\tvar collision_distance := global_position.distance_to(collision_point)\n\t\t# Only consider it blocked if the collision is before the target\n\t\treturn collision_distance >= distance - 10.0\n\n\treturn true\n\n\n## Find cover position closer to the flank target.\n## Used during FLANKING state to move cover-to-cover toward the flank position.\nfunc _find_flank_cover_toward_target() -> void:\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For flanking, we want cover that is:\n\t\t\t# 1. Closer to the flank target than we currently are\n\t\t\t# 2. Not too far from our current position\n\t\t\t# 3. Reachable (has clear path)\n\n\t\t\tvar my_distance_to_target := global_position.distance_to(_flank_target)\n\t\t\tvar cover_distance_to_target := cover_pos.distance_to(_flank_target)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to flank target\n\t\t\tif cover_distance_to_target >= my_distance_to_target:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if we can reach this cover (has clear path)\n\t\t\tif not _has_clear_path_to(cover_pos):\n\t\t\t\t# Even if direct path is blocked, we might be able to reach\n\t\t\t\t# via another intermediate cover, but skip for now\n\t\t\t\tcontinue\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Closer to flank target (priority)\n\t\t\t# - Not too far from current position\n\t\t\tvar approach_score: float = (my_distance_to_target - cover_distance_to_target) / flank_distance\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_flank_next_cover = best_cover\n\t\t_has_flank_cover = true\n\t\t_log_debug(\"Found flank cover at %s (score: %.2f)\" % [_flank_next_cover, best_score])\n\telse:\n\t\t_has_flank_cover = false\n\n\n## Check if there's a wall ahead in the given direction and return avoidance direction.\n## Returns Vector2.ZERO if no wall detected, otherwise returns a vector to avoid the wall.\nfunc _check_wall_ahead(direction: Vector2) -> Vector2:\n\tif _wall_raycasts.is_empty():\n\t\treturn Vector2.ZERO\n\n\tvar avoidance := Vector2.ZERO\n\tvar perpendicular := Vector2(-direction.y, direction.x)  # 90 degrees rotation\n\n\t# Check center, left, and right raycasts\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar angle_offset := (i - 1) * 0.5  # -0.5, 0, 0.5 radians (~-28, 0, 28 degrees)\n\t\tvar check_direction := direction.rotated(angle_offset)\n\n\t\tvar raycast := _wall_raycasts[i]\n\t\traycast.target_position = check_direction * WALL_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\t# Calculate avoidance based on which raycast hit\n\t\t\tif i == 0:  # Left raycast hit\n\t\t\t\tavoidance += perpendicular  # Steer right\n\t\t\telif i == 1:  # Center raycast hit\n\t\t\t\tavoidance += perpendicular if randf() > 0.5 else -perpendicular  # Random steer\n\t\t\telif i == 2:  # Right raycast hit\n\t\t\t\tavoidance -= perpendicular  # Steer left\n\n\treturn avoidance.normalized() if avoidance.length() > 0 else Vector2.ZERO\n\n\n## Check if the player is visible using raycast.\n## If detection_range is 0 or negative, uses unlimited detection range (line-of-sight only).\n## This allows the enemy to see the player even outside the viewport if there's no obstacle.\n## Also updates the continuous visibility timer and visibility ratio for lead prediction control.\nfunc _check_player_visibility() -> void:\n\tvar was_visible := _can_see_player\n\t_can_see_player = false\n\t_player_visibility_ratio = 0.0\n\n\tif _player == null or not _raycast:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t# Check if player is within detection range (only if detection_range is positive)\n\t# If detection_range <= 0, detection is unlimited (line-of-sight only)\n\tif detection_range > 0 and distance_to_player > detection_range:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\t# Point raycast at player - use actual distance to player for the raycast length\n\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\tvar raycast_length := distance_to_player + 10.0  # Add small buffer to ensure we reach player\n\t_raycast.target_position = direction_to_player * raycast_length\n\t_raycast.force_raycast_update()\n\n\t# Check if raycast hit something\n\tif _raycast.is_colliding():\n\t\tvar collider := _raycast.get_collider()\n\t\t# If we hit the player, we can see them\n\t\tif collider == _player:\n\t\t\t_can_see_player = true\n\t\t# If we hit a wall/obstacle before the player, we can't see them\n\telse:\n\t\t# No collision between us and player - we have clear line of sight\n\t\t_can_see_player = true\n\n\t# Update continuous visibility timer and visibility ratio\n\tif _can_see_player:\n\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n\t\t# Calculate what fraction of the player's body is visible\n\t\t# This is used to determine if lead prediction should be enabled\n\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n\telse:\n\t\t# Lost line of sight - reset the timer and visibility ratio\n\t\t_continuous_visibility_timer = 0.0\n\t\t_player_visibility_ratio = 0.0\n\n\n## Aim the enemy sprite/direction at the player using gradual rotation.\nfunc _aim_at_player() -> void:\n\tif _player == null:\n\t\treturn\n\tvar direction := (_player.global_position - global_position).normalized()\n\tvar target_angle := direction.angle()\n\n\t# Calculate the shortest rotation direction\n\tvar angle_diff := wrapf(target_angle - rotation, -PI, PI)\n\n\t# Get the delta time from the current physics process\n\tvar delta := get_physics_process_delta_time()\n\n\t# Apply gradual rotation based on rotation_speed\n\tif abs(angle_diff) <= rotation_speed * delta:\n\t\t# Close enough to snap to target\n\t\trotation = target_angle\n\telif angle_diff > 0:\n\t\trotation += rotation_speed * delta\n\telse:\n\t\trotation -= rotation_speed * delta\n\n\n## Shoot a bullet towards the player.\nfunc _shoot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\t# Check if we can shoot (have ammo and not reloading)\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Apply lead prediction if enabled\n\tif enable_lead_prediction:\n\t\ttarget_position = _calculate_lead_prediction()\n\n\t# Check if the shot should be taken (friendly fire and cover checks)\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Create bullet instance\n\tvar bullet := bullet_scene.instantiate()\n\n\t# Set bullet position with offset in shoot direction\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\n\t# Set bullet direction\n\tbullet.direction = direction\n\n\t# Set shooter ID to identify this enemy as the source\n\t# This prevents enemies from detecting their own bullets in the threat sphere\n\tbullet.shooter_id = get_instance_id()\n\n\t# Add bullet to the scene tree\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play shooting sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\n\t# Play shell casing sound with a small delay\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\t# Auto-reload when magazine is empty\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Play shell casing sound with a delay to simulate the casing hitting the ground.\nfunc _play_delayed_shell_sound() -> void:\n\tawait get_tree().create_timer(0.15).timeout\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_shell_rifle\"):\n\t\taudio_manager.play_shell_rifle(global_position)\n\n\n## Calculate lead prediction - aims where the player will be, not where they are.\n## Uses iterative approach for better accuracy with moving targets.\n## Only applies lead prediction if:\n## 1. The player has been continuously visible for at least lead_prediction_delay seconds\n## 2. At least lead_prediction_visibility_threshold of the player's body is visible\n## 3. The predicted position is also visible to the enemy (not behind cover)\n## This prevents enemies from \"knowing\" where the player will emerge from cover.\nfunc _calculate_lead_prediction() -> Vector2:\n\tif _player == null:\n\t\treturn global_position\n\n\tvar player_pos := _player.global_position\n\n\t# Only use lead prediction if the player has been continuously visible\n\t# for long enough. This prevents enemies from predicting player position\n\t# immediately when they emerge from cover.\n\tif _continuous_visibility_timer < lead_prediction_delay:\n\t\t_log_debug(\"Lead prediction disabled: visibility time %.2fs < %.2fs required\" % [_continuous_visibility_timer, lead_prediction_delay])\n\t\treturn player_pos\n\n\t# Only use lead prediction if enough of the player's body is visible.\n\t# This prevents pre-firing when the player is at the edge of cover with only\n\t# a small part of their body visible. The player must be significantly exposed\n\t# before the enemy can predict their movement.\n\tif _player_visibility_ratio < lead_prediction_visibility_threshold:\n\t\t_log_debug(\"Lead prediction disabled: visibility ratio %.2f < %.2f required (player at cover edge)\" % [_player_visibility_ratio, lead_prediction_visibility_threshold])\n\t\treturn player_pos\n\n\tvar player_velocity := Vector2.ZERO\n\n\t# Get player velocity if they are a CharacterBody2D\n\tif _player is CharacterBody2D:\n\t\tplayer_velocity = _player.velocity\n\n\t# If player is stationary, no need for prediction\n\tif player_velocity.length_squared() < 1.0:\n\t\treturn player_pos\n\n\t# Iterative lead prediction for better accuracy\n\t# Start with player's current position\n\tvar predicted_pos := player_pos\n\tvar distance := global_position.distance_to(predicted_pos)\n\n\t# Iterate 2-3 times for convergence\n\tfor i in range(3):\n\t\t# Time for bullet to reach the predicted position\n\t\tvar time_to_target := distance / bullet_speed\n\n\t\t# Predict where player will be at that time\n\t\tpredicted_pos = player_pos + player_velocity * time_to_target\n\n\t\t# Update distance for next iteration\n\t\tdistance = global_position.distance_to(predicted_pos)\n\n\t# CRITICAL: Validate that the predicted position is actually visible to the enemy.\n\t# If the predicted position is behind cover (e.g., player is running toward cover exit),\n\t# we should NOT aim there - it would feel like the enemy is \"cheating\" by knowing\n\t# where the player will emerge. Fall back to player's current visible position.\n\tif not _is_position_visible_to_enemy(predicted_pos):\n\t\t_log_debug(\"Lead prediction blocked: predicted position %s is not visible, using current position %s\" % [predicted_pos, player_pos])\n\t\treturn player_pos\n\n\t_log_debug(\"Lead prediction: player at %s moving %s, aiming at %s\" % [player_pos, player_velocity, predicted_pos])\n\n\treturn predicted_pos\n\n\n## Process patrol behavior - move between patrol points.\nfunc _process_patrol(delta: float) -> void:\n\tif _patrol_points.is_empty():\n\t\treturn\n\n\t# Handle waiting at patrol point\n\tif _is_waiting_at_patrol_point:\n\t\t_patrol_wait_timer += delta\n\t\tif _patrol_wait_timer >= patrol_wait_time:\n\t\t\t_is_waiting_at_patrol_point = false\n\t\t\t_patrol_wait_timer = 0.0\n\t\t\t_current_patrol_index = (_current_patrol_index + 1) % _patrol_points.size()\n\t\tvelocity = Vector2.ZERO\n\t\treturn\n\n\t# Move towards current patrol point\n\tvar target_point := _patrol_points[_current_patrol_index]\n\tvar direction := (target_point - global_position).normalized()\n\tvar distance := global_position.distance_to(target_point)\n\n\tif distance < 5.0:\n\t\t# Reached patrol point, start waiting\n\t\t_is_waiting_at_patrol_point = true\n\t\tvelocity = Vector2.ZERO\n\telse:\n\t\t# Check for walls and apply avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\t# Blend movement direction with avoidance\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * move_speed\n\t\t# Face movement direction when patrolling\n\t\trotation = direction.angle()\n\n\n## Process guard behavior - stand still and look around.\nfunc _process_guard(_delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\t# In guard mode, enemy doesn't move but can still aim at player when visible\n\n\n## Called when a bullet enters the threat sphere.\nfunc _on_threat_area_entered(area: Area2D) -> void:\n\t# Check if bullet has shooter_id property and if it's from this enemy\n\t# This prevents enemies from being suppressed by their own bullets\n\tif \"shooter_id\" in area and area.shooter_id == get_instance_id():\n\t\treturn  # Ignore own bullets\n\n\t_bullets_in_threat_sphere.append(area)\n\t# Set threat memory timer so enemy can react even after fast bullets exit\n\t# This allows the reaction delay to complete even if bullets pass through quickly\n\t_threat_memory_timer = THREAT_MEMORY_DURATION\n\t# Note: _under_fire is now set in _update_suppression after threat_reaction_delay\n\t# This gives the player more time before the enemy reacts to nearby gunfire\n\t_log_debug(\"Bullet entered threat sphere, starting reaction delay...\")\n\n\n## Called when a bullet exits the threat sphere.\nfunc _on_threat_area_exited(area: Area2D) -> void:\n\t_bullets_in_threat_sphere.erase(area)\n\n\n## Called when the enemy is hit (by bullet.gd).\nfunc on_hit() -> void:\n\tif not _is_alive:\n\t\treturn\n\n\thit.emit()\n\n\t# Track hits for retreat behavior\n\t_hits_taken_in_encounter += 1\n\t_log_debug(\"Hit taken! Total hits in encounter: %d\" % _hits_taken_in_encounter)\n\t_log_to_file(\"Hit taken, health: %d/%d\" % [_current_health - 1, _max_health])\n\n\t# Show hit flash effect\n\t_show_hit_flash()\n\n\t# Apply damage\n\t_current_health -= 1\n\n\t# Play appropriate hit sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif _current_health <= 0:\n\t\t# Play lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_lethal\"):\n\t\t\taudio_manager.play_hit_lethal(global_position)\n\t\t_on_death()\n\telse:\n\t\t# Play non-lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_non_lethal\"):\n\t\t\taudio_manager.play_hit_non_lethal(global_position)\n\t\t_update_health_visual()\n\n\n## Shows a brief flash effect when hit.\nfunc _show_hit_flash() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t_sprite.modulate = hit_flash_color\n\n\tawait get_tree().create_timer(hit_flash_duration).timeout\n\n\t# Restore color based on current health (if still alive)\n\tif _is_alive:\n\t\t_update_health_visual()\n\n\n## Updates the sprite color based on current health percentage.\nfunc _update_health_visual() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t# Interpolate color based on health percentage\n\tvar health_percent := _get_health_percent()\n\t_sprite.modulate = full_health_color.lerp(low_health_color, 1.0 - health_percent)\n\n\n## Returns the current health as a percentage (0.0 to 1.0).\nfunc _get_health_percent() -> float:\n\tif _max_health <= 0:\n\t\treturn 0.0\n\treturn float(_current_health) / float(_max_health)\n\n\n## Called when the enemy dies.\nfunc _on_death() -> void:\n\t_is_alive = false\n\t_log_to_file(\"Enemy died\")\n\tdied.emit()\n\n\tif destroy_on_death:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\tqueue_free()\n\telse:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\t_reset()\n\n\n## Resets the enemy to its initial state.\nfunc _reset() -> void:\n\tglobal_position = _initial_position\n\trotation = 0.0\n\t_current_patrol_index = 0\n\t_is_waiting_at_patrol_point = false\n\t_patrol_wait_timer = 0.0\n\t_current_state = AIState.IDLE\n\t_has_valid_cover = false\n\t_under_fire = false\n\t_suppression_timer = 0.0\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t_continuous_visibility_timer = 0.0\n\t_player_visibility_ratio = 0.0\n\t_threat_reaction_timer = 0.0\n\t_threat_reaction_delay_elapsed = false\n\t_threat_memory_timer = 0.0\n\t_bullets_in_threat_sphere.clear()\n\t# Reset retreat state variables\n\t_hits_taken_in_encounter = 0\n\t_retreat_mode = RetreatMode.FULL_HP\n\t_retreat_turn_timer = 0.0\n\t_retreat_turning_to_cover = false\n\t_retreat_burst_remaining = 0\n\t_retreat_burst_timer = 0.0\n\t_retreat_burst_complete = false\n\t_retreat_burst_angle_offset = 0.0\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\t# Reset combat state variables\n\t_combat_shoot_timer = 0.0\n\t_combat_shoot_duration = 2.5\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_approach_timer = 0.0\n\t# Reset pursuit state variables\n\t_pursuit_cover_wait_timer = 0.0\n\t_pursuit_next_cover = Vector2.ZERO\n\t_has_pursuit_cover = false\n\t# Reset assault state variables\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset flank state variables\n\t_flank_cover_wait_timer = 0.0\n\t_flank_next_cover = Vector2.ZERO\n\t_has_flank_cover = false\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_initialize_goap_state()\n\n\n## Log debug message if debug_logging is enabled.\nfunc _log_debug(message: String) -> void:\n\tif debug_logging:\n\t\tprint(\"[Enemy %s] %s\" % [name, message])\n\n\n## Log a message to the file logger (always logs, regardless of debug_logging setting).\n## Use for important events like spawning, dying, or critical state changes.\nfunc _log_to_file(message: String) -> void:\n\tif not is_inside_tree():\n\t\treturn\n\tvar file_logger: Node = get_node_or_null(\"/root/FileLogger\")\n\tif file_logger and file_logger.has_method(\"log_enemy\"):\n\t\tfile_logger.log_enemy(name, message)\n\n\n## Log spawn info (called via call_deferred to ensure FileLogger is loaded).\nfunc _log_spawn_info() -> void:\n\t_log_to_file(\"Enemy spawned at %s, health: %d, behavior: %s, player_found: %s\" % [\n\t\tglobal_position, _max_health, BehaviorMode.keys()[behavior_mode],\n\t\t\"yes\" if _player != null else \"no\"])\n\n\n## Get AI state name as a human-readable string.\nfunc _get_state_name(state: AIState) -> String:\n\tmatch state:\n\t\tAIState.IDLE:\n\t\t\treturn \"IDLE\"\n\t\tAIState.COMBAT:\n\t\t\treturn \"COMBAT\"\n\t\tAIState.SEEKING_COVER:\n\t\t\treturn \"SEEKING_COVER\"\n\t\tAIState.IN_COVER:\n\t\t\treturn \"IN_COVER\"\n\t\tAIState.FLANKING:\n\t\t\treturn \"FLANKING\"\n\t\tAIState.SUPPRESSED:\n\t\t\treturn \"SUPPRESSED\"\n\t\tAIState.RETREATING:\n\t\t\treturn \"RETREATING\"\n\t\tAIState.PURSUING:\n\t\t\treturn \"PURSUING\"\n\t\tAIState.ASSAULT:\n\t\t\treturn \"ASSAULT\"\n\t\t_:\n\t\t\treturn \"UNKNOWN\"\n\n\n## Update the debug label with current AI state.\nfunc _update_debug_label() -> void:\n\tif _debug_label == null:\n\t\treturn\n\n\t_debug_label.visible = debug_label_enabled\n\tif not debug_label_enabled:\n\t\treturn\n\n\tvar state_text := _get_state_name(_current_state)\n\n\t# Add retreat mode info if retreating\n\tif _current_state == AIState.RETREATING:\n\t\tmatch _retreat_mode:\n\t\t\tRetreatMode.FULL_HP:\n\t\t\t\tstate_text += \"\\n(FULL_HP)\"\n\t\t\tRetreatMode.ONE_HIT:\n\t\t\t\tstate_text += \"\\n(ONE_HIT)\"\n\t\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t\tstate_text += \"\\n(MULTI_HITS)\"\n\n\t# Add assault timer info if in assault state\n\tif _current_state == AIState.ASSAULT:\n\t\tif _assault_ready:\n\t\t\tstate_text += \"\\n(RUSHING)\"\n\t\telse:\n\t\t\tvar time_left := ASSAULT_WAIT_DURATION - _assault_wait_timer\n\t\t\tstate_text += \"\\n(%.1fs)\" % time_left\n\n\t# Add combat phase info if in combat\n\tif _current_state == AIState.COMBAT:\n\t\tif _combat_exposed:\n\t\t\tvar time_left := _combat_shoot_duration - _combat_shoot_timer\n\t\t\tstate_text += \"\\n(EXPOSED %.1fs)\" % time_left\n\t\telif _seeking_clear_shot:\n\t\t\tvar time_left := CLEAR_SHOT_MAX_TIME - _clear_shot_timer\n\t\t\tstate_text += \"\\n(SEEK SHOT %.1fs)\" % time_left\n\t\telif _combat_approaching:\n\t\t\tstate_text += \"\\n(APPROACH)\"\n\n\t# Add pursuit timer info if pursuing and waiting at cover\n\tif _current_state == AIState.PURSUING:\n\t\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t\tvar time_left := PURSUIT_COVER_WAIT_DURATION - _pursuit_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_pursuit_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\n\t# Add flanking phase info if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_valid_cover and not _has_flank_cover:\n\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_flank_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\t\telse:\n\t\t\tstate_text += \"\\n(DIRECT)\"\n\n\t_debug_label.text = state_text\n\n\n## Get current AI state (for external access/debugging).\nfunc get_current_state() -> AIState:\n\treturn _current_state\n\n\n## Get GOAP world state (for GOAP planner).\nfunc get_goap_world_state() -> Dictionary:\n\treturn _goap_world_state.duplicate()\n\n\n## Check if enemy is currently under fire.\nfunc is_under_fire() -> bool:\n\treturn _under_fire\n\n\n## Check if enemy is in cover.\nfunc is_in_cover() -> bool:\n\treturn _current_state == AIState.IN_COVER or _current_state == AIState.SUPPRESSED\n\n\n## Get current ammo in magazine.\nfunc get_current_ammo() -> int:\n\treturn _current_ammo\n\n\n## Get reserve ammo.\nfunc get_reserve_ammo() -> int:\n\treturn _reserve_ammo\n\n\n## Get total ammo (current + reserve).\nfunc get_total_ammo() -> int:\n\treturn _current_ammo + _reserve_ammo\n\n\n## Check if enemy is currently reloading.\nfunc is_reloading() -> bool:\n\treturn _is_reloading\n\n\n## Check if enemy has any ammo left.\nfunc has_ammo() -> bool:\n\treturn _current_ammo > 0 or _reserve_ammo > 0\n\n\n## Get current player visibility ratio (for debugging).\n## Returns 0.0 if player is completely hidden, 1.0 if fully visible.\nfunc get_player_visibility_ratio() -> float:\n\treturn _player_visibility_ratio\n\n\n## Draw debug visualization when debug mode is enabled.\n## Shows: line to target (cover, clear shot, player), bullet spawn point status.\nfunc _draw() -> void:\n\tif not debug_label_enabled:\n\t\treturn\n\n\t# Colors for different debug elements\n\tvar color_to_cover := Color.CYAN  # Line to cover position\n\tvar color_to_player := Color.RED  # Line to player (when visible)\n\tvar color_clear_shot := Color.YELLOW  # Line to clear shot target\n\tvar color_pursuit := Color.ORANGE  # Line to pursuit cover\n\tvar color_flank := Color.MAGENTA  # Line to flank position\n\tvar color_bullet_spawn := Color.GREEN  # Bullet spawn point indicator\n\tvar color_blocked := Color.RED  # Blocked path indicator\n\n\t# Draw line to player if visible\n\tif _can_see_player and _player:\n\t\tvar to_player := _player.global_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_player, color_to_player, 1.5)\n\n\t\t# Draw bullet spawn point and check if blocked\n\t\tvar direction_to_player := to_player.normalized()\n\t\tvar spawn_point := direction_to_player * bullet_spawn_offset\n\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\tdraw_circle(spawn_point, 5.0, color_bullet_spawn)\n\t\telse:\n\t\t\t# Draw X for blocked spawn point\n\t\t\tdraw_line(spawn_point + Vector2(-5, -5), spawn_point + Vector2(5, 5), color_blocked, 2.0)\n\t\t\tdraw_line(spawn_point + Vector2(-5, 5), spawn_point + Vector2(5, -5), color_blocked, 2.0)\n\n\t# Draw line to cover position if we have one\n\tif _has_valid_cover:\n\t\tvar to_cover := _cover_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_cover, color_to_cover, 1.5)\n\t\t# Draw small circle at cover position\n\t\tdraw_circle(to_cover, 8.0, color_to_cover)\n\n\t# Draw line to clear shot target if seeking clear shot\n\tif _seeking_clear_shot and _clear_shot_target != Vector2.ZERO:\n\t\tvar to_target := _clear_shot_target - global_position\n\t\tdraw_line(Vector2.ZERO, to_target, color_clear_shot, 2.0)\n\t\t# Draw triangle at target position\n\t\tvar target_pos := to_target\n\t\tdraw_line(target_pos + Vector2(-6, 6), target_pos + Vector2(6, 6), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(6, 6), target_pos + Vector2(0, -8), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(0, -8), target_pos + Vector2(-6, 6), color_clear_shot, 2.0)\n\n\t# Draw line to pursuit cover if pursuing\n\tif _current_state == AIState.PURSUING and _has_pursuit_cover:\n\t\tvar to_pursuit := _pursuit_next_cover - global_position\n\t\tdraw_line(Vector2.ZERO, to_pursuit, color_pursuit, 2.0)\n\t\tdraw_circle(to_pursuit, 8.0, color_pursuit)\n\n\t# Draw line to flank target if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_flank_cover:\n\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n\t\telif _flank_target != Vector2.ZERO:\n\t\t\tvar to_flank := _flank_target - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n\t\t\t# Draw diamond at flank target\n\t\t\tvar flank_pos := to_flank\n\t\t\tdraw_line(flank_pos + Vector2(
[2026-01-18T02:52:28.044Z] [INFO] 0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)\n","structuredPatch":[{"oldStart":575,"oldLines":7,"newStart":575,"newLines":11,"lines":["     \"is_assaulting\": false,","     \"can_hit_from_cover\": false,","     \"player_close\": false,","-    \"enemies_in_combat\": 0","+    \"enemies_in_combat\": 0,","+    \"has_search_zone\": false,","+    \"search_zone_cleared\": false,","+    \"inspection_points_remaining\": 0,","+    \"is_searching\": false","   }"," "," "]}],"userModified":false,"replaceAll":false}}
[2026-01-18T02:52:30.362Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01JaFHnxTyCm84Gy9iPPsKn1",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now update the `_update_goap_state` function:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 1237,
      "cache_read_input_tokens": 108572,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1237,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 2,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "7ae5132b-7105-48c1-97d3-b7df9ac1bce4"
}
[2026-01-18T02:52:37.709Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01JaFHnxTyCm84Gy9iPPsKn1",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01UyFa9FFpsjcwJhDWxLpM3v",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "old_string": "## Update GOAP world state based on current conditions.\nfunc _update_goap_state() -> void:\n\t_goap_world_state[\"player_visible\"] = _can_see_player\n\t_goap_world_state[\"under_fire\"] = _under_fire\n\t_goap_world_state[\"health_low\"] = _get_health_percent() < 0.5\n\t_goap_world_state[\"in_cover\"] = _current_state == AIState.IN_COVER\n\t_goap_world_state[\"has_cover\"] = _has_valid_cover\n\t_goap_world_state[\"is_retreating\"] = _current_state == AIState.RETREATING\n\t_goap_world_state[\"hits_taken\"] = _hits_taken_in_encounter\n\t_goap_world_state[\"is_pursuing\"] = _current_state == AIState.PURSUING\n\t_goap_world_state[\"is_assaulting\"] = _current_state == AIState.ASSAULT\n\t_goap_world_state[\"player_close\"] = _is_player_close()\n\t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n\t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()",
          "new_string": "## Update GOAP world state based on current conditions.\nfunc _update_goap_state() -> void:\n\t_goap_world_state[\"player_visible\"] = _can_see_player\n\t_goap_world_state[\"under_fire\"] = _under_fire\n\t_goap_world_state[\"health_low\"] = _get_health_percent() < 0.5\n\t_goap_world_state[\"in_cover\"] = _current_state == AIState.IN_COVER\n\t_goap_world_state[\"has_cover\"] = _has_valid_cover\n\t_goap_world_state[\"is_retreating\"] = _current_state == AIState.RETREATING\n\t_goap_world_state[\"hits_taken\"] = _hits_taken_in_encounter\n\t_goap_world_state[\"is_pursuing\"] = _current_state == AIState.PURSUING\n\t_goap_world_state[\"is_assaulting\"] = _current_state == AIState.ASSAULT\n\t_goap_world_state[\"player_close\"] = _is_player_close()\n\t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n\t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()\n\t_goap_world_state[\"has_search_zone\"] = _search_zone_active\n\t_goap_world_state[\"search_zone_cleared\"] = not _search_zone_active and _last_known_player_position != Vector2.ZERO\n\t_goap_world_state[\"inspection_points_remaining\"] = _inspection_points.size() - _current_inspection_index\n\t_goap_world_state[\"is_searching\"] = _current_state == AIState.SEARCHING"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 1237,
      "cache_read_input_tokens": 108572,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1237,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 2,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "98f84405-9afc-451d-b3f3-8d18572c6485"
}
[2026-01-18T02:52:37.749Z] [INFO] {"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UyFa9FFpsjcwJhDWxLpM3v","type":"tool_result","content":"The file /tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   656‚Üí\n   657‚Üí\tmove_and_slide()\n   658‚Üí\n   659‚Üí\n   660‚Üí## Update GOAP world state based on current conditions.\n   661‚Üífunc _update_goap_state() -> void:\n   662‚Üí\t_goap_world_state[\"player_visible\"] = _can_see_player\n   663‚Üí\t_goap_world_state[\"under_fire\"] = _under_fire\n   664‚Üí\t_goap_world_state[\"health_low\"] = _get_health_percent() < 0.5\n   665‚Üí\t_goap_world_state[\"in_cover\"] = _current_state == AIState.IN_COVER\n   666‚Üí\t_goap_world_state[\"has_cover\"] = _has_valid_cover\n   667‚Üí\t_goap_world_state[\"is_retreating\"] = _current_state == AIState.RETREATING\n   668‚Üí\t_goap_world_state[\"hits_taken\"] = _hits_taken_in_encounter\n   669‚Üí\t_goap_world_state[\"is_pursuing\"] = _current_state == AIState.PURSUING\n   670‚Üí\t_goap_world_state[\"is_assaulting\"] = _current_state == AIState.ASSAULT\n   671‚Üí\t_goap_world_state[\"player_close\"] = _is_player_close()\n   672‚Üí\t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n   673‚Üí\t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()\n   674‚Üí\t_goap_world_state[\"has_search_zone\"] = _search_zone_active\n   675‚Üí\t_goap_world_state[\"search_zone_cleared\"] = not _search_zone_active and _last_known_player_position != Vector2.ZERO\n   676‚Üí\t_goap_world_state[\"inspection_points_remaining\"] = _inspection_points.size() - _current_inspection_index\n   677‚Üí\t_goap_world_state[\"is_searching\"] = _current_state == AIState.SEARCHING\n   678‚Üí\n   679‚Üí\n   680‚Üí## Update suppression state.\n   681‚Üífunc _update_suppression(delta: float) -> void:"}]},"parent_tool_use_id":null,"session_id":"797fbac8-f5e6-4339-8fd2-77453410db49","uuid":"505a9b65-415e-4465-99db-82a8ecd04312","tool_use_result":{"filePath":"/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd","oldString":"## Update GOAP world state based on current conditions.\nfunc _update_goap_state() -> void:\n\t_goap_world_state[\"player_visible\"] = _can_see_player\n\t_goap_world_state[\"under_fire\"] = _under_fire\n\t_goap_world_state[\"health_low\"] = _get_health_percent() < 0.5\n\t_goap_world_state[\"in_cover\"] = _current_state == AIState.IN_COVER\n\t_goap_world_state[\"has_cover\"] = _has_valid_cover\n\t_goap_world_state[\"is_retreating\"] = _current_state == AIState.RETREATING\n\t_goap_world_state[\"hits_taken\"] = _hits_taken_in_encounter\n\t_goap_world_state[\"is_pursuing\"] = _current_state == AIState.PURSUING\n\t_goap_world_state[\"is_assaulting\"] = _current_state == AIState.ASSAULT\n\t_goap_world_state[\"player_close\"] = _is_player_close()\n\t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n\t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()","newString":"## Update GOAP world state based on current conditions.\nfunc _update_goap_state() -> void:\n\t_goap_world_state[\"player_visible\"] = _can_see_player\n\t_goap_world_state[\"under_fire\"] = _under_fire\n\t_goap_world_state[\"health_low\"] = _get_health_percent() < 0.5\n\t_goap_world_state[\"in_cover\"] = _current_state == AIState.IN_COVER\n\t_goap_world_state[\"has_cover\"] = _has_valid_cover\n\t_goap_world_state[\"is_retreating\"] = _current_state == AIState.RETREATING\n\t_goap_world_state[\"hits_taken\"] = _hits_taken_in_encounter\n\t_goap_world_state[\"is_pursuing\"] = _current_state == AIState.PURSUING\n\t_goap_world_state[\"is_assaulting\"] = _current_state == AIState.ASSAULT\n\t_goap_world_state[\"player_close\"] = _is_player_close()\n\t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n\t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()\n\t_goap_world_state[\"has_search_zone\"] = _search_zone_active\n\t_goap_world_state[\"search_zone_cleared\"] = not _search_zone_active and _last_known_player_position != Vector2.ZERO\n\t_goap_world_state[\"inspection_points_remaining\"] = _inspection_points.size() - _current_inspection_index\n\t_goap_world_state[\"is_searching\"] = _current_state == AIState.SEARCHING","originalFile":"extends CharacterBody2D\n## Enemy AI with tactical behaviors including patrol, guard, cover, and flanking.\n##\n## Supports multiple behavior modes:\n## - PATROL: Moves between patrol points\n## - GUARD: Stands in place watching for the player\n##\n## Tactical features:\n## - Uses cover when under fire (suppression)\n## - Attempts to flank the player from the sides\n## - Coordinates with other enemies (optional)\n## - GOAP foundation for goal-oriented planning\n\n## AI States for tactical behavior.\nenum AIState {\n\tIDLE,       ## Default idle state (patrol or guard)\n\tCOMBAT,     ## Actively engaging the player (coming out of cover, shooting 2-3s, returning)\n\tSEEKING_COVER,  ## Moving to cover position\n\tIN_COVER,   ## Taking cover from player fire\n\tFLANKING,   ## Attempting to flank the player\n\tSUPPRESSED, ## Under fire, staying in cover\n\tRETREATING, ## Retreating to cover while possibly shooting\n\tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n\tASSAULT,    ## Coordinated multi-enemy assault (rush player after 5s wait)\n\tSEARCHING   ## Searching for player at last-known-position zone\n}\n\n## Retreat behavior modes based on damage taken.\nenum RetreatMode {\n\tFULL_HP,        ## No damage - retreat backwards while shooting, periodically turn to cover\n\tONE_HIT,        ## One hit taken - quick burst then retreat without shooting\n\tMULTIPLE_HITS   ## Multiple hits - quick burst then retreat without shooting (same as ONE_HIT)\n}\n\n## Behavior modes for the enemy.\nenum BehaviorMode {\n\tPATROL,  ## Moves between patrol points\n\tGUARD    ## Stands in one place\n}\n\n## Current behavior mode.\n@export var behavior_mode: BehaviorMode = BehaviorMode.GUARD\n\n## Maximum movement speed in pixels per second.\n@export var move_speed: float = 220.0\n\n## Combat movement speed (faster when flanking/seeking cover).\n@export var combat_move_speed: float = 320.0\n\n## Rotation speed in radians per second for gradual turning.\n## Default is 15 rad/sec for challenging but fair combat.\n@export var rotation_speed: float = 15.0\n\n## Detection range for spotting the player.\n## Set to 0 or negative to allow unlimited detection range (line-of-sight only).\n## This allows enemies to see the player even outside the viewport if no obstacles block view.\n@export var detection_range: float = 0.0\n\n## Time between shots in seconds.\n## Default matches assault rifle fire rate (10 shots/second = 0.1s cooldown).\n@export var shoot_cooldown: float = 0.1\n\n## Bullet scene to instantiate when shooting.\n@export var bullet_scene: PackedScene\n\n## Offset from enemy center for bullet spawn position.\n@export var bullet_spawn_offset: float = 30.0\n\n## Patrol points as offsets from the initial position.\n## Only used when behavior_mode is PATROL.\n@export var patrol_offsets: Array[Vector2] = [Vector2(100, 0), Vector2(-100, 0)]\n\n## Wait time at each patrol point in seconds.\n@export var patrol_wait_time: float = 1.5\n\n## Color when at full health.\n@export var full_health_color: Color = Color(0.9, 0.2, 0.2, 1.0)\n\n## Color when at low health (interpolates based on health percentage).\n@export var low_health_color: Color = Color(0.3, 0.1, 0.1, 1.0)\n\n## Color to flash when hit.\n@export var hit_flash_color: Color = Color(1.0, 1.0, 1.0, 1.0)\n\n## Duration of hit flash effect in seconds.\n@export var hit_flash_duration: float = 0.1\n\n## Whether to destroy the enemy after death.\n@export var destroy_on_death: bool = false\n\n## Delay before respawning or destroying (in seconds).\n@export var respawn_delay: float = 2.0\n\n## Minimum random health.\n@export var min_health: int = 2\n\n## Maximum random health.\n@export var max_health: int = 4\n\n## Threat sphere radius - bullets within this radius trigger suppression.\n@export var threat_sphere_radius: float = 100.0\n\n## Time to stay suppressed after bullets leave threat sphere.\n@export var suppression_cooldown: float = 2.0\n\n## Delay (in seconds) before reacting to bullets in the threat sphere.\n## This prevents instant reactions to nearby gunfire, giving the player more time.\n@export var threat_reaction_delay: float = 0.2\n\n## Flank angle from player's facing direction (radians).\n@export var flank_angle: float = PI / 3.0  # 60 degrees\n\n## Distance to maintain while flanking.\n@export var flank_distance: float = 200.0\n\n## Enable/disable flanking behavior.\n@export var enable_flanking: bool = true\n\n## Enable/disable cover behavior.\n@export var enable_cover: bool = true\n\n## Enable/disable debug logging.\n@export var debug_logging: bool = false\n\n## Enable/disable debug label above enemy showing current AI state.\n@export var debug_label_enabled: bool = false\n\n## Enable/disable friendly fire avoidance (don't shoot if other enemies are in the way).\n@export var enable_friendly_fire_avoidance: bool = true\n\n## Enable/disable lead prediction (shooting ahead of moving targets).\n@export var enable_lead_prediction: bool = true\n\n## Bullet speed for lead prediction calculation.\n## Should match the actual bullet speed (default is 2500 for assault rifle).\n@export var bullet_speed: float = 2500.0\n\n## Ammunition system - magazine size (bullets per magazine).\n@export var magazine_size: int = 30\n\n## Ammunition system - number of magazines the enemy carries.\n@export var total_magazines: int = 5\n\n## Ammunition system - time to reload in seconds.\n@export var reload_time: float = 3.0\n\n## Delay (in seconds) between spotting player and starting to shoot.\n## Gives player a brief reaction time when entering enemy line of sight.\n## This delay \"recharges\" each time the player breaks direct contact with the enemy.\n@export var detection_delay: float = 0.2\n\n## Minimum time (in seconds) the player must be continuously visible before\n## lead prediction is enabled. This prevents enemies from predicting player\n## position immediately when they emerge from cover.\n@export var lead_prediction_delay: float = 0.3\n\n## Minimum visibility ratio (0.0 to 1.0) of player body that must be visible\n## before lead prediction is enabled. At 1.0, the player's entire body must be\n## visible. At 0.5, at least half of the check points must be visible.\n## This prevents pre-firing at players who are at cover edges.\n@export var lead_prediction_visibility_threshold: float = 0.6\n\n## Signal emitted when the enemy is hit.\nsignal hit\n\n## Signal emitted when the enemy dies.\nsignal died\n\n## Signal emitted when AI state changes.\nsignal state_changed(new_state: AIState)\n\n## Signal emitted when ammunition changes.\nsignal ammo_changed(current_ammo: int, reserve_ammo: int)\n\n## Signal emitted when reloading starts.\nsignal reload_started\n\n## Signal emitted when reloading finishes.\nsignal reload_finished\n\n## Signal emitted when all ammunition is depleted.\nsignal ammo_depleted\n\n## Reference to the sprite for color changes.\n@onready var _sprite: Sprite2D = $Sprite2D\n\n## RayCast2D for line of sight detection.\n@onready var _raycast: RayCast2D = $RayCast2D\n\n## Debug label for showing current AI state above the enemy.\n@onready var _debug_label: Label = $DebugLabel\n\n## Wall detection raycasts for obstacle avoidance (created at runtime).\nvar _wall_raycasts: Array[RayCast2D] = []\n\n## Distance to check for walls ahead.\nconst WALL_CHECK_DISTANCE: float = 40.0\n\n## Number of raycasts for wall detection (spread around the enemy).\nconst WALL_CHECK_COUNT: int = 3\n\n## Cover detection raycasts (created at runtime).\nvar _cover_raycasts: Array[RayCast2D] = []\n\n## Number of raycasts for cover detection.\nconst COVER_CHECK_COUNT: int = 16\n\n## Distance to check for cover.\nconst COVER_CHECK_DISTANCE: float = 300.0\n\n## Current health of the enemy.\nvar _current_health: int = 0\n\n## Maximum health of the enemy (set at spawn).\nvar _max_health: int = 0\n\n## Whether the enemy is alive.\nvar _is_alive: bool = true\n\n## Reference to the player (found at runtime).\nvar _player: Node2D = null\n\n## Time since last shot.\nvar _shoot_timer: float = 0.0\n\n## Current ammo in the magazine.\nvar _current_ammo: int = 0\n\n## Reserve ammo (ammo in remaining magazines).\nvar _reserve_ammo: int = 0\n\n## Whether the enemy is currently reloading.\nvar _is_reloading: bool = false\n\n## Timer for reload progress.\nvar _reload_timer: float = 0.0\n\n## Patrol state variables.\nvar _patrol_points: Array[Vector2] = []\nvar _current_patrol_index: int = 0\nvar _is_waiting_at_patrol_point: bool = false\nvar _patrol_wait_timer: float = 0.0\nvar _initial_position: Vector2\n\n## Whether the enemy can currently see the player.\nvar _can_see_player: bool = false\n\n## Current AI state.\nvar _current_state: AIState = AIState.IDLE\n\n## Current cover position (if any).\nvar _cover_position: Vector2 = Vector2.ZERO\n\n## Is currently in a valid cover position.\nvar _has_valid_cover: bool = false\n\n## Timer for suppression cooldown.\nvar _suppression_timer: float = 0.0\n\n## Whether enemy is currently under fire (bullets in threat sphere).\nvar _under_fire: bool = false\n\n## Flank target position.\nvar _flank_target: Vector2 = Vector2.ZERO\n\n## Threat sphere Area2D for detecting nearby bullets.\nvar _threat_sphere: Area2D = null\n\n## Bullets currently in threat sphere.\nvar _bullets_in_threat_sphere: Array = []\n\n## Timer for threat reaction delay - time since first bullet entered threat sphere.\nvar _threat_reaction_timer: float = 0.0\n\n## Whether the threat reaction delay has elapsed (enemy can react to bullets).\nvar _threat_reaction_delay_elapsed: bool = false\n\n## Memory of bullets that have passed through the threat sphere recently.\n## This allows the enemy to react even after fast-moving bullets have exited.\nvar _threat_memory_timer: float = 0.0\n\n## Duration to remember that a bullet passed through the threat sphere.\n## This should be longer than the reaction delay to ensure enemies can complete\n## their reaction even after bullets have passed through quickly.\nconst THREAT_MEMORY_DURATION: float = 0.5\n\n## Current retreat mode determined by damage taken.\nvar _retreat_mode: RetreatMode = RetreatMode.FULL_HP\n\n## Number of hits taken during the current retreat/combat encounter.\n## Resets when enemy enters IDLE state or finishes retreating.\nvar _hits_taken_in_encounter: int = 0\n\n## Timer for periodic turning to cover during FULL_HP retreat.\nvar _retreat_turn_timer: float = 0.0\n\n## Duration to face cover during FULL_HP retreat turn (seconds).\nconst RETREAT_TURN_DURATION: float = 0.8\n\n## Interval between turns toward cover in FULL_HP retreat (seconds).\nconst RETREAT_TURN_INTERVAL: float = 1.5\n\n## Whether currently in the \"turn to cover\" phase of FULL_HP retreat.\nvar _retreat_turning_to_cover: bool = false\n\n## Burst fire counter for ONE_HIT retreat mode.\nvar _retreat_burst_remaining: int = 0\n\n## Timer for burst fire cooldown in ONE_HIT retreat.\nvar _retreat_burst_timer: float = 0.0\n\n## Fast cooldown between burst shots (seconds).\nconst RETREAT_BURST_COOLDOWN: float = 0.06\n\n## Whether burst fire phase is complete in ONE_HIT retreat.\nvar _retreat_burst_complete: bool = false\n\n## Accuracy reduction during retreat (multiplier for inaccuracy angle spread).\nconst RETREAT_INACCURACY_SPREAD: float = 0.15\n\n## Arc spread for ONE_HIT burst fire (radians, total spread).\nconst RETREAT_BURST_ARC: float = 0.4\n\n## Current angle offset within burst arc.\nvar _retreat_burst_angle_offset: float = 0.0\n\n## Whether enemy is in \"alarm\" mode (was suppressed/retreating and hasn't calmed down).\n## This persists until the enemy reaches safety in cover or returns to idle.\nvar _in_alarm_mode: bool = false\n\n## Whether the enemy needs to fire a cover burst (when leaving cover while in alarm).\nvar _cover_burst_pending: bool = false\n\n## --- Combat Cover Cycling (come out, shoot 2-3s, go back) ---\n## Timer for how long the enemy has been shooting while out of cover.\nvar _combat_shoot_timer: float = 0.0\n\n## Duration to shoot while out of cover (2-3 seconds, randomized).\nvar _combat_shoot_duration: float = 2.5\n\n## Whether the enemy is currently in the \"exposed shooting\" phase of combat.\nvar _combat_exposed: bool = false\n\n## Whether the enemy is in the \"approaching player\" phase of combat.\n## In this phase, the enemy moves toward the player to get into direct contact.\nvar _combat_approaching: bool = false\n\n## Timer for the approach phase of combat.\nvar _combat_approach_timer: float = 0.0\n\n## Maximum time to spend approaching player before starting to shoot (seconds).\nconst COMBAT_APPROACH_MAX_TIME: float = 2.0\n\n## Distance at which enemy is considered \"close enough\" to start shooting phase.\nconst COMBAT_DIRECT_CONTACT_DISTANCE: float = 250.0\n\n## --- Pursuit State (cover-to-cover movement) ---\n## Timer for waiting at cover during pursuit.\nvar _pursuit_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during pursuit (1-2 seconds, reduced for faster pursuit).\nconst PURSUIT_COVER_WAIT_DURATION: float = 1.5\n\n## Current pursuit target cover position.\nvar _pursuit_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid pursuit cover target.\nvar _has_pursuit_cover: bool = false\n\n## --- Flanking State (cover-to-cover movement toward flank target) ---\n## Timer for waiting at cover during flanking.\nvar _flank_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during flanking (seconds).\nconst FLANK_COVER_WAIT_DURATION: float = 0.8\n\n## Current flank cover position to move to.\nvar _flank_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid flank cover target.\nvar _has_flank_cover: bool = false\n\n## --- Assault State (coordinated multi-enemy rush) ---\n## Timer for assault wait period (5 seconds before rushing).\nvar _assault_wait_timer: float = 0.0\n\n## Duration to wait at cover before assault (5 seconds).\nconst ASSAULT_WAIT_DURATION: float = 5.0\n\n## Whether the assault wait period is complete.\nvar _assault_ready: bool = false\n\n## Whether this enemy is currently participating in an assault.\nvar _in_assault: bool = false\n\n## Distance threshold for \"close\" vs \"far\" from player.\n## Used to determine if enemy can engage from current position or needs to pursue.\nconst CLOSE_COMBAT_DISTANCE: float = 400.0\n\n## GOAP world state for goal-oriented planning.\nvar _goap_world_state: Dictionary = {}\n\n## --- Search/Investigation State (for when player escapes from view) ---\n## Last known position where the player was seen before escaping view.\nvar _last_known_player_position: Vector2 = Vector2.ZERO\n\n## Whether a search zone is currently active.\nvar _search_zone_active: bool = false\n\n## Radius of the potential player zone (area where player might be hiding).\nconst SEARCH_ZONE_RADIUS: float = 200.0\n\n## Timer for search timeout - enemy gives up searching after this time.\nvar _search_timer: float = 0.0\n\n## Maximum time to spend searching before giving up (seconds).\nconst SEARCH_MAX_DURATION: float = 15.0\n\n## Inspection points within the search zone (hiding spots behind covers and corners).\nvar _inspection_points: Array[Vector2] = []\n\n## Index of current inspection point being checked.\nvar _current_inspection_index: int = 0\n\n## Timer for waiting at each inspection point (looking around).\nvar _inspection_wait_timer: float = 0.0\n\n## Duration to wait at each inspection point (seconds).\nconst INSPECTION_WAIT_DURATION: float = 1.5\n\n## Whether currently waiting at an inspection point.\nvar _inspecting_point: bool = false\n\n## Number of raycasts for detecting inspection points (corners/hiding spots).\nconst INSPECTION_POINT_CHECK_COUNT: int = 24\n\n## Distance to check for inspection points from search zone center.\nconst INSPECTION_CHECK_DISTANCE: float = 250.0\n\n## Detection delay timer - tracks time since entering combat.\nvar _detection_timer: float = 0.0\n\n## Whether the detection delay has elapsed.\nvar _detection_delay_elapsed: bool = false\n\n## Continuous visibility timer - tracks how long the player has been continuously visible.\n## Resets when line of sight is lost.\nvar _continuous_visibility_timer: float = 0.0\n\n## Current visibility ratio of the player (0.0 to 1.0).\n## Represents what fraction of the player's body is visible to the enemy.\n## Used to determine if lead prediction should be enabled.\nvar _player_visibility_ratio: float = 0.0\n\n## --- Clear Shot Movement (move out from cover to get clear shot) ---\n## Target position to move to for getting a clear shot.\nvar _clear_shot_target: Vector2 = Vector2.ZERO\n\n## Whether we're currently moving to find a clear shot position.\nvar _seeking_clear_shot: bool = false\n\n## Timer for how long we've been trying to find a clear shot.\nvar _clear_shot_timer: float = 0.0\n\n## Maximum time to spend finding a clear shot before giving up (seconds).\nconst CLEAR_SHOT_MAX_TIME: float = 3.0\n\n## Distance to move when exiting cover to find a clear shot.\nconst CLEAR_SHOT_EXIT_DISTANCE: float = 60.0\n\n\n\nfunc _ready() -> void:\n\t_initial_position = global_position\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_setup_patrol_points()\n\t_find_player()\n\t_setup_wall_detection()\n\t_setup_cover_detection()\n\t_setup_threat_sphere()\n\t_initialize_goap_state()\n\t_connect_debug_mode_signal()\n\t_update_debug_label()\n\n\t# Log that this enemy is ready (use call_deferred to ensure FileLogger is loaded)\n\tcall_deferred(\"_log_spawn_info\")\n\n\t# Preload bullet scene if not set in inspector\n\tif bullet_scene == null:\n\t\tbullet_scene = preload(\"res://scenes/projectiles/Bullet.tscn\")\n\n\n## Initialize health with random value between min and max.\nfunc _initialize_health() -> void:\n\t_max_health = randi_range(min_health, max_health)\n\t_current_health = _max_health\n\t_is_alive = true\n\n\n## Initialize ammunition with full magazine and reserve ammo.\nfunc _initialize_ammo() -> void:\n\t_current_ammo = magazine_size\n\t# Reserve ammo is (total_magazines - 1) * magazine_size since one magazine is loaded\n\t_reserve_ammo = (total_magazines - 1) * magazine_size\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\n## Setup patrol points based on patrol offsets from initial position.\nfunc _setup_patrol_points() -> void:\n\t_patrol_points.clear()\n\t_patrol_points.append(_initial_position)\n\tfor offset in patrol_offsets:\n\t\t_patrol_points.append(_initial_position + offset)\n\n\n## Setup wall detection raycasts for obstacle avoidance.\nfunc _setup_wall_detection() -> void:\n\t# Create multiple raycasts spread in front of the enemy\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_wall_raycasts.append(raycast)\n\n\n## Setup cover detection raycasts for finding cover positions.\nfunc _setup_cover_detection() -> void:\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_cover_raycasts.append(raycast)\n\n\n## Setup threat sphere for detecting nearby bullets.\nfunc _setup_threat_sphere() -> void:\n\t_threat_sphere = Area2D.new()\n\t_threat_sphere.name = \"ThreatSphere\"\n\t_threat_sphere.collision_layer = 0\n\t_threat_sphere.collision_mask = 16  # Detect projectiles (layer 5)\n\n\tvar collision_shape := CollisionShape2D.new()\n\tvar circle_shape := CircleShape2D.new()\n\tcircle_shape.radius = threat_sphere_radius\n\tcollision_shape.shape = circle_shape\n\t_threat_sphere.add_child(collision_shape)\n\n\tadd_child(_threat_sphere)\n\n\t# Connect signals\n\t_threat_sphere.area_entered.connect(_on_threat_area_entered)\n\t_threat_sphere.area_exited.connect(_on_threat_area_exited)\n\n\n## Initialize GOAP world state.\nfunc _initialize_goap_state() -> void:\n\t_goap_world_state = {\n\t\t\"player_visible\": false,\n\t\t\"has_cover\": false,\n\t\t\"in_cover\": false,\n\t\t\"under_fire\": false,\n\t\t\"health_low\": false,\n\t\t\"can_flank\": false,\n\t\t\"at_flank_position\": false,\n\t\t\"is_retreating\": false,\n\t\t\"hits_taken\": 0,\n\t\t\"is_pursuing\": false,\n\t\t\"is_assaulting\": false,\n\t\t\"can_hit_from_cover\": false,\n\t\t\"player_close\": false,\n\t\t\"enemies_in_combat\": 0,\n\t\t\"has_search_zone\": false,\n\t\t\"search_zone_cleared\": false,\n\t\t\"inspection_points_remaining\": 0,\n\t\t\"is_searching\": false\n\t}\n\n\n## Connect to GameManager's debug mode signal for F7 toggle.\nfunc _connect_debug_mode_signal() -> void:\n\tvar game_manager: Node = get_node_or_null(\"/root/GameManager\")\n\tif game_manager:\n\t\t# Connect to debug mode toggle signal\n\t\tif game_manager.has_signal(\"debug_mode_toggled\"):\n\t\t\tgame_manager.debug_mode_toggled.connect(_on_debug_mode_toggled)\n\t\t# Sync with current debug mode state\n\t\tif game_manager.has_method(\"is_debug_mode_enabled\"):\n\t\t\tdebug_label_enabled = game_manager.is_debug_mode_enabled()\n\n\n## Called when debug mode is toggled via F7 key.\nfunc _on_debug_mode_toggled(enabled: bool) -> void:\n\tdebug_label_enabled = enabled\n\t_update_debug_label()\n\n\n## Find the player node in the scene tree.\nfunc _find_player() -> void:\n\t# Try to find the player by group first\n\tvar players := get_tree().get_nodes_in_group(\"player\")\n\tif players.size() > 0:\n\t\t_player = players[0]\n\t\treturn\n\n\t# Fallback: search for player by node name or type\n\tvar root := get_tree().current_scene\n\tif root:\n\t\t_player = _find_player_recursive(root)\n\n\n## Recursively search for a player node.\nfunc _find_player_recursive(node: Node) -> Node2D:\n\tif node.name == \"Player\" and node is Node2D:\n\t\treturn node\n\tfor child in node.get_children():\n\t\tvar result := _find_player_recursive(child)\n\t\tif result:\n\t\t\treturn result\n\treturn null\n\n\nfunc _physics_process(delta: float) -> void:\n\tif not _is_alive:\n\t\treturn\n\n\t# Update shoot cooldown timer\n\t_shoot_timer += delta\n\n\t# Update reload timer\n\t_update_reload(delta)\n\n\t# Check for player visibility and try to find player if not found\n\tif _player == null:\n\t\t_find_player()\n\n\t_check_player_visibility()\n\t_update_goap_state()\n\t_update_suppression(delta)\n\n\t# Process AI state machine\n\t_process_ai_state(delta)\n\n\t# Update debug label if enabled\n\t_update_debug_label()\n\n\t# Request redraw for debug visualization\n\tif debug_label_enabled:\n\t\tqueue_redraw()\n\n\tmove_and_slide()\n\n\n## Update GOAP world state based on current conditions.\nfunc _update_goap_state() -> void:\n\t_goap_world_state[\"player_visible\"] = _can_see_player\n\t_goap_world_state[\"under_fire\"] = _under_fire\n\t_goap_world_state[\"health_low\"] = _get_health_percent() < 0.5\n\t_goap_world_state[\"in_cover\"] = _current_state == AIState.IN_COVER\n\t_goap_world_state[\"has_cover\"] = _has_valid_cover\n\t_goap_world_state[\"is_retreating\"] = _current_state == AIState.RETREATING\n\t_goap_world_state[\"hits_taken\"] = _hits_taken_in_encounter\n\t_goap_world_state[\"is_pursuing\"] = _current_state == AIState.PURSUING\n\t_goap_world_state[\"is_assaulting\"] = _current_state == AIState.ASSAULT\n\t_goap_world_state[\"player_close\"] = _is_player_close()\n\t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n\t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()\n\n\n## Update suppression state.\nfunc _update_suppression(delta: float) -> void:\n\t# Clean up destroyed bullets from tracking\n\t_bullets_in_threat_sphere = _bullets_in_threat_sphere.filter(func(b): return is_instance_valid(b))\n\n\t# Determine if there's an active threat (bullets in sphere OR recent threat memory)\n\tvar has_active_threat := not _bullets_in_threat_sphere.is_empty() or _threat_memory_timer > 0.0\n\n\tif not has_active_threat:\n\t\tif _under_fire:\n\t\t\t_suppression_timer += delta\n\t\t\tif _suppression_timer >= suppression_cooldown:\n\t\t\t\t_under_fire = false\n\t\t\t\t_suppression_timer = 0.0\n\t\t\t\t_log_debug(\"Suppression ended\")\n\t\t# Reset threat reaction timer when no bullets are in threat sphere and no threat memory\n\t\t_threat_reaction_timer = 0.0\n\t\t_threat_reaction_delay_elapsed = false\n\telse:\n\t\t# Decrement threat memory timer if no bullets currently in sphere\n\t\tif _bullets_in_threat_sphere.is_empty() and _threat_memory_timer > 0.0:\n\t\t\t_threat_memory_timer -= delta\n\n\t\t# Update threat reaction timer\n\t\tif not _threat_reaction_delay_elapsed:\n\t\t\t_threat_reaction_timer += delta\n\t\t\tif _threat_reaction_timer >= threat_reaction_delay:\n\t\t\t\t_threat_reaction_delay_elapsed = true\n\t\t\t\t_log_debug(\"Threat reaction delay elapsed, now reacting to bullets\")\n\n\t\t# Only set under_fire after the reaction delay has elapsed\n\t\tif _threat_reaction_delay_elapsed:\n\t\t\t_under_fire = true\n\t\t\t_suppression_timer = 0.0\n\n\n## Update reload state.\nfunc _update_reload(delta: float) -> void:\n\tif not _is_reloading:\n\t\treturn\n\n\t_reload_timer += delta\n\tif _reload_timer >= reload_time:\n\t\t_finish_reload()\n\n\n## Start reloading the weapon.\nfunc _start_reload() -> void:\n\t# Can't reload if already reloading or no reserve ammo\n\tif _is_reloading or _reserve_ammo <= 0:\n\t\treturn\n\n\t_is_reloading = true\n\t_reload_timer = 0.0\n\treload_started.emit()\n\t_log_debug(\"Reloading... (%d reserve ammo)\" % _reserve_ammo)\n\n\n## Finish the reload process.\nfunc _finish_reload() -> void:\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\t# Calculate how many rounds to load\n\tvar ammo_needed := magazine_size - _current_ammo\n\tvar ammo_to_load := mini(ammo_needed, _reserve_ammo)\n\n\t_reserve_ammo -= ammo_to_load\n\t_current_ammo += ammo_to_load\n\n\treload_finished.emit()\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\t_log_debug(\"Reload complete. Magazine: %d/%d, Reserve: %d\" % [_current_ammo, magazine_size, _reserve_ammo])\n\n\n## Check if the enemy can shoot (has ammo and not reloading).\nfunc _can_shoot() -> bool:\n\t# Can't shoot if reloading\n\tif _is_reloading:\n\t\treturn false\n\n\t# Can't shoot if no ammo in magazine\n\tif _current_ammo <= 0:\n\t\t# Try to start reload if we have reserve ammo\n\t\tif _reserve_ammo > 0:\n\t\t\t_start_reload()\n\t\telse:\n\t\t\t# No ammo at all - emit depleted signal once\n\t\t\tif not _goap_world_state.get(\"ammo_depleted\", false):\n\t\t\t\t_goap_world_state[\"ammo_depleted\"] = true\n\t\t\t\tammo_depleted.emit()\n\t\t\t\t_log_debug(\"All ammunition depleted!\")\n\t\treturn false\n\n\treturn true\n\n\n## Process the AI state machine.\nfunc _process_ai_state(delta: float) -> void:\n\tvar previous_state := _current_state\n\n\t# State transitions based on conditions\n\tmatch _current_state:\n\t\tAIState.IDLE:\n\t\t\t_process_idle_state(delta)\n\t\tAIState.COMBAT:\n\t\t\t_process_combat_state(delta)\n\t\tAIState.SEEKING_COVER:\n\t\t\t_process_seeking_cover_state(delta)\n\t\tAIState.IN_COVER:\n\t\t\t_process_in_cover_state(delta)\n\t\tAIState.FLANKING:\n\t\t\t_process_flanking_state(delta)\n\t\tAIState.SUPPRESSED:\n\t\t\t_process_suppressed_state(delta)\n\t\tAIState.RETREATING:\n\t\t\t_process_retreating_state(delta)\n\t\tAIState.PURSUING:\n\t\t\t_process_pursuing_state(delta)\n\t\tAIState.ASSAULT:\n\t\t\t_process_assault_state(delta)\n\n\tif previous_state != _current_state:\n\t\tstate_changed.emit(_current_state)\n\t\t_log_debug(\"State changed: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\t\t# Also log to file for exported build debugging\n\t\t_log_to_file(\"State: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\n\n## Process IDLE state - patrol or guard behavior.\nfunc _process_idle_state(delta: float) -> void:\n\t# Transition to combat if player is visible\n\tif _can_see_player and _player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Execute idle behavior\n\tmatch behavior_mode:\n\t\tBehaviorMode.PATROL:\n\t\t\t_process_patrol(delta)\n\t\tBehaviorMode.GUARD:\n\t\t\t_process_guard(delta)\n\n\n## Process COMBAT state - approach player for direct contact, shoot for 2-3 seconds, return to cover.\n## Implements the combat cycling behavior: exit cover -> exposed shooting -> return to cover.\n## Phase 0 (seeking clear shot): If bullet spawn blocked, move out from cover to find clear shot.\n## Phase 1 (approaching): Move toward player to get into direct contact range.\n## Phase 2 (exposed): Stand and shoot for 2-3 seconds.\n## Phase 3: Return to cover via SEEKING_COVER state.\nfunc _process_combat_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies in combat (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can't see player, pursue them (move cover-to-cover toward player)\n\tif not _can_see_player:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\t\treturn\n\n\t# Update detection delay timer\n\tif not _detection_delay_elapsed:\n\t\t_detection_timer += delta\n\t\tif _detection_timer >= detection_delay:\n\t\t\t_detection_delay_elapsed = true\n\n\t# If we don't have cover, find some first (needed for returning later)\n\tif not _has_valid_cover and enable_cover:\n\t\t_find_cover_position()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found cover at %s for combat cycling\" % _cover_position)\n\n\t# Check player distance for approach/exposed phase decisions\n\tvar distance_to_player := INF\n\tif _player:\n\t\tdistance_to_player = global_position.distance_to(_player.global_position)\n\n\t# Check if we have a clear shot (no wall blocking bullet spawn)\n\tvar direction_to_player := Vector2.ZERO\n\tvar has_clear_shot := true\n\tif _player:\n\t\tdirection_to_player = (_player.global_position - global_position).normalized()\n\t\thas_clear_shot = _is_bullet_spawn_clear(direction_to_player)\n\n\t# If already exposed (shooting phase), handle shooting and timer\n\tif _combat_exposed:\n\t\t_combat_shoot_timer += delta\n\n\t\t# Check if exposure time is complete - go back to cover\n\t\tif _combat_shoot_timer >= _combat_shoot_duration and _has_valid_cover:\n\t\t\t_log_debug(\"Combat exposure time complete (%.1fs), returning to cover\" % _combat_shoot_duration)\n\t\t\t_combat_exposed = false\n\t\t\t_combat_approaching = false\n\t\t\t_combat_shoot_timer = 0.0\n\t\t\t_transition_to_seeking_cover()\n\t\t\treturn\n\n\t\t# Check if we still have a clear shot - if not, move sideways to find one\n\t\tif _player and not has_clear_shot:\n\t\t\t# Bullet spawn is blocked - move sideways to find a clear shot position\n\t\t\tvar sidestep_dir := _find_sidestep_direction_for_clear_shot(direction_to_player)\n\t\t\tif sidestep_dir != Vector2.ZERO:\n\t\t\t\tvelocity = sidestep_dir * combat_move_speed * 0.7\n\t\t\t\trotation = direction_to_player.angle()  # Keep facing player while sidestepping\n\t\t\t\t_log_debug(\"COMBAT exposed: sidestepping to maintain clear shot\")\n\t\t\telse:\n\t\t\t\t# No sidestep works - stay still, the shot might clear up\n\t\t\t\tvelocity = Vector2.ZERO\n\t\t\treturn\n\n\t\t# In exposed phase with clear shot, stand still and shoot\n\t\tvelocity = Vector2.ZERO\n\n\t\t# Aim and shoot at player (only shoot after detection delay)\n\t\tif _player:\n\t\t\t_aim_at_player()\n\t\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot()\n\t\t\t\t_shoot_timer = 0.0\n\t\treturn\n\n\t# --- CLEAR SHOT SEEKING PHASE ---\n\t# If bullet spawn is blocked and we're not already exposed, we need to move out from cover\n\tif not has_clear_shot and _player:\n\t\t# Start seeking clear shot if not already doing so\n\t\tif not _seeking_clear_shot:\n\t\t\t_seeking_clear_shot = true\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Calculate target position: move perpendicular to player direction (around cover edge)\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\t_log_debug(\"COMBAT: bullet spawn blocked, seeking clear shot at %s\" % _clear_shot_target)\n\n\t\t_clear_shot_timer += delta\n\n\t\t# Check if we've exceeded the max time trying to find a clear shot\n\t\tif _clear_shot_timer >= CLEAR_SHOT_MAX_TIME:\n\t\t\t_log_debug(\"COMBAT: clear shot timeout, trying flanking\")\n\t\t\t_seeking_clear_shot = false\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Try flanking to get around the obstacle\n\t\t\tif enable_flanking:\n\t\t\t\t_transition_to_flanking()\n\t\t\telse:\n\t\t\t\t_transition_to_pursuing()\n\t\t\treturn\n\n\t\t# Move toward the clear shot target position\n\t\tvar distance_to_target := global_position.distance_to(_clear_shot_target)\n\t\tif distance_to_target > 15.0:\n\t\t\tvar move_direction := (_clear_shot_target - global_position).normalized()\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed\n\t\t\trotation = direction_to_player.angle()  # Keep facing player\n\n\t\t\t# Check if the new position now has a clear shot\n\t\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\t\t_log_debug(\"COMBAT: found clear shot position while moving\")\n\t\t\t\t_seeking_clear_shot = false\n\t\t\t\t_clear_shot_timer = 0.0\n\t\t\t\t# Continue to exposed phase check below\n\t\t\telse:\n\t\t\t\treturn  # Keep moving toward target\n\t\telse:\n\t\t\t# Reached target but still no clear shot - recalculate target\n\t\t\t_log_debug(\"COMBAT: reached target but no clear shot, recalculating\")\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\treturn\n\n\t# Reset seeking state if we now have a clear shot\n\tif _seeking_clear_shot and has_clear_shot:\n\t\t_log_debug(\"COMBAT: clear shot acquired\")\n\t\t_seeking_clear_shot = false\n\t\t_clear_shot_timer = 0.0\n\n\t# Determine if we should be in approach phase or exposed shooting phase\n\tvar in_direct_contact := distance_to_player <= COMBAT_DIRECT_CONTACT_DISTANCE\n\n\t# Enter exposed phase if we have a clear shot and are either close enough or have approached long enough\n\tif has_clear_shot and (in_direct_contact or _combat_approach_timer >= COMBAT_APPROACH_MAX_TIME):\n\t\t# Close enough AND have clear shot - start exposed shooting phase\n\t\t_combat_exposed = true\n\t\t_combat_approaching = false\n\t\t_combat_shoot_timer = 0.0\n\t\t_combat_approach_timer = 0.0\n\t\t# Randomize exposure duration between 2-3 seconds\n\t\t_combat_shoot_duration = randf_range(2.0, 3.0)\n\t\t_log_debug(\"COMBAT exposed phase started (distance: %.0f), will shoot for %.1fs\" % [distance_to_player, _combat_shoot_duration])\n\t\treturn\n\n\t# Need to approach player - move toward them\n\tif not _combat_approaching:\n\t\t_combat_approaching = true\n\t\t_combat_approach_timer = 0.0\n\t\t_log_debug(\"COMBAT approach phase started, moving toward player\")\n\n\t_combat_approach_timer += delta\n\n\t# Move toward player while approaching\n\tif _player:\n\t\tvar move_direction := direction_to_player\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = move_direction * combat_move_speed\n\t\trotation = direction_to_player.angle()  # Always face player\n\n\t\t# Can shoot while approaching (only after detection delay and if have clear shot)\n\t\tif has_clear_shot and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\n## Calculate a target position to exit cover and get a clear shot.\n## Returns a position that should allow the bullet spawn point to be unobstructed.\nfunc _calculate_clear_shot_exit_position(direction_to_player: Vector2) -> Vector2:\n\t# Calculate perpendicular directions to the player\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Try both perpendicular directions and pick the one that's more likely to work\n\t# Also blend with forward movement toward player to help navigate around cover\n\tvar best_position := global_position\n\tvar best_score := -1.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\t\t# Blend sidestep with forward movement for better cover navigation\n\t\tvar exit_dir: Vector2 = (sidestep_dir * 0.7 + direction_to_player * 0.3).normalized()\n\t\tvar test_position: Vector2 = global_position + exit_dir * CLEAR_SHOT_EXIT_DISTANCE\n\n\t\t# Score this position based on:\n\t\t# 1. Does it have a clear path? (no walls in the way)\n\t\t# 2. Would the bullet spawn be clear from there?\n\t\tvar score: float = 0.0\n\n\t\t# Check if we can move to this position\n\t\tif _has_clear_path_to(test_position):\n\t\t\tscore += 1.0\n\n\t\t# Check if bullet spawn would be clear from this position\n\t\t# This is a rough estimate - we check from the test position toward player\n\t\tvar world_2d := get_world_2d()\n\t\tif world_2d != null:\n\t\t\tvar space_state := world_2d.direct_space_state\n\t\t\tif space_state != null:\n\t\t\t\tvar check_distance := bullet_spawn_offset + 5.0\n\t\t\t\tvar query := PhysicsRayQueryParameters2D.new()\n\t\t\t\tquery.from = test_position\n\t\t\t\tquery.to = test_position + direction_to_player * check_distance\n\t\t\t\tquery.collision_mask = 4  # Only check obstacles\n\t\t\t\tquery.exclude = [get_rid()]\n\t\t\t\tvar result := space_state.intersect_ray(query)\n\t\t\t\tif result.is_empty():\n\t\t\t\t\tscore += 2.0  # Higher score for clear bullet spawn\n\n\t\tif score > best_score:\n\t\t\tbest_score = score\n\t\t\tbest_position = test_position\n\n\t# If no good position found, just move forward toward player\n\tif best_score < 0.5:\n\t\tbest_position = global_position + direction_to_player * CLEAR_SHOT_EXIT_DISTANCE\n\n\treturn best_position\n\n\n## Process SEEKING_COVER state - moving to cover position.\nfunc _process_seeking_cover_state(_delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, stay in combat\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're already hidden from the player (the main goal)\n\tif not _is_visible_from_player():\n\t\t_transition_to_in_cover()\n\t\t_log_debug(\"Hidden from player, entering cover state\")\n\t\treturn\n\n\t# Move towards cover\n\tvar direction := (_cover_position - global_position).normalized()\n\tvar distance := global_position.distance_to(_cover_position)\n\n\tif distance < 10.0:\n\t\t# Reached the cover position, but still visible - try to find better cover\n\t\tif _is_visible_from_player():\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\t# No better cover found, stay in combat\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\n\t# Apply wall avoidance\n\tvar avoidance := _check_wall_ahead(direction)\n\tif avoidance != Vector2.ZERO:\n\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\tvelocity = direction * combat_move_speed\n\trotation = direction.angle()\n\n\t# Can still shoot while moving to cover (only after detection delay)\n\tif _can_see_player and _player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t_aim_at_player()\n\t\t_shoot()\n\t\t_shoot_timer = 0.0\n\n\n## Process IN_COVER state - taking cover from enemy fire.\n## Decides next action based on:\n## 1. If under fire -> suppressed\n## 2. If player is close (can exit cover for direct contact) -> COMBAT\n## 3. If player is far but can hit from current position -> COMBAT (stay and shoot)\n## 4. If player is far and can't hit -> PURSUING (move cover-to-cover)\nfunc _process_in_cover_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# If still under fire, stay suppressed\n\tif _under_fire:\n\t\t_transition_to_suppressed()\n\t\treturn\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover\n\tif _is_visible_from_player():\n\t\t# If in alarm mode and can see player, fire a burst before escaping\n\t\tif _in_alarm_mode and _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"IN_COVER alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay in cover while firing burst\n\n\t\t# Burst complete or not in alarm mode, seek new cover\n\t\t_log_debug(\"Player flanked our cover position, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# Decision making based on player distance and visibility\n\tif _player:\n\t\tvar player_close := _is_player_close()\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\n\t\tif _can_see_player:\n\t\t\tif player_close:\n\t\t\t\t# Player is close - engage in combat (come out, shoot, go back)\n\t\t\t\t_log_debug(\"Player is close, transitioning to COMBAT\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\t# Player is far\n\t\t\t\tif can_hit:\n\t\t\t\t\t# Can hit from current position - come out and shoot\n\t\t\t\t\t# (Don't pursue, just transition to combat which will handle the cycling)\n\t\t\t\t\t_log_debug(\"Player is far but can hit from here, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\telse:\n\t\t\t\t\t# Can't hit from here - need to pursue (move cover-to-cover)\n\t\t\t\t\t_log_debug(\"Player is far and can't hit, transitioning to PURSUING\")\n\t\t\t\t\t_transition_to_pursuing()\n\t\t\t\t\treturn\n\n\t# If not under fire and can see player, engage (only shoot after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If player is no longer visible and not under fire, try pursuing\n\tif not _can_see_player and not _under_fire:\n\t\t_log_debug(\"Lost sight of player from cover, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\n\n## Process FLANKING state - attempting to flank the player using cover-to-cover movement.\n## Uses intermediate cover positions to navigate around obstacles instead of walking\n## directly toward the flank target.\nfunc _process_flanking_state(delta: float) -> void:\n\t# If under fire, retreat with shooting behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# If can see player, engage in combat\n\tif _can_see_player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\tif _player == null:\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# Recalculate flank position (player may have moved)\n\t_calculate_flank_position()\n\n\tvar distance_to_flank := global_position.distance_to(_flank_target)\n\n\t# Check if we've reached the flank target\n\tif distance_to_flank < 30.0:\n\t\t_log_debug(\"Reached flank position, engaging\")\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Check if we have direct line of sight to flank target (no obstacles)\n\tif _has_clear_path_to(_flank_target):\n\t\t# Direct path is clear - move directly toward flank target\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\t_has_flank_cover = false\n\t\treturn\n\n\t# Path is blocked - use cover-to-cover movement\n\n\t# If we're at a cover position, wait briefly before moving to next\n\tif _has_valid_cover and not _has_flank_cover:\n\t\t_flank_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _flank_cover_wait_timer >= FLANK_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover toward flank target\n\t\t\t_find_flank_cover_toward_target()\n\t\t\tif not _has_flank_cover:\n\t\t\t\t_log_debug(\"No flank cover found, attempting direct movement\")\n\t\t\t\t# No cover found - try direct movement with enhanced wall avoidance\n\t\t\t\tvar direction := (_flank_target - global_position).normalized()\n\t\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\t\tvelocity = direction * combat_move_speed\n\t\t\t\trotation = direction.angle()\n\t\t\t\t# Invalidate current cover to trigger new search next frame\n\t\t\t\t_has_valid_cover = false\n\t\treturn\n\n\t# If we have a flank cover target, move toward it\n\tif _has_flank_cover:\n\t\tvar direction := (_flank_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_flank_next_cover)\n\n\t\t# Check if we've reached the flank cover\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached flank cover at distance %.1f\" % distance)\n\t\t\t_has_flank_cover = false\n\t\t\t_flank_cover_wait_timer = 0.0\n\t\t\t_cover_position = _flank_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no flank cover target - find initial flank cover\n\t_find_flank_cover_toward_target()\n\tif not _has_flank_cover:\n\t\t# Can't find cover, try direct movement with wall avoidance\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\n\n## Process SUPPRESSED state - staying in cover under fire.\nfunc _process_suppressed_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover even while suppressed\n\tif _is_visible_from_player():\n\t\t# In suppressed state we're always in alarm mode - fire a burst before escaping if we can see player\n\t\tif _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"SUPPRESSED alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay suppressed while firing burst\n\n\t\t# Burst complete or can't see player, seek new cover\n\t\t_log_debug(\"Player flanked our cover position while suppressed, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Can still shoot while suppressed (only after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If no longer under fire, exit suppression\n\tif not _under_fire:\n\t\t_transition_to_in_cover()\n\n\n## Process RETREATING state - moving to cover with behavior based on damage taken.\nfunc _process_retreating_state(delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, transition to combat or suppressed\n\t\t\tif _under_fire:\n\t\t\t\t_transition_to_suppressed()\n\t\t\telse:\n\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we've reached cover and are hidden from player\n\tif not _is_visible_from_player():\n\t\t_log_debug(\"Reached cover during retreat\")\n\t\t# Reset encounter hits when successfully reaching cover\n\t\t_hits_taken_in_encounter = 0\n\t\t_transition_to_in_cover()\n\t\treturn\n\n\t# Calculate direction to cover\n\tvar direction_to_cover := (_cover_position - global_position).normalized()\n\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\n\t# Check if reached cover position\n\tif distance_to_cover < 10.0:\n\t\tif _is_visible_from_player():\n\t\t\t# Still visible, find better cover\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\tif _under_fire:\n\t\t\t\t\t_transition_to_suppressed()\n\t\t\t\telse:\n\t\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Apply retreat behavior based on mode\n\tmatch _retreat_mode:\n\t\tRetreatMode.FULL_HP:\n\t\t\t_process_retreat_full_hp(delta, direction_to_cover)\n\t\tRetreatMode.ONE_HIT:\n\t\t\t_process_retreat_one_hit(delta, direction_to_cover)\n\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t_process_retreat_multiple_hits(delta, direction_to_cover)\n\n\n## Process FULL_HP retreat: walk backwards facing player, shoot with reduced accuracy,\n## periodically turn toward cover.\nfunc _process_retreat_full_hp(delta: float, direction_to_cover: Vector2) -> void:\n\t_retreat_turn_timer += delta\n\n\tif _retreat_turning_to_cover:\n\t\t# Turning to face cover, don't shoot\n\t\tif _retreat_tu
[2026-01-18T02:52:37.754Z] [INFO] rn_timer >= RETREAT_TURN_DURATION:\n\t\t\t_retreat_turning_to_cover = false\n\t\t\t_retreat_turn_timer = 0.0\n\n\t\t# Face cover and move toward it\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\telse:\n\t\t# Face player and back up (walk backwards)\n\t\tif _retreat_turn_timer >= RETREAT_TURN_INTERVAL:\n\t\t\t_retreat_turning_to_cover = true\n\t\t\t_retreat_turn_timer = 0.0\n\t\t\t_log_debug(\"FULL_HP retreat: turning to check cover\")\n\n\t\tif _player:\n\t\t\t# Face the player\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\t_aim_at_player()\n\n\t\t\t# Move backwards (opposite of player direction = toward cover generally)\n\t\t\t# Use the negative of the direction we're facing for \"backing up\"\n\t\t\tvar move_direction := -direction_to_player\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed * 0.7  # Slower when backing up\n\n\t\t\t# Shoot with reduced accuracy (only after detection delay)\n\t\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot_with_inaccuracy()\n\t\t\t\t_shoot_timer = 0.0\n\n\n## Process ONE_HIT retreat: quick burst of 2-4 shots in an arc while turning, then face cover.\nfunc _process_retreat_one_hit(delta: float, direction_to_cover: Vector2) -> void:\n\tif not _retreat_burst_complete:\n\t\t# During burst phase\n\t\t_retreat_burst_timer += delta\n\n\t\tif _player and _retreat_burst_remaining > 0 and _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t# Fire a burst shot with arc spread\n\t\t\t_shoot_burst_shot()\n\t\t\t_retreat_burst_remaining -= 1\n\t\t\t_retreat_burst_timer = 0.0\n\n\t\t\t# Progress through the arc\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0  # Spread across 4 shots max\n\n\t\t# Gradually turn from player to cover during burst\n\t\tif _player:\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\tvar target_angle: float\n\n\t\t\t# Interpolate rotation from player direction to cover direction\n\t\t\tvar burst_progress := 1.0 - (float(_retreat_burst_remaining) / 4.0)\n\t\t\tvar player_angle := direction_to_player.angle()\n\t\t\tvar cover_angle := direction_to_cover.angle()\n\t\t\ttarget_angle = lerp_angle(player_angle, cover_angle, burst_progress * 0.7)\n\t\t\trotation = target_angle\n\n\t\t# Move toward cover (slower during burst)\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed * 0.5\n\n\t\t# Check if burst is complete\n\t\tif _retreat_burst_remaining <= 0:\n\t\t\t_retreat_burst_complete = true\n\t\t\t_log_debug(\"ONE_HIT retreat: burst complete, now running to cover\")\n\telse:\n\t\t# After burst, run to cover without shooting\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\n\n## Process MULTIPLE_HITS retreat: quick burst of 2-4 shots then run to cover (same as ONE_HIT).\nfunc _process_retreat_multiple_hits(delta: float, direction_to_cover: Vector2) -> void:\n\t# Same behavior as ONE_HIT - quick burst then escape\n\t_process_retreat_one_hit(delta, direction_to_cover)\n\n\n## Process PURSUING state - move cover-to-cover toward player.\n## Enemy moves between covers, waiting 1-2 seconds at each cover,\n## until they can see and hit the player.\nfunc _process_pursuing_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected during pursuit (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can see player and can hit them from current position, engage\n\tif _can_see_player and _player:\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\t\tif can_hit:\n\t\t\t_log_debug(\"Can see and hit player from pursuit, transitioning to COMBAT\")\n\t\t\t_has_pursuit_cover = false\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're waiting at cover\n\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t# Currently at cover, wait for 1-2 seconds before moving to next cover\n\t\t_pursuit_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _pursuit_cover_wait_timer >= PURSUIT_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover closer to player\n\t\t\t_log_debug(\"Pursuit wait complete, finding next cover\")\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_find_pursuit_cover_toward_player()\n\t\t\tif _has_pursuit_cover:\n\t\t\t\t_log_debug(\"Found pursuit cover at %s\" % _pursuit_next_cover)\n\t\t\telse:\n\t\t\t\t# No pursuit cover found - fallback behavior\n\t\t\t\t_log_debug(\"No pursuit cover found, checking fallback options\")\n\t\t\t\t# If we can now see the player, engage directly\n\t\t\t\tif _can_see_player:\n\t\t\t\t\t_log_debug(\"Can see player, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\t# Try flanking\n\t\t\t\tif enable_flanking and _player:\n\t\t\t\t\t_log_debug(\"Attempting flanking maneuver\")\n\t\t\t\t\t_transition_to_flanking()\n\t\t\t\t\treturn\n\t\t\t\t# Last resort: move directly toward player\n\t\t\t\t_log_debug(\"No cover options, moving directly toward player\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\treturn\n\n\t# If we have a pursuit cover target, move toward it\n\tif _has_pursuit_cover:\n\t\tvar direction := (_pursuit_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_pursuit_next_cover)\n\n\t\t# Check if we've reached the pursuit cover\n\t\t# Note: We only check distance here, NOT visibility from player.\n\t\t# If we checked visibility, the enemy would immediately consider themselves\n\t\t# \"at cover\" even before moving, since they start hidden from player.\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached pursuit cover at distance %.1f\" % distance)\n\t\t\t_has_pursuit_cover = false\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_cover_position = _pursuit_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no pursuit target - find initial pursuit cover\n\t_find_pursuit_cover_toward_player()\n\tif not _has_pursuit_cover:\n\t\t# Can't find cover to pursue, try flanking or combat\n\t\tif enable_flanking and _player:\n\t\t\t_transition_to_flanking()\n\t\telse:\n\t\t\t_transition_to_combat()\n\n\n## Process ASSAULT state - coordinated multi-enemy rush.\n## Wait at cover for 5 seconds, then all enemies rush the player simultaneously.\nfunc _process_assault_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover and not _assault_ready:\n\t\t_in_assault = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if we're the only enemy left in assault - switch back to combat\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat < 2 and not _assault_ready:\n\t\t_log_debug(\"Not enough enemies for assault, switching to COMBAT\")\n\t\t_in_assault = false\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Find closest cover to player if we don't have one\n\tif not _has_valid_cover:\n\t\t_find_cover_closest_to_player()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found assault cover at %s\" % _cover_position)\n\n\t# Move to cover position first\n\tif _has_valid_cover and not _in_assault:\n\t\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\t\tif distance_to_cover > 15.0 and _is_visible_from_player():\n\t\t\t# Still need to reach cover\n\t\t\tvar direction := (_cover_position - global_position).normalized()\n\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\tvelocity = direction * combat_move_speed\n\t\t\trotation = direction.angle()\n\t\t\treturn\n\n\t# At cover, wait for assault timer\n\tif not _assault_ready:\n\t\tvelocity = Vector2.ZERO\n\t\t_assault_wait_timer += delta\n\n\t\t# Check if all assault enemies are ready (synchronized assault)\n\t\tif _assault_wait_timer >= ASSAULT_WAIT_DURATION:\n\t\t\t# Check if situation has changed - player might have moved\n\t\t\tif _player and _is_player_close():\n\t\t\t\t_assault_ready = true\n\t\t\t\t_in_assault = true\n\t\t\t\t_log_debug(\"ASSAULT ready - rushing player!\")\n\t\t\telse:\n\t\t\t\t# Player moved away, reset timer and check if we should pursue\n\t\t\t\t_log_debug(\"Player moved away during assault wait, resetting\")\n\t\t\t\t_assault_wait_timer = 0.0\n\t\t\t\t_in_assault = false\n\t\t\t\t_transition_to_pursuing()\n\t\t\t\treturn\n\t\treturn\n\n\t# Assault phase - rush the player while shooting\n\tif _assault_ready and _player:\n\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction_to_player)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_player = (direction_to_player * 0.5 + avoidance * 0.5).normalized()\n\n\t\t# Rush at full speed\n\t\tvelocity = direction_to_player * combat_move_speed\n\t\trotation = direction_to_player.angle()\n\n\t\t# Update detection delay timer\n\t\tif not _detection_delay_elapsed:\n\t\t\t_detection_timer += delta\n\t\t\tif _detection_timer >= detection_delay:\n\t\t\t\t_detection_delay_elapsed = true\n\n\t\t# Shoot while rushing (only after detection delay)\n\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t\t# If very close to player, stay in combat\n\t\tif distance_to_player < 50.0:\n\t\t\t_log_debug(\"Assault complete - reached player\")\n\t\t\t_assault_ready = false\n\t\t\t_in_assault = false\n\t\t\t_transition_to_combat()\n\n\n## Shoot with reduced accuracy for retreat mode.\nfunc _shoot_with_inaccuracy() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Check if the shot should be taken\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Add inaccuracy spread\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD, RETREAT_INACCURACY_SPREAD)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the inaccurate shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Inaccurate shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Shoot a burst shot with arc spread for ONE_HIT retreat.\nfunc _shoot_burst_shot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Apply arc offset for burst spread\n\tdirection = direction.rotated(_retreat_burst_angle_offset)\n\n\t# Also add some random inaccuracy on top of the arc\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD * 0.5, RETREAT_INACCURACY_SPREAD * 0.5)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the burst shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Burst shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Transition to IDLE state.\nfunc _transition_to_idle() -> void:\n\t_current_state = AIState.IDLE\n\t# Reset encounter hit tracking when returning to idle\n\t_hits_taken_in_encounter = 0\n\t# Reset alarm mode when returning to idle\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\n\n## Transition to COMBAT state.\nfunc _transition_to_combat() -> void:\n\t_current_state = AIState.COMBAT\n\t# Reset detection delay timer when entering combat\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Reset combat phase variables\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_shoot_timer = 0.0\n\t_combat_approach_timer = 0.0\n\t# Reset clear shot seeking variables\n\t_seeking_clear_shot = false\n\t_clear_shot_timer = 0.0\n\t_clear_shot_target = Vector2.ZERO\n\n\n## Transition to SEEKING_COVER state.\nfunc _transition_to_seeking_cover() -> void:\n\t_current_state = AIState.SEEKING_COVER\n\t_find_cover_position()\n\n\n## Transition to IN_COVER state.\nfunc _transition_to_in_cover() -> void:\n\t_current_state = AIState.IN_COVER\n\n\n## Transition to FLANKING state.\nfunc _transition_to_flanking() -> void:\n\t_current_state = AIState.FLANKING\n\t_calculate_flank_position()\n\t_flank_cover_wait_timer = 0.0\n\t_has_flank_cover = false\n\t_has_valid_cover = false\n\n\n## Transition to SUPPRESSED state.\nfunc _transition_to_suppressed() -> void:\n\t_current_state = AIState.SUPPRESSED\n\t# Enter alarm mode when suppressed\n\t_in_alarm_mode = true\n\n\n## Transition to PURSUING state.\nfunc _transition_to_pursuing() -> void:\n\t_current_state = AIState.PURSUING\n\t_pursuit_cover_wait_timer = 0.0\n\t_has_pursuit_cover = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\n\n## Transition to ASSAULT state.\nfunc _transition_to_assault() -> void:\n\t_current_state = AIState.ASSAULT\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Find closest cover to player for assault position\n\t_find_cover_closest_to_player()\n\n\n## Transition to RETREATING state with appropriate retreat mode.\nfunc _transition_to_retreating() -> void:\n\t_current_state = AIState.RETREATING\n\t# Enter alarm mode when retreating\n\t_in_alarm_mode = true\n\n\t# Determine retreat mode based on hits taken\n\tif _hits_taken_in_encounter == 0:\n\t\t_retreat_mode = RetreatMode.FULL_HP\n\t\t_retreat_turn_timer = 0.0\n\t\t_retreat_turning_to_cover = false\n\t\t_log_debug(\"Entering RETREATING state: FULL_HP mode (shoot while backing up)\")\n\telif _hits_taken_in_encounter == 1:\n\t\t_retreat_mode = RetreatMode.ONE_HIT\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t# Calculate arc spread: shots will be distributed across the arc\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: ONE_HIT mode (burst of %d shots)\" % _retreat_burst_remaining)\n\telse:\n\t\t_retreat_mode = RetreatMode.MULTIPLE_HITS\n\t\t# Multiple hits also gets burst fire (same as ONE_HIT)\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: MULTIPLE_HITS mode (burst of %d shots)\" % _retreat_burst_remaining)\n\n\t# Find cover position for retreating\n\t_find_cover_position()\n\n\n## Check if the enemy is visible from the player's position.\n## Uses raycasting from player to enemy to determine if there are obstacles blocking line of sight.\n## This is the inverse of _can_see_player - it checks if the PLAYER can see the ENEMY.\n## Checks multiple points on the enemy body (center and corners) to account for enemy size.\nfunc _is_visible_from_player() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check visibility to multiple points on the enemy body\n\t# This accounts for the enemy's size - corners can stick out from cover\n\tvar check_points := _get_enemy_check_points(global_position)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Get multiple check points on the enemy body for visibility testing.\n## Returns center and 4 corner points offset by the enemy's radius.\nfunc _get_enemy_check_points(center: Vector2) -> Array[Vector2]:\n\t# Enemy collision radius is 24, sprite is 48x48\n\t# Use a slightly smaller radius to avoid edge cases\n\tconst ENEMY_RADIUS: float = 22.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := ENEMY_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point is visible from the player's position.\nfunc _is_point_visible_from_player(point: Vector2) -> bool:\n\tif _player == null:\n\t\treturn false\n\n\tvar player_pos := _player.global_position\n\tvar distance := player_pos.distance_to(point)\n\n\t# Use direct space state to check line of sight from player to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = player_pos\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = []\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between player and point - point is visible\n\t\treturn true\n\telse:\n\t\t# Check if we hit an obstacle before reaching the point\n\t\tvar hit_position: Vector2 = result[\"position\"]\n\t\tvar distance_to_hit := player_pos.distance_to(hit_position)\n\n\t\t# If we hit something closer than the point, the point is hidden\n\t\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t\treturn false\n\t\telse:\n\t\t\treturn true\n\n\n## Check if a specific position would make the enemy visible from the player's position.\n## Checks all enemy body points (center and corners) to account for enemy size.\n## Used to validate cover positions before moving to them.\nfunc _is_position_visible_from_player(pos: Vector2) -> bool:\n\tif _player == null:\n\t\treturn true  # Assume visible if no player\n\n\t# Check visibility for all enemy body points at the given position\n\tvar check_points := _get_enemy_check_points(pos)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Check if a target position is visible from the enemy's perspective.\n## Uses raycast to verify there are no obstacles between enemy and the target position.\n## This is used to validate lead prediction targets - enemies should only aim at\n## positions they can actually see.\nfunc _is_position_visible_to_enemy(target_pos: Vector2) -> bool:\n\tvar distance := global_position.distance_to(target_pos)\n\n\t# Use direct space state to check line of sight from enemy to target\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = target_pos\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and target - position is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t# Hit obstacle before target - position is NOT visible\n\t\t_log_debug(\"Position %s blocked by obstacle at distance %.1f (target at %.1f)\" % [target_pos, distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Get multiple check points on the player's body for visibility testing.\n## Returns center and 4 corner points offset by the player's radius.\n## The player has a collision radius of 16 pixels (from Player.tscn).\nfunc _get_player_check_points(center: Vector2) -> Array[Vector2]:\n\t# Player collision radius is 16, sprite is 32x32\n\t# Use a slightly smaller radius to be conservative\n\tconst PLAYER_RADIUS: float = 14.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := PLAYER_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point on the player is visible from the enemy's position.\n## Uses direct space state query to check for obstacles blocking line of sight.\nfunc _is_player_point_visible_to_enemy(point: Vector2) -> bool:\n\tvar distance := global_position.distance_to(point)\n\n\t# Use direct space state to check line of sight from enemy to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and point - point is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the point\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\t# If we hit something before the point, the point is blocked\n\tif distance_to_hit < distance - 5.0:  # 5 pixel tolerance\n\t\treturn false\n\n\treturn true\n\n\n## Calculate what fraction of the player's body is visible to the enemy.\n## Returns a value from 0.0 (completely hidden) to 1.0 (fully visible).\n## Checks multiple points on the player's body (center + corners).\nfunc _calculate_player_visibility_ratio() -> float:\n\tif _player == null:\n\t\treturn 0.0\n\n\tvar check_points := _get_player_check_points(_player.global_position)\n\tvar visible_count := 0\n\n\tfor point in check_points:\n\t\tif _is_player_point_visible_to_enemy(point):\n\t\t\tvisible_count += 1\n\n\treturn float(visible_count) / float(check_points.size())\n\n\n## Check if the line of fire to the target position is clear of other enemies.\n## Returns true if no other enemies would be hit by a bullet traveling to the target.\nfunc _is_firing_line_clear_of_friendlies(target_position: Vector2) -> bool:\n\tif not enable_friendly_fire_avoidance:\n\t\treturn true\n\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if any enemies are in the firing line\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 2  # Only check enemies (layer 2)\n\tquery.exclude = [get_rid()]  # Exclude self using RID\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No enemies in the way\n\n\t# Check if the hit position is before the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 20.0:  # 20 pixel tolerance\n\t\t_log_debug(\"Friendly in firing line at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if a bullet fired at the target position would be blocked by cover/obstacles.\n## Returns true if the shot would likely hit the target, false if blocked by cover.\nfunc _is_shot_clear_of_cover(target_position: Vector2) -> bool:\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if obstacles block the shot\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No obstacles in the way\n\n\t# Check if the obstacle is before the target position\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t_log_debug(\"Shot blocked by cover at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if there's an obstacle immediately in front of the enemy that would block bullets.\n## This prevents shooting into walls that the enemy is flush against or very close to.\n## Uses a single raycast from enemy center to the bullet spawn position.\nfunc _is_bullet_spawn_clear(direction: Vector2) -> bool:\n\t# Fail-open: allow shooting if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn true\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn true\n\n\t# Check from enemy center to bullet spawn position plus a small buffer\n\tvar check_distance := bullet_spawn_offset + 5.0\n\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = global_position + direction * check_distance\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]\n\n\tvar result := space_state.intersect_ray(query)\n\tif not result.is_empty():\n\t\t_log_debug(\"Bullet spawn blocked: wall at distance %.1f\" % [\n\t\t\tglobal_position.distance_to(result[\"position\"])])\n\t\treturn false\n\n\treturn true\n\n\n## Find a sidestep direction that would lead to a clear shot position.\n## Checks perpendicular directions to the player and returns the first one\n## that would allow the bullet spawn point to be clear.\n## Returns Vector2.ZERO if no clear direction is found.\nfunc _find_sidestep_direction_for_clear_shot(direction_to_player: Vector2) -> Vector2:\n\t# Fail-safe: allow normal behavior if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn Vector2.ZERO\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn Vector2.ZERO\n\n\t# Check perpendicular directions (left and right of the player direction)\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Check both sidestep directions and pick the one that leads to clear shot faster\n\tvar check_distance := 50.0  # Check if moving 50 pixels in this direction would help\n\tvar bullet_check_distance := bullet_spawn_offset + 5.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:  # Try both sides\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\n\t\t# First check if we can actually move in this direction (no wall blocking movement)\n\t\tvar move_query := PhysicsRayQueryParameters2D.new()\n\t\tmove_query.from = global_position\n\t\tmove_query.to = global_position + sidestep_dir * 30.0\n\t\tmove_query.collision_mask = 4  # Only check obstacles\n\t\tmove_query.exclude = [get_rid()]\n\n\t\tvar move_result := space_state.intersect_ray(move_query)\n\t\tif not move_result.is_empty():\n\t\t\tcontinue  # Can't move this way, wall is blocking\n\n\t\t# Check if after sidestepping, we'd have a clear shot\n\t\tvar test_position: Vector2 = global_position + sidestep_dir * check_distance\n\t\tvar shot_query := PhysicsRayQueryParameters2D.new()\n\t\tshot_query.from = test_position\n\t\tshot_query.to = test_position + direction_to_player * bullet_check_distance\n\t\tshot_query.collision_mask = 4\n\t\tshot_query.exclude = [get_rid()]\n\n\t\tvar shot_result := space_state.intersect_ray(shot_query)\n\t\tif shot_result.is_empty():\n\t\t\t# Found a direction that leads to a clear shot\n\t\t\t_log_debug(\"Found sidestep direction: %s\" % sidestep_dir)\n\t\t\treturn sidestep_dir\n\n\treturn Vector2.ZERO  # No clear sidestep direction found\n\n\n## Check if the enemy should shoot at the current target.\n## Validates bullet spawn clearance, friendly fire avoidance, and cover blocking.\nfunc _should_shoot_at_target(target_position: Vector2) -> bool:\n\t# Check if the immediate path to bullet spawn is clear\n\t# This prevents shooting into walls the enemy is flush against\n\tvar direction := (target_position - global_position).normalized()\n\tif not _is_bullet_spawn_clear(direction):\n\t\treturn false\n\n\t# Check if friendlies are in the way\n\tif not _is_firing_line_clear_of_friendlies(target_position):\n\t\treturn false\n\n\t# Check if cover blocks the shot\n\tif not _is_shot_clear_of_cover(target_position):\n\t\treturn false\n\n\treturn true\n\n\n## Check if the player is \"close\" (within CLOSE_COMBAT_DISTANCE).\n## Used to determine if the enemy should engage directly or pursue.\nfunc _is_player_close() -> bool:\n\tif _player == null:\n\t\treturn false\n\treturn global_position.distance_to(_player.global_position) <= CLOSE_COMBAT_DISTANCE\n\n\n## Check if the enemy can hit the player from their current position.\n## Returns true if there's a clear line of fire to the player.\nfunc _can_hit_player_from_current_position() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check if we can see the player\n\tif not _can_see_player:\n\t\treturn false\n\n\t# Check if the shot would be blocked by cover\n\treturn _is_shot_clear_of_cover(_player.global_position)\n\n\n## Count the number of enemies currently in combat-related states.\n## Includes COMBAT, PURSUING, ASSAULT, IN_COVER (if can see player).\n## Used to determine if multi-enemy assault should be triggered.\nfunc _count_enemies_in_combat() -> int:\n\tvar count := 0\n\tvar enemies := get_tree().get_nodes_in_group(\"enemies\")\n\n\tfor enemy in enemies:\n\t\tif enemy == self:\n\t\t\tcontinue\n\t\tif not enemy.has_method(\"get_current_state\"):\n\t\t\tcontinue\n\n\t\tvar state: AIState = enemy.get_current_state()\n\t\t# Count enemies in combat-related states\n\t\tif state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\t\t# For IN_COVER, only count if they can see the player\n\t\t\tif state == AIState.IN_COVER:\n\t\t\t\tif enemy.has_method(\"is_in_combat_engagement\") and enemy.is_in_combat_engagement():\n\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tcount += 1\n\n\t# Count self if in a combat-related state\n\tif _current_state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\tcount += 1\n\n\treturn count\n\n\n## Check if this enemy is engaged in combat (can see player and in combat state).\nfunc is_in_combat_engagement() -> bool:\n\treturn _can_see_player and _current_state in [AIState.COMBAT, AIState.IN_COVER, AIState.ASSAULT]\n\n\n## Find cover position closer to the player for pursuit.\n## Used during PURSUING state to move cover-to-cover toward the player.\nfunc _find_pursuit_cover_toward_player() -> void:\n\tif _player == null:\n\t\t_has_pursuit_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For pursuit, we want cover that is:\n\t\t\t# 1. Closer to the player than we currently are\n\t\t\t# 2. Hidden from the player (or mostly hidden)\n\t\t\t# 3. Not too far from our current position\n\n\t\t\tvar my_distance_to_player := global_position.distance_to(player_pos)\n\t\t\tvar cover_distance_to_player := cover_pos.distance_to(player_pos)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to player\n\t\t\tif cover_distance_to_player >= my_distance_to_player:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if this position is hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Hidden from player (priority)\n\t\t\t# - Closer to player\n\t\t\t# - Not too far from current position\n\t\t\tvar hidden_score: float = 5.0 if is_hidden else 0.0\n\t\t\tvar approach_score: float = (my_distance_to_player - cover_distance_to_player) / CLOSE_COMBAT_DISTANCE\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = hidden_score + approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_pursuit_next_cover = best_cover\n\t\t_has_pursuit_cover = true\n\t\t_log_debug(\"Found pursuit cover at %s (score: %.2f)\" % [_pursuit_next_cover, best_score])\n\telse:\n\t\t_has_pursuit_cover = false\n\n\n## Find cover position closest to the player for assault positioning.\n## Used during ASSAULT state to take the nearest safe cover to the player.\nfunc _find_cover_closest_to_player() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_distance: float = INF\n\tvar found_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# Check if this position is hidden from player (safe cover)\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\tif is_hidden:\n\t\t\t\t# Calculate distance from this cover to the player\n\t\t\t\tvar distance_to_player := cover_pos.distance_to(player_pos)\n\n\t\t\t\t# We want the cover closest to the player\n\t\t\t\tif distance_to_player < best_distance:\n\t\t\t\t\tbest_distance = distance_to_player\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\t\tfound_cover = true\n\n\tif found_cover:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found assault cover at %s (distance to player: %.1f)\" % [_cover_position, best_distance])\n\telse:\n\t\t# Fall back to normal cover finding\n\t\t_find_cover_position()\n\n\n## Find a valid cover position relative to the player.\n## The cover position must be hidden from the player's line of sight.\nfunc _find_cover_position() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_hidden_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is on the opposite side of the obstacle from player\n\t\t\tvar direction_from_player := (collision_point - player_pos).normalized()\n\n\t\t\t# Position behind cover (offset from collision point along normal)\n\t\t\t# Offset must be large enough to hide the entire enemy body (radius ~24 pixels)\n\t\t\t# Using 35 pixels to provide some margin for the enemy's collision shape\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# First priority: Check if this position is actually hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Only consider hidden positions unless we have no choice\n\t\t\tif is_hidden or not found_hidden_cover:\n\t\t\t\t# Score based on:\n\t\t\t\t# 1. Whether position is hidden (highest priority)\n\t\t\t\t# 2. Distance from enemy (closer is better)\n\t\t\t\t# 3. Position relative to player (behind cover from player's view)\n\t\t\t\tvar hidden_score: float = 10.0 if is_hidden else 0.0  # Heavy weight for hidden positions\n\n\t\t\t\tvar distance_score := 1.0 - (global_position.distance_to(cover_pos) / COVER_CHECK_DISTANCE)\n\n\t\t\t\t# Check if this position is on the far side of obstacle from player\n\t\t\t\tvar cover_direction := (cover_pos - player_pos).normalized()\n\t\t\t\tvar dot_product := direction_from_player.dot(cover_direction)\n\t\t\t\tvar blocking_score: float = maxf(0.0, dot_product)\n\n\t\t\t\tvar total_score: float = hidden_score + distance_score * 0.3 + blocking_score * 0.7\n\n\t\t\t\t# If we find a hidden position, only accept other hidden positions\n\t\t\t\tif is_hidden and not found_hidden_cover:\n\t\t\t\t\tfound_hidden_cover = true\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\telif (is_hidden or not found_hidden_cover) and total_score > best_score:\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\n\tif best_score > 0:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found cover at: %s (hidden: %s)\" % [_cover_position, found_hidden_cover])\n\telse:\n\t\t_has_valid_cover = false\n\n\n## Calculate flank position based on player location.\nfunc _calculate_flank_position() -> void:\n\tif _player == null:\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar player_to_enemy := (global_position - player_pos).normalized()\n\n\t# Choose left or right flank based on current position\n\tvar flank_side := 1.0 if randf() > 0.5 else -1.0\n\tvar flank_direction := player_to_enemy.rotated(flank_angle * flank_side)\n\n\t_flank_target = player_pos + flank_direction * flank_distance\n\t_log_debug(\"Flank target: %s\" % _flank_target)\n\n\n## Check if there's a clear path (no obstacles) to the target position.\n## Uses a raycast to check for walls/obstacles between current position and target.\nfunc _has_clear_path_to(target: Vector2) -> bool:\n\tif _raycast == null:\n\t\treturn true  # Assume clear if no raycast available\n\n\tvar direction := (target - global_position).normalized()\n\tvar distance := global_position.distance_to(target)\n\n\t_raycast.target_position = direction * distance\n\t_raycast.force_raycast_update()\n\n\t# If we hit something, path is blocked\n\tif _raycast.is_colliding():\n\t\tvar collision_point := _raycast.get_collision_point()\n\t\tvar collision_distance := global_position.distance_to(collision_point)\n\t\t# Only consider it blocked if the collision is before the target\n\t\treturn collision_distance >= distance - 10.0\n\n\treturn true\n\n\n## Find cover position closer to the flank target.\n## Used during FLANKING state to move cover-to-cover toward the flank position.\nfunc _find_flank_cover_toward_target() -> void:\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For flanking, we want cover that is:\n\t\t\t# 1. Closer to the flank target than we currently are\n\t\t\t# 2. Not too far from our current position\n\t\t\t# 3. Reachable (has clear path)\n\n\t\t\tvar my_distance_to_target := global_position.distance_to(_flank_target)\n\t\t\tvar cover_distance_to_target := cover_pos.distance_to(_flank_target)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to flank target\n\t\t\tif cover_distance_to_target >= my_distance_to_target:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if we can reach this cover (has clear path)\n\t\t\tif not _has_clear_path_to(cover_pos):\n\t\t\t\t# Even if direct path is blocked, we might be able to reach\n\t\t\t\t# via another intermediate cover, but skip for now\n\t\t\t\tcontinue\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Closer to flank target (priority)\n\t\t\t# - Not too far from current position\n\t\t\tvar approach_score: float = (my_distance_to_target - cover_distance_to_target) / flank_distance\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_flank_next_cover = best_cover\n\t\t_has_flank_cover = true\n\t\t_log_debug(\"Found flank cover at %s (score: %.2f)\" % [_flank_next_cover, best_score])\n\telse:\n\t\t_has_flank_cover = false\n\n\n## Check if there's a wall ahead in the given direction and return avoidance direction.\n## Returns Vector2.ZERO if no wall detected, otherwise returns a vector to avoid the wall.\nfunc _check_wall_ahead(direction: Vector2) -> Vector2:\n\tif _wall_raycasts.is_empty():\n\t\treturn Vector2.ZERO\n\n\tvar avoidance := Vector2.ZERO\n\tvar perpendicular := Vector2(-direction.y, direction.x)  # 90 degrees rotation\n\n\t# Check center, left, and right raycasts\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar angle_offset := (i - 1) * 0.5  # -0.5, 0, 0.5 radians (~-28, 0, 28 degrees)\n\t\tvar check_direction := direction.rotated(angle_offset)\n\n\t\tvar raycast := _wall_raycasts[i]\n\t\traycast.target_position = check_direction * WALL_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\t# Calculate avoidance based on which raycast hit\n\t\t\tif i == 0:  # Left raycast hit\n\t\t\t\tavoidance += perpendicular  # Steer right\n\t\t\telif i == 1:  # Center raycast hit\n\t\t\t\tavoidance += perpendicular if randf() > 0.5 else -perpendicular  # Random steer\n\t\t\telif i == 2:  # Right raycast hit\n\t\t\t\tavoidance -= perpendicular  # Steer left\n\n\treturn avoidance.normalized() if avoidance.length() > 0 else Vector2.ZERO\n\n\n## Check if the player is visible using raycast.\n## If detection_range is 0 or negative, uses unlimited detection range (line-of-sight only).\n## This allows the enemy to see the player even outside the viewport if there's no obstacle.\n## Also updates the continuous visibility timer and visibility ratio for lead prediction control.\nfunc _check_player_visibility() -> void:\n\tvar was_visible := _can_see_player\n\t_can_see_player = false\n\t_player_visibility_ratio = 0.0\n\n\tif _player == null or not _raycast:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t# Check if player is within detection range (only if detection_range is positive)\n\t# If detection_range <= 0, detection is unlimited (line-of-sight only)\n\tif detection_range > 0 and distance_to_player > detection_range:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\t# Point raycast at player - use actual distance to player for the raycast length\n\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\tvar raycast_length := distance_to_player + 10.0  # Add small buffer to ensure we reach player\n\t_raycast.target_position = direction_to_player * raycast_length\n\t_raycast.force_raycast_update()\n\n\t# Check if raycast hit something\n\tif _raycast.is_colliding():\n\t\tvar collider := _raycast.get_collider()\n\t\t# If we hit the player, we can see them\n\t\tif collider == _player:\n\t\t\t_can_see_player = true\n\t\t# If we hit a wall/obstacle before the player, we can't see them\n\telse:\n\t\t# No collision between us and player - we have clear line of sight\n\t\t_can_see_player = true\n\n\t# Update continuous visibility timer and visibility ratio\n\tif _can_see_player:\n\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n\t\t# Calculate what fraction of the player's body is visible\n\t\t# This is used to determine if lead prediction should be enabled\n\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n\telse:\n\t\t# Lost line of sight - reset the timer and visibility ratio\n\t\t_continuous_visibility_timer = 0.0\n\t\t_player_visibility_ratio = 0.0\n\n\n## Aim the enemy sprite/direction at the player using gradual rotation.\nfunc _aim_at_player() -> void:\n\tif _player == null:\n\t\treturn\n\tvar direction := (_player.global_position - global_position).normalized()\n\tvar target_angle := direction.angle()\n\n\t# Calculate the shortest rotation direction\n\tvar angle_diff := wrapf(target_angle - rotation, -PI, PI)\n\n\t# Get the delta time from the current physics process\n\tvar delta := get_physics_process_delta_time()\n\n\t# Apply gradual rotation based on rotation_speed\n\tif abs(angle_diff) <= rotation_speed * delta:\n\t\t# Close enough to snap to target\n\t\trotation = target_angle\n\telif angle_diff > 0:\n\t\trotation += rotation_speed * delta\n\telse:\n\t\trotation -= rotation_speed * delta\n\n\n## Shoot a bullet towards the player.\nfunc _shoot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\t# Check if we can shoot (have ammo and not reloading)\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Apply lead prediction if enabled\n\tif enable_lead_prediction:\n\t\ttarget_position = _calculate_lead_prediction()\n\n\t# Check if the shot should be taken (friendly fire and cover checks)\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Create bullet instance\n\tvar bullet := bullet_scene.instantiate()\n\n\t# Set bullet position with offset in shoot direction\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\n\t# Set bullet direction\n\tbullet.direction = direction\n\n\t# Set shooter ID to identify this enemy as the source\n\t# This prevents enemies from detecting their own bullets in the threat sphere\n\tbullet.shooter_id = get_instance_id()\n\n\t# Add bullet to the scene tree\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play shooting sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\n\t# Play shell casing sound with a small delay\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\t# Auto-reload when magazine is empty\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Play shell casing sound with a delay to simulate the casing hitting the ground.\nfunc _play_delayed_shell_sound() -> void:\n\tawait get_tree().create_timer(0.15).timeout\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_shell_rifle\"):\n\t\taudio_manager.play_shell_rifle(global_position)\n\n\n## Calculate lead prediction - aims where the player will be, not where they are.\n## Uses iterative approach for better accuracy with moving targets.\n## Only applies lead prediction if:\n## 1. The player has been continuously visible for at least lead_prediction_delay seconds\n## 2. At least lead_prediction_visibility_threshold of the player's body is visible\n## 3. The predicted position is also visible to the enemy (not behind cover)\n## This prevents enemies from \"knowing\" where the player will emerge from cover.\nfunc _calculate_lead_prediction() -> Vector2:\n\tif _player == null:\n\t\treturn global_position\n\n\tvar player_pos := _player.global_position\n\n\t# Only use lead prediction if the player has been continuously visible\n\t# for long enough. This prevents enemies from predicting player position\n\t# immediately when they emerge from cover.\n\tif _continuous_visibility_timer < lead_prediction_delay:\n\t\t_log_debug(\"Lead prediction disabled: visibility time %.2fs < %.2fs required\" % [_continuous_visibility_timer, lead_prediction_delay])\n\t\treturn player_pos\n\n\t# Only use lead prediction if enough of the player's body is visible.\n\t# This prevents pre-firing when the player is at the edge of cover with only\n\t# a small part of their body visible. The player must be significantly exposed\n\t# before the enemy can predict their movement.\n\tif _player_visibility_ratio < lead_prediction_visibility_threshold:\n\t\t_log_debug(\"Lead prediction disabled: visibility ratio %.2f < %.2f required (player at cover edge)\" % [_player_visibility_ratio, lead_prediction_visibility_threshold])\n\t\treturn player_pos\n\n\tvar player_velocity := Vector2.ZERO\n\n\t# Get player velocity if they are a CharacterBody2D\n\tif _player is CharacterBody2D:\n\t\tplayer_velocity = _player.velocity\n\n\t# If player is stationary, no need for prediction\n\tif player_velocity.length_squared() < 1.0:\n\t\treturn player_pos\n\n\t# Iterative lead prediction for better accuracy\n\t# Start with player's current position\n\tvar predicted_pos := player_pos\n\tvar distance := global_position.distance_to(predicted_pos)\n\n\t# Iterate 2-3 times for convergence\n\tfor i in range(3):\n\t\t# Time for bullet to reach the predicted position\n\t\tvar time_to_target := distance / bullet_speed\n\n\t\t# Predict where player will be at that time\n\t\tpredicted_pos = player_pos + player_velocity * time_to_target\n\n\t\t# Update distance for next iteration\n\t\tdistance = global_position.distance_to(predicted_pos)\n\n\t# CRITICAL: Validate that the predicted position is actually visible to the enemy.\n\t# If the predicted position is behind cover (e.g., player is running toward cover exit),\n\t# we should NOT aim there - it would feel like the enemy is \"cheating\" by knowing\n\t# where the player will emerge. Fall back to player's current visible position.\n\tif not _is_position_visible_to_enemy(predicted_pos):\n\t\t_log_debug(\"Lead prediction blocked: predicted position %s is not visible, using current position %s\" % [predicted_pos, player_pos])\n\t\treturn player_pos\n\n\t_log_debug(\"Lead prediction: player at %s moving %s, aiming at %s\" % [player_pos, player_velocity, predicted_pos])\n\n\treturn predicted_pos\n\n\n## Process patrol behavior - move between patrol points.\nfunc _process_patrol(delta: float) -> void:\n\tif _patrol_points.is_empty():\n\t\treturn\n\n\t# Handle waiting at patrol point\n\tif _is_waiting_at_patrol_point:\n\t\t_patrol_wait_timer += delta\n\t\tif _patrol_wait_timer >= patrol_wait_time:\n\t\t\t_is_waiting_at_patrol_point = false\n\t\t\t_patrol_wait_timer = 0.0\n\t\t\t_current_patrol_index = (_current_patrol_index + 1) % _patrol_points.size()\n\t\tvelocity = Vector2.ZERO\n\t\treturn\n\n\t# Move towards current patrol point\n\tvar target_point := _patrol_points[_current_patrol_index]\n\tvar direction := (target_point - global_position).normalized()\n\tvar distance := global_position.distance_to(target_point)\n\n\tif distance < 5.0:\n\t\t# Reached patrol point, start waiting\n\t\t_is_waiting_at_patrol_point = true\n\t\tvelocity = Vector2.ZERO\n\telse:\n\t\t# Check for walls and apply avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\t# Blend movement direction with avoidance\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * move_speed\n\t\t# Face movement direction when patrolling\n\t\trotation = direction.angle()\n\n\n## Process guard behavior - stand still and look around.\nfunc _process_guard(_delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\t# In guard mode, enemy doesn't move but can still aim at player when visible\n\n\n## Called when a bullet enters the threat sphere.\nfunc _on_threat_area_entered(area: Area2D) -> void:\n\t# Check if bullet has shooter_id property and if it's from this enemy\n\t# This prevents enemies from being suppressed by their own bullets\n\tif \"shooter_id\" in area and area.shooter_id == get_instance_id():\n\t\treturn  # Ignore own bullets\n\n\t_bullets_in_threat_sphere.append(area)\n\t# Set threat memory timer so enemy can react even after fast bullets exit\n\t# This allows the reaction delay to complete even if bullets pass through quickly\n\t_threat_memory_timer = THREAT_MEMORY_DURATION\n\t# Note: _under_fire is now set in _update_suppression after threat_reaction_delay\n\t# This gives the player more time before the enemy reacts to nearby gunfire\n\t_log_debug(\"Bullet entered threat sphere, starting reaction delay...\")\n\n\n## Called when a bullet exits the threat sphere.\nfunc _on_threat_area_exited(area: Area2D) -> void:\n\t_bullets_in_threat_sphere.erase(area)\n\n\n## Called when the enemy is hit (by bullet.gd).\nfunc on_hit() -> void:\n\tif not _is_alive:\n\t\treturn\n\n\thit.emit()\n\n\t# Track hits for retreat behavior\n\t_hits_taken_in_encounter += 1\n\t_log_debug(\"Hit taken! Total hits in encounter: %d\" % _hits_taken_in_encounter)\n\t_log_to_file(\"Hit taken, health: %d/%d\" % [_current_health - 1, _max_health])\n\n\t# Show hit flash effect\n\t_show_hit_flash()\n\n\t# Apply damage\n\t_current_health -= 1\n\n\t# Play appropriate hit sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif _current_health <= 0:\n\t\t# Play lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_lethal\"):\n\t\t\taudio_manager.play_hit_lethal(global_position)\n\t\t_on_death()\n\telse:\n\t\t# Play non-lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_non_lethal\"):\n\t\t\taudio_manager.play_hit_non_lethal(global_position)\n\t\t_update_health_visual()\n\n\n## Shows a brief flash effect when hit.\nfunc _show_hit_flash() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t_sprite.modulate = hit_flash_color\n\n\tawait get_tree().create_timer(hit_flash_duration).timeout\n\n\t# Restore color based on current health (if still alive)\n\tif _is_alive:\n\t\t_update_health_visual()\n\n\n## Updates the sprite color based on current health percentage.\nfunc _update_health_visual() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t# Interpolate color based on health percentage\n\tvar health_percent := _get_health_percent()\n\t_sprite.modulate = full_health_color.lerp(low_health_color, 1.0 - health_percent)\n\n\n## Returns the current health as a percentage (0.0 to 1.0).\nfunc _get_health_percent() -> float:\n\tif _max_health <= 0:\n\t\treturn 0.0\n\treturn float(_current_health) / float(_max_health)\n\n\n## Called when the enemy dies.\nfunc _on_death() -> void:\n\t_is_alive = false\n\t_log_to_file(\"Enemy died\")\n\tdied.emit()\n\n\tif destroy_on_death:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\tqueue_free()\n\telse:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\t_reset()\n\n\n## Resets the enemy to its initial state.\nfunc _reset() -> void:\n\tglobal_position = _initial_position\n\trotation = 0.0\n\t_current_patrol_index = 0\n\t_is_waiting_at_patrol_point = false\n\t_patrol_wait_timer = 0.0\n\t_current_state = AIState.IDLE\n\t_has_valid_cover = false\n\t_under_fire = false\n\t_suppression_timer = 0.0\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t_continuous_visibility_timer = 0.0\n\t_player_visibility_ratio = 0.0\n\t_threat_reaction_timer = 0.0\n\t_threat_reaction_delay_elapsed = false\n\t_threat_memory_timer = 0.0\n\t_bullets_in_threat_sphere.clear()\n\t# Reset retreat state variables\n\t_hits_taken_in_encounter = 0\n\t_retreat_mode = RetreatMode.FULL_HP\n\t_retreat_turn_timer = 0.0\n\t_retreat_turning_to_cover = false\n\t_retreat_burst_remaining = 0\n\t_retreat_burst_timer = 0.0\n\t_retreat_burst_complete = false\n\t_retreat_burst_angle_offset = 0.0\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\t# Reset combat state variables\n\t_combat_shoot_timer = 0.0\n\t_combat_shoot_duration = 2.5\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_approach_timer = 0.0\n\t# Reset pursuit state variables\n\t_pursuit_cover_wait_timer = 0.0\n\t_pursuit_next_cover = Vector2.ZERO\n\t_has_pursuit_cover = false\n\t# Reset assault state variables\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset flank state variables\n\t_flank_cover_wait_timer = 0.0\n\t_flank_next_cover = Vector2.ZERO\n\t_has_flank_cover = false\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_initialize_goap_state()\n\n\n## Log debug message if debug_logging is enabled.\nfunc _log_debug(message: String) -> void:\n\tif debug_logging:\n\t\tprint(\"[Enemy %s] %s\" % [name, message])\n\n\n## Log a message to the file logger (always logs, regardless of debug_logging setting).\n## Use for important events like spawning, dying, or critical state changes.\nfunc _log_to_file(message: String) -> void:\n\tif not is_inside_tree():\n\t\treturn\n\tvar file_logger: Node = get_node_or_null(\"/root/FileLogger\")\n\tif file_logger and file_logger.has_method(\"log_enemy\"):\n\t\tfile_logger.log_enemy(name, message)\n\n\n## Log spawn info (called via call_deferred to ensure FileLogger is loaded).\nfunc _log_spawn_info() -> void:\n\t_log_to_file(\"Enemy spawned at %s, health: %d, behavior: %s, player_found: %s\" % [\n\t\tglobal_position, _max_health, BehaviorMode.keys()[behavior_mode],\n\t\t\"yes\" if _player != null else \"no\"])\n\n\n## Get AI state name as a human-readable string.\nfunc _get_state_name(state: AIState) -> String:\n\tmatch state:\n\t\tAIState.IDLE:\n\t\t\treturn \"IDLE\"\n\t\tAIState.COMBAT:\n\t\t\treturn \"COMBAT\"\n\t\tAIState.SEEKING_COVER:\n\t\t\treturn \"SEEKING_COVER\"\n\t\tAIState.IN_COVER:\n\t\t\treturn \"IN_COVER\"\n\t\tAIState.FLANKING:\n\t\t\treturn \"FLANKING\"\n\t\tAIState.SUPPRESSED:\n\t\t\treturn \"SUPPRESSED\"\n\t\tAIState.RETREATING:\n\t\t\treturn \"RETREATING\"\n\t\tAIState.PURSUING:\n\t\t\treturn \"PURSUING\"\n\t\tAIState.ASSAULT:\n\t\t\treturn \"ASSAULT\"\n\t\t_:\n\t\t\treturn \"UNKNOWN\"\n\n\n## Update the debug label with current AI state.\nfunc _update_debug_label() -> void:\n\tif _debug_label == null:\n\t\treturn\n\n\t_debug_label.visible = debug_label_enabled\n\tif not debug_label_enabled:\n\t\treturn\n\n\tvar state_text := _get_state_name(_current_state)\n\n\t# Add retreat mode info if retreating\n\tif _current_state == AIState.RETREATING:\n\t\tmatch _retreat_mode:\n\t\t\tRetreatMode.FULL_HP:\n\t\t\t\tstate_text += \"\\n(FULL_HP)\"\n\t\t\tRetreatMode.ONE_HIT:\n\t\t\t\tstate_text += \"\\n(ONE_HIT)\"\n\t\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t\tstate_text += \"\\n(MULTI_HITS)\"\n\n\t# Add assault timer info if in assault state\n\tif _current_state == AIState.ASSAULT:\n\t\tif _assault_ready:\n\t\t\tstate_text += \"\\n(RUSHING)\"\n\t\telse:\n\t\t\tvar time_left := ASSAULT_WAIT_DURATION - _assault_wait_timer\n\t\t\tstate_text += \"\\n(%.1fs)\" % time_left\n\n\t# Add combat phase info if in combat\n\tif _current_state == AIState.COMBAT:\n\t\tif _combat_exposed:\n\t\t\tvar time_left := _combat_shoot_duration - _combat_shoot_timer\n\t\t\tstate_text += \"\\n(EXPOSED %.1fs)\" % time_left\n\t\telif _seeking_clear_shot:\n\t\t\tvar time_left := CLEAR_SHOT_MAX_TIME - _clear_shot_timer\n\t\t\tstate_text += \"\\n(SEEK SHOT %.1fs)\" % time_left\n\t\telif _combat_approaching:\n\t\t\tstate_text += \"\\n(APPROACH)\"\n\n\t# Add pursuit timer info if pursuing and waiting at cover\n\tif _current_state == AIState.PURSUING:\n\t\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t\tvar time_left := PURSUIT_COVER_WAIT_DURATION - _pursuit_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_pursuit_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\n\t# Add flanking phase info if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_valid_cover and not _has_flank_cover:\n\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_flank_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\t\telse:\n\t\t\tstate_text += \"\\n(DIRECT)\"\n\n\t_debug_label.text = state_text\n\n\n## Get current AI state (for external access/debugging).\nfunc get_current_state() -> AIState:\n\treturn _current_state\n\n\n## Get GOAP world state (for GOAP planner).\nfunc get_goap_world_state() -> Dictionary:\n\treturn _goap_world_state.duplicate()\n\n\n## Check if enemy is currently under fire
[2026-01-18T02:52:37.759Z] [INFO] .\nfunc is_under_fire() -> bool:\n\treturn _under_fire\n\n\n## Check if enemy is in cover.\nfunc is_in_cover() -> bool:\n\treturn _current_state == AIState.IN_COVER or _current_state == AIState.SUPPRESSED\n\n\n## Get current ammo in magazine.\nfunc get_current_ammo() -> int:\n\treturn _current_ammo\n\n\n## Get reserve ammo.\nfunc get_reserve_ammo() -> int:\n\treturn _reserve_ammo\n\n\n## Get total ammo (current + reserve).\nfunc get_total_ammo() -> int:\n\treturn _current_ammo + _reserve_ammo\n\n\n## Check if enemy is currently reloading.\nfunc is_reloading() -> bool:\n\treturn _is_reloading\n\n\n## Check if enemy has any ammo left.\nfunc has_ammo() -> bool:\n\treturn _current_ammo > 0 or _reserve_ammo > 0\n\n\n## Get current player visibility ratio (for debugging).\n## Returns 0.0 if player is completely hidden, 1.0 if fully visible.\nfunc get_player_visibility_ratio() -> float:\n\treturn _player_visibility_ratio\n\n\n## Draw debug visualization when debug mode is enabled.\n## Shows: line to target (cover, clear shot, player), bullet spawn point status.\nfunc _draw() -> void:\n\tif not debug_label_enabled:\n\t\treturn\n\n\t# Colors for different debug elements\n\tvar color_to_cover := Color.CYAN  # Line to cover position\n\tvar color_to_player := Color.RED  # Line to player (when visible)\n\tvar color_clear_shot := Color.YELLOW  # Line to clear shot target\n\tvar color_pursuit := Color.ORANGE  # Line to pursuit cover\n\tvar color_flank := Color.MAGENTA  # Line to flank position\n\tvar color_bullet_spawn := Color.GREEN  # Bullet spawn point indicator\n\tvar color_blocked := Color.RED  # Blocked path indicator\n\n\t# Draw line to player if visible\n\tif _can_see_player and _player:\n\t\tvar to_player := _player.global_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_player, color_to_player, 1.5)\n\n\t\t# Draw bullet spawn point and check if blocked\n\t\tvar direction_to_player := to_player.normalized()\n\t\tvar spawn_point := direction_to_player * bullet_spawn_offset\n\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\tdraw_circle(spawn_point, 5.0, color_bullet_spawn)\n\t\telse:\n\t\t\t# Draw X for blocked spawn point\n\t\t\tdraw_line(spawn_point + Vector2(-5, -5), spawn_point + Vector2(5, 5), color_blocked, 2.0)\n\t\t\tdraw_line(spawn_point + Vector2(-5, 5), spawn_point + Vector2(5, -5), color_blocked, 2.0)\n\n\t# Draw line to cover position if we have one\n\tif _has_valid_cover:\n\t\tvar to_cover := _cover_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_cover, color_to_cover, 1.5)\n\t\t# Draw small circle at cover position\n\t\tdraw_circle(to_cover, 8.0, color_to_cover)\n\n\t# Draw line to clear shot target if seeking clear shot\n\tif _seeking_clear_shot and _clear_shot_target != Vector2.ZERO:\n\t\tvar to_target := _clear_shot_target - global_position\n\t\tdraw_line(Vector2.ZERO, to_target, color_clear_shot, 2.0)\n\t\t# Draw triangle at target position\n\t\tvar target_pos := to_target\n\t\tdraw_line(target_pos + Vector2(-6, 6), target_pos + Vector2(6, 6), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(6, 6), target_pos + Vector2(0, -8), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(0, -8), target_pos + Vector2(-6, 6), color_clear_shot, 2.0)\n\n\t# Draw line to pursuit cover if pursuing\n\tif _current_state == AIState.PURSUING and _has_pursuit_cover:\n\t\tvar to_pursuit := _pursuit_next_cover - global_position\n\t\tdraw_line(Vector2.ZERO, to_pursuit, color_pursuit, 2.0)\n\t\tdraw_circle(to_pursuit, 8.0, color_pursuit)\n\n\t# Draw line to flank target if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_flank_cover:\n\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n\t\telif _flank_target != Vector2.ZERO:\n\t\t\tvar to_flank := _flank_target - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n\t\t\t# Draw diamond at flank target\n\t\t\tvar flank_pos := to_flank\n\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)\n","structuredPatch":[{"oldStart":671,"oldLines":6,"newStart":671,"newLines":10,"lines":["   _goap_world_state[\"player_close\"] = _is_player_close()","   _goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()","   _goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()","+  _goap_world_state[\"has_search_zone\"] = _search_zone_active","+  _goap_world_state[\"search_zone_cleared\"] = not _search_zone_active and _last_known_player_position != Vector2.ZERO","+  _goap_world_state[\"inspection_points_remaining\"] = _inspection_points.size() - _current_inspection_index","+  _goap_world_state[\"is_searching\"] = _current_state == AIState.SEARCHING"," "," "," ## Update suppression state."]}],"userModified":false,"replaceAll":false}}
[2026-01-18T02:52:40.096Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01BiySFhtky495UwM3pJKyNx",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now update the state machine to include the SEARCHING state:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 1520,
      "cache_read_input_tokens": 109809,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1520,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 4,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "ff4c5a75-28a8-446b-aa5d-1b01975d825c"
}
[2026-01-18T02:52:44.964Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01BiySFhtky495UwM3pJKyNx",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_012Ay6wgvc4aTFqokCaWNWk1",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "old_string": "## Process the AI state machine.\nfunc _process_ai_state(delta: float) -> void:\n\tvar previous_state := _current_state\n\n\t# State transitions based on conditions\n\tmatch _current_state:\n\t\tAIState.IDLE:\n\t\t\t_process_idle_state(delta)\n\t\tAIState.COMBAT:\n\t\t\t_process_combat_state(delta)\n\t\tAIState.SEEKING_COVER:\n\t\t\t_process_seeking_cover_state(delta)\n\t\tAIState.IN_COVER:\n\t\t\t_process_in_cover_state(delta)\n\t\tAIState.FLANKING:\n\t\t\t_process_flanking_state(delta)\n\t\tAIState.SUPPRESSED:\n\t\t\t_process_suppressed_state(delta)\n\t\tAIState.RETREATING:\n\t\t\t_process_retreating_state(delta)\n\t\tAIState.PURSUING:\n\t\t\t_process_pursuing_state(delta)\n\t\tAIState.ASSAULT:\n\t\t\t_process_assault_state(delta)",
          "new_string": "## Process the AI state machine.\nfunc _process_ai_state(delta: float) -> void:\n\tvar previous_state := _current_state\n\n\t# State transitions based on conditions\n\tmatch _current_state:\n\t\tAIState.IDLE:\n\t\t\t_process_idle_state(delta)\n\t\tAIState.COMBAT:\n\t\t\t_process_combat_state(delta)\n\t\tAIState.SEEKING_COVER:\n\t\t\t_process_seeking_cover_state(delta)\n\t\tAIState.IN_COVER:\n\t\t\t_process_in_cover_state(delta)\n\t\tAIState.FLANKING:\n\t\t\t_process_flanking_state(delta)\n\t\tAIState.SUPPRESSED:\n\t\t\t_process_suppressed_state(delta)\n\t\tAIState.RETREATING:\n\t\t\t_process_retreating_state(delta)\n\t\tAIState.PURSUING:\n\t\t\t_process_pursuing_state(delta)\n\t\tAIState.ASSAULT:\n\t\t\t_process_assault_state(delta)\n\t\tAIState.SEARCHING:\n\t\t\t_process_searching_state(delta)"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 1520,
      "cache_read_input_tokens": 109809,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1520,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 4,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "b39f5c5d-ea0c-4800-b064-543675be497d"
}
[2026-01-18T02:52:45.011Z] [INFO] {"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012Ay6wgvc4aTFqokCaWNWk1","type":"tool_result","content":"The file /tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   773‚Üí\n   774‚Üí\treturn true\n   775‚Üí\n   776‚Üí\n   777‚Üí## Process the AI state machine.\n   778‚Üífunc _process_ai_state(delta: float) -> void:\n   779‚Üí\tvar previous_state := _current_state\n   780‚Üí\n   781‚Üí\t# State transitions based on conditions\n   782‚Üí\tmatch _current_state:\n   783‚Üí\t\tAIState.IDLE:\n   784‚Üí\t\t\t_process_idle_state(delta)\n   785‚Üí\t\tAIState.COMBAT:\n   786‚Üí\t\t\t_process_combat_state(delta)\n   787‚Üí\t\tAIState.SEEKING_COVER:\n   788‚Üí\t\t\t_process_seeking_cover_state(delta)\n   789‚Üí\t\tAIState.IN_COVER:\n   790‚Üí\t\t\t_process_in_cover_state(delta)\n   791‚Üí\t\tAIState.FLANKING:\n   792‚Üí\t\t\t_process_flanking_state(delta)\n   793‚Üí\t\tAIState.SUPPRESSED:\n   794‚Üí\t\t\t_process_suppressed_state(delta)\n   795‚Üí\t\tAIState.RETREATING:\n   796‚Üí\t\t\t_process_retreating_state(delta)\n   797‚Üí\t\tAIState.PURSUING:\n   798‚Üí\t\t\t_process_pursuing_state(delta)\n   799‚Üí\t\tAIState.ASSAULT:\n   800‚Üí\t\t\t_process_assault_state(delta)\n   801‚Üí\t\tAIState.SEARCHING:\n   802‚Üí\t\t\t_process_searching_state(delta)\n   803‚Üí\n   804‚Üí\tif previous_state != _current_state:\n   805‚Üí\t\tstate_changed.emit(_current_state)\n   806‚Üí\t\t_log_debug(\"State changed: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])"}]},"parent_tool_use_id":null,"session_id":"797fbac8-f5e6-4339-8fd2-77453410db49","uuid":"5648ec77-5b31-4934-9979-193cc579d237","tool_use_result":{"filePath":"/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd","oldString":"## Process the AI state machine.\nfunc _process_ai_state(delta: float) -> void:\n\tvar previous_state := _current_state\n\n\t# State transitions based on conditions\n\tmatch _current_state:\n\t\tAIState.IDLE:\n\t\t\t_p
[2026-01-18T02:52:45.016Z] [INFO] rocess_idle_state(delta)\n\t\tAIState.COMBAT:\n\t\t\t_process_combat_state(delta)\n\t\tAIState.SEEKING_COVER:\n\t\t\t_process_seeking_cover_state(delta)\n\t\tAIState.IN_COVER:\n\t\t\t_process_in_cover_state(delta)\n\t\tAIState.FLANKING:\n\t\t\t_process_flanking_state(delta)\n\t\tAIState.SUPPRESSED:\n\t\t\t_process_suppressed_state(delta)\n\t\tAIState.RETREATING:\n\t\t\t_process_retreating_state(delta)\n\t\tAIState.PURSUING:\n\t\t\t_process_pursuing_state(delta)\n\t\tAIState.ASSAULT:\n\t\t\t_process_assault_state(delta)","newString":"## Process the AI state machine.\nfunc _process_ai_state(delta: float) -> void:\n\tvar previous_state := _current_state\n\n\t# State transitions based on conditions\n\tmatch _current_state:\n\t\tAIState.IDLE:\n\t\t\t_process_idle_state(delta)\n\t\tAIState.COMBAT:\n\t\t\t_process_combat_state(delta)\n\t\tAIState.SEEKING_COVER:\n\t\t\t_process_seeking_cover_state(delta)\n\t\tAIState.IN_COVER:\n\t\t\t_process_in_cover_state(delta)\n\t\tAIState.FLANKING:\n\t\t\t_process_flanking_state(delta)\n\t\tAIState.SUPPRESSED:\n\t\t\t_process_suppressed_state(delta)\n\t\tAIState.RETREATING:\n\t\t\t_process_retreating_state(delta)\n\t\tAIState.PURSUING:\n\t\t\t_process_pursuing_state(delta)\n\t\tAIState.ASSAULT:\n\t\t\t_process_assault_state(delta)\n\t\tAIState.SEARCHING:\n\t\t\t_process_searching_state(delta)","originalFile":"extends CharacterBody2D\n## Enemy AI with tactical behaviors including patrol, guard, cover, and flanking.\n##\n## Supports multiple behavior modes:\n## - PATROL: Moves between patrol points\n## - GUARD: Stands in place watching for the player\n##\n## Tactical features:\n## - Uses cover when under fire (suppression)\n## - Attempts to flank the player from the sides\n## - Coordinates with other enemies (optional)\n## - GOAP foundation for goal-oriented planning\n\n## AI States for tactical behavior.\nenum AIState {\n\tIDLE,       ## Default idle state (patrol or guard)\n\tCOMBAT,     ## Actively engaging the player (coming out of cover, shooting 2-3s, returning)\n\tSEEKING_COVER,  ## Moving to cover position\n\tIN_COVER,   ## Taking cover from player fire\n\tFLANKING,   ## Attempting to flank the player\n\tSUPPRESSED, ## Under fire, staying in cover\n\tRETREATING, ## Retreating to cover while possibly shooting\n\tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n\tASSAULT,    ## Coordinated multi-enemy assault (rush player after 5s wait)\n\tSEARCHING   ## Searching for player at last-known-position zone\n}\n\n## Retreat behavior modes based on damage taken.\nenum RetreatMode {\n\tFULL_HP,        ## No damage - retreat backwards while shooting, periodically turn to cover\n\tONE_HIT,        ## One hit taken - quick burst then retreat without shooting\n\tMULTIPLE_HITS   ## Multiple hits - quick burst then retreat without shooting (same as ONE_HIT)\n}\n\n## Behavior modes for the enemy.\nenum BehaviorMode {\n\tPATROL,  ## Moves between patrol points\n\tGUARD    ## Stands in one place\n}\n\n## Current behavior mode.\n@export var behavior_mode: BehaviorMode = BehaviorMode.GUARD\n\n## Maximum movement speed in pixels per second.\n@export var move_speed: float = 220.0\n\n## Combat movement speed (faster when flanking/seeking cover).\n@export var combat_move_speed: float = 320.0\n\n## Rotation speed in radians per second for gradual turning.\n## Default is 15 rad/sec for challenging but fair combat.\n@export var rotation_speed: float = 15.0\n\n## Detection range for spotting the player.\n## Set to 0 or negative to allow unlimited detection range (line-of-sight only).\n## This allows enemies to see the player even outside the viewport if no obstacles block view.\n@export var detection_range: float = 0.0\n\n## Time between shots in seconds.\n## Default matches assault rifle fire rate (10 shots/second = 0.1s cooldown).\n@export var shoot_cooldown: float = 0.1\n\n## Bullet scene to instantiate when shooting.\n@export var bullet_scene: PackedScene\n\n## Offset from enemy center for bullet spawn position.\n@export var bullet_spawn_offset: float = 30.0\n\n## Patrol points as offsets from the initial position.\n## Only used when behavior_mode is PATROL.\n@export var patrol_offsets: Array[Vector2] = [Vector2(100, 0), Vector2(-100, 0)]\n\n## Wait time at each patrol point in seconds.\n@export var patrol_wait_time: float = 1.5\n\n## Color when at full health.\n@export var full_health_color: Color = Color(0.9, 0.2, 0.2, 1.0)\n\n## Color when at low health (interpolates based on health percentage).\n@export var low_health_color: Color = Color(0.3, 0.1, 0.1, 1.0)\n\n## Color to flash when hit.\n@export var hit_flash_color: Color = Color(1.0, 1.0, 1.0, 1.0)\n\n## Duration of hit flash effect in seconds.\n@export var hit_flash_duration: float = 0.1\n\n## Whether to destroy the enemy after death.\n@export var destroy_on_death: bool = false\n\n## Delay before respawning or destroying (in seconds).\n@export var respawn_delay: float = 2.0\n\n## Minimum random health.\n@export var min_health: int = 2\n\n## Maximum random health.\n@export var max_health: int = 4\n\n## Threat sphere radius - bullets within this radius trigger suppression.\n@export var threat_sphere_radius: float = 100.0\n\n## Time to stay suppressed after bullets leave threat sphere.\n@export var suppression_cooldown: float = 2.0\n\n## Delay (in seconds) before reacting to bullets in the threat sphere.\n## This prevents instant reactions to nearby gunfire, giving the player more time.\n@export var threat_reaction_delay: float = 0.2\n\n## Flank angle from player's facing direction (radians).\n@export var flank_angle: float = PI / 3.0  # 60 degrees\n\n## Distance to maintain while flanking.\n@export var flank_distance: float = 200.0\n\n## Enable/disable flanking behavior.\n@export var enable_flanking: bool = true\n\n## Enable/disable cover behavior.\n@export var enable_cover: bool = true\n\n## Enable/disable debug logging.\n@export var debug_logging: bool = false\n\n## Enable/disable debug label above enemy showing current AI state.\n@export var debug_label_enabled: bool = false\n\n## Enable/disable friendly fire avoidance (don't shoot if other enemies are in the way).\n@export var enable_friendly_fire_avoidance: bool = true\n\n## Enable/disable lead prediction (shooting ahead of moving targets).\n@export var enable_lead_prediction: bool = true\n\n## Bullet speed for lead prediction calculation.\n## Should match the actual bullet speed (default is 2500 for assault rifle).\n@export var bullet_speed: float = 2500.0\n\n## Ammunition system - magazine size (bullets per magazine).\n@export var magazine_size: int = 30\n\n## Ammunition system - number of magazines the enemy carries.\n@export var total_magazines: int = 5\n\n## Ammunition system - time to reload in seconds.\n@export var reload_time: float = 3.0\n\n## Delay (in seconds) between spotting player and starting to shoot.\n## Gives player a brief reaction time when entering enemy line of sight.\n## This delay \"recharges\" each time the player breaks direct contact with the enemy.\n@export var detection_delay: float = 0.2\n\n## Minimum time (in seconds) the player must be continuously visible before\n## lead prediction is enabled. This prevents enemies from predicting player\n## position immediately when they emerge from cover.\n@export var lead_prediction_delay: float = 0.3\n\n## Minimum visibility ratio (0.0 to 1.0) of player body that must be visible\n## before lead prediction is enabled. At 1.0, the player's entire body must be\n## visible. At 0.5, at least half of the check points must be visible.\n## This prevents pre-firing at players who are at cover edges.\n@export var lead_prediction_visibility_threshold: float = 0.6\n\n## Signal emitted when the enemy is hit.\nsignal hit\n\n## Signal emitted when the enemy dies.\nsignal died\n\n## Signal emitted when AI state changes.\nsignal state_changed(new_state: AIState)\n\n## Signal emitted when ammunition changes.\nsignal ammo_changed(current_ammo: int, reserve_ammo: int)\n\n## Signal emitted when reloading starts.\nsignal reload_started\n\n## Signal emitted when reloading finishes.\nsignal reload_finished\n\n## Signal emitted when all ammunition is depleted.\nsignal ammo_depleted\n\n## Reference to the sprite for color changes.\n@onready var _sprite: Sprite2D = $Sprite2D\n\n## RayCast2D for line of sight detection.\n@onready var _raycast: RayCast2D = $RayCast2D\n\n## Debug label for showing current AI state above the enemy.\n@onready var _debug_label: Label = $DebugLabel\n\n## Wall detection raycasts for obstacle avoidance (created at runtime).\nvar _wall_raycasts: Array[RayCast2D] = []\n\n## Distance to check for walls ahead.\nconst WALL_CHECK_DISTANCE: float = 40.0\n\n## Number of raycasts for wall detection (spread around the enemy).\nconst WALL_CHECK_COUNT: int = 3\n\n## Cover detection raycasts (created at runtime).\nvar _cover_raycasts: Array[RayCast2D] = []\n\n## Number of raycasts for cover detection.\nconst COVER_CHECK_COUNT: int = 16\n\n## Distance to check for cover.\nconst COVER_CHECK_DISTANCE: float = 300.0\n\n## Current health of the enemy.\nvar _current_health: int = 0\n\n## Maximum health of the enemy (set at spawn).\nvar _max_health: int = 0\n\n## Whether the enemy is alive.\nvar _is_alive: bool = true\n\n## Reference to the player (found at runtime).\nvar _player: Node2D = null\n\n## Time since last shot.\nvar _shoot_timer: float = 0.0\n\n## Current ammo in the magazine.\nvar _current_ammo: int = 0\n\n## Reserve ammo (ammo in remaining magazines).\nvar _reserve_ammo: int = 0\n\n## Whether the enemy is currently reloading.\nvar _is_reloading: bool = false\n\n## Timer for reload progress.\nvar _reload_timer: float = 0.0\n\n## Patrol state variables.\nvar _patrol_points: Array[Vector2] = []\nvar _current_patrol_index: int = 0\nvar _is_waiting_at_patrol_point: bool = false\nvar _patrol_wait_timer: float = 0.0\nvar _initial_position: Vector2\n\n## Whether the enemy can currently see the player.\nvar _can_see_player: bool = false\n\n## Current AI state.\nvar _current_state: AIState = AIState.IDLE\n\n## Current cover position (if any).\nvar _cover_position: Vector2 = Vector2.ZERO\n\n## Is currently in a valid cover position.\nvar _has_valid_cover: bool = false\n\n## Timer for suppression cooldown.\nvar _suppression_timer: float = 0.0\n\n## Whether enemy is currently under fire (bullets in threat sphere).\nvar _under_fire: bool = false\n\n## Flank target position.\nvar _flank_target: Vector2 = Vector2.ZERO\n\n## Threat sphere Area2D for detecting nearby bullets.\nvar _threat_sphere: Area2D = null\n\n## Bullets currently in threat sphere.\nvar _bullets_in_threat_sphere: Array = []\n\n## Timer for threat reaction delay - time since first bullet entered threat sphere.\nvar _threat_reaction_timer: float = 0.0\n\n## Whether the threat reaction delay has elapsed (enemy can react to bullets).\nvar _threat_reaction_delay_elapsed: bool = false\n\n## Memory of bullets that have passed through the threat sphere recently.\n## This allows the enemy to react even after fast-moving bullets have exited.\nvar _threat_memory_timer: float = 0.0\n\n## Duration to remember that a bullet passed through the threat sphere.\n## This should be longer than the reaction delay to ensure enemies can complete\n## their reaction even after bullets have passed through quickly.\nconst THREAT_MEMORY_DURATION: float = 0.5\n\n## Current retreat mode determined by damage taken.\nvar _retreat_mode: RetreatMode = RetreatMode.FULL_HP\n\n## Number of hits taken during the current retreat/combat encounter.\n## Resets when enemy enters IDLE state or finishes retreating.\nvar _hits_taken_in_encounter: int = 0\n\n## Timer for periodic turning to cover during FULL_HP retreat.\nvar _retreat_turn_timer: float = 0.0\n\n## Duration to face cover during FULL_HP retreat turn (seconds).\nconst RETREAT_TURN_DURATION: float = 0.8\n\n## Interval between turns toward cover in FULL_HP retreat (seconds).\nconst RETREAT_TURN_INTERVAL: float = 1.5\n\n## Whether currently in the \"turn to cover\" phase of FULL_HP retreat.\nvar _retreat_turning_to_cover: bool = false\n\n## Burst fire counter for ONE_HIT retreat mode.\nvar _retreat_burst_remaining: int = 0\n\n## Timer for burst fire cooldown in ONE_HIT retreat.\nvar _retreat_burst_timer: float = 0.0\n\n## Fast cooldown between burst shots (seconds).\nconst RETREAT_BURST_COOLDOWN: float = 0.06\n\n## Whether burst fire phase is complete in ONE_HIT retreat.\nvar _retreat_burst_complete: bool = false\n\n## Accuracy reduction during retreat (multiplier for inaccuracy angle spread).\nconst RETREAT_INACCURACY_SPREAD: float = 0.15\n\n## Arc spread for ONE_HIT burst fire (radians, total spread).\nconst RETREAT_BURST_ARC: float = 0.4\n\n## Current angle offset within burst arc.\nvar _retreat_burst_angle_offset: float = 0.0\n\n## Whether enemy is in \"alarm\" mode (was suppressed/retreating and hasn't calmed down).\n## This persists until the enemy reaches safety in cover or returns to idle.\nvar _in_alarm_mode: bool = false\n\n## Whether the enemy needs to fire a cover burst (when leaving cover while in alarm).\nvar _cover_burst_pending: bool = false\n\n## --- Combat Cover Cycling (come out, shoot 2-3s, go back) ---\n## Timer for how long the enemy has been shooting while out of cover.\nvar _combat_shoot_timer: float = 0.0\n\n## Duration to shoot while out of cover (2-3 seconds, randomized).\nvar _combat_shoot_duration: float = 2.5\n\n## Whether the enemy is currently in the \"exposed shooting\" phase of combat.\nvar _combat_exposed: bool = false\n\n## Whether the enemy is in the \"approaching player\" phase of combat.\n## In this phase, the enemy moves toward the player to get into direct contact.\nvar _combat_approaching: bool = false\n\n## Timer for the approach phase of combat.\nvar _combat_approach_timer: float = 0.0\n\n## Maximum time to spend approaching player before starting to shoot (seconds).\nconst COMBAT_APPROACH_MAX_TIME: float = 2.0\n\n## Distance at which enemy is considered \"close enough\" to start shooting phase.\nconst COMBAT_DIRECT_CONTACT_DISTANCE: float = 250.0\n\n## --- Pursuit State (cover-to-cover movement) ---\n## Timer for waiting at cover during pursuit.\nvar _pursuit_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during pursuit (1-2 seconds, reduced for faster pursuit).\nconst PURSUIT_COVER_WAIT_DURATION: float = 1.5\n\n## Current pursuit target cover position.\nvar _pursuit_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid pursuit cover target.\nvar _has_pursuit_cover: bool = false\n\n## --- Flanking State (cover-to-cover movement toward flank target) ---\n## Timer for waiting at cover during flanking.\nvar _flank_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during flanking (seconds).\nconst FLANK_COVER_WAIT_DURATION: float = 0.8\n\n## Current flank cover position to move to.\nvar _flank_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid flank cover target.\nvar _has_flank_cover: bool = false\n\n## --- Assault State (coordinated multi-enemy rush) ---\n## Timer for assault wait period (5 seconds before rushing).\nvar _assault_wait_timer: float = 0.0\n\n## Duration to wait at cover before assault (5 seconds).\nconst ASSAULT_WAIT_DURATION: float = 5.0\n\n## Whether the assault wait period is complete.\nvar _assault_ready: bool = false\n\n## Whether this enemy is currently participating in an assault.\nvar _in_assault: bool = false\n\n## Distance threshold for \"close\" vs \"far\" from player.\n## Used to determine if enemy can engage from current position or needs to pursue.\nconst CLOSE_COMBAT_DISTANCE: float = 400.0\n\n## GOAP world state for goal-oriented planning.\nvar _goap_world_state: Dictionary = {}\n\n## --- Search/Investigation State (for when player escapes from view) ---\n## Last known position where the player was seen before escaping view.\nvar _last_known_player_position: Vector2 = Vector2.ZERO\n\n## Whether a search zone is currently active.\nvar _search_zone_active: bool = false\n\n## Radius of the potential player zone (area where player might be hiding).\nconst SEARCH_ZONE_RADIUS: float = 200.0\n\n## Timer for search timeout - enemy gives up searching after this time.\nvar _search_timer: float = 0.0\n\n## Maximum time to spend searching before giving up (seconds).\nconst SEARCH_MAX_DURATION: float = 15.0\n\n## Inspection points within the search zone (hiding spots behind covers and corners).\nvar _inspection_points: Array[Vector2] = []\n\n## Index of current inspection point being checked.\nvar _current_inspection_index: int = 0\n\n## Timer for waiting at each inspection point (looking around).\nvar _inspection_wait_timer: float = 0.0\n\n## Duration to wait at each inspection point (seconds).\nconst INSPECTION_WAIT_DURATION: float = 1.5\n\n## Whether currently waiting at an inspection point.\nvar _inspecting_point: bool = false\n\n## Number of raycasts for detecting inspection points (corners/hiding spots).\nconst INSPECTION_POINT_CHECK_COUNT: int = 24\n\n## Distance to check for inspection points from search zone center.\nconst INSPECTION_CHECK_DISTANCE: float = 250.0\n\n## Detection delay timer - tracks time since entering combat.\nvar _detection_timer: float = 0.0\n\n## Whether the detection delay has elapsed.\nvar _detection_delay_elapsed: bool = false\n\n## Continuous visibility timer - tracks how long the player has been continuously visible.\n## Resets when line of sight is lost.\nvar _continuous_visibility_timer: float = 0.0\n\n## Current visibility ratio of the player (0.0 to 1.0).\n## Represents what fraction of the player's body is visible to the enemy.\n## Used to determine if lead prediction should be enabled.\nvar _player_visibility_ratio: float = 0.0\n\n## --- Clear Shot Movement (move out from cover to get clear shot) ---\n## Target position to move to for getting a clear shot.\nvar _clear_shot_target: Vector2 = Vector2.ZERO\n\n## Whether we're currently moving to find a clear shot position.\nvar _seeking_clear_shot: bool = false\n\n## Timer for how long we've been trying to find a clear shot.\nvar _clear_shot_timer: float = 0.0\n\n## Maximum time to spend finding a clear shot before giving up (seconds).\nconst CLEAR_SHOT_MAX_TIME: float = 3.0\n\n## Distance to move when exiting cover to find a clear shot.\nconst CLEAR_SHOT_EXIT_DISTANCE: float = 60.0\n\n\n\nfunc _ready() -> void:\n\t_initial_position = global_position\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_setup_patrol_points()\n\t_find_player()\n\t_setup_wall_detection()\n\t_setup_cover_detection()\n\t_setup_threat_sphere()\n\t_initialize_goap_state()\n\t_connect_debug_mode_signal()\n\t_update_debug_label()\n\n\t# Log that this enemy is ready (use call_deferred to ensure FileLogger is loaded)\n\tcall_deferred(\"_log_spawn_info\")\n\n\t# Preload bullet scene if not set in inspector\n\tif bullet_scene == null:\n\t\tbullet_scene = preload(\"res://scenes/projectiles/Bullet.tscn\")\n\n\n## Initialize health with random value between min and max.\nfunc _initialize_health() -> void:\n\t_max_health = randi_range(min_health, max_health)\n\t_current_health = _max_health\n\t_is_alive = true\n\n\n## Initialize ammunition with full magazine and reserve ammo.\nfunc _initialize_ammo() -> void:\n\t_current_ammo = magazine_size\n\t# Reserve ammo is (total_magazines - 1) * magazine_size since one magazine is loaded\n\t_reserve_ammo = (total_magazines - 1) * magazine_size\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\n## Setup patrol points based on patrol offsets from initial position.\nfunc _setup_patrol_points() -> void:\n\t_patrol_points.clear()\n\t_patrol_points.append(_initial_position)\n\tfor offset in patrol_offsets:\n\t\t_patrol_points.append(_initial_position + offset)\n\n\n## Setup wall detection raycasts for obstacle avoidance.\nfunc _setup_wall_detection() -> void:\n\t# Create multiple raycasts spread in front of the enemy\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_wall_raycasts.append(raycast)\n\n\n## Setup cover detection raycasts for finding cover positions.\nfunc _setup_cover_detection() -> void:\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_cover_raycasts.append(raycast)\n\n\n## Setup threat sphere for detecting nearby bullets.\nfunc _setup_threat_sphere() -> void:\n\t_threat_sphere = Area2D.new()\n\t_threat_sphere.name = \"ThreatSphere\"\n\t_threat_sphere.collision_layer = 0\n\t_threat_sphere.collision_mask = 16  # Detect projectiles (layer 5)\n\n\tvar collision_shape := CollisionShape2D.new()\n\tvar circle_shape := CircleShape2D.new()\n\tcircle_shape.radius = threat_sphere_radius\n\tcollision_shape.shape = circle_shape\n\t_threat_sphere.add_child(collision_shape)\n\n\tadd_child(_threat_sphere)\n\n\t# Connect signals\n\t_threat_sphere.area_entered.connect(_on_threat_area_entered)\n\t_threat_sphere.area_exited.connect(_on_threat_area_exited)\n\n\n## Initialize GOAP world state.\nfunc _initialize_goap_state() -> void:\n\t_goap_world_state = {\n\t\t\"player_visible\": false,\n\t\t\"has_cover\": false,\n\t\t\"in_cover\": false,\n\t\t\"under_fire\": false,\n\t\t\"health_low\": false,\n\t\t\"can_flank\": false,\n\t\t\"at_flank_position\": false,\n\t\t\"is_retreating\": false,\n\t\t\"hits_taken\": 0,\n\t\t\"is_pursuing\": false,\n\t\t\"is_assaulting\": false,\n\t\t\"can_hit_from_cover\": false,\n\t\t\"player_close\": false,\n\t\t\"enemies_in_combat\": 0,\n\t\t\"has_search_zone\": false,\n\t\t\"search_zone_cleared\": false,\n\t\t\"inspection_points_remaining\": 0,\n\t\t\"is_searching\": false\n\t}\n\n\n## Connect to GameManager's debug mode signal for F7 toggle.\nfunc _connect_debug_mode_signal() -> void:\n\tvar game_manager: Node = get_node_or_null(\"/root/GameManager\")\n\tif game_manager:\n\t\t# Connect to debug mode toggle signal\n\t\tif game_manager.has_signal(\"debug_mode_toggled\"):\n\t\t\tgame_manager.debug_mode_toggled.connect(_on_debug_mode_toggled)\n\t\t# Sync with current debug mode state\n\t\tif game_manager.has_method(\"is_debug_mode_enabled\"):\n\t\t\tdebug_label_enabled = game_manager.is_debug_mode_enabled()\n\n\n## Called when debug mode is toggled via F7 key.\nfunc _on_debug_mode_toggled(enabled: bool) -> void:\n\tdebug_label_enabled = enabled\n\t_update_debug_label()\n\n\n## Find the player node in the scene tree.\nfunc _find_player() -> void:\n\t# Try to find the player by group first\n\tvar players := get_tree().get_nodes_in_group(\"player\")\n\tif players.size() > 0:\n\t\t_player = players[0]\n\t\treturn\n\n\t# Fallback: search for player by node name or type\n\tvar root := get_tree().current_scene\n\tif root:\n\t\t_player = _find_player_recursive(root)\n\n\n## Recursively search for a player node.\nfunc _find_player_recursive(node: Node) -> Node2D:\n\tif node.name == \"Player\" and node is Node2D:\n\t\treturn node\n\tfor child in node.get_children():\n\t\tvar result := _find_player_recursive(child)\n\t\tif result:\n\t\t\treturn result\n\treturn null\n\n\nfunc _physics_process(delta: float) -> void:\n\tif not _is_alive:\n\t\treturn\n\n\t# Update shoot cooldown timer\n\t_shoot_timer += delta\n\n\t# Update reload timer\n\t_update_reload(delta)\n\n\t# Check for player visibility and try to find player if not found\n\tif _player == null:\n\t\t_find_player()\n\n\t_check_player_visibility()\n\t_update_goap_state()\n\t_update_suppression(delta)\n\n\t# Process AI state machine\n\t_process_ai_state(delta)\n\n\t# Update debug label if enabled\n\t_update_debug_label()\n\n\t# Request redraw for debug visualization\n\tif debug_label_enabled:\n\t\tqueue_redraw()\n\n\tmove_and_slide()\n\n\n## Update GOAP world state based on current conditions.\nfunc _update_goap_state() -> void:\n\t_goap_world_state[\"player_visible\"] = _can_see_player\n\t_goap_world_state[\"under_fire\"] = _under_fire\n\t_goap_world_state[\"health_low\"] = _get_health_percent() < 0.5\n\t_goap_world_state[\"in_cover\"] = _current_state == AIState.IN_COVER\n\t_goap_world_state[\"has_cover\"] = _has_valid_cover\n\t_goap_world_state[\"is_retreating\"] = _current_state == AIState.RETREATING\n\t_goap_world_state[\"hits_taken\"] = _hits_taken_in_encounter\n\t_goap_world_state[\"is_pursuing\"] = _current_state == AIState.PURSUING\n\t_goap_world_state[\"is_assaulting\"] = _current_state == AIState.ASSAULT\n\t_goap_world_state[\"player_close\"] = _is_player_close()\n\t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n\t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()\n\t_goap_world_state[\"has_search_zone\"] = _search_zone_active\n\t_goap_world_state[\"search_zone_cleared\"] = not _search_zone_active and _last_known_player_position != Vector2.ZERO\n\t_goap_world_state[\"inspection_points_remaining\"] = _inspection_points.size() - _current_inspection_index\n\t_goap_world_state[\"is_searching\"] = _current_state == AIState.SEARCHING\n\n\n## Update suppression state.\nfunc _update_suppression(delta: float) -> void:\n\t# Clean up destroyed bullets from tracking\n\t_bullets_in_threat_sphere = _bullets_in_threat_sphere.filter(func(b): return is_instance_valid(b))\n\n\t# Determine if there's an active threat (bullets in sphere OR recent threat memory)\n\tvar has_active_threat := not _bullets_in_threat_sphere.is_empty() or _threat_memory_timer > 0.0\n\n\tif not has_active_threat:\n\t\tif _under_fire:\n\t\t\t_suppression_timer += delta\n\t\t\tif _suppression_timer >= suppression_cooldown:\n\t\t\t\t_under_fire = false\n\t\t\t\t_suppression_timer = 0.0\n\t\t\t\t_log_debug(\"Suppression ended\")\n\t\t# Reset threat reaction timer when no bullets are in threat sphere and no threat memory\n\t\t_threat_reaction_timer = 0.0\n\t\t_threat_reaction_delay_elapsed = false\n\telse:\n\t\t# Decrement threat memory timer if no bullets currently in sphere\n\t\tif _bullets_in_threat_sphere.is_empty() and _threat_memory_timer > 0.0:\n\t\t\t_threat_memory_timer -= delta\n\n\t\t# Update threat reaction timer\n\t\tif not _threat_reaction_delay_elapsed:\n\t\t\t_threat_reaction_timer += delta\n\t\t\tif _threat_reaction_timer >= threat_reaction_delay:\n\t\t\t\t_threat_reaction_delay_elapsed = true\n\t\t\t\t_log_debug(\"Threat reaction delay elapsed, now reacting to bullets\")\n\n\t\t# Only set under_fire after the reaction delay has elapsed\n\t\tif _threat_reaction_delay_elapsed:\n\t\t\t_under_fire = true\n\t\t\t_suppression_timer = 0.0\n\n\n## Update reload state.\nfunc _update_reload(delta: float) -> void:\n\tif not _is_reloading:\n\t\treturn\n\n\t_reload_timer += delta\n\tif _reload_timer >= reload_time:\n\t\t_finish_reload()\n\n\n## Start reloading the weapon.\nfunc _start_reload() -> void:\n\t# Can't reload if already reloading or no reserve ammo\n\tif _is_reloading or _reserve_ammo <= 0:\n\t\treturn\n\n\t_is_reloading = true\n\t_reload_timer = 0.0\n\treload_started.emit()\n\t_log_debug(\"Reloading... (%d reserve ammo)\" % _reserve_ammo)\n\n\n## Finish the reload process.\nfunc _finish_reload() -> void:\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\t# Calculate how many rounds to load\n\tvar ammo_needed := magazine_size - _current_ammo\n\tvar ammo_to_load := mini(ammo_needed, _reserve_ammo)\n\n\t_reserve_ammo -= ammo_to_load\n\t_current_ammo += ammo_to_load\n\n\treload_finished.emit()\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\t_log_debug(\"Reload complete. Magazine: %d/%d, Reserve: %d\" % [_current_ammo, magazine_size, _reserve_ammo])\n\n\n## Check if the enemy can shoot (has ammo and not reloading).\nfunc _can_shoot() -> bool:\n\t# Can't shoot if reloading\n\tif _is_reloading:\n\t\treturn false\n\n\t# Can't shoot if no ammo in magazine\n\tif _current_ammo <= 0:\n\t\t# Try to start reload if we have reserve ammo\n\t\tif _reserve_ammo > 0:\n\t\t\t_start_reload()\n\t\telse:\n\t\t\t# No ammo at all - emit depleted signal once\n\t\t\tif not _goap_world_state.get(\"ammo_depleted\", false):\n\t\t\t\t_goap_world_state[\"ammo_depleted\"] = true\n\t\t\t\tammo_depleted.emit()\n\t\t\t\t_log_debug(\"All ammunition depleted!\")\n\t\treturn false\n\n\treturn true\n\n\n## Process the AI state machine.\nfunc _process_ai_state(delta: float) -> void:\n\tvar previous_state := _current_state\n\n\t# State transitions based on conditions\n\tmatch _current_state:\n\t\tAIState.IDLE:\n\t\t\t_process_idle_state(delta)\n\t\tAIState.COMBAT:\n\t\t\t_process_combat_state(delta)\n\t\tAIState.SEEKING_COVER:\n\t\t\t_process_seeking_cover_state(delta)\n\t\tAIState.IN_COVER:\n\t\t\t_process_in_cover_state(delta)\n\t\tAIState.FLANKING:\n\t\t\t_process_flanking_state(delta)\n\t\tAIState.SUPPRESSED:\n\t\t\t_process_suppressed_state(delta)\n\t\tAIState.RETREATING:\n\t\t\t_process_retreating_state(delta)\n\t\tAIState.PURSUING:\n\t\t\t_process_pursuing_state(delta)\n\t\tAIState.ASSAULT:\n\t\t\t_process_assault_state(delta)\n\n\tif previous_state != _current_state:\n\t\tstate_changed.emit(_current_state)\n\t\t_log_debug(\"State changed: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\t\t# Also log to file for exported build debugging\n\t\t_log_to_file(\"State: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\n\n## Process IDLE state - patrol or guard behavior.\nfunc _process_idle_state(delta: float) -> void:\n\t# Transition to combat if player is visible\n\tif _can_see_player and _player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Execute idle behavior\n\tmatch behavior_mode:\n\t\tBehaviorMode.PATROL:\n\t\t\t_process_patrol(delta)\n\t\tBehaviorMode.GUARD:\n\t\t\t_process_guard(delta)\n\n\n## Process COMBAT state - approach player for direct contact, shoot for 2-3 seconds, return to cover.\n## Implements the combat cycling behavior: exit cover -> exposed shooting -> return to cover.\n## Phase 0 (seeking clear shot): If bullet spawn blocked, move out from cover to find clear shot.\n## Phase 1 (approaching): Move toward player to get into direct contact range.\n## Phase 2 (exposed): Stand and shoot for 2-3 seconds.\n## Phase 3: Return to cover via SEEKING_COVER state.\nfunc _process_combat_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies in combat (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can't see player, pursue them (move cover-to-cover toward player)\n\tif not _can_see_player:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\t\treturn\n\n\t# Update detection delay timer\n\tif not _detection_delay_elapsed:\n\t\t_detection_timer += delta\n\t\tif _detection_timer >= detection_delay:\n\t\t\t_detection_delay_elapsed = true\n\n\t# If we don't have cover, find some first (needed for returning later)\n\tif not _has_valid_cover and enable_cover:\n\t\t_find_cover_position()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found cover at %s for combat cycling\" % _cover_position)\n\n\t# Check player distance for approach/exposed phase decisions\n\tvar distance_to_player := INF\n\tif _player:\n\t\tdistance_to_player = global_position.distance_to(_player.global_position)\n\n\t# Check if we have a clear shot (no wall blocking bullet spawn)\n\tvar direction_to_player := Vector2.ZERO\n\tvar has_clear_shot := true\n\tif _player:\n\t\tdirection_to_player = (_player.global_position - global_position).normalized()\n\t\thas_clear_shot = _is_bullet_spawn_clear(direction_to_player)\n\n\t# If already exposed (shooting phase), handle shooting and timer\n\tif _combat_exposed:\n\t\t_combat_shoot_timer += delta\n\n\t\t# Check if exposure time is complete - go back to cover\n\t\tif _combat_shoot_timer >= _combat_shoot_duration and _has_valid_cover:\n\t\t\t_log_debug(\"Combat exposure time complete (%.1fs), returning to cover\" % _combat_shoot_duration)\n\t\t\t_combat_exposed = false\n\t\t\t_combat_approaching = false\n\t\t\t_combat_shoot_timer = 0.0\n\t\t\t_transition_to_seeking_cover()\n\t\t\treturn\n\n\t\t# Check if we still have a clear shot - if not, move sideways to find one\n\t\tif _player and not has_clear_shot:\n\t\t\t# Bullet spawn is blocked - move sideways to find a clear shot position\n\t\t\tvar sidestep_dir := _find_sidestep_direction_for_clear_shot(direction_to_player)\n\t\t\tif sidestep_dir != Vector2.ZERO:\n\t\t\t\tvelocity = sidestep_dir * combat_move_speed * 0.7\n\t\t\t\trotation = direction_to_player.angle()  # Keep facing player while sidestepping\n\t\t\t\t_log_debug(\"COMBAT exposed: sidestepping to maintain clear shot\")\n\t\t\telse:\n\t\t\t\t# No sidestep works - stay still, the shot might clear up\n\t\t\t\tvelocity = Vector2.ZERO\n\t\t\treturn\n\n\t\t# In exposed phase with clear shot, stand still and shoot\n\t\tvelocity = Vector2.ZERO\n\n\t\t# Aim and shoot at player (only shoot after detection delay)\n\t\tif _player:\n\t\t\t_aim_at_player()\n\t\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot()\n\t\t\t\t_shoot_timer = 0.0\n\t\treturn\n\n\t# --- CLEAR SHOT SEEKING PHASE ---\n\t# If bullet spawn is blocked and we're not already exposed, we need to move out from cover\n\tif not has_clear_shot and _player:\n\t\t# Start seeking clear shot if not already doing so\n\t\tif not _seeking_clear_shot:\n\t\t\t_seeking_clear_shot = true\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Calculate target position: move perpendicular to player direction (around cover edge)\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\t_log_debug(\"COMBAT: bullet spawn blocked, seeking clear shot at %s\" % _clear_shot_target)\n\n\t\t_clear_shot_timer += delta\n\n\t\t# Check if we've exceeded the max time trying to find a clear shot\n\t\tif _clear_shot_timer >= CLEAR_SHOT_MAX_TIME:\n\t\t\t_log_debug(\"COMBAT: clear shot timeout, trying flanking\")\n\t\t\t_seeking_clear_shot = false\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Try flanking to get around the obstacle\n\t\t\tif enable_flanking:\n\t\t\t\t_transition_to_flanking()\n\t\t\telse:\n\t\t\t\t_transition_to_pursuing()\n\t\t\treturn\n\n\t\t# Move toward the clear shot target position\n\t\tvar distance_to_target := global_position.distance_to(_clear_shot_target)\n\t\tif distance_to_target > 15.0:\n\t\t\tvar move_direction := (_clear_shot_target - global_position).normalized()\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed\n\t\t\trotation = direction_to_player.angle()  # Keep facing player\n\n\t\t\t# Check if the new position now has a clear shot\n\t\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\t\t_log_debug(\"COMBAT: found clear shot position while moving\")\n\t\t\t\t_seeking_clear_shot = false\n\t\t\t\t_clear_shot_timer = 0.0\n\t\t\t\t# Continue to exposed phase check below\n\t\t\telse:\n\t\t\t\treturn  # Keep moving toward target\n\t\telse:\n\t\t\t# Reached target but still no clear shot - recalculate target\n\t\t\t_log_debug(\"COMBAT: reached target but no clear shot, recalculating\")\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\treturn\n\n\t# Reset seeking state if we now have a clear shot\n\tif _seeking_clear_shot and has_clear_shot:\n\t\t_log_debug(\"COMBAT: clear shot acquired\")\n\t\t_seeking_clear_shot = false\n\t\t_clear_shot_timer = 0.0\n\n\t# Determine if we should be in approach phase or exposed shooting phase\n\tvar in_direct_contact := distance_to_player <= COMBAT_DIRECT_CONTACT_DISTANCE\n\n\t# Enter exposed phase if we have a clear shot and are either close enough or have approached long enough\n\tif has_clear_shot and (in_direct_contact or _combat_approach_timer >= COMBAT_APPROACH_MAX_TIME):\n\t\t# Close enough AND have clear shot - start exposed shooting phase\n\t\t_combat_exposed = true\n\t\t_combat_approaching = false\n\t\t_combat_shoot_timer = 0.0\n\t\t_combat_approach_timer = 0.0\n\t\t# Randomize exposure duration between 2-3 seconds\n\t\t_combat_shoot_duration = randf_range(2.0, 3.0)\n\t\t_log_debug(\"COMBAT exposed phase started (distance: %.0f), will shoot for %.1fs\" % [distance_to_player, _combat_shoot_duration])\n\t\treturn\n\n\t# Need to approach player - move toward them\n\tif not _combat_approaching:\n\t\t_combat_approaching = true\n\t\t_combat_approach_timer = 0.0\n\t\t_log_debug(\"COMBAT approach phase started, moving toward player\")\n\n\t_combat_approach_timer += delta\n\n\t# Move toward player while approaching\n\tif _player:\n\t\tvar move_direction := direction_to_player\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = move_direction * combat_move_speed\n\t\trotation = direction_to_player.angle()  # Always face player\n\n\t\t# Can shoot while approaching (only after detection delay and if have clear shot)\n\t\tif has_clear_shot and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\n## Calculate a target position to exit cover and get a clear shot.\n## Returns a position that should allow the bullet spawn point to be unobstructed.\nfunc _calculate_clear_shot_exit_position(direction_to_player: Vector2) -> Vector2:\n\t# Calculate perpendicular directions to the player\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Try both perpendicular directions and pick the one that's more likely to work\n\t# Also blend with forward movement toward player to help navigate around cover\n\tvar best_position := global_position\n\tvar best_score := -1.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\t\t# Blend sidestep with forward movement for better cover navigation\n\t\tvar exit_dir: Vector2 = (sidestep_dir * 0.7 + direction_to_player * 0.3).normalized()\n\t\tvar test_position: Vector2 = global_position + exit_dir * CLEAR_SHOT_EXIT_DISTANCE\n\n\t\t# Score this position based on:\n\t\t# 1. Does it have a clear path? (no walls in the way)\n\t\t# 2. Would the bullet spawn be clear from there?\n\t\tvar score: float = 0.0\n\n\t\t# Check if we can move to this position\n\t\tif _has_clear_path_to(test_position):\n\t\t\tscore += 1.0\n\n\t\t# Check if bullet spawn would be clear from this position\n\t\t# This is a rough estimate - we check from the test position toward player\n\t\tvar world_2d := get_world_2d()\n\t\tif world_2d != null:\n\t\t\tvar space_state := world_2d.direct_space_state\n\t\t\tif space_state != null:\n\t\t\t\tvar check_distance := bullet_spawn_offset + 5.0\n\t\t\t\tvar query := PhysicsRayQueryParameters2D.new()\n\t\t\t\tquery.from = test_position\n\t\t\t\tquery.to = test_position + direction_to_player * check_distance\n\t\t\t\tquery.collision_mask = 4  # Only check obstacles\n\t\t\t\tquery.exclude = [get_rid()]\n\t\t\t\tvar result := space_state.intersect_ray(query)\n\t\t\t\tif result.is_empty():\n\t\t\t\t\tscore += 2.0  # Higher score for clear bullet spawn\n\n\t\tif score > best_score:\n\t\t\tbest_score = score\n\t\t\tbest_position = test_position\n\n\t# If no good position found, just move forward toward player\n\tif best_score < 0.5:\n\t\tbest_position = global_position + direction_to_player * CLEAR_SHOT_EXIT_DISTANCE\n\n\treturn best_position\n\n\n## Process SEEKING_COVER state - moving to cover position.\nfunc _process_seeking_cover_state(_delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, stay in combat\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're already hidden from the player (the main goal)\n\tif not _is_visible_from_player():\n\t\t_transition_to_in_cover()\n\t\t_log_debug(\"Hidden from player, entering cover state\")\n\t\treturn\n\n\t# Move towards cover\n\tvar direction := (_cover_position - global_position).normalized()\n\tvar distance := global_position.distance_to(_cover_position)\n\n\tif distance < 10.0:\n\t\t# Reached the cover position, but still visible - try to find better cover\n\t\tif _is_visible_from_player():\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\t# No better cover found, stay in combat\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\n\t# Apply wall avoidance\n\tvar avoidance := _check_wall_ahead(direction)\n\tif avoidance != Vector2.ZERO:\n\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\tvelocity = direction * combat_move_speed\n\trotation = direction.angle()\n\n\t# Can still shoot while moving to cover (only after detection delay)\n\tif _can_see_player and _player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t_aim_at_player()\n\t\t_shoot()\n\t\t_shoot_timer = 0.0\n\n\n## Process IN_COVER state - taking cover from enemy fire.\n## Decides next action based on:\n## 1. If under fire -> suppressed\n## 2. If player is close (can exit cover for direct contact) -> COMBAT\n## 3. If player is far but can hit from current position -> COMBAT (stay and shoot)\n## 4. If player is far and can't hit -> PURSUING (move cover-to-cover)\nfunc _process_in_cover_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# If still under fire, stay suppressed\n\tif _under_fire:\n\t\t_transition_to_suppressed()\n\t\treturn\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover\n\tif _is_visible_from_player():\n\t\t# If in alarm mode and can see player, fire a burst before escaping\n\t\tif _in_alarm_mode and _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"IN_COVER alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay in cover while firing burst\n\n\t\t# Burst complete or not in alarm mode, seek new cover\n\t\t_log_debug(\"Player flanked our cover position, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# Decision making based on player distance and visibility\n\tif _player:\n\t\tvar player_close := _is_player_close()\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\n\t\tif _can_see_player:\n\t\t\tif player_close:\n\t\t\t\t# Player is close - engage in combat (come out, shoot, go back)\n\t\t\t\t_log_debug(\"Player is close, transitioning to COMBAT\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\t# Player is far\n\t\t\t\tif can_hit:\n\t\t\t\t\t# Can hit from current position - come out and shoot\n\t\t\t\t\t# (Don't pursue, just transition to combat which will handle the cycling)\n\t\t\t\t\t_log_debug(\"Player is far but can hit from here, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\telse:\n\t\t\t\t\t# Can't hit from here - need to pursue (move cover-to-cover)\n\t\t\t\t\t_log_debug(\"Player is far and can't hit, transitioning to PURSUING\")\n\t\t\t\t\t_transition_to_pursuing()\n\t\t\t\t\treturn\n\n\t# If not under fire and can see player, engage (only shoot after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If player is no longer visible and not under fire, try pursuing\n\tif not _can_see_player and not _under_fire:\n\t\t_log_debug(\"Lost sight of player from cover, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\n\n## Process FLANKING state - attempting to flank the player using cover-to-cover movement.\n## Uses intermediate cover positions to navigate around obstacles instead of walking\n## directly toward the flank target.\nfunc _process_flanking_state(delta: float) -> void:\n\t# If under fire, retreat with shooting behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# If can see player, engage in combat\n\tif _can_see_player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\tif _player == null:\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# Recalculate flank position (player may have moved)\n\t_calculate_flank_position()\n\n\tvar distance_to_flank := global_position.distance_to(_flank_target)\n\n\t# Check if we've reached the flank target\n\tif distance_to_flank < 30.0:\n\t\t_log_debug(\"Reached flank position, engaging\")\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Check if we have direct line of sight to flank target (no obstacles)\n\tif _has_clear_path_to(_flank_target):\n\t\t# Direct path is clear - move directly toward flank target\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\t_has_flank_cover = false\n\t\treturn\n\n\t# Path is blocked - use cover-to-cover movement\n\n\t# If we're at a cover position, wait briefly before moving to next\n\tif _has_valid_cover and not _has_flank_cover:\n\t\t_flank_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _flank_cover_wait_timer >= FLANK_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover toward flank target\n\t\t\t_find_flank_cover_toward_target()\n\t\t\tif not _has_flank_cover:\n\t\t\t\t_log_debug(\"No flank cover found, attempting direct movement\")\n\t\t\t\t# No cover found - try direct movement with enhanced wall avoidance\n\t\t\t\tvar direction := (_flank_target - global_position).normalized()\n\t\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\t\tvelocity = direction * combat_move_speed\n\t\t\t\trotation = direction.angle()\n\t\t\t\t# Invalidate current cover to trigger new search next frame\n\t\t\t\t_has_valid_cover = false\n\t\treturn\n\n\t# If we have a flank cover target, move toward it\n\tif _has_flank_cover:\n\t\tvar direction := (_flank_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_flank_next_cover)\n\n\t\t# Check if we've reached the flank cover\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached flank cover at distance %.1f\" % distance)\n\t\t\t_has_flank_cover = false\n\t\t\t_flank_cover_wait_timer = 0.0\n\t\t\t_cover_position = _flank_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no flank cover target - find initial flank cover\n\t_find_flank_cover_toward_target()\n\tif not _has_flank_cover:\n\t\t# Can't find cover, try direct movement with wall avoidance\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\n\n## Process SUPPRESSED state - staying in cover under fire.\nfunc _process_suppressed_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover even while suppressed\n\tif _is_visible_from_player():\n\t\t# In suppressed state we're always in alarm mode - fire a burst before escaping if we can see player\n\t\tif _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"SUPPRESSED alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay suppressed while firing burst\n\n\t\t# Burst complete or can't see player, seek new cover\n\t\t_log_debug(\"Player flanked our cover position while suppressed, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Can still shoot while suppressed (only after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If no longer under fire, exit suppression\n\tif not _under_fire:\n\t\t_transition_to_in_cover()\n\n\n## Process RETREATING state - moving to cover with behavior based on damage taken.\nfunc _process_retreating_state(delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, transition to combat or suppressed\n\t\t\tif _under_fire:\n\t\t\t\t_transition_to_suppressed()\n\t\t\telse:\n\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we've reached cover and are hidden from player\n\tif not _is_visible_from_player():\n\t\t_log_debug(\"Reached cover during retreat\")\n\t\t# Reset encounter hits when successfully reaching cover\n\t\t_hits_taken_in_encounter = 0\n\t\t_transition_to_in_cover()\n\t\treturn\n\n\t# Calculate direction to cover\n\tvar direction_to_cover := (_cover_position - global_position).normalized()\n\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\n\t# Check if reached cover position\n\tif distance_to_cover < 10.0:\n\t\tif _is_visible_from_player():\n\t\t\t# Still visible, find better cover\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\tif _under_fire:\n\t\t\t\t\t_transition_to_suppressed()\n\t\t\t\telse:\n\t\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Apply retreat behavior based on mode\n\tmatch _retreat_mode:\n\t\tRetreatMode.FULL_HP:\n\t\t\t_process_retreat_full_hp(delta, direction_to_cover)\n\t\tRetreatMode.ONE_HIT:\n\t\t\t_process_retreat_one_hit(delta, direction_to_cover)\n\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t_process_retreat_multiple_hits(delta, direction_to_cover)\n\n\n## Process FULL_HP retreat: walk backwards facing player, shoot with reduced accuracy,\n## periodically turn toward cover.\nfunc _process_retreat_full_hp(delta: float, direction_to_cover: Vector2) -> void:\n\t_retreat_turn_timer += delta\n\n\tif _retreat_turning_to_cover:\n\t\t# Turning to face cover, don't shoot\n\t\tif _retreat_turn_timer >= RETREAT_TURN_DURATION:\n\t\t\t_retreat_turning_to_cover = false\n\t\t\t_retreat_turn_timer = 0.0\n\n\t\t# Face cover and move toward it\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\telse:\n\t\t# Face player and back up (walk backwards)\n\t\tif _retreat_turn_timer >= RETREAT_TURN_INTERVAL:\n\t\t\t_retreat_turning_to_cover = true\n\t\t\t_retreat_turn_timer = 0.0\n\t\t\t_log_debug(\"FULL_HP retreat: turning to check cover\")\n\n\t\tif _player:\n\t\t\t# Face the player\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\t_aim_at_player()\n\n\t\t\t# Move backwards (opposite of player direction = toward cover generally)\n\t\t\t# Use the negative of the direction we're facing for \"backing up\"\n\t\t\tvar move_direction := -direction_to_player\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed * 0.7  # Slower when backing up\n\n\t\t\t# Shoot with reduced accuracy (only after detection delay)\n\t\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot_with_inaccuracy()\n\t\t\t\t_shoot_timer = 0.0\n\n\n## Process ONE_HIT retreat: quick burst of 2-4 shots in an arc while turning, then face cover.\nfunc _process_retreat_one_hit(delta: float, direction_to_cover: Vector2) -> void:\n\tif not _retreat_burst_complete:\n\t\t# During burst phase\n\t\t_retreat_burst_timer += delta\n\n\t\tif _player and _retreat_burst_remaining > 0 and _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t# Fire a burst shot with arc spread\n\t\t\t_shoot_burst_shot()\n\t\t\t_retreat_burst_remaining -= 1\n\t\t\t_retreat_burst_timer = 0.0\n\n\t\t\t# Progress through the arc\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0  # Spread across 4 shots max\n\n\t\t# Gradually turn from player to cover during burst\n\t\tif _player:\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\tvar target_angle: float\n\n\t\t\t# Interpolate rotation from player direction to cover direction\n\t\t\tvar burst_progress := 1.0 - (float(_retreat_burst_remaining) / 4.0)\n\t\t\tvar player_angle := direction_to_player.angle()\n\t\t\tvar cover_angle := direction_to_cover.angle()\n\t\t\ttarget_angle = lerp_angle(player_angle, cover_angle, burst_progress * 0.7)\n\t\t\trotation = target_angle\n\n\t\t# Move toward cover (slower during burst)\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed * 0.5\n\n\t\t# Check if burst is complete\n\t\tif _retreat_burst_remaining <= 0:\n\t\t\t_retreat_burst_complete = true\n\t\t\t_log_debug(\"ONE_HIT retreat: burst complete, now running to cover\")\n\telse:\n\t\t# After burst, run to cover without shooting\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\n\n## Process MULTIPLE_HITS retreat: quick burst of 2-4 shots then run to cover (same as ONE_HIT).\nfunc _process_retreat_multiple_hits(delta: float, direction_to_cover: Vector2) -> void:\n\t# Same behavior as ONE_HIT - quick burst then escape\n\t_process_retreat_one_hit(delta, direction_to_cover)\n\n\n## Process PURSUING state - move cover-to-cover toward player.\n## Enemy moves between covers, waiting 1-2 seconds at each cover,\n## until they can see and hit the player.\nfunc _process_pursuing_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected during pursuit (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can see player and can hit them from current position, engage\n\tif _can_see_player and _player:\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\t\tif can_hit:\n\t\t\t_log_debug(\"Can see and hit player from pursuit, transitioning to COMBAT\")\n\t\t\t_has_pursuit_cover = false\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're waiting at cover\n\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t# Currently at cover, wait for 1-2 seconds before moving to next cover\n\t\t_pursuit_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _pursuit_cover_wait_timer >= PURSUIT_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover closer to player\n\t\t\t_log_debug(\"Pursuit wait complete, finding next cover\")\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_find_pursuit_cover_toward_player()\n\t\t\tif _has_pursuit_cover:\n\t\t\t\t_log_debug(\"Found pursuit cover at %s\" % _pursuit_next_cover)\n\t\t\telse:\n\t\t\t\t# No pursuit cover found - fallback behavior\n\t\t\t\t_log_debug(\"No pursuit cover found, checking fallback options\")\n\t\t\t\t# If we can now see the player, engage directly\n\t\t\t\tif _can_see_player:\n\t\t\t\t\t_log_debug(\"Can see player, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\t# Try flanking\n\t\t\t\tif enable_flanking and _player:\n\t\t\t\t\t_log_debug(\"Attempting flanking maneuver\")\n\t\t\t\t\t_transition_to_flanking()\n\t\t\t\t\treturn\n\t\t\t\t# Last resort: move directly toward player\n\t\t\t\t_log_debug(\"No cover options, moving directly toward player\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\treturn\n\n\t# If we have a pursuit cover target, move toward it\n\tif _has_pursuit_cover:\n\t\tvar direction := (_pursuit_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_pursuit_next_cover)\n\n\t\t# Check if we've reached the pursuit cover\n\t\t# Note: We only check distance here, NOT visibility from player.\n\t\t# If we checked visibility, the enemy would immediately consider themselves\n\t\t# \"at cover\" even before moving, since they start hidden from player.\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached pursuit cover at distance %.1f\" % distance)\n\t\t\t_has_pursuit_cover = false\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_cover_position = _pursuit_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no pursuit target - find initial pursuit cover\n\t_find_pursuit_cover_toward_player()\n\tif not _has_pursuit_cover:\n\t\t# Can't find cover to pursue, try flanking or combat\n\t\tif enable_flanking and _player:\n\t\t\t_transition_to_flanking()\n\t\telse:\n\t\t\t_transition_to_combat()\n\n\n## Process ASSAULT state - coordinated multi-enemy rush.\n## Wait at cover for 5 seconds, then all enemies rush the player simultaneously.\nfunc _process_assault_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover and not _assault_ready:\n\t\t_in_assault = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if we're the only enemy left in assault - switch back to combat\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat < 2 and not _assault_ready:\n\t\t_log_debug(\"Not enough enemies for assault, switching to COMBAT\")\n\t\t_in_assault = false\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Find closest cover to player if we don't have one\n\tif not _has_valid_cover:\n\t\t_find_cover_closest_to_player()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found assault cover at %s\" % _cover_position)\n\n\t# Move to cover position first\n\tif _has_valid_cover and not _in_assault:\n\t\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\t\tif distance_to_cover > 15.0 and _is_visible_from_player():\n\t\t\t# Still need to reach cover\n\t\t\tvar direction := (_cover_position - global_position).normalized()\n\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\tvelocity = direction * combat_move_speed\n\t\t\trotation = direction.angle()\n\t\t\treturn\n\n\t# At cover, wait for assault timer\n\tif not _assault_ready:\n\t\tvelocity = Vector2.ZERO\n\t\t_assault_wait_timer += delta\n\n\t\t# Check if all assault enemies are ready (synchronized assault)\n\t\tif _assault_wait_timer >= ASSAULT_WAIT_DURATION:\n\t\t\t# Check if situation has changed - player might have moved\n\t\t\tif _player and _is_player_close():\n\t\t\t\t_assault_ready = true\n\t\t\t\t_in_assault = true\n\t\t\t\t_log_debug(\"ASSAULT ready - rushing player!\")\n\t\t\telse:\n\t\t\t\t# Player moved away, reset timer and check if we should pursue\n\t\t\t\t_log_debug(\"Player moved away during assault wait, resetting\")\n\t\t\t\t_assault_wait_timer = 0.0\n\t\t\t\t_in_assault = false\n\t\t\t\t_transition_to_pursuing()\n\t\t\t\treturn\n\t\treturn\n\n\t# Assault phase - rush the player while shooting\n\tif _assault_ready and _player:\n\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction_to_player)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_player = (direction_to_player * 0.5 + avoidance * 0.5).normalized()\n\n\t\t# Rush at full speed\n\t\tvelocity = direction_to_player * combat_move_speed\n\t\trotation = direction_to_player.angle()\n\n\t\t# Update detection delay timer\n\t\tif not _detection_delay_elapsed:\n\t\t\t_detection_timer += delta\n\t\t\tif _detection_timer >= detection_delay:\n\t\t\t\t_detection_delay_elapsed = true\n\n\t\t# Shoot while rushing (only after detection delay)\n\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t\t# If very close to player, stay in combat\n\t\tif distance_to_player < 50.0:\n\t\t\t_log_debug(\"Assault complete - reached player\")\n\t\t\t_assault_ready = false\n\t\t\t_in_assault = false\n\t\t\t_transition_to_combat()\n\n\n## Shoot with reduced accuracy for retreat mode.\nfunc _shoot_with_inaccuracy() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Check if the shot should be taken\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Add inaccuracy spread\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD, RETREAT_INACCURACY_SPREAD)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the inaccurate shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Inaccurate shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bulle
[2026-01-18T02:52:45.021Z] [INFO] t_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Shoot a burst shot with arc spread for ONE_HIT retreat.\nfunc _shoot_burst_shot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Apply arc offset for burst spread\n\tdirection = direction.rotated(_retreat_burst_angle_offset)\n\n\t# Also add some random inaccuracy on top of the arc\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD * 0.5, RETREAT_INACCURACY_SPREAD * 0.5)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the burst shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Burst shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Transition to IDLE state.\nfunc _transition_to_idle() -> void:\n\t_current_state = AIState.IDLE\n\t# Reset encounter hit tracking when returning to idle\n\t_hits_taken_in_encounter = 0\n\t# Reset alarm mode when returning to idle\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\n\n## Transition to COMBAT state.\nfunc _transition_to_combat() -> void:\n\t_current_state = AIState.COMBAT\n\t# Reset detection delay timer when entering combat\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Reset combat phase variables\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_shoot_timer = 0.0\n\t_combat_approach_timer = 0.0\n\t# Reset clear shot seeking variables\n\t_seeking_clear_shot = false\n\t_clear_shot_timer = 0.0\n\t_clear_shot_target = Vector2.ZERO\n\n\n## Transition to SEEKING_COVER state.\nfunc _transition_to_seeking_cover() -> void:\n\t_current_state = AIState.SEEKING_COVER\n\t_find_cover_position()\n\n\n## Transition to IN_COVER state.\nfunc _transition_to_in_cover() -> void:\n\t_current_state = AIState.IN_COVER\n\n\n## Transition to FLANKING state.\nfunc _transition_to_flanking() -> void:\n\t_current_state = AIState.FLANKING\n\t_calculate_flank_position()\n\t_flank_cover_wait_timer = 0.0\n\t_has_flank_cover = false\n\t_has_valid_cover = false\n\n\n## Transition to SUPPRESSED state.\nfunc _transition_to_suppressed() -> void:\n\t_current_state = AIState.SUPPRESSED\n\t# Enter alarm mode when suppressed\n\t_in_alarm_mode = true\n\n\n## Transition to PURSUING state.\nfunc _transition_to_pursuing() -> void:\n\t_current_state = AIState.PURSUING\n\t_pursuit_cover_wait_timer = 0.0\n\t_has_pursuit_cover = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\n\n## Transition to ASSAULT state.\nfunc _transition_to_assault() -> void:\n\t_current_state = AIState.ASSAULT\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Find closest cover to player for assault position\n\t_find_cover_closest_to_player()\n\n\n## Transition to RETREATING state with appropriate retreat mode.\nfunc _transition_to_retreating() -> void:\n\t_current_state = AIState.RETREATING\n\t# Enter alarm mode when retreating\n\t_in_alarm_mode = true\n\n\t# Determine retreat mode based on hits taken\n\tif _hits_taken_in_encounter == 0:\n\t\t_retreat_mode = RetreatMode.FULL_HP\n\t\t_retreat_turn_timer = 0.0\n\t\t_retreat_turning_to_cover = false\n\t\t_log_debug(\"Entering RETREATING state: FULL_HP mode (shoot while backing up)\")\n\telif _hits_taken_in_encounter == 1:\n\t\t_retreat_mode = RetreatMode.ONE_HIT\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t# Calculate arc spread: shots will be distributed across the arc\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: ONE_HIT mode (burst of %d shots)\" % _retreat_burst_remaining)\n\telse:\n\t\t_retreat_mode = RetreatMode.MULTIPLE_HITS\n\t\t# Multiple hits also gets burst fire (same as ONE_HIT)\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: MULTIPLE_HITS mode (burst of %d shots)\" % _retreat_burst_remaining)\n\n\t# Find cover position for retreating\n\t_find_cover_position()\n\n\n## Check if the enemy is visible from the player's position.\n## Uses raycasting from player to enemy to determine if there are obstacles blocking line of sight.\n## This is the inverse of _can_see_player - it checks if the PLAYER can see the ENEMY.\n## Checks multiple points on the enemy body (center and corners) to account for enemy size.\nfunc _is_visible_from_player() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check visibility to multiple points on the enemy body\n\t# This accounts for the enemy's size - corners can stick out from cover\n\tvar check_points := _get_enemy_check_points(global_position)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Get multiple check points on the enemy body for visibility testing.\n## Returns center and 4 corner points offset by the enemy's radius.\nfunc _get_enemy_check_points(center: Vector2) -> Array[Vector2]:\n\t# Enemy collision radius is 24, sprite is 48x48\n\t# Use a slightly smaller radius to avoid edge cases\n\tconst ENEMY_RADIUS: float = 22.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := ENEMY_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point is visible from the player's position.\nfunc _is_point_visible_from_player(point: Vector2) -> bool:\n\tif _player == null:\n\t\treturn false\n\n\tvar player_pos := _player.global_position\n\tvar distance := player_pos.distance_to(point)\n\n\t# Use direct space state to check line of sight from player to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = player_pos\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = []\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between player and point - point is visible\n\t\treturn true\n\telse:\n\t\t# Check if we hit an obstacle before reaching the point\n\t\tvar hit_position: Vector2 = result[\"position\"]\n\t\tvar distance_to_hit := player_pos.distance_to(hit_position)\n\n\t\t# If we hit something closer than the point, the point is hidden\n\t\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t\treturn false\n\t\telse:\n\t\t\treturn true\n\n\n## Check if a specific position would make the enemy visible from the player's position.\n## Checks all enemy body points (center and corners) to account for enemy size.\n## Used to validate cover positions before moving to them.\nfunc _is_position_visible_from_player(pos: Vector2) -> bool:\n\tif _player == null:\n\t\treturn true  # Assume visible if no player\n\n\t# Check visibility for all enemy body points at the given position\n\tvar check_points := _get_enemy_check_points(pos)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Check if a target position is visible from the enemy's perspective.\n## Uses raycast to verify there are no obstacles between enemy and the target position.\n## This is used to validate lead prediction targets - enemies should only aim at\n## positions they can actually see.\nfunc _is_position_visible_to_enemy(target_pos: Vector2) -> bool:\n\tvar distance := global_position.distance_to(target_pos)\n\n\t# Use direct space state to check line of sight from enemy to target\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = target_pos\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and target - position is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t# Hit obstacle before target - position is NOT visible\n\t\t_log_debug(\"Position %s blocked by obstacle at distance %.1f (target at %.1f)\" % [target_pos, distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Get multiple check points on the player's body for visibility testing.\n## Returns center and 4 corner points offset by the player's radius.\n## The player has a collision radius of 16 pixels (from Player.tscn).\nfunc _get_player_check_points(center: Vector2) -> Array[Vector2]:\n\t# Player collision radius is 16, sprite is 32x32\n\t# Use a slightly smaller radius to be conservative\n\tconst PLAYER_RADIUS: float = 14.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := PLAYER_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point on the player is visible from the enemy's position.\n## Uses direct space state query to check for obstacles blocking line of sight.\nfunc _is_player_point_visible_to_enemy(point: Vector2) -> bool:\n\tvar distance := global_position.distance_to(point)\n\n\t# Use direct space state to check line of sight from enemy to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and point - point is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the point\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\t# If we hit something before the point, the point is blocked\n\tif distance_to_hit < distance - 5.0:  # 5 pixel tolerance\n\t\treturn false\n\n\treturn true\n\n\n## Calculate what fraction of the player's body is visible to the enemy.\n## Returns a value from 0.0 (completely hidden) to 1.0 (fully visible).\n## Checks multiple points on the player's body (center + corners).\nfunc _calculate_player_visibility_ratio() -> float:\n\tif _player == null:\n\t\treturn 0.0\n\n\tvar check_points := _get_player_check_points(_player.global_position)\n\tvar visible_count := 0\n\n\tfor point in check_points:\n\t\tif _is_player_point_visible_to_enemy(point):\n\t\t\tvisible_count += 1\n\n\treturn float(visible_count) / float(check_points.size())\n\n\n## Check if the line of fire to the target position is clear of other enemies.\n## Returns true if no other enemies would be hit by a bullet traveling to the target.\nfunc _is_firing_line_clear_of_friendlies(target_position: Vector2) -> bool:\n\tif not enable_friendly_fire_avoidance:\n\t\treturn true\n\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if any enemies are in the firing line\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 2  # Only check enemies (layer 2)\n\tquery.exclude = [get_rid()]  # Exclude self using RID\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No enemies in the way\n\n\t# Check if the hit position is before the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 20.0:  # 20 pixel tolerance\n\t\t_log_debug(\"Friendly in firing line at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if a bullet fired at the target position would be blocked by cover/obstacles.\n## Returns true if the shot would likely hit the target, false if blocked by cover.\nfunc _is_shot_clear_of_cover(target_position: Vector2) -> bool:\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if obstacles block the shot\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No obstacles in the way\n\n\t# Check if the obstacle is before the target position\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t_log_debug(\"Shot blocked by cover at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if there's an obstacle immediately in front of the enemy that would block bullets.\n## This prevents shooting into walls that the enemy is flush against or very close to.\n## Uses a single raycast from enemy center to the bullet spawn position.\nfunc _is_bullet_spawn_clear(direction: Vector2) -> bool:\n\t# Fail-open: allow shooting if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn true\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn true\n\n\t# Check from enemy center to bullet spawn position plus a small buffer\n\tvar check_distance := bullet_spawn_offset + 5.0\n\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = global_position + direction * check_distance\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]\n\n\tvar result := space_state.intersect_ray(query)\n\tif not result.is_empty():\n\t\t_log_debug(\"Bullet spawn blocked: wall at distance %.1f\" % [\n\t\t\tglobal_position.distance_to(result[\"position\"])])\n\t\treturn false\n\n\treturn true\n\n\n## Find a sidestep direction that would lead to a clear shot position.\n## Checks perpendicular directions to the player and returns the first one\n## that would allow the bullet spawn point to be clear.\n## Returns Vector2.ZERO if no clear direction is found.\nfunc _find_sidestep_direction_for_clear_shot(direction_to_player: Vector2) -> Vector2:\n\t# Fail-safe: allow normal behavior if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn Vector2.ZERO\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn Vector2.ZERO\n\n\t# Check perpendicular directions (left and right of the player direction)\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Check both sidestep directions and pick the one that leads to clear shot faster\n\tvar check_distance := 50.0  # Check if moving 50 pixels in this direction would help\n\tvar bullet_check_distance := bullet_spawn_offset + 5.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:  # Try both sides\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\n\t\t# First check if we can actually move in this direction (no wall blocking movement)\n\t\tvar move_query := PhysicsRayQueryParameters2D.new()\n\t\tmove_query.from = global_position\n\t\tmove_query.to = global_position + sidestep_dir * 30.0\n\t\tmove_query.collision_mask = 4  # Only check obstacles\n\t\tmove_query.exclude = [get_rid()]\n\n\t\tvar move_result := space_state.intersect_ray(move_query)\n\t\tif not move_result.is_empty():\n\t\t\tcontinue  # Can't move this way, wall is blocking\n\n\t\t# Check if after sidestepping, we'd have a clear shot\n\t\tvar test_position: Vector2 = global_position + sidestep_dir * check_distance\n\t\tvar shot_query := PhysicsRayQueryParameters2D.new()\n\t\tshot_query.from = test_position\n\t\tshot_query.to = test_position + direction_to_player * bullet_check_distance\n\t\tshot_query.collision_mask = 4\n\t\tshot_query.exclude = [get_rid()]\n\n\t\tvar shot_result := space_state.intersect_ray(shot_query)\n\t\tif shot_result.is_empty():\n\t\t\t# Found a direction that leads to a clear shot\n\t\t\t_log_debug(\"Found sidestep direction: %s\" % sidestep_dir)\n\t\t\treturn sidestep_dir\n\n\treturn Vector2.ZERO  # No clear sidestep direction found\n\n\n## Check if the enemy should shoot at the current target.\n## Validates bullet spawn clearance, friendly fire avoidance, and cover blocking.\nfunc _should_shoot_at_target(target_position: Vector2) -> bool:\n\t# Check if the immediate path to bullet spawn is clear\n\t# This prevents shooting into walls the enemy is flush against\n\tvar direction := (target_position - global_position).normalized()\n\tif not _is_bullet_spawn_clear(direction):\n\t\treturn false\n\n\t# Check if friendlies are in the way\n\tif not _is_firing_line_clear_of_friendlies(target_position):\n\t\treturn false\n\n\t# Check if cover blocks the shot\n\tif not _is_shot_clear_of_cover(target_position):\n\t\treturn false\n\n\treturn true\n\n\n## Check if the player is \"close\" (within CLOSE_COMBAT_DISTANCE).\n## Used to determine if the enemy should engage directly or pursue.\nfunc _is_player_close() -> bool:\n\tif _player == null:\n\t\treturn false\n\treturn global_position.distance_to(_player.global_position) <= CLOSE_COMBAT_DISTANCE\n\n\n## Check if the enemy can hit the player from their current position.\n## Returns true if there's a clear line of fire to the player.\nfunc _can_hit_player_from_current_position() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check if we can see the player\n\tif not _can_see_player:\n\t\treturn false\n\n\t# Check if the shot would be blocked by cover\n\treturn _is_shot_clear_of_cover(_player.global_position)\n\n\n## Count the number of enemies currently in combat-related states.\n## Includes COMBAT, PURSUING, ASSAULT, IN_COVER (if can see player).\n## Used to determine if multi-enemy assault should be triggered.\nfunc _count_enemies_in_combat() -> int:\n\tvar count := 0\n\tvar enemies := get_tree().get_nodes_in_group(\"enemies\")\n\n\tfor enemy in enemies:\n\t\tif enemy == self:\n\t\t\tcontinue\n\t\tif not enemy.has_method(\"get_current_state\"):\n\t\t\tcontinue\n\n\t\tvar state: AIState = enemy.get_current_state()\n\t\t# Count enemies in combat-related states\n\t\tif state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\t\t# For IN_COVER, only count if they can see the player\n\t\t\tif state == AIState.IN_COVER:\n\t\t\t\tif enemy.has_method(\"is_in_combat_engagement\") and enemy.is_in_combat_engagement():\n\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tcount += 1\n\n\t# Count self if in a combat-related state\n\tif _current_state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\tcount += 1\n\n\treturn count\n\n\n## Check if this enemy is engaged in combat (can see player and in combat state).\nfunc is_in_combat_engagement() -> bool:\n\treturn _can_see_player and _current_state in [AIState.COMBAT, AIState.IN_COVER, AIState.ASSAULT]\n\n\n## Find cover position closer to the player for pursuit.\n## Used during PURSUING state to move cover-to-cover toward the player.\nfunc _find_pursuit_cover_toward_player() -> void:\n\tif _player == null:\n\t\t_has_pursuit_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For pursuit, we want cover that is:\n\t\t\t# 1. Closer to the player than we currently are\n\t\t\t# 2. Hidden from the player (or mostly hidden)\n\t\t\t# 3. Not too far from our current position\n\n\t\t\tvar my_distance_to_player := global_position.distance_to(player_pos)\n\t\t\tvar cover_distance_to_player := cover_pos.distance_to(player_pos)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to player\n\t\t\tif cover_distance_to_player >= my_distance_to_player:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if this position is hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Hidden from player (priority)\n\t\t\t# - Closer to player\n\t\t\t# - Not too far from current position\n\t\t\tvar hidden_score: float = 5.0 if is_hidden else 0.0\n\t\t\tvar approach_score: float = (my_distance_to_player - cover_distance_to_player) / CLOSE_COMBAT_DISTANCE\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = hidden_score + approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_pursuit_next_cover = best_cover\n\t\t_has_pursuit_cover = true\n\t\t_log_debug(\"Found pursuit cover at %s (score: %.2f)\" % [_pursuit_next_cover, best_score])\n\telse:\n\t\t_has_pursuit_cover = false\n\n\n## Find cover position closest to the player for assault positioning.\n## Used during ASSAULT state to take the nearest safe cover to the player.\nfunc _find_cover_closest_to_player() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_distance: float = INF\n\tvar found_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# Check if this position is hidden from player (safe cover)\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\tif is_hidden:\n\t\t\t\t# Calculate distance from this cover to the player\n\t\t\t\tvar distance_to_player := cover_pos.distance_to(player_pos)\n\n\t\t\t\t# We want the cover closest to the player\n\t\t\t\tif distance_to_player < best_distance:\n\t\t\t\t\tbest_distance = distance_to_player\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\t\tfound_cover = true\n\n\tif found_cover:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found assault cover at %s (distance to player: %.1f)\" % [_cover_position, best_distance])\n\telse:\n\t\t# Fall back to normal cover finding\n\t\t_find_cover_position()\n\n\n## Find a valid cover position relative to the player.\n## The cover position must be hidden from the player's line of sight.\nfunc _find_cover_position() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_hidden_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is on the opposite side of the obstacle from player\n\t\t\tvar direction_from_player := (collision_point - player_pos).normalized()\n\n\t\t\t# Position behind cover (offset from collision point along normal)\n\t\t\t# Offset must be large enough to hide the entire enemy body (radius ~24 pixels)\n\t\t\t# Using 35 pixels to provide some margin for the enemy's collision shape\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# First priority: Check if this position is actually hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Only consider hidden positions unless we have no choice\n\t\t\tif is_hidden or not found_hidden_cover:\n\t\t\t\t# Score based on:\n\t\t\t\t# 1. Whether position is hidden (highest priority)\n\t\t\t\t# 2. Distance from enemy (closer is better)\n\t\t\t\t# 3. Position relative to player (behind cover from player's view)\n\t\t\t\tvar hidden_score: float = 10.0 if is_hidden else 0.0  # Heavy weight for hidden positions\n\n\t\t\t\tvar distance_score := 1.0 - (global_position.distance_to(cover_pos) / COVER_CHECK_DISTANCE)\n\n\t\t\t\t# Check if this position is on the far side of obstacle from player\n\t\t\t\tvar cover_direction := (cover_pos - player_pos).normalized()\n\t\t\t\tvar dot_product := direction_from_player.dot(cover_direction)\n\t\t\t\tvar blocking_score: float = maxf(0.0, dot_product)\n\n\t\t\t\tvar total_score: float = hidden_score + distance_score * 0.3 + blocking_score * 0.7\n\n\t\t\t\t# If we find a hidden position, only accept other hidden positions\n\t\t\t\tif is_hidden and not found_hidden_cover:\n\t\t\t\t\tfound_hidden_cover = true\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\telif (is_hidden or not found_hidden_cover) and total_score > best_score:\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\n\tif best_score > 0:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found cover at: %s (hidden: %s)\" % [_cover_position, found_hidden_cover])\n\telse:\n\t\t_has_valid_cover = false\n\n\n## Calculate flank position based on player location.\nfunc _calculate_flank_position() -> void:\n\tif _player == null:\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar player_to_enemy := (global_position - player_pos).normalized()\n\n\t# Choose left or right flank based on current position\n\tvar flank_side := 1.0 if randf() > 0.5 else -1.0\n\tvar flank_direction := player_to_enemy.rotated(flank_angle * flank_side)\n\n\t_flank_target = player_pos + flank_direction * flank_distance\n\t_log_debug(\"Flank target: %s\" % _flank_target)\n\n\n## Check if there's a clear path (no obstacles) to the target position.\n## Uses a raycast to check for walls/obstacles between current position and target.\nfunc _has_clear_path_to(target: Vector2) -> bool:\n\tif _raycast == null:\n\t\treturn true  # Assume clear if no raycast available\n\n\tvar direction := (target - global_position).normalized()\n\tvar distance := global_position.distance_to(target)\n\n\t_raycast.target_position = direction * distance\n\t_raycast.force_raycast_update()\n\n\t# If we hit something, path is blocked\n\tif _raycast.is_colliding():\n\t\tvar collision_point := _raycast.get_collision_point()\n\t\tvar collision_distance := global_position.distance_to(collision_point)\n\t\t# Only consider it blocked if the collision is before the target\n\t\treturn collision_distance >= distance - 10.0\n\n\treturn true\n\n\n## Find cover position closer to the flank target.\n## Used during FLANKING state to move cover-to-cover toward the flank position.\nfunc _find_flank_cover_toward_target() -> void:\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For flanking, we want cover that is:\n\t\t\t# 1. Closer to the flank target than we currently are\n\t\t\t# 2. Not too far from our current position\n\t\t\t# 3. Reachable (has clear path)\n\n\t\t\tvar my_distance_to_target := global_position.distance_to(_flank_target)\n\t\t\tvar cover_distance_to_target := cover_pos.distance_to(_flank_target)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to flank target\n\t\t\tif cover_distance_to_target >= my_distance_to_ta
[2026-01-18T02:52:45.074Z] [INFO] rget:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if we can reach this cover (has clear path)\n\t\t\tif not _has_clear_path_to(cover_pos):\n\t\t\t\t# Even if direct path is blocked, we might be able to reach\n\t\t\t\t# via another intermediate cover, but skip for now\n\t\t\t\tcontinue\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Closer to flank target (priority)\n\t\t\t# - Not too far from current position\n\t\t\tvar approach_score: float = (my_distance_to_target - cover_distance_to_target) / flank_distance\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_flank_next_cover = best_cover\n\t\t_has_flank_cover = true\n\t\t_log_debug(\"Found flank cover at %s (score: %.2f)\" % [_flank_next_cover, best_score])\n\telse:\n\t\t_has_flank_cover = false\n\n\n## Check if there's a wall ahead in the given direction and return avoidance direction.\n## Returns Vector2.ZERO if no wall detected, otherwise returns a vector to avoid the wall.\nfunc _check_wall_ahead(direction: Vector2) -> Vector2:\n\tif _wall_raycasts.is_empty():\n\t\treturn Vector2.ZERO\n\n\tvar avoidance := Vector2.ZERO\n\tvar perpendicular := Vector2(-direction.y, direction.x)  # 90 degrees rotation\n\n\t# Check center, left, and right raycasts\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar angle_offset := (i - 1) * 0.5  # -0.5, 0, 0.5 radians (~-28, 0, 28 degrees)\n\t\tvar check_direction := direction.rotated(angle_offset)\n\n\t\tvar raycast := _wall_raycasts[i]\n\t\traycast.target_position = check_di
[2026-01-18T02:52:45.077Z] [INFO] rection * WALL_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\t# Calculate avoidance based on which raycast hit\n\t\t\tif i == 0:  # Left raycast hit\n\t\t\t\tavoidance += perpendicular  # Steer right\n\t\t\telif i == 1:  # Center raycast hit\n\t\t\t\tavoidance += perpendicular if randf() > 0.5 else -perpendicular  # Random steer\n\t\t\telif i == 2:  # Right raycast hit\n\t\t\t\tavoidance -= perpendicular  # Steer left\n\n\treturn avoidance.normalized() if avoidance.length() > 0 else Vector2.ZERO\n\n\n## Check if the player is visible using raycast.\n## If detection_range is 0 or negative, uses unlimited detection range (line-of-sight only).\n## This allows the enemy to see the player even outside the viewport if there's no obstacle.\n## Also updates the continuous visibility timer and visibility ratio for lead prediction control.\nfunc _check_player_visibility() -> void:\n\tvar was_visible := _can_see_player\n\t_can_see_player = false\n\t_player_visibility_ratio = 0.0\n\n\tif _player == null or not _raycast:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t# Check if player is within detection range (only if detection_range is positive)\n\t# If detection_range <= 0, detection is unlimited (line-of-sight only)\n\tif detection_range > 0 and distance_to_player > detection_range:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\t# Point raycast at player - use actual distance to player for the raycast length\n\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\tvar raycast_length := distance_to_player + 10.0  # Add small buffer to ensure we reach player\n\t_raycast.target_position = direction_to_player * raycast_length\n\t_raycast.force_raycast_update()\n\n\t# Check if raycast hit something\n\tif _raycast.is_colliding():\n\t\tvar collider := _raycast.get_collider()\n\t\t# If we hit the player, we can see them\n\t\tif collider == _player:\n\t\t\t_can_see_player = true\n\t\t# If we hit a wall/obstacle before the player, we can't see them\n\telse:\n\t\t# No collision between us and player - we have clear line of sight\n\t\t_can_see_player = true\n\n\t# Update continuous visibility timer and visibility ratio\n\tif _can_see_player:\n\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n\t\t# Calculate what fraction of the player's body is visible\n\t\t# This is used to determine if lead prediction should be enabled\n\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n\telse:\n\t\t# Lost line of sight - reset the timer and visibility ratio\n\t\t_continuous_visibility_timer = 0.0\n\t\t_player_visibility_ratio = 0.0\n\n\n## Aim the enemy sprite/direction at the player using gradual rotation.\nfunc _aim_at_player() -> void:\n\tif _player == null:\n\t\treturn\n\tvar direction := (_player.global_position - global_position).normalized()\n\tvar target_angle := direction.angle()\n\n\t# Calculate the shortest rotation direction\n\tvar angle_diff := wrapf(target_angle - rotation, -PI, PI)\n\n\t# Get the delta time from the current physics process\n\tvar delta := get_physics_process_delta_time()\n\n\t# Apply gradual rotation based on rotation_speed\n\tif abs(angle_diff) <= rotation_speed * delta:\n\t\t# Close enough to snap to target\n\t\trotation = target_angle\n\telif angle_diff > 0:\n\t\trotation += rotation_speed * delta\n\telse:\n\t\trotation -= rotation_speed * delta\n\n\n## Shoot a bullet towards the player.\nfunc _shoot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\t# Check if we can shoot (have ammo and not reloading)\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Apply lead prediction if enabled\n\tif enable_lead_prediction:\n\t\ttarget_position = _calculate_lead_prediction()\n\n\t# Check if the shot should be taken (friendly fire and cover checks)\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Create bullet instance\n\tvar bullet := bullet_scene.instantiate()\n\n\t# Set bullet position with offset in shoot direction\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\n\t# Set bullet direction\n\tbullet.direction = direction\n\n\t# Set shooter ID to identify this enemy as the source\n\t# This prevents enemies from detecting their own bullets in the threat sphere\n\tbullet.shooter_id = get_instance_id()\n\n\t# Add bullet to the scene tree\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play shooting sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\n\t# Play shell casing sound with a small delay\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\t# Auto-reload when magazine is empty\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Play shell casing sound with a delay to simulate the casing hitting the ground.\nfunc _play_delayed_shell_sound() -> void:\n\tawait get_tree().create_timer(0.15).timeout\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_shell_rifle\"):\n\t\taudio_manager.play_shell_rifle(global_position)\n\n\n## Calculate lead prediction - aims where the player will be, not where they are.\n## Uses iterative approach for better accuracy with moving targets.\n## Only applies lead prediction if:\n## 1. The player has been continuously visible for at least lead_prediction_delay seconds\n## 2. At least lead_prediction_visibility_threshold of the player's body is visible\n## 3. The predicted position is also visible to the enemy (not behind cover)\n## This prevents enemies from \"knowing\" where the player will emerge from cover.\nfunc _calculate_lead_prediction() -> Vector2:\n\tif _player == null:\n\t\treturn global_position\n\n\tvar player_pos := _player.global_position\n\n\t# Only use lead prediction if the player has been continuously visible\n\t# for long enough. This prevents enemies from predicting player position\n\t# immediately when they emerge from cover.\n\tif _continuous_visibility_timer < lead_prediction_delay:\n\t\t_log_debug(\"Lead prediction disabled: visibility time %.2fs < %.2fs required\" % [_continuous_visibility_timer, lead_prediction_delay])\n\t\treturn player_pos\n\n\t# Only use lead prediction if enough of the player's body is visible.\n\t# This prevents pre-firing when the player is at the edge of cover with only\n\t# a small part of their body visible. The player must be significantly exposed\n\t# before the enemy can predict their movement.\n\tif _player_visibility_ratio < lead_prediction_visibility_threshold:\n\t\t_log_debug(\"Lead prediction disabled: visibility ratio %.2f < %.2f required (player at cover edge)\" % [_player_visibility_ratio, lead_prediction_visibility_threshold])\n\t\treturn player_pos\n\n\tvar player_velocity := Vector2.ZERO\n\n\t# Get player velocity if they are a CharacterBody2D\n\tif _player is CharacterBody2D:\n\t\tplayer_velocity = _player.velocity\n\n\t# If player is stationary, no need for prediction\n\tif player_velocity.length_squared() < 1.0:\n\t\treturn player_pos\n\n\t# Iterative lead prediction for better accuracy\n\t# Start with player's current position\n\tvar predicted_pos := player_pos\n\tvar distance := global_position.distance_to(predicted_pos)\n\n\t# Iterate 2-3 times for convergence\n\tfor i in range(3):\n\t\t# Time for bullet to reach the predicted position\n\t\tvar time_to_target := distance / bullet_speed\n\n\t\t# Predict where player will be at that time\n\t\tpredicted_pos = player_pos + player_velocity * time_to_target\n\n\t\t# Update distance for next iteration\n\t\tdistance = global_position.distance_to(predicted_pos)\n\n\t# CRITICAL: Validate that the predicted position is actually visible to the enemy.\n\t# If the predicted position is behind cover (e.g., player is running toward cover exit),\n\t# we should NOT aim there - it would feel like the enemy is \"cheating\" by knowing\n\t# where the player will emerge. Fall back to player's current visible position.\n\tif not _is_position_visible_to_enemy(predicted_pos):\n\t\t_log_debug(\"Lead prediction blocked: predicted position %s is not visible, using current position %s\" % [predicted_pos, player_pos])\n\t\treturn player_pos\n\n\t_log_debug(\"Lead prediction: player at %s moving %s, aiming at %s\" % [player_pos, player_velocity, predicted_pos])\n\n\treturn predicted_pos\n\n\n## Process patrol behavior - move between patrol points.\nfunc _process_patrol(delta: float) -> void:\n\tif _patrol_points.is_empty():\n\t\treturn\n\n\t# Handle waiting at patrol point\n\tif _is_waiting_at_patrol_point:\n\t\t_patrol_wait_timer += delta\n\t\tif _patrol_wait_timer >= patrol_wait_time:\n\t\t\t_is_waiting_at_patrol_point = false\n\t\t\t_patrol_wait_timer = 0.0\n\t\t\t_current_patrol_index = (_current_patrol_index + 1) % _patrol_points.size()\n\t\tvelocity = Vector2.ZERO\n\t\treturn\n\n\t# Move towards current patrol point\n\tvar target_point := _patrol_points[_current_patrol_index]\n\tvar direction := (target_point - global_position).normalized()\n\tvar distance := global_position.distance_to(target_point)\n\n\tif distance < 5.0:\n\t\t# Reached patrol point, start waiting\n\t\t_is_waiting_at_patrol_point = true\n\t\tvelocity = Vector2.ZERO\n\telse:\n\t\t# Check for walls and apply avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\t# Blend movement direction with avoidance\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * move_speed\n\t\t# Face movement direction when patrolling\n\t\trotation = direction.angle()\n\n\n## Process guard behavior - stand still and look around.\nfunc _process_guard(_delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\t# In guard mode, enemy doesn't move but can still aim at player when visible\n\n\n## Called when a bullet enters the threat sphere.\nfunc _on_threat_area_entered(area: Area2D) -> void:\n\t# Check if bullet has shooter_id property and if it's from this enemy\n\t# This prevents enemies from being suppressed by their own bullets\n\tif \"shooter_id\" in area and area.shooter_id == get_instance_id():\n\t\treturn  # Ignore own bullets\n\n\t_bullets_in_threat_sphere.append(area)\n\t# Set threat memory timer so enemy can react even after fast bullets exit\n\t# This allows the reaction delay to complete even if bullets pass through quickly\n\t_threat_memory_timer = THREAT_MEMORY_DURATION\n\t# Note: _under_fire is now set in _update_suppression after threat_reaction_delay\n\t# This gives the player more time before the enemy reacts to nearby gunfire\n\t_log_debug(\"Bullet entered threat sphere, starting reaction delay...\")\n\n\n## Called when a bullet exits the threat sphere.\nfunc _on_threat_area_exited(area: Area2D) -> void:\n\t_bullets_in_threat_sphere.erase(area)\n\n\n## Called when the enemy is hit (by bullet.gd).\nfunc on_hit() -> void:\n\tif not _is_alive:\n\t\treturn\n\n\thit.emit()\n\n\t# Track hits for retreat behavior\n\t_hits_taken_in_encounter += 1\n\t_log_debug(\"Hit taken! Total hits in encounter: %d\" % _hits_taken_in_encounter)\n\t_log_to_file(\"Hit taken, health: %d/%d\" % [_current_health - 1, _max_health])\n\n\t# Show hit flash effect\n\t_show_hit_flash()\n\n\t# Apply damage\n\t_current_health -= 1\n\n\t# Play appropriate hit sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif _current_health <= 0:\n\t\t# Play lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_lethal\"):\n\t\t\taudio_manager.play_hit_lethal(global_position)\n\t\t_on_death()\n\telse:\n\t\t# Play non-lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_non_lethal\"):\n\t\t\taudio_manager.play_hit_non_lethal(global_position)\n\t\t_update_health_visual()\n\n\n## Shows a brief flash effect when hit.\nfunc _show_hit_flash() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t_sprite.modulate = hit_flash_color\n\n\tawait get_tree().create_timer(hit_flash_duration).timeout\n\n\t# Restore color based on current health (if still alive)\n\tif _is_alive:\n\t\t_update_health_visual()\n\n\n## Updates the sprite color based on current health percentage.\nfunc _update_health_visual() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t# Interpolate color based on health percentage\n\tvar health_percent := _get_health_percent()\n\t_sprite.modulate = full_health_color.lerp(low_health_color, 1.0 - health_percent)\n\n\n## Returns the current health as a percentage (0.0 to 1.0).\nfunc _get_health_percent() -> float:\n\tif _max_health <= 0:\n\t\treturn 0.0\n\treturn float(_current_health) / float(_max_health)\n\n\n## Called when the enemy dies.\nfunc _on_death() -> void:\n\t_is_alive = false\n\t_log_to_file(\"Enemy died\")\n\tdied.emit()\n\n\tif destroy_on_death:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\tqueue_free()\n\telse:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\t_reset()\n\n\n## Resets the enemy to its initial state.\nfunc _reset() -> void:\n\tglobal_position = _initial_position\n\trotation = 0.0\n\t_current_patrol_index = 0\n\t_is_waiting_at_patrol_point = false\n\t_patrol_wait_timer = 0.0\n\t_current_state = AIState.IDLE\n\t_has_valid_cover = false\n\t_under_fire = false\n\t_suppression_timer = 0.0\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t_continuous_visibility_timer = 0.0\n\t_player_visibility_ratio = 0.0\n\t_threat_reaction_timer = 0.0\n\t_threat_reaction_delay_elapsed = false\n\t_threat_memory_timer = 0.0\n\t_bullets_in_threat_sphere.clear()\n\t# Reset retreat state variables\n\t_hits_taken_in_encounter = 0\n\t_retreat_mode = RetreatMode.FULL_HP\n\t_retreat_turn_timer = 0.0\n\t_retreat_turning_to_cover = false\n\t_retreat_burst_remaining = 0\n\t_retreat_burst_timer = 0.0\n\t_retreat_burst_complete = false\n\t_retreat_burst_angle_offset = 0.0\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\t# Reset combat state variables\n\t_combat_shoot_timer = 0.0\n\t_combat_shoot_duration = 2.5\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_approach_timer = 0.0\n\t# Reset pursuit state variables\n\t_pursuit_cover_wait_timer = 0.0\n\t_pursuit_next_cover = Vector2.ZERO\n\t_has_pursuit_cover = false\n\t# Reset assault state variables\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset flank state variables\n\t_flank_cover_wait_timer = 0.0\n\t_flank_next_cover = Vector2.ZERO\n\t_has_flank_cover = false\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_initialize_goap_state()\n\n\n## Log debug message if debug_logging is enabled.\nfunc _log_debug(message: String) -> void:\n\tif debug_logging:\n\t\tprint(\"[Enemy %s] %s\" % [name, message])\n\n\n## Log a message to the file logger (always logs, regardless of debug_logging setting).\n## Use for important events like spawning, dying, or critical state changes.\nfunc _log_to_file(message: String) -> void:\n\tif not is_inside_tree():\n\t\treturn\n\tvar file_logger: Node = get_node_or_null(\"/root/FileLogger\")\n\tif file_logger and file_logger.has_method(\"log_enemy\"):\n\t\tfile_logger.log_enemy(name, message)\n\n\n## Log spawn info (called via call_deferred to ensure FileLogger is loaded).\nfunc _log_spawn_info() -> void:\n\t_log_to_file(\"Enemy spawned at %s, health: %d, behavior: %s, player_found: %s\" % [\n\t\tglobal_position, _max_health, BehaviorMode.keys()[behavior_mode],\n\t\t\"yes\" if _player != null else \"no\"])\n\n\n## Get AI state name as a human-readable string.\nfunc _get_state_name(state: AIState) -> String:\n\tmatch state:\n\t\tAIState.IDLE:\n\t\t\treturn \"IDLE\"\n\t\tAIState.COMBAT:\n\t\t\treturn \"COMBAT\"\n\t\tAIState.SEEKING_COVER:\n\t\t\treturn \"SEEKING_COVER\"\n\t\tAIState.IN_COVER:\n\t\t\treturn \"IN_COVER\"\n\t\tAIState.FLANKING:\n\t\t\treturn \"FLANKING\"\n\t\tAIState.SUPPRESSED:\n\t\t\treturn \"SUPPRESSED\"\n\t\tAIState.RETREATING:\n\t\t\treturn \"RETREATING\"\n\t\tAIState.PURSUING:\n\t\t\treturn \"PURSUING\"\n\t\tAIState.ASSAULT:\n\t\t\treturn \"ASSAULT\"\n\t\t_:\n\t\t\treturn \"UNKNOWN\"\n\n\n## Update the debug label with current AI state.\nfunc _update_debug_label() -> void:\n\tif _debug_label == null:\n\t\treturn\n\n\t_debug_label.visible = debug_label_enabled\n\tif not debug_label_enabled:\n\t\treturn\n\n\tvar state_text := _get_state_name(_current_state)\n\n\t# Add retreat mode info if retreating\n\tif _current_state == AIState.RETREATING:\n\t\tmatch _retreat_mode:\n\t\t\tRetreatMode.FULL_HP:\n\t\t\t\tstate_text += \"\\n(FULL_HP)\"\n\t\t\tRetreatMode.ONE_HIT:\n\t\t\t\tstate_text += \"\\n(ONE_HIT)\"\n\t\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t\tstate_text += \"\\n(MULTI_HITS)\"\n\n\t# Add assault timer info if in assault state\n\tif _current_state == AIState.ASSAULT:\n\t\tif _assault_ready:\n\t\t\tstate_text += \"\\n(RUSHING)\"\n\t\telse:\n\t\t\tvar time_left := ASSAULT_WAIT_DURATION - _assault_wait_timer\n\t\t\tstate_text += \"\\n(%.1fs)\" % time_left\n\n\t# Add combat phase info if in combat\n\tif _current_state == AIState.COMBAT:\n\t\tif _combat_exposed:\n\t\t\tvar time_left := _combat_shoot_duration - _combat_shoot_timer\n\t\t\tstate_text += \"\\n(EXPOSED %.1fs)\" % time_left\n\t\telif _seeking_clear_shot:\n\t\t\tvar time_left := CLEAR_SHOT_MAX_TIME - _clear_shot_timer\n\t\t\tstate_text += \"\\n(SEEK SHOT %.1fs)\" % time_left\n\t\telif _combat_approaching:\n\t\t\tstate_text += \"\\n(APPROACH)\"\n\n\t# Add pursuit timer info if pursuing and waiting at cover\n\tif _current_state == AIState.PURSUING:\n\t\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t\tvar time_left := PURSUIT_COVER_WAIT_DURATION - _pursuit_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_pursuit_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\n\t# Add flanking phase info if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_valid_cover and not _has_flank_cover:\n\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_flank_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\t\telse:\n\t\t\tstate_text += \"\\n(DIRECT)\"\n\n\t_debug_label.text = state_text\n\n\n## Get current AI state (for external access/debugging).\nfunc get_current_state() -> AIState:\n\treturn _current_state\n\n\n## Get GOAP world state (for GOAP planner).\nfunc get_goap_world_state() -> Dictionary:\n\treturn _goap_world_state.duplicate()\n\n\n## Check if enemy is currently under fire.\nfunc is_under_fire() -> bool:\n\treturn _under_fire\n\n\n## Check if enemy is in cover.\nfunc is_in_cover() -> bool:\n\treturn _current_state == AIState.IN_COVER or _current_state == AIState.SUPPRESSED\n\n\n## Get current ammo in magazine.\nfunc get_current_ammo() -> int:\n\treturn _current_ammo\n\n\n## Get reserve ammo.\nfunc get_reserve_ammo() -> int:\n\treturn _reserve_ammo\n\n\n## Get total ammo (current + reserve).\nfunc get_total_ammo() -> int:\n\treturn _current_ammo + _reserve_ammo\n\n\n## Check if enemy is currently reloading.\nfunc is_reloading() -> bool:\n\treturn _is_reloading\n\n\n## Check if enemy has any ammo left.\nfunc has_ammo() -> bool:\n\treturn _current_ammo > 0 or _reserve_ammo > 0\n\n\n## Get current player visibility ratio (for debugging).\n## Returns 0.0 if player is completely hidden, 1.0 if fully visible.\nfunc get_player_visibility_ratio() -> float:\n\treturn _player_visibility_ratio\n\n\n## Draw debug visualization when debug mode is enabled.\n## Shows: line to target (cover, clear shot, player), bullet spawn point status.\nfunc _draw() -> void:\n\tif not debug_label_enabled:\n\t\treturn\n\n\t# Colors for different debug elements\n\tvar color_to_cover := Color.CYAN  # Line to cover position\n\tvar color_to_player := Color.RED  # Line to player (when visible)\n\tvar color_clear_shot := Color.YELLOW  # Line to clear shot target\n\tvar color_pursuit := Color.ORANGE  # Line to pursuit cover\n\tvar color_flank := Color.MAGENTA  # Line to flank position\n\tvar color_bullet_spawn := Color.GREEN  # Bullet spawn point indicator\n\tvar color_blocked := Color.RED  # Blocked path indicator\n\n\t# Draw line to player if visible\n\tif _can_see_player and _player:\n\t\tvar to_player := _player.global_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_player, color_to_player, 1.5)\n\n\t\t# Draw bullet spawn point and check if blocked\n\t\tvar direction_to_player := to_player.normalized()\n\t\tvar spawn_point := direction_to_player * bullet_spawn_offset\n\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\tdraw_circle(spawn_point, 5.0, color_bullet_spawn)\n\t\telse:\n\t\t\t# Draw X for blocked spawn point\n\t\t\tdraw_line(spawn_point + Vector2(-5, -5), spawn_point + Vector2(5, 5), color_blocked, 2.0)\n\t\t\tdraw_line(spawn_point + Vector2(-5, 5), spawn_point + Vector2(5, -5), color_blocked, 2.0)\n\n\t# Draw line to cover position if we have one\n\tif _has_valid_cover:\n\t\tvar to_cover := _cover_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_cover, color_to_cover, 1.5)\n\t\t# Draw small circle at cover position\n\t\tdraw_circle(to_cover, 8.0, color_to_cover)\n\n\t# Draw line to clear shot target if seeking clear shot\n\tif _seeking_clear_shot and _clear_shot_target != Vector2.ZERO:\n\t\tvar to_target := _clear_shot_target - global_position\n\t\tdraw_line(Vector2.ZERO, to_target, color_clear_shot, 2.0)\n\t\t# Draw triangle at target position\n\t\tvar target_pos := to_target\n\t\tdraw_line(target_pos + Vector2(-6, 6), target_pos + Vector2(6, 6), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(6, 6), target_pos + Vector2(0, -8), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(0, -8), target_pos + Vector2(-6, 6), color_clear_shot, 2.0)\n\n\t# Draw line to pursuit cover if pursuing\n\tif _current_state == AIState.PURSUING and _has_pursuit_cover:\n\t\tvar to_pursuit := _pursuit_next_cover - global_position\n\t\tdraw_line(Vector2.ZERO, to_pursuit, color_pursuit, 2.0)\n\t\tdraw_circle(to_pursuit, 8.0, color_pursuit)\n\n\t# Draw line to flank target if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_flank_cover:\n\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n\t\telif _flank_target != Vector2.ZERO:\n\t\t\tvar to_flank := _flank_target - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n\t\t\t# Draw diamond at flank target\n\t\t\tvar flank_pos := to_flank\n\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)\n","structuredPatch":[{"oldStart":798,"oldLines":6,"newStart":798,"newLines":8,"lines":["       _process_pursuing_state(delta)","     AIState.ASSAULT:","       _process_assault_state(delta)","+    AIState.SEARCHING:","+      _process_searching_state(delta)"," ","   if previous_state != _current_state:","     state_changed.emit(_current_state)"]}],"userModified":false,"replaceAll":false}}
[2026-01-18T02:52:47.658Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_019RUJsxjhQyuxVkg42woSfk",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now I need to update the player visibility check to track the last-known position. Let me find that function:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 1120,
      "cache_read_input_tokens": 111329,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1120,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 2,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "439197e8-1d16-4555-9c68-830e023693ce"
}
[2026-01-18T02:52:48.716Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_019RUJsxjhQyuxVkg42woSfk",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01FvfLE8eJehZcQYmRzj3U5N",
        "name": "Grep",
        "input": {
          "pattern": "func _check_player_visibility",
          "path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "output_mode": "content",
          "-n": true
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 1120,
      "cache_read_input_tokens": 111329,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1120,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 2,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "c1e1c73f-b5d8-4090-9390-fd931150ef0a"
}
[2026-01-18T02:52:48.777Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01FvfLE8eJehZcQYmRzj3U5N",
        "type": "tool_result",
        "content": "2634:func _check_player_visibility() -> void:"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "2fcd0e5a-e978-40a9-a7ad-3265aa317c65",
  "tool_use_result": {
    "mode": "content",
    "numFiles": 0,
    "filenames": [],
    "content": "2634:func _check_player_visibility() -> void:",
    "numLines": 1
  }
}
[2026-01-18T02:52:51.988Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01UohYQdmMNTTZ1dXHMpjMyX",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01EToVD2f62M7gxp5k8cX86h",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "offset": 2634,
          "limit": 70
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 183,
      "cache_read_input_tokens": 112449,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 183,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 25,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "0284c167-7161-415f-9e35-147cbe77b6bf"
}
[2026-01-18T02:52:52.048Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01EToVD2f62M7gxp5k8cX86h",
        "type": "tool_result",
        "content": "  2634‚Üífunc _check_player_visibility() -> void:\n  2635‚Üí\tvar was_visible := _can_see_player\n  2636‚Üí\t_can_see_player = false\n  2637‚Üí\t_player_visibility_ratio = 0.0\n  2638‚Üí\n  2639‚Üí\tif _player == null or not _raycast:\n  2640‚Üí\t\t_continuous_visibility_timer = 0.0\n  2641‚Üí\t\treturn\n  2642‚Üí\n  2643‚Üí\tvar distance_to_player := global_position.distance_to(_player.global_position)\n  2644‚Üí\n  2645‚Üí\t# Check if player is within detection range (only if detection_range is positive)\n  2646‚Üí\t# If detection_range <= 0, detection is unlimited (line-of-sight only)\n  2647‚Üí\tif detection_range > 0 and distance_to_player > detection_range:\n  2648‚Üí\t\t_continuous_visibility_timer = 0.0\n  2649‚Üí\t\treturn\n  2650‚Üí\n  2651‚Üí\t# Point raycast at player - use actual distance to player for the raycast length\n  2652‚Üí\tvar direction_to_player := (_player.global_position - global_position).normalized()\n  2653‚Üí\tvar raycast_length := distance_to_player + 10.0  # Add small buffer to ensure we reach player\n  2654‚Üí\t_raycast.target_position = direction_to_player * raycast_length\n  2655‚Üí\t_raycast.force_raycast_update()\n  2656‚Üí\n  2657‚Üí\t# Check if raycast hit something\n  2658‚Üí\tif _raycast.is_colliding():\n  2659‚Üí\t\tvar collider := _raycast.get_collider()\n  2660‚Üí\t\t# If we hit the player, we can see them\n  2661‚Üí\t\tif collider == _player:\n  2662‚Üí\t\t\t_can_see_player = true\n  2663‚Üí\t\t# If we hit a wall/obstacle before the player, we can't see them\n  2664‚Üí\telse:\n  2665‚Üí\t\t# No collision between us and player - we have clear line of sight\n  2666‚Üí\t\t_can_see_player = true\n  2667‚Üí\n  2668‚Üí\t# Update continuous visibility timer and visibility ratio\n  2669‚Üí\tif _can_see_player:\n  2670‚Üí\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n  2671‚Üí\t\t# Calculate what fraction of the player's body is visible\n  2672‚Üí\t\t# This is used to determine if lead prediction should be enabled\n  2673‚Üí\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n  2674‚Üí\telse:\n  2675‚Üí\t\t# Lost line of sight - reset the timer and visibility ratio\n  2676‚Üí\t\t_continuous_visibility_timer = 0.0\n  2677‚Üí\t\t_player_visibility_ratio = 0.0\n  2678‚Üí\n  2679‚Üí\n  2680‚Üí## Aim the enemy sprite/direction at the player using gradual rotation.\n  2681‚Üífunc _aim_at_player() -> void:\n  2682‚Üí\tif _player == null:\n  2683‚Üí\t\treturn\n  2684‚Üí\tvar direction := (_player.global_position - global_position).normalized()\n  2685‚Üí\tvar target_angle := direction.angle()\n  2686‚Üí\n  2687‚Üí\t# Calculate the shortest rotation direction\n  2688‚Üí\tvar angle_diff := wrapf(target_angle - rotation, -PI, PI)\n  2689‚Üí\n  2690‚Üí\t# Get the delta time from the current physics process\n  2691‚Üí\tvar delta := get_physics_process_delta_time()\n  2692‚Üí\n  2693‚Üí\t# Apply gradual rotation based on rotation_speed\n  2694‚Üí\tif abs(angle_diff) <= rotation_speed * delta:\n  2695‚Üí\t\t# Close enough to snap to target\n  2696‚Üí\t\trotation = target_angle\n  2697‚Üí\telif angle_diff > 0:\n  2698‚Üí\t\trotation += rotation_speed * delta\n  2699‚Üí\telse:\n  2700‚Üí\t\trotation -= rotation_speed * delta\n  2701‚Üí\n  2702‚Üí\n  2703‚Üí## Shoot a bullet towards the player.\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "b499aaf2-bbe9-4fae-a357-a9d75e85de3e",
  "tool_use_result": {
    "type": "text",
    "file": {
      "filePath": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
      "content": "func _check_player_visibility() -> void:\n\tvar was_visible := _can_see_player\n\t_can_see_player = false\n\t_player_visibility_ratio = 0.0\n\n\tif _player == null or not _raycast:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t# Check if player is within detection range (only if detection_range is positive)\n\t# If detection_range <= 0, detection is unlimited (line-of-sight only)\n\tif detection_range > 0 and distance_to_player > detection_range:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\t# Point raycast at player - use actual distance to player for the raycast length\n\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\tvar raycast_length := distance_to_player + 10.0  # Add small buffer to ensure we reach player\n\t_raycast.target_position = direction_to_player * raycast_length\n\t_raycast.force_raycast_update()\n\n\t# Check if raycast hit something\n\tif _raycast.is_colliding():\n\t\tvar collider := _raycast.get_collider()\n\t\t# If we hit the player, we can see them\n\t\tif collider == _player:\n\t\t\t_can_see_player = true\n\t\t# If we hit a wall/obstacle before the player, we can't see them\n\telse:\n\t\t# No collision between us and player - we have clear line of sight\n\t\t_can_see_player = true\n\n\t# Update continuous visibility timer and visibility ratio\n\tif _can_see_player:\n\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n\t\t# Calculate what fraction of the player's body is visible\n\t\t# This is used to determine if lead prediction should be enabled\n\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n\telse:\n\t\t# Lost line of sight - reset the timer and visibility ratio\n\t\t_continuous_visibility_timer = 0.0\n\t\t_player_visibility_ratio = 0.0\n\n\n## Aim the enemy sprite/direction at the player using gradual rotation.\nfunc _aim_at_player() -> void:\n\tif _player == null:\n\t\treturn\n\tvar direction := (_player.global_position - global_position).normalized()\n\tvar target_angle := direction.angle()\n\n\t# Calculate the shortest rotation direction\n\tvar angle_diff := wrapf(target_angle - rotation, -PI, PI)\n\n\t# Get the delta time from the current physics process\n\tvar delta := get_physics_process_delta_time()\n\n\t# Apply gradual rotation based on rotation_speed\n\tif abs(angle_diff) <= rotation_speed * delta:\n\t\t# Close enough to snap to target\n\t\trotation = target_angle\n\telif angle_diff > 0:\n\t\trotation += rotation_speed * delta\n\telse:\n\t\trotation -= rotation_speed * delta\n\n\n## Shoot a bullet towards the player.",
      "numLines": 70,
      "startLine": 2634,
      "totalLines": 3254
    }
  }
}
[2026-01-18T02:52:58.846Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_012q6jTBWYUu6UxUjd9HLJjz",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01JbMRSgcsv5m3T7it8Z4ins",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "old_string": "\t# Update continuous visibility timer and visibility ratio\n\tif _can_see_player:\n\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n\t\t# Calculate what fraction of the player's body is visible\n\t\t# This is used to determine if lead prediction should be enabled\n\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n\telse:\n\t\t# Lost line of sight - reset the timer and visibility ratio\n\t\t_continuous_visibility_timer = 0.0\n\t\t_player_visibility_ratio = 0.0",
          "new_string": "\t# Update continuous visibility timer and visibility ratio\n\tif _can_see_player:\n\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n\t\t# Calculate what fraction of the player's body is visible\n\t\t# This is used to determine if lead prediction should be enabled\n\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n\t\t# Update last known player position while we can see them\n\t\t_last_known_player_position = _player.global_position\n\t\t# Clear search zone when player is seen\n\t\tif _search_zone_active:\n\t\t\t_clear_search_zone()\n\telse:\n\t\t# Lost line of sight - reset the timer and visibility ratio\n\t\t_continuous_visibility_timer = 0.0\n\t\t_player_visibility_ratio = 0.0\n\t\t# If we just lost sight and were in combat, activate search zone\n\t\tif was_visible and _last_known_player_position != Vector2.ZERO:\n\t\t\t_log_debug(\"Player escaped from view at %s\" % _last_known_player_position)"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 0,
      "cache_creation_input_tokens": 1231,
      "cache_read_input_tokens": 112632,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1231,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 25,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "01b15abb-255d-45d9-9535-f5dd9bff08a6"
}
[2026-01-18T02:52:58.878Z] [INFO] {"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JbMRSgcsv5m3T7it8Z4ins","type":"tool_result","content":"The file /tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  2664‚Üí\telse:\n  2665‚Üí\t\t# No collision between us and player - we have clear line of sight\n  2666‚Üí\t\t_can_see_player = true\n  2667‚Üí\n  2668‚Üí\t# Update continuous visibility timer and visibility ratio\n  2669‚Üí\tif _can_see_player:\n  2670‚Üí\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n  2671‚Üí\t\t# Calculate what fraction of the player's body is visible\n  2672‚Üí\t\t# This is used to determine if lead prediction should be enabled\n  2673‚Üí\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n  2674‚Üí\t\t# Update last known player position while we can see them\n  2675‚Üí\t\t_last_known_player_position = _player.global_position\n  2676‚Üí\t\t# Clear search zone when player is seen\n  2677‚Üí\t\tif _search_zone_active:\n  2678‚Üí\t\t\t_clear_search_zone()\n  2679‚Üí\telse:\n  2680‚Üí\t\t# Lost line of sight - reset the timer and visibility ratio\n  2681‚Üí\t\t_continuous_visibility_timer = 0.0\n  2682‚Üí\t\t_player_visibility_ratio = 0.0\n  2683‚Üí\t\t# If we just lost sight and were in combat, activate search zone\n  2684‚Üí\t\tif was_visible and _last_known_player_position != Vector2.ZERO:\n  2685‚Üí\t\t\t_log_debug(\"Player escaped from view at %s\" % _last_known_player_position)\n  2686‚Üí\n  2687‚Üí\n  2688‚Üí## Aim the enemy sprite/direction at the player using gradual rotation.\n  2689‚Üífunc _aim_at_player() -> void:"}]},"parent_tool_use_id":null,"session_id":"797fbac8-f5e6-4339-8fd2-77453410db49","uuid":"bdd6a925-058c-4df1-b474-fba057f24815","tool_use_result":{"filePath":"/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd","oldString":"\t# Update continuous visibility timer and visibility ratio\n\tif _can_see_player:\n\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n\t\t# Calculate what fraction of the player's body is visible\n\t\t# This is used to determine if lead prediction should be enabled\n\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n\telse:\n\t\t# Lost line of sight - reset the timer and visibility ratio\n\t\t_continuous_visibility_timer = 0.0\n\t\t_player_visibility_ratio = 0.0","newString":"\t# Update continuous visibility timer and visibility ratio\n\tif _can_see_player:\n\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n\t\t# Calculate what fraction of the player's body is visible\n\t\t# This is used to determine if lead prediction should be enabled\n\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n\t\t# Update last known player position while we can see them\n\t\t_last_known_player_position = _player.global_position\n\t\t# Clear search zone when player is seen\n\t\tif _search_zone_active:\n\t\t\t_clear_search_zone()\n\telse:\n\t\t# Lost line of sight - reset the timer and visibility ratio\n\t\t_continuous_visibility_timer = 0.0\n\t\t_player_visibility_ratio = 0.0\n\t\t# If we just lost sight and were in combat, activate search zone\n\t\tif was_visible and _last_known_player_position != Vector2.ZERO:\n\t\t\t_log_debug(\"Player escaped from view at %s\" % _last_known_player_position)","originalFile":"extends CharacterBody2D\n## Enemy AI with tactical behaviors including patrol, guard, cover, and flanking.\n##\n## Supports multiple behavior modes:\n## - PATROL: Moves between patrol points\n## - GUARD: Stands in place watching for the player\n##\n## Tactical features:\n## - Uses cover when under fire (suppression)\n## - Attempts to flank the player from the sides\n## - Coordinates with other enemies (optional)\n## - GOAP foundation for goal-oriented planning\n\n## AI States for tactical behavior.\nenum AIState {\n\tIDLE,       ## Default idle state (patrol or guard)\n\tCOMBAT,     ## Actively engaging the player (coming out of cover, shooting 2-3s, returning)\n\tSEEKING_COVER,  ## Moving to cover position\n\tIN_COVER,   ## Taking cover from player fire\n\tFLANKING,   ## Attempting to flank the player\n\tSUPPRESSED, ## Under fire, staying in cover\n\tRETREATING, ## Retreating to cover while possibly shooting\n\tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n\tASSAULT,    ## Coordinated multi-enemy assault (rush player after 5s wait)\n\tSEARCHING   ## Searching for player at last-known-position zone\n}\n\n## Retreat behavior modes based on damage taken.\nenum RetreatMode {\n\tFULL_HP,        ## No damage - retreat backwards while shooting, periodically turn to cover\n\tONE_HIT,        ## One hit taken - quick burst then retreat without shooting\n\tMULTIPLE_HITS   ## Multiple hits - quick burst then retreat without shooting (same as ONE_HIT)\n}\n\n## Behavior modes for the enemy.\nenum BehaviorMode {\n\tPATROL,  ## Moves between patrol points\n\tGUARD    ## Stands in one place\n}\n\n## Current behavior mode.\n@export var behavior_mode: BehaviorMode = BehaviorMode.GUARD\n\n## Maximum movement speed in pixels per second.\n@export var move_speed: float = 220.0\n\n## Combat movement speed (faster when flanking/seeking cover).\n@export var combat_move_speed: float = 320.0\n\n## Rotation speed in radians per second for gradual turning.\n## Default is 15 rad/sec for challenging but fair combat.\n@export var rotation_speed: float = 15.0\n\n## Detection range for spotting the player.\n## Set to 0 or negative to allow unlimited detection range (line-of-sight only).\n## This allows enemies to see the player even outside the viewport if no obstacles block view.\n@export var detection_range: float = 0.0\n\n## Time between shots in seconds.\n## Default matches assault rifle fire rate (10 shots/second = 0.1s cooldown).\n@export var shoot_cooldown: float = 0.1\n\n## Bullet scene to instantiate when shooting.\n@export var bullet_scene: PackedScene\n\n## Offset from enemy center for bullet spawn position.\n@export var bullet_spawn_offset: float = 30.0\n\n## Patrol points as offsets from the initial position.\n## Only used when behavior_mode is PATROL.\n@export var patrol_offsets: Array[Vector2] = [Vector2(100, 0), Vector2(-100, 0)]\n\n## Wait time at each patrol point in seconds.\n@export var patrol_wait_time: float = 1.5\n\n## Color when at full health.\n@export var full_health_color: Color = Color(0.9, 0.2, 0.2, 1.0)\n\n## Color when at low health (interpolates based on health percentage).\n@export var low_health_color: Color = Color(0.3, 0.1, 0.1, 1.0)\n\n## Color to flash when hit.\n@export var hit_flash_color: Color = Color(1.0, 1.0, 1.0, 1.0)\n\n## Duration of hit flash effect in seconds.\n@export var hit_flash_duration: float = 0.1\n\n## Whether to destroy the enemy after death.\n@export var destroy_on_death: bool = false\n\n## Delay before respawning or destroying (in seconds).\n@export var respawn_delay: float = 2.0\n\n## Minimum random health.\n@export var min_health: int = 2\n\n## Maximum random health.\n@export var max_health: int = 4\n\n## Threat sphere radius - bullets within this radius trigger suppression.\n@export var threat_sphere_radius: float = 100.0\n\n## Time to stay suppressed after bullets leave threat sphere.\n@export var suppression_cooldown: float = 2.0\n\n## Delay (in seconds) before reacting to bullets in the threat sphere.\n## This prevents instant reactions to nearby gunfire, giving the player more time.\n@export var threat_reaction_delay: float = 0.2\n\n## Flank angle from player's facing direction (radians).\n@export var flank_angle: float = PI / 3.0  # 60 degrees\n\n## Distance to maintain while flanking.\n@export var flank_distance: float = 200.0\n\n## Enable/disable flanking behavior.\n@export var enable_flanking: bool = true\n\n## Enable/disable cover behavior.\n@export var enable_cover: bool = true\n\n## Enable/disable debug logging.\n@export var debug_logging: bool = false\n\n## Enable/disable debug label above enemy showing current AI state.\n@export var debug_label_enabled: bool = false\n\n## Enable/disable friendly fire avoidance (don't shoot if other enemies are in the way).\n@export var enable_friendly_fire_avoidance: bool = true\n\n## Enable/disable lead prediction (shooting ahead of moving targets).\n@export var enable_lead_prediction: bool = true\n\n## Bullet speed for lead prediction calculation.\n## Should match the actual bullet speed (default is 2500 for assault rifle).\n@export var bullet_speed: float = 2500.0\n\n## Ammunition system - magazine size (bullets per magazine).\n@export var magazine_size: int = 30\n\n## Ammunition system - number of magazines the enemy carries.\n@export var total_magazines: int = 5\n\n## Ammunition system - time to reload in seconds.\n@export var reload_time: float = 3.0\n\n## Delay (in seconds) between spotting player and starting to shoot.\n## Gives player a brief reaction time when entering enemy line of sight.\n## This delay \"recharges\" each time the player breaks direct contact with the enemy.\n@export var detection_delay: float = 0.2\n\n## Minimum time (in seconds) the player must be continuously visible before\n## lead prediction is enabled. This prevents enemies from predicting player\n## position immediately when they emerge from cover.\n@export var lead_prediction_delay: float = 0.3\n\n## Minimum visibility ratio (0.0 to 1.0) of player body that must be visible\n## before lead prediction is enabled. At 1.0, the player's entire body must be\n## visible. At 0.5, at least half of the check points must be visible.\n## This prevents pre-firing at players who are at cover edges.\n@export var lead_prediction_visibility_threshold: float = 0.6\n\n## Signal emitted when the enemy is hit.\nsignal hit\n\n## Signal emitted when the enemy dies.\nsignal died\n\n## Signal emitted when AI state changes.\nsignal state_changed(new_state: AIState)\n\n## Signal emitted when ammunition changes.\nsignal ammo_changed(current_ammo: int, reserve_ammo: int)\n\n## Signal emitted when reloading starts.\nsignal reload_started\n\n## Signal emitted when reloading finishes.\nsignal reload_finished\n\n## Signal emitted when all ammunition is depleted.\nsignal ammo_depleted\n\n## Reference to the sprite for color changes.\n@onready var _sprite: Sprite2D = $Sprite2D\n\n## RayCast2D for line of sight detection.\n@onready var _raycast: RayCast2D = $RayCast2D\n\n## Debug label for showing current AI state above the enemy.\n@onready var _debug_label: Label = $DebugLabel\n\n## Wall detection raycasts for obstacle avoidance (created at runtime).\nvar _wall_raycasts: Array[RayCast2D] = []\n\n## Distance to check for walls ahead.\nconst WALL_CHECK_DISTANCE: float = 40.0\n\n## Number of raycasts for wall detection (spread around the enemy).\nconst WALL_CHECK_COUNT: int = 3\n\n## Cover detection raycasts (created at runtime).\nvar _cover_raycasts: Array[RayCast2D] = []\n\n## Number of raycasts for cover detection.\nconst COVER_CHECK_COUNT: int = 16\n\n## Distance to check for cover.\nconst COVER_CHECK_DISTANCE: float = 300.0\n\n## Current health of the enemy.\nvar _current_health: int = 0\n\n## Maximum health of the enemy (set at spawn).\nvar _max_health: int = 0\n\n## Whether the enemy is alive.\nvar _is_alive: bool = true\n\n## Reference to the player (found at runtime).\nvar _player: Node2D = null\n\n## Time since last shot.\nvar _shoot_timer: float = 0.0\n\n## Current ammo in the magazine.\nvar _current_ammo: int = 0\n\n## Reserve ammo (ammo in remaining magazines).\nvar _reserve_ammo: int = 0\n\n## Whether the enemy is currently reloading.\nvar _is_reloading: bool = false\n\n## Timer for reload progress.\nvar _reload_timer: float = 0.0\n\n## Patrol state variables.\nvar _patrol_points: Array[Vector2] = []\nvar _current_patrol_index: int = 0\nvar _is_waiting_at_patrol_point: bool = false\nvar _patrol_wait_timer: float = 0.0\nvar _initial_position: Vector2\n\n## Whether the enemy can currently see the player.\nvar _can_see_player: bool = false\n\n## Current AI state.\nvar _current_state: AIState = AIState.IDLE\n\n## Current cover position (if any).\nvar _cover_position: Vector2 = Vector2.ZERO\n\n## Is currently in a valid cover position.\nvar _has_valid_cover: bool = false\n\n## Timer for suppression cooldown.\nvar _suppression_timer: float = 0.0\n\n## Whether enemy is currently under fire (bullets in threat sphere).\nvar _under_fire: bool = false\n\n## Flank target position.\nvar _flank_target: Vector2 = Vector2.ZERO\n\n## Threat sphere Area2D for detecting nearby bullets.\nvar _threat_sphere: Area2D = null\n\n## Bullets currently in threat sphere.\nvar _bullets_in_threat_sphere: Array = []\n\n## Timer for threat reaction delay - time since first bullet entered threat sphere.\nvar _threat_reaction_timer: float = 0.0\n\n## Whether the threat reaction delay has elapsed (enemy can react to bullets).\nvar _threat_reaction_delay_elapsed: bool = false\n\n## Memory of bullets that have passed through the threat sphere recently.\n## This allows the enemy to react even after fast-moving bullets have exited.\nvar _threat_memory_timer: float = 0.0\n\n## Duration to remember that a bullet passed through the threat sphere.\n## This should be longer than the reaction delay to ensure enemies can complete\n## their reaction even after bullets have passed through quickly.\nconst THREAT_MEMORY_DURATION: float = 0.5\n\n## Current retreat mode determined by damage taken.\nvar _retreat_mode: RetreatMode = RetreatMode.FULL_HP\n\n## Number of hits taken during the current retreat/combat encounter.\n## Resets when enemy enters IDLE state or finishes retreating.\nvar _hits_taken_in_encounter: int = 0\n\n## Timer for periodic turning to cover during FULL_HP retreat.\nvar _retreat_turn_timer: float = 0.0\n\n## Duration to face cover during FULL_HP retreat turn (seconds).\nconst RETREAT_TURN_DURATION: float = 0.8\n\n## Interval between turns toward cover in FULL_HP retreat (seconds).\nconst RETREAT_TURN_INTERVAL: float = 1.5\n\n## Whether currently in the \"turn to cover\" phase of FULL_HP retreat.\nvar _retreat_turning_to_cover: bool = false\n\n## Burst fire counter for ONE_HIT retreat mode.\nvar _retreat_burst_remaining: int = 0\n\n## Timer for burst fire cooldown in ONE_HIT retreat.\nvar _retreat_burst_timer: float = 0.0\n\n## Fast cooldown between burst shots (seconds).\nconst RETREAT_BURST_COOLDOWN: float = 0.06\n\n## Whether burst fire phase is complete in ONE_HIT retreat.\nvar _retreat_burst_complete: bool = false\n\n## Accuracy reduction during retreat (multiplier for inaccuracy angle spread).\nconst RETREAT_INACCURACY_SPREAD: float = 0.15\n\n## Arc spread for ONE_HIT burst fire (radians, total spread).\nconst RETREAT_BURST_ARC: float = 0.4\n\n## Current angle offset within burst arc.\nvar _retreat_burst_angle_offset: float = 0.0\n\n## Whether enemy is in \"alarm\" mode (was suppressed/retreating and hasn't calmed down).\n## This persists until the enemy reaches safety in cover or returns to idle.\nvar _in_alarm_mode: bool = false\n\n## Whether the enemy needs to fire a cover burst (when leaving cover while in alarm).\nvar _cover_burst_pending: bool = false\n\n## --- Combat Cover Cycling (come out, shoot 2-3s, go back) ---\n## Timer for how long the enemy has been shooting while out of cover.\nvar _combat_shoot_timer: float = 0.0\n\n## Duration to shoot while out of cover (2-3 seconds, randomized).\nvar _combat_shoot_duration: float = 2.5\n\n## Whether the enemy is currently in the \"exposed shooting\" phase of combat.\nvar _combat_exposed: bool = false\n\n## Whether the enemy is in the \"approaching player\" phase of combat.\n## In this phase, the enemy moves toward the player to get into direct contact.\nvar _combat_approaching: bool = false\n\n## Timer for the approach phase of combat.\nvar _combat_approach_timer: float = 0.0\n\n## Maximum time to spend approaching player before starting to shoot (seconds).\nconst COMBAT_APPROACH_MAX_TIME: float = 2.0\n\n## Distance at which enemy is considered \"close enough\" to start shooting phase.\nconst COMBAT_DIRECT_CONTACT_DISTANCE: float = 250.0\n\n## --- Pursuit State (cover-to-cover movement) ---\n## Timer for waiting at cover during pursuit.\nvar _pursuit_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during pursuit (1-2 seconds, reduced for faster pursuit).\nconst PURSUIT_COVER_WAIT_DURATION: float = 1.5\n\n## Current pursuit target cover position.\nvar _pursuit_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid pursuit cover target.\nvar _has_pursuit_cover: bool = false\n\n## --- Flanking State (cover-to-cover movement toward flank target) ---\n## Timer for waiting at cover during flanking.\nvar _flank_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during flanking (seconds).\nconst FLANK_COVER_WAIT_DURATION: float = 0.8\n\n## Current flank cover position to move to.\nvar _flank_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid flank cover target.\nvar _has_flank_cover: bool = false\n\n## --- Assault State (coordinated multi-enemy rush) ---\n## Timer for assault wait period (5 seconds before rushing).\nvar _assault_wait_timer: float = 0.0\n\n## Duration to wait at cover before assault (5 seconds).\nconst ASSAULT_WAIT_DURATION: float = 5.0\n\n## Whether the assault wait period is complete.\nvar _assault_ready: bool = false\n\n## Whether this enemy is currently participating in an assault.\nvar _in_assault: bool = false\n\n## Distance threshold for \"close\" vs \"far\" from player.\n## Used to determine if enemy can engage from current position or needs to pursue.\nconst CLOSE_COMBAT_DISTANCE: float = 400.0\n\n## GOAP world state for goal-oriented planning.\nvar _goap_world_state: Dictionary = {}\n\n## --- Search/Investigation State (for when player escapes from view) ---\n## Last known position where the player was seen before escaping view.\nvar _last_known_player_position: Vector2 = Vector2.ZERO\n\n## Whether a search zone is currently active.\nvar _search_zone_active: bool = false\n\n## Radius of the potential player zone (area where player might be hiding).\nconst SEARCH_ZONE_RADIUS: float = 200.0\n\n## Timer for search timeout - enemy gives up searching after this time.\nvar _search_timer: float = 0.0\n\n## Maximum time to spend searching before giving up (seconds).\nconst SEARCH_MAX_DURATION: float = 15.0\n\n## Inspection points within the search zone (hiding spots behind covers and corners).\nvar _inspection_points: Array[Vector2] = []\n\n## Index of current inspection point being checked.\nvar _current_inspection_index: int = 0\n\n## Timer for waiting at each inspection point (looking around).\nvar _inspection_wait_timer: float = 0.0\n\n## Duration to wait at each inspection point (seconds).\nconst INSPECTION_WAIT_DURATION: float = 1.5\n\n## Whether currently waiting at an inspection point.\nvar _inspecting_point: bool = false\n\n## Number of raycasts for detecting inspection points (corners/hiding spots).\nconst INSPECTION_POINT_CHECK_COUNT: int = 24\n\n## Distance to check for inspection points from search zone center.\nconst INSPECTION_CHECK_DISTANCE: float = 250.0\n\n## Detection delay timer - tracks time since entering combat.\nvar _detection_timer: float = 0.0\n\n## Whether the detection delay has elapsed.\nvar _detection_delay_elapsed: bool = false\n\n## Continuous visibility timer - tracks how long the player has been continuously visible.\n## Resets when line of sight is lost.\nvar _continuous_visibility_timer: float = 0.0\n\n## Current visibility ratio of the player (0.0 to 1.0).\n## Represents what fraction of the player's body is visible to the enemy.\n## Used to determine if lead prediction should be enabled.\nvar _player_visibility_ratio: float = 0.0\n\n## --- Clear Shot Movement (move out from cover to get clear shot) ---\n## Target position to move to for getting a clear shot.\nvar _clear_shot_target: Vector2 = Vector2.ZERO\n\n## Whether we're currently moving to find a clear shot position.\nvar _seeking_clear_shot: bool = false\n\n## Timer for how long we've been trying to find a clear shot.\nvar _clear_shot_timer: float = 0.0\n\n## Maximum time to spend finding a clear shot before giving up (seconds).\nconst CLEAR_SHOT_MAX_TIME: float = 3.0\n\n## Distance to move when exiting cover to find a clear shot.\nconst CLEAR_SHOT_EXIT_DISTANCE: float = 60.0\n\n\n\nfunc _ready() -> void:\n\t_initial_position = global_position\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_setup_patrol_points()\n\t_find_player()\n\t_setup_wall_detection()\n\t_setup_cover_detection()\n\t_setup_threat_sphere()\n\t_initialize_goap_state()\n\t_connect_debug_mode_signal()\n\t_update_debug_label()\n\n\t# Log that this enemy is ready (use call_deferred to ensure FileLogger is loaded)\n\tcall_deferred(\"_log_spawn_info\")\n\n\t# Preload bullet scene if not set in inspector\n\tif bullet_scene == null:\n\t\tbullet_scene = preload(\"res://scenes/projectiles/Bullet.tscn\")\n\n\n## Initialize health with random value between min and max.\nfunc _initialize_health() -> void:\n\t_max_health = randi_range(min_health, max_health)\n\t_current_health = _max_health\n\t_is_alive = true\n\n\n## Initialize ammunition with full magazine and reserve ammo.\nfunc _initialize_ammo() -> void:\n\t_current_ammo = magazine_size\n\t# Reserve ammo is (total_magazines - 1) * magazine_size since one magazine is loaded\n\t_reserve_ammo = (total_magazines - 1) * magazine_size\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\n## Setup patrol points based on patrol offsets from initial position.\nfunc _setup_patrol_points() -> void:\n\t_patrol_points.clear()\n\t_patrol_points.append(_initial_position)\n\tfor offset in patrol_offsets:\n\t\t_patrol_points.append(_initial_position + offset)\n\n\n## Setup wall detection raycasts for obstacle avoidance.\nfunc _setup_wall_detection() -> void:\n\t# Create multiple raycasts spread in front of the enemy\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_wall_raycasts.append(raycast)\n\n\n## Setup cover detection raycasts for finding cover positions.\nfunc _setup_cover_detection() -> void:\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_cover_raycasts.append(raycast)\n\n\n## Setup threat sphere for detecting nearby bullets.\nfunc _setup_threat_sphere() -> void:\n\t_threat_sphere = Area2D.new()\n\t_threat_sphere.name = \"ThreatSphere\"\n\t_threat_sphere.collision_layer = 0\n\t_threat_sphere.collision_mask = 16  # Detect projectiles (layer 5)\n\n\tvar collision_shape := CollisionShape2D.new()\n\tvar circle_shape := CircleShape2D.new()\n\tcircle_shape.radius = threat_sphere_radius\n\tcollision_shape.shape = circle_shape\n\t_threat_sphere.add_child(collision_shape)\n\n\tadd_child(_threat_sphere)\n\n\t# Connect signals\n\t_threat_sphere.area_entered.connect(_on_threat_area_entered)\n\t_threat_sphere.area_exited.connect(_on_threat_area_exited)\n\n\n## Initialize GOAP world state.\nfunc _initialize_goap_state() -> void:\n\t_goap_world_state = {\n\t\t\"player_visible\": false,\n\t\t\"has_cover\": false,\n\t\t\"in_cover\": false,\n\t\t\"under_fire\": false,\n\t\t\"health_low\": false,\n\t\t\"can_flank\": false,\n\t\t\"at_flank_position\": false,\n\t\t\"is_retreating\": false,\n\t\t\"hits_taken\": 0,\n\t\t\"is_pursuing\": false,\n\t\t\"is_assaulting\": false,\n\t\t\"can_hit_from_cover\": false,\n\t\t\"player_close\": false,\n\t\t\"enemies_in_combat\": 0,\n\t\t\"has_search_zone\": false,\n\t\t\"search_zone_cleared\": false,\n\t\t\"inspection_points_remaining\": 0,\n\t\t\"is_searching\": false\n\t}\n\n\n## Connect to GameManager's debug mode signal for F7 toggle.\nfunc _connect_debug_mode_signal() -> void:\n\tvar game_manager: Node = get_node_or_null(\"/root/GameManager\")\n\tif game_manager:\n\t\t# Connect to debug mode toggle signal\n\t\tif game_manager.has_signal(\"debug_mode_toggled\"):\n\t\t\tgame_manager.debug_mode_toggled.connect(_on_debug_mode_toggled)\n\t\t# Sync with current debug mode state\n\t\tif game_manager.has_method(\"is_debug_mode_enabled\"):\n\t\t\tdebug_label_enabled = game_manager.is_debug_mode_enabled()\n\n\n## Called when debug mode is toggled via F7 key.\nfunc _on_debug_mode_toggled(enabled: bool) -> void:\n\tdebug_label_enabled = enabled\n\t_update_debug_label()\n\n\n## Find the player node in the scene tree.\nfunc _find_player() -> void:\n\t# Try to find the player by group first\n\tvar players := get_tree().get_nodes_in_group(\"player\")\n\tif players.size() > 0:\n\t\t_player = players[0]\n\t\treturn\n\n\t# Fallback: search for player by node name or type\n\tvar root := get_tree().current_scene\n\tif root:\n\t\t_player = _find_player_recursive(root)\n\n\n## Recursively search for a player node.\nfunc _find_player_recursive(node: Node) -> Node2D:\n\tif node.name == \"Player\" and node is Node2D:\n\t\treturn node\n\tfor child in node.get_children():\n\t\tvar result := _find_player_recursive(child)\n\t\tif result:\n\t\t\treturn result\n\treturn null\n\n\nfunc _physics_process(delta: float) -> void:\n\tif not _is_alive:\n\t\treturn\n\n\t# Update shoot cooldown timer\n\t_shoot_timer += delta\n\n\t# Update reload timer\n\t_update_reload(delta)\n\n\t# Check for player visibility and try to find player if not found\n\tif _player == null:\n\t\t_find_player()\n\n\t_check_player_visibility()\n\t_update_goap_state()\n\t_update_suppression(delta)\n\n\t# Process AI state machine\n\t_process_ai_state(delta)\n\n\t# Update debug label if enabled\n\t_update_debug_label()\n\n\t# Request redraw for debug visualization\n\tif debug_label_enabled:\n\t\tqueue_redraw()\n\n\tmove_and_slide()\n\n\n## Update GOAP world state based on current conditions.\nfunc _update_goap_state() -> void:\n\t_goap_world_state[\"player_visible\"] = _can_see_player\n\t_goap_world_state[\"under_fire\"] = _under_fire\n\t_goap_world_state[\"health_low\"] = _get_health_percent() < 0.5\n\t_goap_world_state[\"in_cover\"] = _current_state == AIState.IN_COVER\n\t_goap_world_state[\"has_cover\"] = _has_valid_cover\n\t_goap_world_state[\"is_retreating\"] = _current_state == AIState.RETREATING\n\t_goap_world_state[\"hits_taken\"] = _hits_taken_in_encounter\n\t_goap_world_state[\"is_pursuing\"] = _current_state == AIState.PURSUING\n\t_goap_world_state[\"is_assaulting\"] = _current_state == AIState.ASSAULT\n\t_goap_world_state[\"player_close\"] = _is_player_close()\n\t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n\t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()\n\t_goap_world_state[\"has_search_zone\"] = _search_zone_active\n\t_goap_world_state[\"search_zone_cleared\"] = not _search_zone_active and _last_known_player_position != Vector2.ZERO\n\t_goap_world_state[\"inspection_points_remaining\"] = _inspection_points.size() - _current_inspection_index\n\t_goap_world_state[\"is_searching\"] = _current_state == AIState.SEARCHING\n\n\n## Update suppression state.\nfunc _update_suppression(delta: float) -> void:\n\t# Clean up destroyed bullets from tracking\n\t_bullets_in_threat_sphere = _bullets_in_threat_sphere.filter(func(b): return is_instance_valid(b))\n\n\t# Determine if there's an active threat (bullets in sphere OR recent threat memory)\n\tvar has_active_threat := not _bullets_in_threat_sphere.is_empty() or _threat_memory_timer > 0.0\n\n\tif not has_active_threat:\n\t\tif _under_fire:\n\t\t\t_suppression_timer += delta\n\t\t\tif _suppression_timer >= suppression_cooldown:\n\t\t\t\t_under_fire = false\n\t\t\t\t_suppression_timer = 0.0\n\t\t\t\t_log_debug(\"Suppression ended\")\n\
[2026-01-18T02:52:58.881Z] [INFO] t\t# Reset threat reaction timer when no bullets are in threat sphere and no threat memory\n\t\t_threat_reaction_timer = 0.0\n\t\t_threat_reaction_delay_elapsed = false\n\telse:\n\t\t# Decrement threat memory timer if no bullets currently in sphere\n\t\tif _bullets_in_threat_sphere.is_empty() and _threat_memory_timer > 0.0:\n\t\t\t_threat_memory_timer -= delta\n\n\t\t# Update threat reaction timer\n\t\tif not _threat_reaction_delay_elapsed:\n\t\t\t_threat_reaction_timer += delta\n\t\t\tif _threat_reaction_timer >= threat_reaction_delay:\n\t\t\t\t_threat_reaction_delay_elapsed = true\n\t\t\t\t_log_debug(\"Threat reaction delay elapsed, now reacting to bullets\")\n\n\t\t# Only set under_fire after the reaction delay has elapsed\n\t\tif _threat_reaction_delay_elapsed:\n\t\t\t_under_fire = true\n\t\t\t_suppression_timer = 0.0\n\n\n## Update reload state.\nfunc _update_reload(delta: float) -> void:\n\tif not _is_reloading:\n\t\treturn\n\n\t_reload_timer += delta\n\tif _reload_timer >= reload_time:\n\t\t_finish_reload()\n\n\n## Start reloading the weapon.\nfunc _start_reload() -> void:\n\t# Can't reload if already reloading or no reserve ammo\n\tif _is_reloading or _reserve_ammo <= 0:\n\t\treturn\n\n\t_is_reloading = true\n\t_reload_timer = 0.0\n\treload_started.emit()\n\t_log_debug(\"Reloading... (%d reserve ammo)\" % _reserve_ammo)\n\n\n## Finish the reload process.\nfunc _finish_reload() -> void:\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\t# Calculate how many rounds to load\n\tvar ammo_needed := magazine_size - _current_ammo\n\tvar ammo_to_load := mini(ammo_needed, _reserve_ammo)\n\n\t_reserve_ammo -= ammo_to_load\n\t_current_ammo += ammo_to_load\n\n\treload_finished.emit()\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\t_log_debug(\"Reload complete. Magazine: %d/%d, Reserve: %d\" % [_current_ammo, magazine_size, _reserve_ammo])\n\n\n## Check if the enemy can shoot (has ammo and not reloading).\nfunc _can_shoot() -> bool:\n\t# Can't shoot if reloading\n\tif _is_reloading:\n\t\treturn false\n\n\t# Can't shoot if no ammo in magazine\n\tif _current_ammo <= 0:\n\t\t# Try to start reload if we have reserve ammo\n\t\tif _reserve_ammo > 0:\n\t\t\t_start_reload()\n\t\telse:\n\t\t\t# No ammo at all - emit depleted signal once\n\t\t\tif not _goap_world_state.get(\"ammo_depleted\", false):\n\t\t\t\t_goap_world_state[\"ammo_depleted\"] = true\n\t\t\t\tammo_depleted.emit()\n\t\t\t\t_log_debug(\"All ammunition depleted!\")\n\t\treturn false\n\n\treturn true\n\n\n## Process the AI state machine.\nfunc _process_ai_state(delta: float) -> void:\n\tvar previous_state := _current_state\n\n\t# State transitions based on conditions\n\tmatch _current_state:\n\t\tAIState.IDLE:\n\t\t\t_process_idle_state(delta)\n\t\tAIState.COMBAT:\n\t\t\t_process_combat_state(delta)\n\t\tAIState.SEEKING_COVER:\n\t\t\t_process_seeking_cover_state(delta)\n\t\tAIState.IN_COVER:\n\t\t\t_process_in_cover_state(delta)\n\t\tAIState.FLANKING:\n\t\t\t_process_flanking_state(delta)\n\t\tAIState.SUPPRESSED:\n\t\t\t_process_suppressed_state(delta)\n\t\tAIState.RETREATING:\n\t\t\t_process_retreating_state(delta)\n\t\tAIState.PURSUING:\n\t\t\t_process_pursuing_state(delta)\n\t\tAIState.ASSAULT:\n\t\t\t_process_assault_state(delta)\n\t\tAIState.SEARCHING:\n\t\t\t_process_searching_state(delta)\n\n\tif previous_state != _current_state:\n\t\tstate_changed.emit(_current_state)\n\t\t_log_debug(\"State changed: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\t\t# Also log to file for exported build debugging\n\t\t_log_to_file(\"State: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\n\n## Process IDLE state - patrol or guard behavior.\nfunc _process_idle_state(delta: float) -> void:\n\t# Transition to combat if player is visible\n\tif _can_see_player and _player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Execute idle behavior\n\tmatch behavior_mode:\n\t\tBehaviorMode.PATROL:\n\t\t\t_process_patrol(delta)\n\t\tBehaviorMode.GUARD:\n\t\t\t_process_guard(delta)\n\n\n## Process COMBAT state - approach player for direct contact, shoot for 2-3 seconds, return to cover.\n## Implements the combat cycling behavior: exit cover -> exposed shooting -> return to cover.\n## Phase 0 (seeking clear shot): If bullet spawn blocked, move out from cover to find clear shot.\n## Phase 1 (approaching): Move toward player to get into direct contact range.\n## Phase 2 (exposed): Stand and shoot for 2-3 seconds.\n## Phase 3: Return to cover via SEEKING_COVER state.\nfunc _process_combat_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies in combat (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can't see player, pursue them (move cover-to-cover toward player)\n\tif not _can_see_player:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\t\treturn\n\n\t# Update detection delay timer\n\tif not _detection_delay_elapsed:\n\t\t_detection_timer += delta\n\t\tif _detection_timer >= detection_delay:\n\t\t\t_detection_delay_elapsed = true\n\n\t# If we don't have cover, find some first (needed for returning later)\n\tif not _has_valid_cover and enable_cover:\n\t\t_find_cover_position()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found cover at %s for combat cycling\" % _cover_position)\n\n\t# Check player distance for approach/exposed phase decisions\n\tvar distance_to_player := INF\n\tif _player:\n\t\tdistance_to_player = global_position.distance_to(_player.global_position)\n\n\t# Check if we have a clear shot (no wall blocking bullet spawn)\n\tvar direction_to_player := Vector2.ZERO\n\tvar has_clear_shot := true\n\tif _player:\n\t\tdirection_to_player = (_player.global_position - global_position).normalized()\n\t\thas_clear_shot = _is_bullet_spawn_clear(direction_to_player)\n\n\t# If already exposed (shooting phase), handle shooting and timer\n\tif _combat_exposed:\n\t\t_combat_shoot_timer += delta\n\n\t\t# Check if exposure time is complete - go back to cover\n\t\tif _combat_shoot_timer >= _combat_shoot_duration and _has_valid_cover:\n\t\t\t_log_debug(\"Combat exposure time complete (%.1fs), returning to cover\" % _combat_shoot_duration)\n\t\t\t_combat_exposed = false\n\t\t\t_combat_approaching = false\n\t\t\t_combat_shoot_timer = 0.0\n\t\t\t_transition_to_seeking_cover()\n\t\t\treturn\n\n\t\t# Check if we still have a clear shot - if not, move sideways to find one\n\t\tif _player and not has_clear_shot:\n\t\t\t# Bullet spawn is blocked - move sideways to find a clear shot position\n\t\t\tvar sidestep_dir := _find_sidestep_direction_for_clear_shot(direction_to_player)\n\t\t\tif sidestep_dir != Vector2.ZERO:\n\t\t\t\tvelocity = sidestep_dir * combat_move_speed * 0.7\n\t\t\t\trotation = direction_to_player.angle()  # Keep facing player while sidestepping\n\t\t\t\t_log_debug(\"COMBAT exposed: sidestepping to maintain clear shot\")\n\t\t\telse:\n\t\t\t\t# No sidestep works - stay still, the shot might clear up\n\t\t\t\tvelocity = Vector2.ZERO\n\t\t\treturn\n\n\t\t# In exposed phase with clear shot, stand still and shoot\n\t\tvelocity = Vector2.ZERO\n\n\t\t# Aim and shoot at player (only shoot after detection delay)\n\t\tif _player:\n\t\t\t_aim_at_player()\n\t\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot()\n\t\t\t\t_shoot_timer = 0.0\n\t\treturn\n\n\t# --- CLEAR SHOT SEEKING PHASE ---\n\t# If bullet spawn is blocked and we're not already exposed, we need to move out from cover\n\tif not has_clear_shot and _player:\n\t\t# Start seeking clear shot if not already doing so\n\t\tif not _seeking_clear_shot:\n\t\t\t_seeking_clear_shot = true\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Calculate target position: move perpendicular to player direction (around cover edge)\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\t_log_debug(\"COMBAT: bullet spawn blocked, seeking clear shot at %s\" % _clear_shot_target)\n\n\t\t_clear_shot_timer += delta\n\n\t\t# Check if we've exceeded the max time trying to find a clear shot\n\t\tif _clear_shot_timer >= CLEAR_SHOT_MAX_TIME:\n\t\t\t_log_debug(\"COMBAT: clear shot timeout, trying flanking\")\n\t\t\t_seeking_clear_shot = false\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Try flanking to get around the obstacle\n\t\t\tif enable_flanking:\n\t\t\t\t_transition_to_flanking()\n\t\t\telse:\n\t\t\t\t_transition_to_pursuing()\n\t\t\treturn\n\n\t\t# Move toward the clear shot target position\n\t\tvar distance_to_target := global_position.distance_to(_clear_shot_target)\n\t\tif distance_to_target > 15.0:\n\t\t\tvar move_direction := (_clear_shot_target - global_position).normalized()\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed\n\t\t\trotation = direction_to_player.angle()  # Keep facing player\n\n\t\t\t# Check if the new position now has a clear shot\n\t\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\t\t_log_debug(\"COMBAT: found clear shot position while moving\")\n\t\t\t\t_seeking_clear_shot = false\n\t\t\t\t_clear_shot_timer = 0.0\n\t\t\t\t# Continue to exposed phase check below\n\t\t\telse:\n\t\t\t\treturn  # Keep moving toward target\n\t\telse:\n\t\t\t# Reached target but still no clear shot - recalculate target\n\t\t\t_log_debug(\"COMBAT: reached target but no clear shot, recalculating\")\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\treturn\n\n\t# Reset seeking state if we now have a clear shot\n\tif _seeking_clear_shot and has_clear_shot:\n\t\t_log_debug(\"COMBAT: clear shot acquired\")\n\t\t_seeking_clear_shot = false\n\t\t_clear_shot_timer = 0.0\n\n\t# Determine if we should be in approach phase or exposed shooting phase\n\tvar in_direct_contact := distance_to_player <= COMBAT_DIRECT_CONTACT_DISTANCE\n\n\t# Enter exposed phase if we have a clear shot and are either close enough or have approached long enough\n\tif has_clear_shot and (in_direct_contact or _combat_approach_timer >= COMBAT_APPROACH_MAX_TIME):\n\t\t# Close enough AND have clear shot - start exposed shooting phase\n\t\t_combat_exposed = true\n\t\t_combat_approaching = false\n\t\t_combat_shoot_timer = 0.0\n\t\t_combat_approach_timer = 0.0\n\t\t# Randomize exposure duration between 2-3 seconds\n\t\t_combat_shoot_duration = randf_range(2.0, 3.0)\n\t\t_log_debug(\"COMBAT exposed phase started (distance: %.0f), will shoot for %.1fs\" % [distance_to_player, _combat_shoot_duration])\n\t\treturn\n\n\t# Need to approach player - move toward them\n\tif not _combat_approaching:\n\t\t_combat_approaching = true\n\t\t_combat_approach_timer = 0.0\n\t\t_log_debug(\"COMBAT approach phase started, moving toward player\")\n\n\t_combat_approach_timer += delta\n\n\t# Move toward player while approaching\n\tif _player:\n\t\tvar move_direction := direction_to_player\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = move_direction * combat_move_speed\n\t\trotation = direction_to_player.angle()  # Always face player\n\n\t\t# Can shoot while approaching (only after detection delay and if have clear shot)\n\t\tif has_clear_shot and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\n## Calculate a target position to exit cover and get a clear shot.\n## Returns a position that should allow the bullet spawn point to be unobstructed.\nfunc _calculate_clear_shot_exit_position(direction_to_player: Vector2) -> Vector2:\n\t# Calculate perpendicular directions to the player\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Try both perpendicular directions and pick the one that's more likely to work\n\t# Also blend with forward movement toward player to help navigate around cover\n\tvar best_position := global_position\n\tvar best_score := -1.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\t\t# Blend sidestep with forward movement for better cover navigation\n\t\tvar exit_dir: Vector2 = (sidestep_dir * 0.7 + direction_to_player * 0.3).normalized()\n\t\tvar test_position: Vector2 = global_position + exit_dir * CLEAR_SHOT_EXIT_DISTANCE\n\n\t\t# Score this position based on:\n\t\t# 1. Does it have a clear path? (no walls in the way)\n\t\t# 2. Would the bullet spawn be clear from there?\n\t\tvar score: float = 0.0\n\n\t\t# Check if we can move to this position\n\t\tif _has_clear_path_to(test_position):\n\t\t\tscore += 1.0\n\n\t\t# Check if bullet spawn would be clear from this position\n\t\t# This is a rough estimate - we check from the test position toward player\n\t\tvar world_2d := get_world_2d()\n\t\tif world_2d != null:\n\t\t\tvar space_state := world_2d.direct_space_state\n\t\t\tif space_state != null:\n\t\t\t\tvar check_distance := bullet_spawn_offset + 5.0\n\t\t\t\tvar query := PhysicsRayQueryParameters2D.new()\n\t\t\t\tquery.from = test_position\n\t\t\t\tquery.to = test_position + direction_to_player * check_distance\n\t\t\t\tquery.collision_mask = 4  # Only check obstacles\n\t\t\t\tquery.exclude = [get_rid()]\n\t\t\t\tvar result := space_state.intersect_ray(query)\n\t\t\t\tif result.is_empty():\n\t\t\t\t\tscore += 2.0  # Higher score for clear bullet spawn\n\n\t\tif score > best_score:\n\t\t\tbest_score = score\n\t\t\tbest_position = test_position\n\n\t# If no good position found, just move forward toward player\n\tif best_score < 0.5:\n\t\tbest_position = global_position + direction_to_player * CLEAR_SHOT_EXIT_DISTANCE\n\n\treturn best_position\n\n\n## Process SEEKING_COVER state - moving to cover position.\nfunc _process_seeking_cover_state(_delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, stay in combat\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're already hidden from the player (the main goal)\n\tif not _is_visible_from_player():\n\t\t_transition_to_in_cover()\n\t\t_log_debug(\"Hidden from player, entering cover state\")\n\t\treturn\n\n\t# Move towards cover\n\tvar direction := (_cover_position - global_position).normalized()\n\tvar distance := global_position.distance_to(_cover_position)\n\n\tif distance < 10.0:\n\t\t# Reached the cover position, but still visible - try to find better cover\n\t\tif _is_visible_from_player():\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\t# No better cover found, stay in combat\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\n\t# Apply wall avoidance\n\tvar avoidance := _check_wall_ahead(direction)\n\tif avoidance != Vector2.ZERO:\n\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\tvelocity = direction * combat_move_speed\n\trotation = direction.angle()\n\n\t# Can still shoot while moving to cover (only after detection delay)\n\tif _can_see_player and _player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t_aim_at_player()\n\t\t_shoot()\n\t\t_shoot_timer = 0.0\n\n\n## Process IN_COVER state - taking cover from enemy fire.\n## Decides next action based on:\n## 1. If under fire -> suppressed\n## 2. If player is close (can exit cover for direct contact) -> COMBAT\n## 3. If player is far but can hit from current position -> COMBAT (stay and shoot)\n## 4. If player is far and can't hit -> PURSUING (move cover-to-cover)\nfunc _process_in_cover_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# If still under fire, stay suppressed\n\tif _under_fire:\n\t\t_transition_to_suppressed()\n\t\treturn\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover\n\tif _is_visible_from_player():\n\t\t# If in alarm mode and can see player, fire a burst before escaping\n\t\tif _in_alarm_mode and _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"IN_COVER alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay in cover while firing burst\n\n\t\t# Burst complete or not in alarm mode, seek new cover\n\t\t_log_debug(\"Player flanked our cover position, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# Decision making based on player distance and visibility\n\tif _player:\n\t\tvar player_close := _is_player_close()\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\n\t\tif _can_see_player:\n\t\t\tif player_close:\n\t\t\t\t# Player is close - engage in combat (come out, shoot, go back)\n\t\t\t\t_log_debug(\"Player is close, transitioning to COMBAT\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\t# Player is far\n\t\t\t\tif can_hit:\n\t\t\t\t\t# Can hit from current position - come out and shoot\n\t\t\t\t\t# (Don't pursue, just transition to combat which will handle the cycling)\n\t\t\t\t\t_log_debug(\"Player is far but can hit from here, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\telse:\n\t\t\t\t\t# Can't hit from here - need to pursue (move cover-to-cover)\n\t\t\t\t\t_log_debug(\"Player is far and can't hit, transitioning to PURSUING\")\n\t\t\t\t\t_transition_to_pursuing()\n\t\t\t\t\treturn\n\n\t# If not under fire and can see player, engage (only shoot after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If player is no longer visible and not under fire, try pursuing\n\tif not _can_see_player and not _under_fire:\n\t\t_log_debug(\"Lost sight of player from cover, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\n\n## Process FLANKING state - attempting to flank the player using cover-to-cover movement.\n## Uses intermediate cover positions to navigate around obstacles instead of walking\n## directly toward the flank target.\nfunc _process_flanking_state(delta: float) -> void:\n\t# If under fire, retreat with shooting behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# If can see player, engage in combat\n\tif _can_see_player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\tif _player == null:\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# Recalculate flank position (player may have moved)\n\t_calculate_flank_position()\n\n\tvar distance_to_flank := global_position.distance_to(_flank_target)\n\n\t# Check if we've reached the flank target\n\tif distance_to_flank < 30.0:\n\t\t_log_debug(\"Reached flank position, engaging\")\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Check if we have direct line of sight to flank target (no obstacles)\n\tif _has_clear_path_to(_flank_target):\n\t\t# Direct path is clear - move directly toward flank target\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\t_has_flank_cover = false\n\t\treturn\n\n\t# Path is blocked - use cover-to-cover movement\n\n\t# If we're at a cover position, wait briefly before moving to next\n\tif _has_valid_cover and not _has_flank_cover:\n\t\t_flank_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _flank_cover_wait_timer >= FLANK_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover toward flank target\n\t\t\t_find_flank_cover_toward_target()\n\t\t\tif not _has_flank_cover:\n\t\t\t\t_log_debug(\"No flank cover found, attempting direct movement\")\n\t\t\t\t# No cover found - try direct movement with enhanced wall avoidance\n\t\t\t\tvar direction := (_flank_target - global_position).normalized()\n\t\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\t\tvelocity = direction * combat_move_speed\n\t\t\t\trotation = direction.angle()\n\t\t\t\t# Invalidate current cover to trigger new search next frame\n\t\t\t\t_has_valid_cover = false\n\t\treturn\n\n\t# If we have a flank cover target, move toward it\n\tif _has_flank_cover:\n\t\tvar direction := (_flank_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_flank_next_cover)\n\n\t\t# Check if we've reached the flank cover\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached flank cover at distance %.1f\" % distance)\n\t\t\t_has_flank_cover = false\n\t\t\t_flank_cover_wait_timer = 0.0\n\t\t\t_cover_position = _flank_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no flank cover target - find initial flank cover\n\t_find_flank_cover_toward_target()\n\tif not _has_flank_cover:\n\t\t# Can't find cover, try direct movement with wall avoidance\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\n\n## Process SUPPRESSED state - staying in cover under fire.\nfunc _process_suppressed_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover even while suppressed\n\tif _is_visible_from_player():\n\t\t# In suppressed state we're always in alarm mode - fire a burst before escaping if we can see player\n\t\tif _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"SUPPRESSED alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay suppressed while firing burst\n\n\t\t# Burst complete or can't see player, seek new cover\n\t\t_log_debug(\"Player flanked our cover position while suppressed, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Can still shoot while suppressed (only after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If no longer under fire, exit suppression\n\tif not _under_fire:\n\t\t_transition_to_in_cover()\n\n\n## Process RETREATING state - moving to cover with behavior based on damage taken.\nfunc _process_retreating_state(delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, transition to combat or suppressed\n\t\t\tif _under_fire:\n\t\t\t\t_transition_to_suppressed()\n\t\t\telse:\n\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we've reached cover and are hidden from player\n\tif not _is_visible_from_player():\n\t\t_log_debug(\"Reached cover during retreat\")\n\t\t# Reset encounter hits when successfully reaching cover\n\t\t_hits_taken_in_encounter = 0\n\t\t_transition_to_in_cover()\n\t\treturn\n\n\t# Calculate direction to cover\n\tvar direction_to_cover := (_cover_position - global_position).normalized()\n\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\n\t# Check if reached cover position\n\tif distance_to_cover < 10.0:\n\t\tif _is_visible_from_player():\n\t\t\t# Still visible, find better cover\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\tif _under_fire:\n\t\t\t\t\t_transition_to_suppressed()\n\t\t\t\telse:\n\t\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Apply retreat behavior based on mode\n\tmatch _retreat_mode:\n\t\tRetreatMode.FULL_HP:\n\t\t\t_process_retreat_full_hp(delta, direction_to_cover)\n\t\tRetreatMode.ONE_HIT:\n\t\t\t_process_retreat_one_hit(delta, direction_to_cover)\n\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t_process_retreat_multiple_hits(delta, direction_to_cover)\n\n\n## Process FULL_HP retreat: walk backwards facing player, shoot with reduced accuracy,\n## periodically turn toward cover.\nfunc _process_retreat_full_hp(delta: float, direction_to_cover: Vector2) -> void:\n\t_retreat_turn_timer += delta\n\n\tif _retreat_turning_to_cover:\n\t\t# Turning to face cover, don't shoot\n\t\tif _retreat_turn_timer >= RETREAT_TURN_DURATION:\n\t\t\t_retreat_turning_to_cover = false\n\t\t\t_retreat_turn_timer = 0.0\n\n\t\t# Face cover and move toward it\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\telse:\n\t\t# Face player and back up (walk backwards)\n\t\tif _retreat_turn_timer >= RETREAT_TURN_INTERVAL:\n\t\t\t_retreat_turning_to_cover = true\n\t\t\t_retreat_turn_timer = 0.0\n\t\t\t_log_debug(\"FULL_HP retreat: turning to check cover\")\n\n\t\tif _player:\n\t\t\t# Face the player\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\t_aim_at_player()\n\n\t\t\t# Move backwards (opposite of player direction = toward cover generally)\n\t\t\t# Use the negative of the direction we're facing for \"backing up\"\n\t\t\tvar move_direction := -direction_to_player\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed * 0.7  # Slower when backing up\n\n\t\t\t# Shoot with reduced accuracy (only after detection delay)\n\t\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot_with_inaccuracy()\n\t\t\t\t_shoot_timer = 0.0\n\n\n## Process ONE_HIT retreat: quick burst of 2-4 shots in an arc while turning, then face cover.\nfunc _process_retreat_one_hit(delta: float, direction_to_cover: Vector2) -> void:\n\tif not _retreat_burst_complete:\n\t\t# During burst phase\n\t\t_retreat_burst_timer += delta\n\n\t\tif _player and _retreat_burst_remaining > 0 and _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t# Fire a burst shot with arc spread\n\t\t\t_shoot_burst_shot()\n\t\t\t_retreat_burst_remaining -= 1\n\t\t\t_retreat_burst_timer = 0.0\n\n\t\t\t# Progress through the arc\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0  # Spread across 4 shots max\n\n\t\t# Gradually turn from player to cover during burst\n\t\tif _player:\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\tvar target_angle: float\n\n\t\t\t# Interpolate rotation from player direction to cover direction\n\t\t\tvar burst_progress := 1.0 - (float(_retreat_burst_remaining) / 4.0)\n\t\t\tvar player_angle := direction_to_player.angle()\n\t\t\tvar cover_angle := direction_to_cover.angle()\n\t\t\ttarget_angle = lerp_angle(player_angle, cover_angle, burst_progress * 0.7)\n\t\t\trotation = target_angle\n\n\t\t# Move toward cover (slower during burst)\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed * 0.5\n\n\t\t# Check if burst is complete\n\t\tif _retreat_burst_remaining <= 0:\n\t\t\t_retreat_burst_complete = true\n\t\t\t_log_debug(\"ONE_HIT retreat: burst complete, now running to cover\")\n\telse:\n\t\t# After burst, run to cover without shooting\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\n\n## Process MULTIPLE_HITS retreat: quick burst of 2-4 shots then run to cover (same as ONE_HIT).\nfunc _process_retreat_multiple_hits(delta: float, direction_to_cover: Vector2) -> void:\n\t# Same behavior as ONE_HIT - quick burst then escape\n\t_process_retreat_one_hit(delta, direction_to_cover)\n\n\n## Process PURSUING state - move cover-to-cover toward player.\n## Enemy moves between covers, waiting 1-2 seconds at each cover,\n## until they can see and hit the player.\nfunc _process_pursuing_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected during pursuit (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can see player and can hit them from current position, engage\n\tif _can_see_player and _player:\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\t\tif can_hit:\n\t\t\t_log_debug(\"Can see and hit player from pursuit, transitioning to COMBAT\")\n\t\t\t_has_pursuit_cover = false\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're waiting at cover\n\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t# Currently at cover, wait for 1-2 seconds before moving to next cover\n\t\t_pursuit_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _pursuit_cover_wait_timer >= PURSUIT_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover closer to player\n\t\t\t_log_debug(\"Pursuit wait complete, finding next cover\")\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_find_pursuit_cover_toward_player()\n\t\t\tif _has_pursuit_cover:\n\t\t\t\t_log_debug(\"Found pursuit cover at %s\" % _pursuit_next_cover)\n\t\t\telse:\n\t\t\t\t# No pursuit cover found - fallback behavior\n\t\t\t\t_log_debug(\"No pursuit cover found, checking fallback options\")\n\t\t\t\t# If we can now see the player, engage directly\n\t\t\t\tif _can_see_player:\n\t\t\t\t\t_log_debug(\"Can see player, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\t# Try flanking\n\t\t\t\tif enable_flanking and _player:\n\t\t\t\t\t_log_debug(\"Attempting flanking maneuver\")\n\t\t\t\t\t_transition_to_flanking()\n\t\t\t\t\treturn\n\t\t\t\t# Last resort: move directly toward player\n\t\t\t\t_log_debug(\"No cover options, moving directly toward player\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\treturn\n\n\t# If we have a pursuit cover target, move toward it\n\tif _has_pursuit_cover:\n\t\tvar direction := (_pursuit_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_pursuit_next_cover)\n\n\t\t# Check if we've reached the pursuit cover\n\t\t# Note: We only check distance here, NOT visibility from player.\n\t\t# If we checked visibility, the enemy would immediately consider themselves\n\t\t# \"at cover\" even before moving, since they start hidden from player.\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached pursuit cover at distance %.1f\" % distance)\n\t\t\t_has_pursuit_cover = false\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_cover_position = _pursuit_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no pursuit target - find initial pursuit cover\n\t_find_pursuit_cover_toward_player()\n\tif not _has_pursuit_cover:\n\t\t# Can't find cover to pursue, try flanking or combat\n\t\tif enable_flanking and _player:\n\t\t\t_transition_to_flanking()\n\t\telse:\n\t\t\t_transition_to_combat()\n\n\n## Process ASSAULT state - coordinated multi-enemy rush.\n## Wait at cover for 5 seconds, then all enemies rush the player simultaneously.\nfunc _process_assault_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover and not _assault_ready:\n\t\t_in_assault = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if we're the only enemy left in assault - switch back to combat\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat < 2 and not _assault_ready:\n\t\t_log_debug(\"Not enough enemies for assault, switching to COMBAT\")\n\t\t_in_assault = false\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Find closest cover to player if we don't have one\n\tif not _has_valid_cover:\n\t\t_find_cover_closest_to_player()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found assault cover at %s\" % _cover_position)\n\n\t# Move to cover position first\n\tif _has_valid_cover and not _in_assault:\n\t\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\t\tif distance_to_cover > 15.0 and _is_visible_from_player():\n\t\t\t# Still need to reach cover\n\t\t\tvar direction := (_cover_position - global_position).normalized()\n\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\tvelocity = direction * combat_move_speed\n\t\t\trotation = direction.angle()\n\t\t\treturn\n\n\t# At cover, wait for assault timer\n\tif not _assault_ready:\n\t\tvelocity = Vector2.ZERO\n\t\t_assault_wait_timer += delta\n\n\t\t# Check if all assault enemies are ready (synchronized assault)\n\t\tif _assault_wait_timer >= ASSAULT_WAIT_DURATION:\n\t\t\t# Check if situation has changed - player might have moved\n\t\t\tif _player and _is_player_close():\n\t\t\t\t_assault_ready = true\n\t\t\t\t_in_assault = true\n\t\t\t\t_log_debug(\"ASSAULT ready - rushing player!\")\n\t\t\telse:\n\t\t\t\t# Player moved away, reset timer and check if we should pursue\n\t\t\t\t_log_debug(\"Player moved away during assault wait, resetting\")\n\t\t\t\t_assault_wait_timer = 0.0\n\t\t\t\t_in_assault = false\n\t\t\t\t_transition_to_pursuing()\n\t\t\t\treturn\n\t\treturn\n\n\t# Assault phase - rush the player while shooting\n\tif _assault_ready and _player:\n\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction_to_player)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_player = (direction_to_player * 0.5 + avoidance * 0.5).normalized()\n\n\t\t# Rush at full speed\n\t\tvelocity = direction_to_player * combat_move_speed\n\t\trotation = direction_to_player.angle()\n\n\t\t# Update detection delay timer\n\t\tif not _detection_delay_elapsed:\n\t\t\t_detection_timer += delta\n\t\t\tif _detection_timer >= detection_delay:\n\t\t\t\t_detection_delay_elapsed = true\n\n\t\t# Shoot while rushing (only after detection delay)\n\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t\t# If very close to player, stay in combat\n\t\tif distance_to_player < 50.0:\n\t\t\t_log_debug(\"Assault complete - reached player\")\n\t\t\t_assault_ready = false\n\t\t\t_in_assault = false\n\t\t\t_transition_to_combat()\n\n\n## Shoot with reduced accuracy for retreat mode.\nfunc _shoot_with_inaccuracy() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Check if the shot should be taken\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Add inaccuracy spread\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD, RETREAT_INACCURACY_SPREAD)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the inaccurate shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Inaccurate shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Shoot a burst shot with arc spread for ONE_HIT retreat.\nfunc _shoot_burst_shot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Apply arc offset for burst spread\n\tdirection = direction.rotated(_retreat_burst_angle_offset)\n\n\t# Also add some random inaccuracy on top of the arc\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD * 0.5, RETREAT_INACCURACY_SPREAD * 0.5)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the burst shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Burst shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Transition to IDLE state.\nfunc _transition_to_idle() -> void:\n\t_current_state = AIState.IDLE\n\t# Reset encounter hit tracking when returning to idle\n\t_hits_taken_in_encounter = 0\n\t# Reset alarm mode when returning to idle\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\n\n## Transition to COMBAT state.\nfunc _transition_to_combat() -> void:\n\t_current_state = AIState.COMBAT\n\t# Reset detection delay timer when entering combat\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Reset combat phase variables\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_shoot_timer = 0.0\n\t_combat_approach_timer = 0.0\n\t# Reset clear shot seeking variables\n\t_seeking_clear_shot = false\n\t_clear_shot_timer = 0.0\n\t_clear_shot_target = Vector2.ZERO\n\n\n## Transition to SEEKING_COVER state.\nfunc _transition_to_seeking_cover() -> void:\n\t_current_state = AIState.SEEKING_COVER\n\t_find_cover_position()\n\n\n## Transition to IN_COVER state.\nfunc _transition_to_in_cover() -> void:\n\t_current_state = AIState.IN_COVER\n\n\n## Transition to FLANKING state.\nfunc _transition_to_flanking() -> void:\n\t_current_state = AIState.FLANKING\n\t_calculate_flank_position()\n\t_flank_cover_wait_timer = 0.0\n\t_has_flank_cover = false\n\t_has_valid_cover = false\n\n\n## Transition to SUPPRESSED state.\nfunc _transition_to_suppressed() -> void:\n\t_current_state = AIState.SUPPRESSED\n\t# Enter alarm mode when suppressed\n\t_in_alarm_mode = true\n\n\n## Transition to PURSUING state.\nfunc _transition_to_pursuing() -> void:\n\t_current_state = AIState.PURSUING\n\t_pursuit_cover_wait_timer = 0.0\n\t_has_pursuit_cover = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\n\n## Transition to ASSAULT state.\nfunc _transition_to_assault() -> void:\n\t_current_state = AIState.ASSAULT\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Find closest cover to player for assault position\n\t_find_cover_closest_to_player()\n\n\n## Transition to RETREATING state with appropriate retreat mode.\nfunc _transition_to_retreating() -> void:\n\t_current_state = AIState.RETREATING\n\t# Enter alarm mode when retreating\n\t_in_alarm_mode = true\n\n\t# Determine retreat mode based on hits taken\n\tif _hits_taken_in_encounter == 0:\n\t\t_retreat_mode = RetreatMode.FULL_HP\n\t\t_retreat_turn_timer = 0.0\n\t\t_retreat_turning_to_cover = false\n\t\t_log_debug(\"Entering RETREATING state: FULL_HP mode (shoot while backing up)\")\n\telif _hits_taken_in_encounter == 1:\n\t\t_retreat_mode = RetreatMode.ONE_HIT\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t# Calculate arc spread: shots will be distributed across the arc\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: ONE_HIT mode (burst of %d shots)\" % _retreat_burst_remaining)\n\telse:\n\t\t_retreat_mode = RetreatMode.MULTIPLE_HITS\n\t\t# Multiple hits also gets burst fire (same as ONE_HIT)\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: MULTIPLE_HITS mode (burst of %d shots)\" % _retreat_burst_remaining)\n\n\t# Find cover position for retreating\n\t_find_cover_position()\n\n\n## Check if the enemy is visible from the player's position.\n## Uses raycasting from player to enemy to determine if there are obstacles blocking line of sight.\n## This is the inverse of _can_see_player - it checks if the PLAYER can see the ENEMY.\n## Checks multiple points on the enemy body (center and corners) to account for enemy size.\nfunc _is_visible_from_player() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check visibility to multiple points on the enemy body\n\t# This accounts for the enemy's size - corners can stick out from cover\n\tvar check_points := _get_enemy_check_points(global_position)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Get multiple check points on the enemy body for visibility testing.\n## Returns center and 4 corner points offset by the enemy's radius.\nfunc _get_enemy_check_points(center: Vector2) -> Array[Vector2]:\n\t# Enemy collision radius is 24, sprite is 48x48\n\t# Use a slightly smaller radius to avoid edge cases\n\tconst ENEMY_RADIUS: float = 22.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := ENEMY_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point is visible from the player's position.\nfunc _is_point_visible_from_player(point: Vector2) -> bool:\n\tif _player == null:\n\t\treturn false\n\n\tvar player_pos := _player.global_position\n\tvar distance := player_pos.distance_to(point)\n\n\t# Use direct space state to check line of sight from player to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = player_pos\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = []\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between player and point - point is visible\n\t\treturn true\n\telse:\n\t\t# Check if we hit an obstacle before reaching the point\n\t\tvar hit_position: Vector2 = result[\"position\"]\n\t\tvar distance_to_hit := player_pos.distance_to(hit_position)\n\n\t\t# If we hit something closer than the point, the point is hidden\n\t\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t\treturn false\n\t\telse:\n\t\t\treturn true\n\n\n## Check if a specific position would make the enemy visible from the player's position.\n## Checks all enemy body points (center and corners) to account for enemy size.\n## Used to validate cover positions before moving to them.\nfunc _is_position_visible_from_player(pos: Vector2) -> bool:\n\tif _player == null:\n\t\treturn true  # Assume visible if no player\n\n\t# Check visibility for all enemy body points at the given position\n\tvar check_points := _get_enemy_check_points(pos)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Check if a target position is visible from the enemy's perspective.\n## Uses raycast to verify there are no obstacles between enemy and the target position.\n## This is used to validate lead prediction targets - enemies should only aim at\n## positions they can actually see.\nfunc _is_position_visible_to_enemy(target_pos: Vector2) -> bool:\n\tvar distance := global_position.distance_to(target_pos)\n\n\t# Use direct space state to check line of sight from enemy to target\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = target_pos\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and target - position is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t# Hit obstacle before target - position is NOT visible\n\t\t_log_debug(\"Position %s blocked by obstacle at distance %.1f (target at %.1f)\" % [target_pos, distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Get multiple check points on the player's body for visibility testing.\n## Returns center and 4 corner points offset by the player's radius.\n## The player has a collision radius of 16 pixels (from Player.tscn).\nfunc _get_player_check_points(center: Vector2) -> Array[Vector2]:\n\t# Player collision radius is 16, sprite is 32x32\n\t# Use a slightly smaller radius to be conservative\n\tconst PLAYER_RADIUS: float = 14.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := PLAYER_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point on the player is visible from the enemy's position.\n## Uses direct space state query to check for obstacles blocking line of sight.\nfunc _is_player_point_visible_to_enemy(point: Vector2) -> bool:\n\tvar distance := global_position.distance_to(point)\n\n\t# Use direct space state to check line of sight from enemy to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and point - point is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the point\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\t# If we hit something before the point, the point is blocked\n\tif distance_to_hit < distance - 5.0:  # 5 pixel tolerance\n\t\treturn false\n\n\treturn true\n\n\n## Calculate what fraction of the player's body is visible to the enemy.\n## Returns a value from 0.0 (completely hidden) to 1.0 (fully visible).\n## Checks multiple points on the player's body (center + corners).\nfunc _calculate_player_visibility_ratio() -> float:\n\tif _player == null:\n\t\treturn 0.0\n\n\tvar check_points := _get_player_check_points(_player.global_position)\n\tvar visible_count := 0\n\n\tfor point in check_points:\n\t\tif _is_player_point_visible_to_enemy(point):\n\t\t\tvisible_count += 1\n\n\treturn float(visible_count) / float(check_points.size())\n\n\n## Check if the line of fire to the target position is clear of other enemies.\n## Returns true if no other enemies would be hit by a bullet traveling to the target.\nfunc _is_firing_line_clear_of_friendlies(target_position: Vector2) -> bool:\n\tif not enable_friendly_fire_avoidance:\n\t\treturn true\n\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if any enemies are in the firing line\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 2  # Only check enemies (layer 2)\n\tquery.exclude = [get_rid()]  # Exclude self using RID\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No enemies in the way\n\n\t# Check if the hit position is before the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 20.0:  # 20 pixel tolerance\n\t\t_log_debug(\"Friendly in firing line at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if a bullet fired at the target position would be blocked by cover/obstacles.\n## Returns true if the shot would likely hit the target, false if blocked by cover.\nfunc _is_shot_clear_of_cover(target_position: Vector2) -> bool:\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if obstacles block the shot\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No obstacles in the way\n\n\t# Check if the obstacle is before the target position\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t_log_debug(\"Shot blocked by cover at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if there's an obstacle immediately in front of the enemy that would block bullets.\n## This prevents shooting into walls that the enemy is flush against or very close to.\n## Uses a single raycast from enemy center to the bullet spawn position.\nfunc _is_bullet_spawn_clear(direction: Vector2) -> bool:\n\t# Fail-open: allow shooting if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn true\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn true\n\n\t# Check from enemy center to bullet spawn position plus a small buffer\n\tvar check_distance := bullet_spawn_offset + 5.0\n\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = global_position + direction * check_distance\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]\n\n\tvar result := space_state.intersect_ray(query)\n\tif not result.is_empty():\n\t\t_log_debug(\"Bullet spawn blocked: wall at distance %.1f\" % [\n\t\t\tglobal_position.distance_to(result[\"position\"])])\n\t\treturn false\n\n\treturn true\n\n\n## Find a sidestep direction that would lead to a clear shot position.\n## Checks perpendicular directions to the player and returns the first one\n## that would allow the bullet spawn point to be clear.\n## Returns Vector2.ZERO if no clear direction is found.\nfunc _find_sidestep_direction_for_clear_shot(direction_to_player: Vector2) -> Vector2:\n\t# Fail-safe: allow normal behavior if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn Vector2.ZERO\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn Vector2.ZERO\n\n\t# Check perpendicular directions (left and right of the player direction)\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Check both sidestep directions and pick the one that leads to clear shot faster\n\tvar check_distance := 50.0  # Check if moving 50 pixels in this direction would help\n\tvar bullet_check_distance := bullet_spawn_offset + 5.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:  # Try both sides\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\n\t\t# First check if we can actually move in this direction (no wall blocking movement)\n\t\tvar move_query := PhysicsRayQueryParameters2D.new()\n\t\tmove_query.from = global_position\n\t\tmove_query.to = global_position + sidestep_dir * 30.0\n\t\tmove_query.collision_mask = 4  # Only check obstacles\n\t\tmove_query.exclude = [get_rid()]\n\n\t\tvar move_result := space_state.intersect_ray(move_query)\n\t\tif not move_result.is_empty():\n\t\t\tcontinue  # Can't move this way, wall is blocking\n\n\t\t# Check if after sidestepping, we'd have a clear shot\n\t\tvar test_position: Vector2 = global_position + sidestep_dir * check_distance\n\t\tvar shot_query := PhysicsRayQueryParameters2D.new()\n\t\tshot_query.from = test_position\n\t\tshot_query.to = test_position + direction_to_player * bullet_check_distance\n\t\tshot_query.collision_mask = 4\n\t\tshot_query.exclude = [get_rid()]\n\n\t\tvar shot_result := space_state.intersect_ray(shot_query)\n\t\tif shot_result.is_empty():\n\t\t\t# Found a direction that leads to a clear shot\n\t\t\t_log_debug(\"Found sidestep direction: %s\" % sidestep_dir)\n\t\t\treturn sidestep_dir\n\n\treturn Vector2.ZERO  # No clear sidestep direction found\n\n\n## Check if the enemy should shoot at the current target.\n## Validates bullet spawn clearance, friendly fire avoidance, and cover blocking.\nfunc _should_shoot_at_target(target_position: Vector2) -> bool:\n\t# Check if the immediate path to bullet spawn is clear\n\t# This prevents shooting into walls the enemy is flush against\n\tvar direction := (target_position - global_position).normalized()\n\tif not _is_bullet_spawn_clear(direction):\n\t\treturn false\n\n\t# Check if friendlies are in the way\n\tif not _is_firing_line_clear_of_friendlies(target_position):\n\t\treturn false\n\n\t# Check if cover blocks the shot\n\tif not _is_shot_clear_of_cover(target_position):\n\t\treturn false\n\n\treturn true\n\n\n## Check if the player is \"close\" (within CLOSE_COMBAT_DISTANCE).\n## Used to determine if the enemy should engage directly or pursue.\nfunc _is_player_close() -> bool:\n\tif _player == null:\n\t\treturn false\n\treturn global_position.distance_to(_player.global_position) <= CLOSE_COMBAT_DISTANCE\n\n\n## Check if the enemy can hit the player from their current position.\n## Returns true if there's a clear line of fire to the player.\nfunc _can_hit_player_from_current_position() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check if we can see the player\n\tif not _can_see_player:\n\t\treturn false\n\n\t# Check if the shot would be blocked by cover\n\treturn _is_shot_clear_of_cover(_player.global_position)\n\n\n## Count the number of enemies currently in combat-related states.\n## Includes COMBAT, PURSUING, ASSAULT, IN_COVER (if can see player).\n## Used to determine if multi-enemy assault should be triggered.\nfunc _count_enemies_in_combat() -> int:\n\tvar count := 0\n\tvar enemies := get_tree().get_nodes_in_group(\"enemies\")\n\n\tfor enemy in enemies:\n\t\tif enemy == self:\n\t\t\tcontinue\n\t\tif not enemy.has_method(\"get_current_state\"):\n\t\t\tcontinue\n\n\t\tvar state: AIState = enemy.get_current_state()\n\t\t# Count enemies in combat-related states\n\t\tif state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\t\t# For IN_COVER, only count if they can see the player\n\t\t\tif state == AIState.IN_COVER:\n\t\t\t\tif enemy.has_method(\"is_in_combat_engagement\") and enemy.is_in_combat_engagement():\n\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tcount += 1\n\n\t# Count self if in a combat-related state\n\tif _current_state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\tcount += 1\n\n\treturn count\n\n\n## Check if this enemy is engaged in combat (can see player and in combat state).\nfunc is_in_combat_engagement() -> bool:\n\treturn _can_see_player and _current_state in [AIState.COMBAT, AIState.IN_COVER, AIState.ASSAULT]\n\n\n## Find cover position closer to the player for pursuit.\n## Used during PURSUING state to move cover-to-cover toward the player.\nfunc _find_pursuit_cover_toward_player() -> void:\n\tif _player == null:\n\t\t_has_pursuit_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For pursuit, we want cover that is:\n\t\t\t# 1. Closer to the player than we currently are\n\t\t\t# 2. Hidden from the player (or mostly hidden)\n\t\t\t# 3. Not too far from our current position\n\n\t\t\tvar my_distance_to_player := global_position.distance_to(player_pos)\n\t\t\tvar cover_distance_to_player := cover_pos.distance_to(player_pos)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to player\n\t\t\tif cover_distance_to_player >= my_distance_to_player:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if this position is hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Hidden from player (priority)\n\t\t\t# - Closer to player\n\t\t\t# - Not too far from current position\n\t\t\tvar hidden_score: float = 5.0 if is_hidden else 0.0\n\t\t\tvar approach_score: float = (my_distance_to_player - cover_distance_to_player) / CLOSE_COMBAT_DISTANCE\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = hidden_score + approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_pursuit_next_cover = best_cover\n\t\t_has_pursuit_cover = true\n\t\t_log_debug(\"Found pursuit cover at %s (score: %.2f)\" % [_pursuit_next_cover, best_score])\n\telse:\n\t\t_has_pursuit_cover = false\n\n\n## Find cover position closest to the player for assault positioning.\n## Used during ASSAULT state to take the nearest safe cover to the player.\nfunc _find_cover_closest_to_player() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_distance: float = INF\n\tvar found_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# Check if this position is hidden from player (safe cover)\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\
[2026-01-18T02:52:58.885Z] [INFO] n\t\t\tif is_hidden:\n\t\t\t\t# Calculate distance from this cover to the player\n\t\t\t\tvar distance_to_player := cover_pos.distance_to(player_pos)\n\n\t\t\t\t# We want the cover closest to the player\n\t\t\t\tif distance_to_player < best_distance:\n\t\t\t\t\tbest_distance = distance_to_player\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\t\tfound_cover = true\n\n\tif found_cover:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found assault cover at %s (distance to player: %.1f)\" % [_cover_position, best_distance])\n\telse:\n\t\t# Fall back to normal cover finding\n\t\t_find_cover_position()\n\n\n## Find a valid cover position relative to the player.\n## The cover position must be hidden from the player's line of sight.\nfunc _find_cover_position() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_hidden_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is on the opposite side of the obstacle from player\n\t\t\tvar direction_from_player := (collision_point - player_pos).normalized()\n\n\t\t\t# Position behind cover (offset from collision point along normal)\n\t\t\t# Offset must be large enough to hide the entire enemy body (radius ~24 pixels)\n\t\t\t# Using 35 pixels to provide some margin for the enemy's collision shape\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# First priority: Check if this position is actually hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Only consider hidden positions unless we have no choice\n\t\t\tif is_hidden or not found_hidden_cover:\n\t\t\t\t# Score based on:\n\t\t\t\t# 1. Whether position is hidden (highest priority)\n\t\t\t\t# 2. Distance from enemy (closer is better)\n\t\t\t\t# 3. Position relative to player (behind cover from player's view)\n\t\t\t\tvar hidden_score: float = 10.0 if is_hidden else 0.0  # Heavy weight for hidden positions\n\n\t\t\t\tvar distance_score := 1.0 - (global_position.distance_to(cover_pos) / COVER_CHECK_DISTANCE)\n\n\t\t\t\t# Check if this position is on the far side of obstacle from player\n\t\t\t\tvar cover_direction := (cover_pos - player_pos).normalized()\n\t\t\t\tvar dot_product := direction_from_player.dot(cover_direction)\n\t\t\t\tvar blocking_score: float = maxf(0.0, dot_product)\n\n\t\t\t\tvar total_score: float = hidden_score + distance_score * 0.3 + blocking_score * 0.7\n\n\t\t\t\t# If we find a hidden position, only accept other hidden positions\n\t\t\t\tif is_hidden and not found_hidden_cover:\n\t\t\t\t\tfound_hidden_cover = true\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\telif (is_hidden or not found_hidden_cover) and total_score > best_score:\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\n\tif best_score > 0:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found cover at: %s (hidden: %s)\" % [_cover_position, found_hidden_cover])\n\telse:\n\t\t_has_valid_cover = false\n\n\n## Calculate flank position based on player location.\nfunc _calculate_flank_position() -> void:\n\tif _player == null:\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar player_to_enemy := (global_position - player_pos).normalized()\n\n\t# Choose left or right flank based on current position\n\tvar flank_side := 1.0 if randf() > 0.5 else -1.0\n\tvar flank_direction := player_to_enemy.rotated(flank_angle * flank_side)\n\n\t_flank_target = player_pos + flank_direction * flank_distance\n\t_log_debug(\"Flank target: %s\" % _flank_target)\n\n\n## Check if there's a clear path (no obstacles) to the target position.\n## Uses a raycast to check for walls/obstacles between current position and target.\nfunc _has_clear_path_to(target: Vector2) -> bool:\n\tif _raycast == null:\n\t\treturn true  # Assume clear if no raycast available\n\n\tvar direction := (target - global_position).normalized()\n\tvar distance := global_position.distance_to(target)\n\n\t_raycast.target_position = direction * distance\n\t_raycast.force_raycast_update()\n\n\t# If we hit something, path is blocked\n\tif _raycast.is_colliding():\n\t\tvar collision_point := _raycast.get_collision_point()\n\t\tvar collision_distance := global_position.distance_to(collision_point)\n\t\t# Only consider it blocked if the collision is before the target\n\t\treturn collision_distance >= distance - 10.0\n\n\treturn true\n\n\n## Find cover position closer to the flank target.\n## Used during FLANKING state to move cover-to-cover toward the flank position.\nfunc _find_flank_cover_toward_target() -> void:\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For flanking, we want cover that is:\n\t\t\t# 1. Closer to the flank target than we currently are\n\t\t\t# 2. Not too far from our current position\n\t\t\t# 3. Reachable (has clear path)\n\n\t\t\tvar my_distance_to_target := global_position.distance_to(_flank_target)\n\t\t\tvar cover_distance_to_target := cover_pos.distance_to(_flank_target)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to flank target\n\t\t\tif cover_distance_to_target >= my_distance_to_target:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if we can reach this cover (has clear path)\n\t\t\tif not _has_clear_path_to(cover_pos):\n\t\t\t\t# Even if direct path is blocked, we might be able to reach\n\t\t\t\t# via another intermediate cover, but skip for now\n\t\t\t\tcontinue\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Closer to flank target (priority)\n\t\t\t# - Not too far from current position\n\t\t\tvar approach_score: float = (my_distance_to_target - cover_distance_to_target) / flank_distance\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_flank_next_cover = best_cover\n\t\t_has_flank_cover = true\n\t\t_log_debug(\"Found flank cover at %s (score: %.2f)\" % [_flank_next_cover, best_score])\n\telse:\n\t\t_has_flank_cover = false\n\n\n## Check if there's a wall ahead in the given direction and return avoidance direction.\n## Returns Vector2.ZERO if no wall detected, otherwise returns a vector to avoid the wall.\nfunc _check_wall_ahead(direction: Vector2) -> Vector2:\n\tif _wall_raycasts.is_empty():\n\t\treturn Vector2.ZERO\n\n\tvar avoidance := Vector2.ZERO\n\tvar perpendicular := Vector2(-direction.y, direction.x)  # 90 degrees rotation\n\n\t# Check center, left, and right raycasts\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar angle_offset := (i - 1) * 0.5  # -0.5, 0, 0.5 radians (~-28, 0, 28 degrees)\n\t\tvar check_direction := direction.rotated(angle_offset)\n\n\t\tvar raycast := _wall_raycasts[i]\n\t\traycast.target_position = check_direction * WALL_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\t# Calculate avoidance based on which raycast hit\n\t\t\tif i == 0:  # Left raycast hit\n\t\t\t\tavoidance += perpendicular  # Steer right\n\t\t\telif i == 1:  # Center raycast hit\n\t\t\t\tavoidance += perpendicular if randf() > 0.5 else -perpendicular  # Random steer\n\t\t\telif i == 2:  # Right raycast hit\n\t\t\t\tavoidance -= perpendicular  # Steer left\n\n\treturn avoidance.normalized() if avoidance.length() > 0 else Vector2.ZERO\n\n\n## Check if the player is visible using raycast.\n## If detection_range is 0 or negative, uses unlimited detection range (line-of-sight only).\n## This allows the enemy to see the player even outside the viewport if there's no obstacle.\n## Also updates the continuous visibility timer and visibility ratio for lead prediction control.\nfunc _check_player_visibility() -> void:\n\tvar was_visible := _can_see_player\n\t_can_see_player = false\n\t_player_visibility_ratio = 0.0\n\n\tif _player == null or not _raycast:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t# Check if player is within detection range (only if detection_range is positive)\n\t# If detection_range <= 0, detection is unlimited (line-of-sight only)\n\tif detection_range > 0 and distance_to_player > detection_range:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\t# Point raycast at player - use actual distance to player for the raycast length\n\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\tvar raycast_length := distance_to_player + 10.0  # Add small buffer to ensure we reach player\n\t_raycast.target_position = direction_to_player * raycast_length\n\t_raycast.force_raycast_update()\n\n\t# Check if raycast hit something\n\tif _raycast.is_colliding():\n\t\tvar collider := _raycast.get_collider()\n\t\t# If we hit the player, we can see them\n\t\tif collider == _player:\n\t\t\t_can_see_player = true\n\t\t# If we hit a wall/obstacle before the player, we can't see them\n\telse:\n\t\t# No collision between us and player - we have clear line of sight\n\t\t_can_see_player = true\n\n\t# Update continuous visibility timer and visibility ratio\n\tif _can_see_player:\n\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n\t\t# Calculate what fraction of the player's body is visible\n\t\t# This is used to determine if lead prediction should be enabled\n\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n\telse:\n\t\t# Lost line of sight - reset the timer and visibility ratio\n\t\t_continuous_visibility_timer = 0.0\n\t\t_player_visibility_ratio = 0.0\n\n\n## Aim the enemy sprite/direction at the player using gradual rotation.\nfunc _aim_at_player() -> void:\n\tif _player == null:\n\t\treturn\n\tvar direction := (_player.global_position - global_position).normalized()\n\tvar target_angle := direction.angle()\n\n\t# Calculate the shortest rotation direction\n\tvar angle_diff := wrapf(target_angle - rotation, -PI, PI)\n\n\t# Get the delta time from the current physics process\n\tvar delta := get_physics_process_delta_time()\n\n\t# Apply gradual rotation based on rotation_speed\n\tif abs(angle_diff) <= rotation_speed * delta:\n\t\t# Close enough to snap to target\n\t\trotation = target_angle\n\telif angle_diff > 0:\n\t\trotation += rotation_speed * delta\n\telse:\n\t\trotation -= rotation_speed * delta\n\n\n## Shoot a bullet towards the player.\nfunc _shoot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\t# Check if we can shoot (have ammo and not reloading)\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Apply lead prediction if enabled\n\tif enable_lead_prediction:\n\t\ttarget_position = _calculate_lead_prediction()\n\n\t# Check if the shot should be taken (friendly fire and cover checks)\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Create bullet instance\n\tvar bullet := bullet_scene.instantiate()\n\n\t# Set bullet position with offset in shoot direction\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\n\t# Set bullet direction\n\tbullet.direction = direction\n\n\t# Set shooter ID to identify this enemy as the source\n\t# This prevents enemies from detecting their own bullets in the threat sphere\n\tbullet.shooter_id = get_instance_id()\n\n\t# Add bullet to the scene tree\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play shooting sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\n\t# Play shell casing sound with a small delay\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\t# Auto-reload when magazine is empty\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Play shell casing sound with a delay to simulate the casing hitting the ground.\nfunc _play_delayed_shell_sound() -> void:\n\tawait get_tree().create_timer(0.15).timeout\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_shell_rifle\"):\n\t\taudio_manager.play_shell_rifle(global_position)\n\n\n## Calculate lead prediction - aims where the player will be, not where they are.\n## Uses iterative approach for better accuracy with moving targets.\n## Only applies lead prediction if:\n## 1. The player has been continuously visible for at least lead_prediction_delay seconds\n## 2. At least lead_prediction_visibility_threshold of the player's body is visible\n## 3. The predicted position is also visible to the enemy (not behind cover)\n## This prevents enemies from \"knowing\" where the player will emerge from cover.\nfunc _calculate_lead_prediction() -> Vector2:\n\tif _player == null:\n\t\treturn global_position\n\n\tvar player_pos := _player.global_position\n\n\t# Only use lead prediction if the player has been continuously visible\n\t# for long enough. This prevents enemies from predicting player position\n\t# immediately when they emerge from cover.\n\tif _continuous_visibility_timer < lead_prediction_delay:\n\t\t_log_debug(\"Lead prediction disabled: visibility time %.2fs < %.2fs required\" % [_continuous_visibility_timer, lead_prediction_delay])\n\t\treturn player_pos\n\n\t# Only use lead prediction if enough of the player's body is visible.\n\t# This prevents pre-firing when the player is at the edge of cover with only\n\t# a small part of their body visible. The player must be significantly exposed\n\t# before the enemy can predict their movement.\n\tif _player_visibility_ratio < lead_prediction_visibility_threshold:\n\t\t_log_debug(\"Lead prediction disabled: visibility ratio %.2f < %.2f required (player at cover edge)\" % [_player_visibility_ratio, lead_prediction_visibility_threshold])\n\t\treturn player_pos\n\n\tvar player_velocity := Vector2.ZERO\n\n\t# Get player velocity if they are a CharacterBody2D\n\tif _player is CharacterBody2D:\n\t\tplayer_velocity = _player.velocity\n\n\t# If player is stationary, no need for prediction\n\tif player_velocity.length_squared() < 1.0:\n\t\treturn player_pos\n\n\t# Iterative lead prediction for better accuracy\n\t# Start with player's current position\n\tvar predicted_pos := player_pos\n\tvar distance := global_position.distance_to(predicted_pos)\n\n\t# Iterate 2-3 times for convergence\n\tfor i in range(3):\n\t\t# Time for bullet to reach the predicted position\n\t\tvar time_to_target := distance / bullet_speed\n\n\t\t# Predict where player will be at that time\n\t\tpredicted_pos = player_pos + player_velocity * time_to_target\n\n\t\t# Update distance for next iteration\n\t\tdistance = global_position.distance_to(predicted_pos)\n\n\t# CRITICAL: Validate that the predicted position is actually visible to the enemy.\n\t# If the predicted position is behind cover (e.g., player is running toward cover exit),\n\t# we should NOT aim there - it would feel like the enemy is \"cheating\" by knowing\n\t# where the player will emerge. Fall back to player's current visible position.\n\tif not _is_position_visible_to_enemy(predicted_pos):\n\t\t_log_debug(\"Lead prediction blocked: predicted position %s is not visible, using current position %s\" % [predicted_pos, player_pos])\n\t\treturn player_pos\n\n\t_log_debug(\"Lead prediction: player at %s moving %s, aiming at %s\" % [player_pos, player_velocity, predicted_pos])\n\n\treturn predicted_pos\n\n\n## Process patrol behavior - move between patrol points.\nfunc _process_patrol(delta: float) -> void:\n\tif _patrol_points.is_empty():\n\t\treturn\n\n\t# Handle waiting at patrol point\n\tif _is_waiting_at_patrol_point:\n\t\t_patrol_wait_timer += delta\n\t\tif _patrol_wait_timer >= patrol_wait_time:\n\t\t\t_is_waiting_at_patrol_point = false\n\t\t\t_patrol_wait_timer = 0.0\n\t\t\t_current_patrol_index = (_current_patrol_index + 1) % _patrol_points.size()\n\t\tvelocity = Vector2.ZERO\n\t\treturn\n\n\t# Move towards current patrol point\n\tvar target_point := _patrol_points[_current_patrol_index]\n\tvar direction := (target_point - global_position).normalized()\n\tvar distance := global_position.distance_to(target_point)\n\n\tif distance < 5.0:\n\t\t# Reached patrol point, start waiting\n\t\t_is_waiting_at_patrol_point = true\n\t\tvelocity = Vector2.ZERO\n\telse:\n\t\t# Check for walls and apply avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\t# Blend movement direction with avoidance\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * move_speed\n\t\t# Face movement direction when patrolling\n\t\trotation = direction.angle()\n\n\n## Process guard behavior - stand still and look around.\nfunc _process_guard(_delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\t# In guard mode, enemy doesn't move but can still aim at player when visible\n\n\n## Called when a bullet enters the threat sphere.\nfunc _on_threat_area_entered(area: Area2D) -> void:\n\t# Check if bullet has shooter_id property and if it's from this enemy\n\t# This prevents enemies from being suppressed by their own bullets\n\tif \"shooter_id\" in area and area.shooter_id == get_instance_id():\n\t\treturn  # Ignore own bullets\n\n\t_bullets_in_threat_sphere.append(area)\n\t# Set threat memory timer so enemy can react even after fast bullets exit\n\t# This allows the reaction delay to complete even if bullets pass through quickly\n\t_threat_memory_timer = THREAT_MEMORY_DURATION\n\t# Note: _under_fire is now set in _update_suppression after threat_reaction_delay\n\t# This gives the player more time before the enemy reacts to nearby gunfire\n\t_log_debug(\"Bullet entered threat sphere, starting reaction delay...\")\n\n\n## Called when a bullet exits the threat sphere.\nfunc _on_threat_area_exited(area: Area2D) -> void:\n\t_bullets_in_threat_sphere.erase(area)\n\n\n## Called when the enemy is hit (by bullet.gd).\nfunc on_hit() -> void:\n\tif not _is_alive:\n\t\treturn\n\n\thit.emit()\n\n\t# Track hits for retreat behavior\n\t_hits_taken_in_encounter += 1\n\t_log_debug(\"Hit taken! Total hits in encounter: %d\" % _hits_taken_in_encounter)\n\t_log_to_file(\"Hit taken, health: %d/%d\" % [_current_health - 1, _max_health])\n\n\t# Show hit flash effect\n\t_show_hit_flash()\n\n\t# Apply damage\n\t_current_health -= 1\n\n\t# Play appropriate hit sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif _current_health <= 0:\n\t\t# Play lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_lethal\"):\n\t\t\taudio_manager.play_hit_lethal(global_position)\n\t\t_on_death()\n\telse:\n\t\t# Play non-lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_non_lethal\"):\n\t\t\taudio_manager.play_hit_non_lethal(global_position)\n\t\t_update_health_visual()\n\n\n## Shows a brief flash effect when hit.\nfunc _show_hit_flash() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t_sprite.modulate = hit_flash_color\n\n\tawait get_tree().create_timer(hit_flash_duration).timeout\n\n\t# Restore color based on current health (if still alive)\n\tif _is_alive:\n\t\t_update_health_visual()\n\n\n## Updates the sprite color based on current health percentage.\nfunc _update_health_visual() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t# Interpolate color based on health percentage\n\tvar health_percent := _get_health_percent()\n\t_sprite.modulate = full_health_color.lerp(low_health_color, 1.0 - health_percent)\n\n\n## Returns the current health as a percentage (0.0 to 1.0).\nfunc _get_health_percent() -> float:\n\tif _max_health <= 0:\n\t\treturn 0.0\n\treturn float(_current_health) / float(_max_health)\n\n\n## Called when the enemy dies.\nfunc _on_death() -> void:\n\t_is_alive = false\n\t_log_to_file(\"Enemy died\")\n\tdied.emit()\n\n\tif destroy_on_death:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\tqueue_free()\n\telse:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\t_reset()\n\n\n## Resets the enemy to its initial state.\nfunc _reset() -> void:\n\tglobal_position = _initial_position\n\trotation = 0.0\n\t_current_patrol_index = 0\n\t_is_waiting_at_patrol_point = false\n\t_patrol_wait_timer = 0.0\n\t_current_state = AIState.IDLE\n\t_has_valid_cover = false\n\t_under_fire = false\n\t_suppression_timer = 0.0\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t_continuous_visibility_timer = 0.0\n\t_player_visibility_ratio = 0.0\n\t_threat_reaction_timer = 0.0\n\t_threat_reaction_delay_elapsed = false\n\t_threat_memory_timer = 0.0\n\t_bullets_in_threat_sphere.clear()\n\t# Reset retreat state variables\n\t_hits_taken_in_encounter = 0\n\t_retreat_mode = RetreatMode.FULL_HP\n\t_retreat_turn_timer = 0.0\n\t_retreat_turning_to_cover = false\n\t_retreat_burst_remaining = 0\n\t_retreat_burst_timer = 0.0\n\t_retreat_burst_complete = false\n\t_retreat_burst_angle_offset = 0.0\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\t# Reset combat state variables\n\t_combat_shoot_timer = 0.0\n\t_combat_shoot_duration = 2.5\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_approach_timer = 0.0\n\t# Reset pursuit state variables\n\t_pursuit_cover_wait_timer = 0.0\n\t_pursuit_next_cover = Vector2.ZERO\n\t_has_pursuit_cover = false\n\t# Reset assault state variables\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset flank state variables\n\t_flank_cover_wait_timer = 0.0\n\t_flank_next_cover = Vector2.ZERO\n\t_has_flank_cover = false\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_initialize_goap_state()\n\n\n## Log debug message if debug_logging is enabled.\nfunc _log_debug(message: String) -> void:\n\tif debug_logging:\n\t\tprint(\"[Enemy %s] %s\" % [name, message])\n\n\n## Log a message to the file logger (always logs, regardless of debug_logging setting).\n## Use for important events like spawning, dying, or critical state changes.\nfunc _log_to_file(message: String) -> void:\n\tif not is_inside_tree():\n\t\treturn\n\tvar file_logger: Node = get_node_or_null(\"/root/FileLogger\")\n\tif file_logger and file_logger.has_method(\"log_enemy\"):\n\t\tfile_logger.log_enemy(name, message)\n\n\n## Log spawn info (called via call_deferred to ensure FileLogger is loaded).\nfunc _log_spawn_info() -> void:\n\t_log_to_file(\"Enemy spawned at %s, health: %d, behavior: %s, player_found: %s\" % [\n\t\tglobal_position, _max_health, BehaviorMode.keys()[behavior_mode],\n\t\t\"yes\" if _player != null else \"no\"])\n\n\n## Get AI state name as a human-readable string.\nfunc _get_state_name(state: AIState) -> String:\n\tmatch state:\n\t\tAIState.IDLE:\n\t\t\treturn \"IDLE\"\n\t\tAIState.COMBAT:\n\t\t\treturn \"COMBAT\"\n\t\tAIState.SEEKING_COVER:\n\t\t\treturn \"SEEKING_COVER\"\n\t\tAIState.IN_COVER:\n\t\t\treturn \"IN_COVER\"\n\t\tAIState.FLANKING:\n\t\t\treturn \"FLANKING\"\n\t\tAIState.SUPPRESSED:\n\t\t\treturn \"SUPPRESSED\"\n\t\tAIState.RETREATING:\n\t\t\treturn \"RETREATING\"\n\t\tAIState.PURSUING:\n\t\t\treturn \"PURSUING\"\n\t\tAIState.ASSAULT:\n\t\t\treturn \"ASSAULT\"\n\t\t_:\n\t\t\treturn \"UNKNOWN\"\n\n\n## Update the debug label with current AI state.\nfunc _update_debug_label() -> void:\n\tif _debug_label == null:\n\t\treturn\n\n\t_debug_label.visible = debug_label_enabled\n\tif not debug_label_enabled:\n\t\treturn\n\n\tvar state_text := _get_state_name(_current_state)\n\n\t# Add retreat mode info if retreating\n\tif _current_state == AIState.RETREATING:\n\t\tmatch _retreat_mode:\n\t\t\tRetreatMode.FULL_HP:\n\t\t\t\tstate_text += \"\\n(FULL_HP)\"\n\t\t\tRetreatMode.ONE_HIT:\n\t\t\t\tstate_text += \"\\n(ONE_HIT)\"\n\t\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t\tstate_text += \"\\n(MULTI_HITS)\"\n\n\t# Add assault timer info if in assault state\n\tif _current_state == AIState.ASSAULT:\n\t\tif _assault_ready:\n\t\t\tstate_text += \"\\n(RUSHING)\"\n\t\telse:\n\t\t\tvar time_left := ASSAULT_WAIT_DURATION - _assault_wait_timer\n\t\t\tstate_text += \"\\n(%.1fs)\" % time_left\n\n\t# Add combat phase info if in combat\n\tif _current_state == AIState.COMBAT:\n\t\tif _combat_exposed:\n\t\t\tvar time_left := _combat_shoot_duration - _combat_shoot_timer\n\t\t\tstate_text += \"\\n(EXPOSED %.1fs)\" % time_left\n\t\telif _seeking_clear_shot:\n\t\t\tvar time_left := CLEAR_SHOT_MAX_TIME - _clear_shot_timer\n\t\t\tstate_text += \"\\n(SEEK SHOT %.1fs)\" % time_left\n\t\telif _combat_approaching:\n\t\t\tstate_text += \"\\n(APPROACH)\"\n\n\t# Add pursuit timer info if pursuing and waiting at cover\n\tif _current_state == AIState.PURSUING:\n\t\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t\tvar time_left := PURSUIT_COVER_WAIT_DURATION - _pursuit_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_pursuit_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\n\t# Add flanking phase info if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_valid_cover and not _has_flank_cover:\n\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_flank_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\t\telse:\n\t\t\tstate_text += \"\\n(DIRECT)\"\n\n\t_debug_label.text = state_text\n\n\n## Get current AI state (for external access/debugging).\nfunc get_current_state() -> AIState:\n\treturn _current_state\n\n\n## Get GOAP world state (for GOAP planner).\nfunc get_goap_world_state() -> Dictionary:\n\treturn _goap_world_state.duplicate()\n\n\n## Check if enemy is currently under fire.\nfunc is_under_fire() -> bool:\n\treturn _under_fire\n\n\n## Check if enemy is in cover.\nfunc is_in_cover() -> bool:\n\treturn _current_state == AIState.IN_COVER or _current_state == AIState.SUPPRESSED\n\n\n## Get current ammo in magazine.\nfunc get_current_ammo() -> int:\n\treturn _current_ammo\n\n\n## Get reserve ammo.\nfunc get_reserve_ammo() -> int:\n\treturn _reserve_ammo\n\n\n## Get total ammo (current + reserve).\nfunc get_total_ammo() -> int:\n\treturn _current_ammo + _reserve_ammo\n\n\n## Check if enemy is currently reloading.\nfunc is_reloading() -> bool:\n\treturn _is_reloading\n\n\n## Check if enemy has any ammo left.\nfunc has_ammo() -> bool:\n\treturn _current_ammo > 0 or _reserve_ammo > 0\n\n\n## Get current player visibility ratio (for debugging).\n## Returns 0.0 if player is completely hidden, 1.0 if fully visible.\nfunc get_player_visibility_ratio() -> float:\n\treturn _player_visibility_ratio\n\n\n## Draw debug visualization when debug mode is enabled.\n## Shows: line to target (cover, clear shot, player), bullet spawn point status.\nfunc _draw() -> void:\n\tif not debug_label_enabled:\n\t\treturn\n\n\t# Colors for different debug elements\n\tvar color_to_cover := Color.CYAN  # Line to cover position\n\tvar color_to_player := Color.RED  # Line to player (when visible)\n\tvar color_clear_shot := Color.YELLOW  # Line to clear shot target\n\tvar color_pursuit := Color.ORANGE  # Line to pursuit cover\n\tvar color_flank := Color.MAGENTA  # Line to flank position\n\tvar color_bullet_spawn := Color.GREEN  # Bullet spawn point indicator\n\tvar color_blocked := Color.RED  # Blocked path indicator\n\n\t# Draw line to player if visible\n\tif _can_see_player and _player:\n\t\tvar to_player := _player.global_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_player, color_to_player, 1.5)\n\n\t\t# Draw bullet spawn point and check if blocked\n\t\tvar direction_to_player := to_player.normalized()\n\t\tvar spawn_point := direction_to_player * bullet_spawn_offset\n\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\tdraw_circle(spawn_point, 5.0, color_bullet_spawn)\n\t\telse:\n\t\t\t# Draw X for blocked spawn point\n\t\t\tdraw_line(spawn_point + Vector2(-5, -5), spawn_point + Vector2(5, 5), color_blocked, 2.0)\n\t\t\tdraw_line(spawn_point + Vector2(-5, 5), spawn_point + Vector2(5, -5), color_blocked, 2.0)\n\n\t# Draw line to cover position if we have one\n\tif _has_valid_cover:\n\t\tvar to_cover := _cover_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_cover, color_to_cover, 1.5)\n\t\t# Draw small circle at cover position\n\t\tdraw_circle(to_cover, 8.0, color_to_cover)\n\n\t# Draw line to clear shot target if seeking clear shot\n\tif _seeking_clear_shot and _clear_shot_target != Vector2.ZERO:\n\t\tvar to_target := _clear_shot_target - global_position\n\t\tdraw_line(Vector2.ZERO, to_target, color_clear_shot, 2.0)\n\t\t# Draw triangle at target position\n\t\tvar target_pos := to_target\n\t\tdraw_line(target_pos + Vector2(-6, 6), target_pos + Vector2(6, 6), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(6, 6), target_pos + Vector2(0, -8), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(0, -8), target_pos + Vector2(-6, 6), color_clear_shot, 2.0)\n\n\t# Draw line to pursuit cover if pursuing\n\tif _current_state == AIState.PURSUING and _has_pursuit_cover:\n\t\tvar to_pursuit := _pursuit_next_cover - global_position\n\t\tdraw_line(Vector2.ZERO, to_pursuit, color_pursuit, 2.0)\n\t\tdraw_circle(to_pursuit, 8.0, color_pursuit)\n\n\t# Draw line to flank target if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_flank_cover:\n\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n\t\telif _flank_target != Vector2.ZERO:\n\t\t\tvar to_flank := _flank_target - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n\t\t\t# Draw diamond at flank target\n\t\t\tvar flank_pos := to_flank\n\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)\n","structuredPatch":[{"oldStart":2671,"oldLines":10,"newStart":2671,"newLines":18,"lines":["     # Calculate what fraction of the player's body is visible","     # This is used to determine if lead prediction should be enabled","     _player_visibility_ratio = _calculate_player_visibility_ratio()","+    # Update last known player position while we can see them","+    _last_known_player_position = _player.global_position","+    # Clear search zone when player is seen","+    if _search_zone_active:","+      _clear_search_zone()","   else:","     # Lost line of sight
[2026-01-18T02:52:58.889Z] [INFO]  - reset the timer and visibility ratio","     _continuous_visibility_timer = 0.0","     _player_visibility_ratio = 0.0","+    # If we just lost sight and were in combat, activate search zone","+    if was_visible and _last_known_player_position != Vector2.ZERO:","+      _log_debug(\"Player escaped from view at %s\" % _last_known_player_position)"," "," "," ## Aim the enemy sprite/direction at the player using gradual rotation."]}],"userModified":false,"replaceAll":false}}
[2026-01-18T02:53:02.238Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_019uuyvvEJiHJaC9uwzXjXVY",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now I need to update the combat state to transition to SEARCHING instead of PURSUING when the player escapes. Let me find the relevant code:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 62475,
      "cache_read_input_tokens": 24718,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 62475,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 7,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "06418998-d66b-4390-a98e-4707b70d20aa"
}
[2026-01-18T02:53:03.664Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_019uuyvvEJiHJaC9uwzXjXVY",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01QW7DvuwtQigQsKCeipmkMr",
        "name": "Grep",
        "input": {
          "pattern": "Lost sight of player in COMBAT",
          "path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "output_mode": "content",
          "-n": true,
          "-A": 5,
          "-B": 5
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 62475,
      "cache_read_input_tokens": 24718,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 62475,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 7,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "7ae4ee99-99eb-4053-b4aa-a0d48b73b052"
}
[2026-01-18T02:53:03.752Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01QW7DvuwtQigQsKCeipmkMr",
        "type": "tool_result",
        "content": "851-\t# If can't see player, pursue them (move cover-to-cover toward player)\n852-\tif not _can_see_player:\n853-\t\t_combat_exposed = false\n854-\t\t_combat_approaching = false\n855-\t\t_seeking_clear_shot = false\n856:\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to PURSUING\")\n857-\t\t_transition_to_pursuing()\n858-\t\treturn\n859-\n860-\t# Update detection delay timer\n861-\tif not _detection_delay_elapsed:"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "7136af04-8c87-4b38-8570-691aa09816ae",
  "tool_use_result": {
    "mode": "content",
    "numFiles": 0,
    "filenames": [],
    "content": "851-\t# If can't see player, pursue them (move cover-to-cover toward player)\n852-\tif not _can_see_player:\n853-\t\t_combat_exposed = false\n854-\t\t_combat_approaching = false\n855-\t\t_seeking_clear_shot = false\n856:\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to PURSUING\")\n857-\t\t_transition_to_pursuing()\n858-\t\treturn\n859-\n860-\t# Update detection delay timer\n861-\tif not _detection_delay_elapsed:",
    "numLines": 11
  }
}
[2026-01-18T02:53:07.835Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01DgUgMpAZffQshhs9gpAkSr",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01R3qmTmSTN3rSUiUWS7W8K1",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "old_string": "\t# If can't see player, pursue them (move cover-to-cover toward player)\n\tif not _can_see_player:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\t\treturn",
          "new_string": "\t# If can't see player, transition to SEARCHING to investigate last-known position\n\tif not _can_see_player:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to SEARCHING\")\n\t\t_transition_to_searching()\n\t\treturn"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 597,
      "cache_read_input_tokens": 87193,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 597,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 24,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "96aa9bd2-7b10-4b6c-979b-9fbfe0c31bca"
}
[2026-01-18T02:53:07.872Z] [INFO] {"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01R3qmTmSTN3rSUiUWS7W8K1","type":"tool_result","content":"The file /tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   847‚Üí\t\t_seeking_clear_shot = false\n   848‚Üí\t\t_transition_to_assault()\n   849‚Üí\t\treturn\n   850‚Üí\n   851‚Üí\t# If can't see player, transition to SEARCHING to investigate last-known position\n   852‚Üí\tif not _can_see_player:\n   853‚Üí\t\t_combat_exposed = false\n   854‚Üí\t\t_combat_approaching = false\n   855‚Üí\t\t_seeking_clear_shot = false\n   856‚Üí\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to SEARCHING\")\n   857‚Üí\t\t_transition_to_searching()\n   858‚Üí\t\treturn\n   859‚Üí\n   860‚Üí\t# Update detection delay timer\n   861‚Üí\tif not _detection_delay_elapsed:\n   862‚Üí\t\t_detection_timer += delta"}]},"parent_tool_use_id":null,"session_id":"797fbac8-f5e6-4339-8fd2-77453410db49","uuid":"75edb012-9f08-4074-85a3-184e80c066cd","tool_use_result":{"filePath":"/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd","oldString":"\t# If can't see player, pursue them (move cover-to-cover toward player)\n\tif not _can_see_player:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\t\treturn","newString":"\t# If can't see player, transition to SEARCHING to investigate last-known position\n\tif not _can_see_player:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to SEARCHING\")\n\t\t_transition_to_searching()\n\t\treturn","originalFile":"extends CharacterBody2D\n## Enemy AI with tactical behaviors including patrol, guard, cover, and flanking.\n##\n## Supports multiple behavior modes:\n## - PATROL: Moves between patrol points\n## - GUARD: Stands in place watching for the player\n##\n## Tactical features:\n## - Uses cover when under fire (suppression)\n## - Attempts to flank the player from the sides\n## - Coordinates with other enemies (optional)\n## - GOAP foundation for goal-oriented planning\n\n## AI States for tactical behavior.\nenum AIState {\n\tIDLE,       ## Default idle state (patrol or guard)\n\tCOMBAT,     ## Actively engaging the player (coming out of cover, shooting 2-3s, returning)\n\tSEEKING_COVER,  ## Moving to cover position\n\tIN_COVER,   ## Taking cover from player fire\n\tFLANKING,   ## Attempting to flank the player\n\tSUPPRESSED, ## Under fire, staying in cover\n\tRETREATING, ## Retreating to cover while possibly shooting\n\tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n\tASSAULT,    ## Coordinated multi-enemy assault (rush player after 5s wait)\n\tSEARCHING   ## Searching for player at last-known-position zone\n}\n\n## Retreat behavior modes based on damage taken.\nenum RetreatMode {\n\tFULL_HP,        ## No damage - retreat backwards while shooting, periodically turn to cover\n\tONE_HIT,        ## One hit taken - quick burst then retreat without shooting\n\tMULTIPLE_HITS   ## Multiple hits - quick burst then retreat without shooting (same as ONE_HIT)\n}\n\n## Behavior modes for the enemy.\nenum BehaviorMode {\n\tPATROL,  ## Moves between patrol points\n\tGUARD    ## Stands in one place\n}\n\n## Current behavior mode.\n@export var behavior_mode: BehaviorMode = BehaviorMode.GUARD\n\n## Maximum movement speed in pixels per second.\n@export var move_speed: float = 220.0\n\n## Combat movement speed (faster when flanking/seeking cover).\n@export var combat_move_speed: float = 320.0\n\n## Rotation speed in radians per second for gradual turning.\n## Default is 15 rad/sec for challenging but fair combat.\n@export var rotation_speed: float = 15.0\n\n## Detection range for spotting the player.\n## Set to 0 or negative to allow unlimited detection range (line-of-sight only).\n## This allows enemies to see the player even outside the viewport if no obstacles block view.\n@export var detection_range: float = 0.0\n\n## Time between shots in seconds.\n## Default matches assault rifle fire rate (10 shots/second = 0.1s cooldown).\n@export var shoot_cooldown: float = 0.1\n\n## Bullet scene to instantiate when shooting.\n@export var bullet_scene: PackedScene\n\n## Offset from enemy center for bullet spawn position.\n@export var bullet_spawn_offset: float = 30.0\n\n## Patrol points as offsets from the initial position.\n## Only used when behavior_mode is PATROL.\n@export var patrol_offsets: Array[Vector2] = [Vector2(100, 0), Vector2(-100, 0)]\n\n## Wait time at each patrol point in seconds.\n@export var patrol_wait_time: float = 1.5\n\n## Color when at full health.\n@export var full_health_color: Color = Color(0.9, 0.2, 0.2, 1.0)\n\n## Color when at low health (interpolates based on health percentage).\n@export var low_health_color: Color = Color(0.3, 0.1, 0.1, 1.0)\n\n## Color to flash when hit.\n@export var hit_flash_color: Color = Color(1.0, 1.0, 1.0, 1.0)\n\n## Duration of hit flash effect in seconds.\n@export var hit_flash_duration: float = 0.1\n\n## Whether to destroy the enemy after death.\n@export var destroy_on_death: bool = false\n\n## Delay before respawning or destroying (in seconds).\n@export var respawn_delay: float = 2.0\n\n## Minimum random health.\n@export var min_health: int = 2\n\n## Maximum random health.\n@export var max_health: int = 4\n\n## Threat sphere radius - bullets within this radius trigger suppression.\n@export var threat_sphere_radius: float = 100.0\n\n## Time to stay suppressed after bullets leave threat sphere.\n@export var suppression_cooldown: float = 2.0\n\n## Delay (in seconds) before reacting to bullets in the threat sphere.\n## This prevents instant reactions to nearby gunfire, giving the player more time.\n@export var threat_reaction_delay: float = 0.2\n\n## Flank angle from player's facing direction (radians).\n@export var flank_angle: float = PI / 3.0  # 60 degrees\n\n## Distance to maintain while flanking.\n@export var flank_distance: float = 200.0\n\n## Enable/disable flanking behavior.\n@export var enable_flanking: bool = true\n\n## Enable/disable cover behavior.\n@export var enable_cover: bool = true\n\n## Enable/disable debug logging.\n@export var debug_logging: bool = false\n\n## Enable/disable debug label above enemy showing current AI state.\n@export var debug_label_enabled: bool = false\n\n## Enable/disable friendly fire avoidance (don't shoot if other enemies are in the way).\n@export var enable_friendly_fire_avoidance: bool = true\n\n## Enable/disable lead prediction (shooting ahead of moving targets).\n@export var enable_lead_prediction: bool = true\n\n## Bullet speed for lead prediction calculation.\n## Should match the actual bullet speed (default is 2500 for assault rifle).\n@export var bullet_speed: float = 2500.0\n\n## Ammunition system - magazine size (bullets per magazine).\n@export var magazine_size: int = 30\n\n## Ammunition system - number of magazines the enemy carries.\n@export var total_magazines: int = 5\n\n## Ammunition system - time to reload in seconds.\n@export var reload_time: float = 3.0\n\n## Delay (in seconds) between spotting player and starting to shoot.\n## Gives player a brief reaction time when entering enemy line of sight.\n## This delay \"recharges\" each time the player breaks direct contact with the enemy.\n@export var detection_delay: float = 0.2\n\n## Minimum time (in seconds) the player must be continuously visible before\n## lead prediction is enabled. This prevents enemies from predicting player\n## position immediately when they emerge from cover.\n@export var lead_prediction_delay: float = 0.3\n\n## Minimum visibility ratio (0.0 to 1.0) of player body that must be visible\n## before lead prediction is enabled. At 1.0, the player's entire body must be\n## visible. At 0.5, at least half of the check points must be visible.\n## This prevents pre-firing at players who are at cover edges.\n@export var lead_prediction_visibility_threshold: float = 0.6\n\n## Signal emitted when the enemy is hit.\nsignal hit\n\n## Signal emitted when the enemy dies.\nsignal died\n\n## Signal emitted when AI state changes.\nsignal state_changed(new_state: AIState)\n\n## Signal emitted when ammunition changes.\nsignal ammo_changed(current_ammo: int, reserve_ammo: int)\n\n## Signal emitted when reloading starts.\nsignal reload_started\n\n## Signal emitted when reloading finishes.\nsignal reload_finished\n\n## Signal emitted when all ammunition is depleted.\nsignal ammo_depleted\n\n## Reference to the sprite for color changes.\n@onready var _sprite: Sprite2D = $Sprite2D\n\n## RayCast2D for line of sight detection.\n@onready var _raycast: RayCast2D = $RayCast2D\n\n## Debug label for showing current AI state above the enemy.\n@onready var _debug_label: Label = $DebugLabel\n\n## Wall detection raycasts for obstacle avoidance (created at runtime).\nvar _wall_raycasts: Array[RayCast2D] = []\n\n## Distance to check for walls ahead.\nconst WALL_CHECK_DISTANCE: float = 40.0\n\n## Number of raycasts for wall detection (spread around the enemy).\nconst WALL_CHECK_COUNT: int = 3\n\n## Cover detection raycasts (created at runtime).\nvar _cover_raycasts: Array[RayCast2D] = []\n\n## Number of raycasts for cover detection.\nconst COVER_CHECK_COUNT: int = 16\n\n## Distance to check for cover.\nconst COVER_CHECK_DISTANCE: float = 300.0\n\n## Current health of the enemy.\nvar _current_health: int = 0\n\n## Maximum health of the enemy (set at spawn).\nvar _max_health: int = 0\n\n## Whether the enemy is alive.\nvar _is_alive: bool = true\n\n## Reference to the player (found at runtime).\nvar _player: Node2D = null\n\n## Time since last shot.\nvar _shoot_timer: float = 0.0\n\n## Current ammo in the magazine.\nvar _current_ammo: int = 0\n\n## Reserve ammo (ammo in remaining magazines).\nvar _reserve_ammo: int = 0\n\n## Whether the enemy is currently reloading.\nvar _is_reloading: bool = false\n\n## Timer for reload progress.\nvar _reload_timer: float = 0.0\n\n## Patrol state variables.\nvar _patrol_points: Array[Vector2] = []\nvar _current_patrol_index: int = 0\nvar _is_waiting_at_patrol_point: bool = false\nvar _patrol_wait_timer: float = 0.0\nvar _initial_position: Vector2\n\n## Whether the enemy can currently see the player.\nvar _can_see_player: bool = false\n\n## Current AI state.\nvar _current_state: AIState = AIState.IDLE\n\n## Current cover position (if any).\nvar _cover_position: Vector2 = Vector2.ZERO\n\n## Is currently in a valid cover position.\nvar _has_valid_cover: bool = false\n\n## Timer for suppression cooldown.\nvar _suppression_timer: float = 0.0\n\n## Whether enemy is currently under fire (bullets in threat sphere).\nvar _under_fire: bool = false\n\n## Flank target position.\nvar _flank_target: Vector2 = Vector2.ZERO\n\n## Threat sphere Area2D for detecting nearby bullets.\nvar _threat_sphere: Area2D = null\n\n## Bullets currently in threat sphere.\nvar _bullets_in_threat_sphere: Array = []\n\n## Timer for threat reaction delay - time since first bullet entered threat sphere.\nvar _threat_reaction_timer: float = 0.0\n\n## Whether the threat reaction delay has elapsed (enemy can react to bullets).\nvar _threat_reaction_delay_elapsed: bool = false\n\n## Memory of bullets that have passed through the threat sphere recently.\n## This allows the enemy to react even after fast-moving bullets have exited.\nvar _threat_memory_timer: float = 0.0\n\n## Duration to remember that a bullet passed through the threat sphere.\n## This should be longer than the reaction delay to ensure enemies can complete\n## their reaction even after bullets have passed through quickly.\nconst THREAT_MEMORY_DURATION: float = 0.5\n\n## Current retreat mode determined by damage taken.\nvar _retreat_mode: RetreatMode = RetreatMode.FULL_HP\n\n## Number of hits taken during the current retreat/combat encounter.\n## Resets when enemy enters IDLE state or finishes retreating.\nvar _hits_taken_in_encounter: int = 0\n\n## Timer for periodic turning to cover during FULL_HP retreat.\nvar _retreat_turn_timer: float = 0.0\n\n## Duration to face cover during FULL_HP retreat turn (seconds).\nconst RETREAT_TURN_DURATION: float = 0.8\n\n## Interval between turns toward cover in FULL_HP retreat (seconds).\nconst RETREAT_TURN_INTERVAL: float = 1.5\n\n## Whether currently in the \"turn to cover\" phase of FULL_HP retreat.\nvar _retreat_turning_to_cover: bool = false\n\n## Burst fire counter for ONE_HIT retreat mode.\nvar _retreat_burst_remaining: int = 0\n\n## Timer for burst fire cooldown in ONE_HIT retreat.\nvar _retreat_burst_timer: float = 0.0\n\n## Fast cooldown between burst shots (seconds).\nconst RETREAT_BURST_COOLDOWN: float = 0.06\n\n## Whether burst fire phase is complete in ONE_HIT retreat.\nvar _retreat_burst_complete: bool = false\n\n## Accuracy reduction during retreat (multiplier for inaccuracy angle spread).\nconst RETREAT_INACCURACY_SPREAD: float = 0.15\n\n## Arc spread for ONE_HIT burst fire (radians, total spread).\nconst RETREAT_BURST_ARC: float = 0.4\n\n## Current angle offset within burst arc.\nvar _retreat_burst_angle_offset: float = 0.0\n\n## Whether enemy is in \"alarm\" mode (was suppressed/retreating and hasn't calmed down).\n## This persists until the enemy reaches safety in cover or returns to idle.\nvar _in_alarm_mode: bool = false\n\n## Whether the enemy needs to fire a cover burst (when leaving cover while in alarm).\nvar _cover_burst_pending: bool = false\n\n## --- Combat Cover Cycling (come out, shoot 2-3s, go back) ---\n## Timer for how long the enemy has been shooting while out of cover.\nvar _combat_shoot_timer: float = 0.0\n\n## Duration to shoot while out of cover (2-3 seconds, randomized).\nvar _combat_shoot_duration: float = 2.5\n\n## Whether the enemy is currently in the \"exposed shooting\" phase of combat.\nvar _combat_exposed: bool = false\n\n## Whether the enemy is in the \"approaching player\" phase of combat.\n## In this phase, the enemy moves toward the player to get into direct contact.\nvar _combat_approaching: bool = false\n\n## Timer for the approach phase of combat.\nvar _combat_approach_timer: float = 0.0\n\n## Maximum time to spend approaching player before starting to shoot (seconds).\nconst COMBAT_APPROACH_MAX_TIME: float = 2.0\n\n## Distance at which enemy is considered \"close enough\" to start shooting phase.\nconst COMBAT_DIRECT_CONTACT_DISTANCE: float = 250.0\n\n## --- Pursuit State (cover-to-cover movement) ---\n## Timer for waiting at cover during pursuit.\nvar _pursuit_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during pursuit (1-2 seconds, reduced for faster pursuit).\nconst PURSUIT_COVER_WAIT_DURATION: float = 1.5\n\n## Current pursuit target cover position.\nvar _pursuit_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid pursuit cover target.\nvar _has_pursuit_cover: bool = false\n\n## --- Flanking State (cover-to-cover movement toward flank target) ---\n## Timer for waiting at cover during flanking.\nvar _flank_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during flanking (seconds).\nconst FLANK_COVER_WAIT_DURATION: float = 0.8\n\n## Current flank cover position to move to.\nvar _flank_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid flank cover target.\nvar _has_flank_cover: bool = false\n\n## --- Assault State (coordinated multi-enemy rush) ---\n## Timer for assault wait period (5 seconds before rushing).\nvar _assault_wait_timer: float = 0.0\n\n## Duration to wait at cover before assault (5 seconds).\nconst ASSAULT_WAIT_DURATION: float = 5.0\n\n## Whether the assault wait period is complete.\nvar _assault_ready: bool = false\n\n## Whether this enemy is currently participating in an assault.\nvar _in_assault: bool = false\n\n## Distance threshold for \"close\" vs \"far\" from player.\n## Used to determine if enemy can engage from current position or needs to pursue.\nconst CLOSE_COMBAT_DISTANCE: float = 400.0\n\n## GOAP world state for goal-oriented planning.\nvar _goap_world_state: Dictionary = {}\n\n## --- Search/Investigation State (for when player escapes from view) ---\n## Last known position where the player was seen before escaping view.\nvar _last_known_player_position: Vector2 = Vector2.ZERO\n\n## Whether a search zone is currently active.\nvar _search_zone_active: bool = false\n\n## Radius of the potential player zone (area where player might be hiding).\nconst SEARCH_ZONE_RADIUS: float = 200.0\n\n## Timer for search timeout - enemy gives up searching after this time.\nvar _search_timer: float = 0.0\n\n## Maximum time to spend searching before giving up (seconds).\nconst SEARCH_MAX_DURATION: float = 15.0\n\n## Inspection points within the search zone (hiding spots behind covers and corners).\nvar _inspection_points: Array[Vector2] = []\n\n## Index of current inspection point being checked.\nvar _current_inspection_index: int = 0\n\n## Timer for waiting at each inspection point (looking around).\nvar _inspection_wait_timer: float = 0.0\n\n## Duration to wait at each inspection point (seconds).\nconst INSPECTION_WAIT_DURATION: float = 1.5\n\n## Whether currently waiting at an inspection point.\nvar _inspecting_point: bool = false\n\n## Number of raycasts for detecting inspection points (corners/hiding spots).\nconst INSPECTION_POINT_CHECK_COUNT: int = 24\n\n## Distance to check for inspection points from search zone center.\nconst INSPECTION_CHECK_DISTANCE: float = 250.0\n\n## Detection delay timer - tracks time since entering combat.\nvar _detection_timer: float = 0.0\n\n## Whether the detection delay has elapsed.\nvar _detection_delay_elapsed: bool = false\n\n## Continuous visibility timer - tracks how long the player has been continuously visible.\n## Resets when line of sight is lost.\nv
[2026-01-18T02:53:07.875Z] [INFO] ar _continuous_visibility_timer: float = 0.0\n\n## Current visibility ratio of the player (0.0 to 1.0).\n## Represents what fraction of the player's body is visible to the enemy.\n## Used to determine if lead prediction should be enabled.\nvar _player_visibility_ratio: float = 0.0\n\n## --- Clear Shot Movement (move out from cover to get clear shot) ---\n## Target position to move to for getting a clear shot.\nvar _clear_shot_target: Vector2 = Vector2.ZERO\n\n## Whether we're currently moving to find a clear shot position.\nvar _seeking_clear_shot: bool = false\n\n## Timer for how long we've been trying to find a clear shot.\nvar _clear_shot_timer: float = 0.0\n\n## Maximum time to spend finding a clear shot before giving up (seconds).\nconst CLEAR_SHOT_MAX_TIME: float = 3.0\n\n## Distance to move when exiting cover to find a clear shot.\nconst CLEAR_SHOT_EXIT_DISTANCE: float = 60.0\n\n\n\nfunc _ready() -> void:\n\t_initial_position = global_position\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_setup_patrol_points()\n\t_find_player()\n\t_setup_wall_detection()\n\t_setup_cover_detection()\n\t_setup_threat_sphere()\n\t_initialize_goap_state()\n\t_connect_debug_mode_signal()\n\t_update_debug_label()\n\n\t# Log that this enemy is ready (use call_deferred to ensure FileLogger is loaded)\n\tcall_deferred(\"_log_spawn_info\")\n\n\t# Preload bullet scene if not set in inspector\n\tif bullet_scene == null:\n\t\tbullet_scene = preload(\"res://scenes/projectiles/Bullet.tscn\")\n\n\n## Initialize health with random value between min and max.\nfunc _initialize_health() -> void:\n\t_max_health = randi_range(min_health, max_health)\n\t_current_health = _max_health\n\t_is_alive = true\n\n\n## Initialize ammunition with full magazine and reserve ammo.\nfunc _initialize_ammo() -> void:\n\t_current_ammo = magazine_size\n\t# Reserve ammo is (total_magazines - 1) * magazine_size since one magazine is loaded\n\t_reserve_ammo = (total_magazines - 1) * magazine_size\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\n## Setup patrol points based on patrol offsets from initial position.\nfunc _setup_patrol_points() -> void:\n\t_patrol_points.clear()\n\t_patrol_points.append(_initial_position)\n\tfor offset in patrol_offsets:\n\t\t_patrol_points.append(_initial_position + offset)\n\n\n## Setup wall detection raycasts for obstacle avoidance.\nfunc _setup_wall_detection() -> void:\n\t# Create multiple raycasts spread in front of the enemy\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_wall_raycasts.append(raycast)\n\n\n## Setup cover detection raycasts for finding cover positions.\nfunc _setup_cover_detection() -> void:\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_cover_raycasts.append(raycast)\n\n\n## Setup threat sphere for detecting nearby bullets.\nfunc _setup_threat_sphere() -> void:\n\t_threat_sphere = Area2D.new()\n\t_threat_sphere.name = \"ThreatSphere\"\n\t_threat_sphere.collision_layer = 0\n\t_threat_sphere.collision_mask = 16  # Detect projectiles (layer 5)\n\n\tvar collision_shape := CollisionShape2D.new()\n\tvar circle_shape := CircleShape2D.new()\n\tcircle_shape.radius = threat_sphere_radius\n\tcollision_shape.shape = circle_shape\n\t_threat_sphere.add_child(collision_shape)\n\n\tadd_child(_threat_sphere)\n\n\t# Connect signals\n\t_threat_sphere.area_entered.connect(_on_threat_area_entered)\n\t_threat_sphere.area_exited.connect(_on_threat_area_exited)\n\n\n## Initialize GOAP world state.\nfunc _initialize_goap_state() -> void:\n\t_goap_world_state = {\n\t\t\"player_visible\": false,\n\t\t\"has_cover\": false,\n\t\t\"in_cover\": false,\n\t\t\"under_fire\": false,\n\t\t\"health_low\": false,\n\t\t\"can_flank\": false,\n\t\t\"at_flank_position\": false,\n\t\t\"is_retreating\": false,\n\t\t\"hits_taken\": 0,\n\t\t\"is_pursuing\": false,\n\t\t\"is_assaulting\": false,\n\t\t\"can_hit_from_cover\": false,\n\t\t\"player_close\": false,\n\t\t\"enemies_in_combat\": 0,\n\t\t\"has_search_zone\": false,\n\t\t\"search_zone_cleared\": false,\n\t\t\"inspection_points_remaining\": 0,\n\t\t\"is_searching\": false\n\t}\n\n\n## Connect to GameManager's debug mode signal for F7 toggle.\nfunc _connect_debug_mode_signal() -> void:\n\tvar game_manager: Node = get_node_or_null(\"/root/GameManager\")\n\tif game_manager:\n\t\t# Connect to debug mode toggle signal\n\t\tif game_manager.has_signal(\"debug_mode_toggled\"):\n\t\t\tgame_manager.debug_mode_toggled.connect(_on_debug_mode_toggled)\n\t\t# Sync with current debug mode state\n\t\tif game_manager.has_method(\"is_debug_mode_enabled\"):\n\t\t\tdebug_label_enabled = game_manager.is_debug_mode_enabled()\n\n\n## Called when debug mode is toggled via F7 key.\nfunc _on_debug_mode_toggled(enabled: bool) -> void:\n\tdebug_label_enabled = enabled\n\t_update_debug_label()\n\n\n## Find the player node in the scene tree.\nfunc _find_player() -> void:\n\t# Try to find the player by group first\n\tvar players := get_tree().get_nodes_in_group(\"player\")\n\tif players.size() > 0:\n\t\t_player = players[0]\n\t\treturn\n\n\t# Fallback: search for player by node name or type\n\tvar root := get_tree().current_scene\n\tif root:\n\t\t_player = _find_player_recursive(root)\n\n\n## Recursively search for a player node.\nfunc _find_player_recursive(node: Node) -> Node2D:\n\tif node.name == \"Player\" and node is Node2D:\n\t\treturn node\n\tfor child in node.get_children():\n\t\tvar result := _find_player_recursive(child)\n\t\tif result:\n\t\t\treturn result\n\treturn null\n\n\nfunc _physics_process(delta: float) -> void:\n\tif not _is_alive:\n\t\treturn\n\n\t# Update shoot cooldown timer\n\t_shoot_timer += delta\n\n\t# Update reload timer\n\t_update_reload(delta)\n\n\t# Check for player visibility and try to find player if not found\n\tif _player == null:\n\t\t_find_player()\n\n\t_check_player_visibility()\n\t_update_goap_state()\n\t_update_suppression(delta)\n\n\t# Process AI state machine\n\t_process_ai_state(delta)\n\n\t# Update debug label if enabled\n\t_update_debug_label()\n\n\t# Request redraw for debug visualization\n\tif debug_label_enabled:\n\t\tqueue_redraw()\n\n\tmove_and_slide()\n\n\n## Update GOAP world state based on current conditions.\nfunc _update_goap_state() -> void:\n\t_goap_world_state[\"player_visible\"] = _can_see_player\n\t_goap_world_state[\"under_fire\"] = _under_fire\n\t_goap_world_state[\"health_low\"] = _get_health_percent() < 0.5\n\t_goap_world_state[\"in_cover\"] = _current_state == AIState.IN_COVER\n\t_goap_world_state[\"has_cover\"] = _has_valid_cover\n\t_goap_world_state[\"is_retreating\"] = _current_state == AIState.RETREATING\n\t_goap_world_state[\"hits_taken\"] = _hits_taken_in_encounter\n\t_goap_world_state[\"is_pursuing\"] = _current_state == AIState.PURSUING\n\t_goap_world_state[\"is_assaulting\"] = _current_state == AIState.ASSAULT\n\t_goap_world_state[\"player_close\"] = _is_player_close()\n\t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n\t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()\n\t_goap_world_state[\"has_search_zone\"] = _search_zone_active\n\t_goap_world_state[\"search_zone_cleared\"] = not _search_zone_active and _last_known_player_position != Vector2.ZERO\n\t_goap_world_state[\"inspection_points_remaining\"] = _inspection_points.size() - _current_inspection_index\n\t_goap_world_state[\"is_searching\"] = _current_state == AIState.SEARCHING\n\n\n## Update suppression state.\nfunc _update_suppression(delta: float) -> void:\n\t# Clean up destroyed bullets from tracking\n\t_bullets_in_threat_sphere = _bullets_in_threat_sphere.filter(func(b): return is_instance_valid(b))\n\n\t# Determine if there's an active threat (bullets in sphere OR recent threat memory)\n\tvar has_active_threat := not _bullets_in_threat_sphere.is_empty() or _threat_memory_timer > 0.0\n\n\tif not has_active_threat:\n\t\tif _under_fire:\n\t\t\t_suppression_timer += delta\n\t\t\tif _suppression_timer >= suppression_cooldown:\n\t\t\t\t_under_fire = false\n\t\t\t\t_suppression_timer = 0.0\n\t\t\t\t_log_debug(\"Suppression ended\")\n\t\t# Reset threat reaction timer when no bullets are in threat sphere and no threat memory\n\t\t_threat_reaction_timer = 0.0\n\t\t_threat_reaction_delay_elapsed = false\n\telse:\n\t\t# Decrement threat memory timer if no bullets currently in sphere\n\t\tif _bullets_in_threat_sphere.is_empty() and _threat_memory_timer > 0.0:\n\t\t\t_threat_memory_timer -= delta\n\n\t\t# Update threat reaction timer\n\t\tif not _threat_reaction_delay_elapsed:\n\t\t\t_threat_reaction_timer += delta\n\t\t\tif _threat_reaction_timer >= threat_reaction_delay:\n\t\t\t\t_threat_reaction_delay_elapsed = true\n\t\t\t\t_log_debug(\"Threat reaction delay elapsed, now reacting to bullets\")\n\n\t\t# Only set under_fire after the reaction delay has elapsed\n\t\tif _threat_reaction_delay_elapsed:\n\t\t\t_under_fire = true\n\t\t\t_suppression_timer = 0.0\n\n\n## Update reload state.\nfunc _update_reload(delta: float) -> void:\n\tif not _is_reloading:\n\t\treturn\n\n\t_reload_timer += delta\n\tif _reload_timer >= reload_time:\n\t\t_finish_reload()\n\n\n## Start reloading the weapon.\nfunc _start_reload() -> void:\n\t# Can't reload if already reloading or no reserve ammo\n\tif _is_reloading or _reserve_ammo <= 0:\n\t\treturn\n\n\t_is_reloading = true\n\t_reload_timer = 0.0\n\treload_started.emit()\n\t_log_debug(\"Reloading... (%d reserve ammo)\" % _reserve_ammo)\n\n\n## Finish the reload process.\nfunc _finish_reload() -> void:\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\t# Calculate how many rounds to load\n\tvar ammo_needed := magazine_size - _current_ammo\n\tvar ammo_to_load := mini(ammo_needed, _reserve_ammo)\n\n\t_reserve_ammo -= ammo_to_load\n\t_current_ammo += ammo_to_load\n\n\treload_finished.emit()\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\t_log_debug(\"Reload complete. Magazine: %d/%d, Reserve: %d\" % [_current_ammo, magazine_size, _reserve_ammo])\n\n\n## Check if the enemy can shoot (has ammo and not reloading).\nfunc _can_shoot() -> bool:\n\t# Can't shoot if reloading\n\tif _is_reloading:\n\t\treturn false\n\n\t# Can't shoot if no ammo in magazine\n\tif _current_ammo <= 0:\n\t\t# Try to start reload if we have reserve ammo\n\t\tif _reserve_ammo > 0:\n\t\t\t_start_reload()\n\t\telse:\n\t\t\t# No ammo at all - emit depleted signal once\n\t\t\tif not _goap_world_state.get(\"ammo_depleted\", false):\n\t\t\t\t_goap_world_state[\"ammo_depleted\"] = true\n\t\t\t\tammo_depleted.emit()\n\t\t\t\t_log_debug(\"All ammunition depleted!\")\n\t\treturn false\n\n\treturn true\n\n\n## Process the AI state machine.\nfunc _process_ai_state(delta: float) -> void:\n\tvar previous_state := _current_state\n\n\t# State transitions based on conditions\n\tmatch _current_state:\n\t\tAIState.IDLE:\n\t\t\t_process_idle_state(delta)\n\t\tAIState.COMBAT:\n\t\t\t_process_combat_state(delta)\n\t\tAIState.SEEKING_COVER:\n\t\t\t_process_seeking_cover_state(delta)\n\t\tAIState.IN_COVER:\n\t\t\t_process_in_cover_state(delta)\n\t\tAIState.FLANKING:\n\t\t\t_process_flanking_state(delta)\n\t\tAIState.SUPPRESSED:\n\t\t\t_process_suppressed_state(delta)\n\t\tAIState.RETREATING:\n\t\t\t_process_retreating_state(delta)\n\t\tAIState.PURSUING:\n\t\t\t_process_pursuing_state(delta)\n\t\tAIState.ASSAULT:\n\t\t\t_process_assault_state(delta)\n\t\tAIState.SEARCHING:\n\t\t\t_process_searching_state(delta)\n\n\tif previous_state != _current_state:\n\t\tstate_changed.emit(_current_state)\n\t\t_log_debug(\"State changed: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\t\t# Also log to file for exported build debugging\n\t\t_log_to_file(\"State: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\n\n## Process IDLE state - patrol or guard behavior.\nfunc _process_idle_state(delta: float) -> void:\n\t# Transition to combat if player is visible\n\tif _can_see_player and _player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Execute idle behavior\n\tmatch behavior_mode:\n\t\tBehaviorMode.PATROL:\n\t\t\t_process_patrol(delta)\n\t\tBehaviorMode.GUARD:\n\t\t\t_process_guard(delta)\n\n\n## Process COMBAT state - approach player for direct contact, shoot for 2-3 seconds, return to cover.\n## Implements the combat cycling behavior: exit cover -> exposed shooting -> return to cover.\n## Phase 0 (seeking clear shot): If bullet spawn blocked, move out from cover to find clear shot.\n## Phase 1 (approaching): Move toward player to get into direct contact range.\n## Phase 2 (exposed): Stand and shoot for 2-3 seconds.\n## Phase 3: Return to cover via SEEKING_COVER state.\nfunc _process_combat_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies in combat (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can't see player, pursue them (move cover-to-cover toward player)\n\tif not _can_see_player:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\t\treturn\n\n\t# Update detection delay timer\n\tif not _detection_delay_elapsed:\n\t\t_detection_timer += delta\n\t\tif _detection_timer >= detection_delay:\n\t\t\t_detection_delay_elapsed = true\n\n\t# If we don't have cover, find some first (needed for returning later)\n\tif not _has_valid_cover and enable_cover:\n\t\t_find_cover_position()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found cover at %s for combat cycling\" % _cover_position)\n\n\t# Check player distance for approach/exposed phase decisions\n\tvar distance_to_player := INF\n\tif _player:\n\t\tdistance_to_player = global_position.distance_to(_player.global_position)\n\n\t# Check if we have a clear shot (no wall blocking bullet spawn)\n\tvar direction_to_player := Vector2.ZERO\n\tvar has_clear_shot := true\n\tif _player:\n\t\tdirection_to_player = (_player.global_position - global_position).normalized()\n\t\thas_clear_shot = _is_bullet_spawn_clear(direction_to_player)\n\n\t# If already exposed (shooting phase), handle shooting and timer\n\tif _combat_exposed:\n\t\t_combat_shoot_timer += delta\n\n\t\t# Check if exposure time is complete - go back to cover\n\t\tif _combat_shoot_timer >= _combat_shoot_duration and _has_valid_cover:\n\t\t\t_log_debug(\"Combat exposure time complete (%.1fs), returning to cover\" % _combat_shoot_duration)\n\t\t\t_combat_exposed = false\n\t\t\t_combat_approaching = false\n\t\t\t_combat_shoot_timer = 0.0\n\t\t\t_transition_to_seeking_cover()\n\t\t\treturn\n\n\t\t# Check if we still have a clear shot - if not, move sideways to find one\n\t\tif _player and not has_clear_shot:\n\t\t\t# Bullet spawn is blocked - move sideways to find a clear shot position\n\t\t\tvar sidestep_dir := _find_sidestep_direction_for_clear_shot(direction_to_player)\n\t\t\tif sidestep_dir != Vector2.ZERO:\n\t\t\t\tvelocity = sidestep_dir * combat_move_speed * 0.7\n\t\t\t\trotation = direction_to_player.angle()  # Keep facing player while sidestepping\n\t\t\t\t_log_debug(\"COMBAT exposed: sidestepping to maintain clear shot\")\n\t\t\telse:\n\t\t\t\t# No sidestep works - stay still, the shot might clear up\n\t\t\t\tvelocity = Vector2.ZERO\n\t\t\treturn\n\n\t\t# In exposed phase with clear shot, stand still and shoot\n\t\tvelocity = Vector2.ZERO\n\n\t\t# Aim and shoot at player (only shoot after detection delay)\n\t\tif _player:\n\t\t\t_aim_at_player()\n\t\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot()\n\t\t\t\t_shoot_timer = 0.0\n\t\treturn\n\n\t# --- CLEAR SHOT SEEKING PHASE ---\n\t# If bullet spawn is blocked and we're not already exposed, we need to move out from cover\n\tif not has_clear_shot and _player:\n\t\t# Start seeking clear shot if not already doing so\n\t\tif not _seeking_clear_shot:\n\t\t\t_seeking_clear_shot = true\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Calculate target position: move perpendicular to player direction (around cover edge)\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\t_log_debug(\"COMBAT: bullet spawn blocked, seeking clear shot at %s\" % _clear_shot_target)\n\n\t\t_clear_shot_timer += delta\n\n\t\t# Check if we've exceeded the max time trying to find a clear shot\n\t\tif _clear_shot_timer >= CLEAR_SHOT_MAX_TIME:\n\t\t\t_log_debug(\"COMBAT: clear shot timeout, trying flanking\")\n\t\t\t_seeking_clear_shot = false\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Try flanking to get around the obstacle\n\t\t\tif enable_flanking:\n\t\t\t\t_transition_to_flanking()\n\t\t\telse:\n\t\t\t\t_transition_to_pursuing()\n\t\t\treturn\n\n\t\t# Move toward the clear shot target position\n\t\tvar distance_to_target := global_position.distance_to(_clear_shot_target)\n\t\tif distance_to_target > 15.0:\n\t\t\tvar move_direction := (_clear_shot_target - global_position).normalized()\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed\n\t\t\trotation = direction_to_player.angle()  # Keep facing player\n\n\t\t\t# Check if the new position now has a clear shot\n\t\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\t\t_log_debug(\"COMBAT: found clear shot position while moving\")\n\t\t\t\t_seeking_clear_shot = false\n\t\t\t\t_clear_shot_timer = 0.0\n\t\t\t\t# Continue to exposed phase check below\n\t\t\telse:\n\t\t\t\treturn  # Keep moving toward target\n\t\telse:\n\t\t\t# Reached target but still no clear shot - recalculate target\n\t\t\t_log_debug(\"COMBAT: reached target but no clear shot, recalculating\")\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\treturn\n\n\t# Reset seeking state if we now have a clear shot\n\tif _seeking_clear_shot and has_clear_shot:\n\t\t_log_debug(\"COMBAT: clear shot acquired\")\n\t\t_seeking_clear_shot = false\n\t\t_clear_shot_timer = 0.0\n\n\t# Determine if we should be in approach phase or exposed shooting phase\n\tvar in_direct_contact := distance_to_player <= COMBAT_DIRECT_CONTACT_DISTANCE\n\n\t# Enter exposed phase if we have a clear shot and are either close enough or have approached long enough\n\tif has_clear_shot and (in_direct_contact or _combat_approach_timer >= COMBAT_APPROACH_MAX_TIME):\n\t\t# Close enough AND have clear shot - start exposed shooting phase\n\t\t_combat_exposed = true\n\t\t_combat_approaching = false\n\t\t_combat_shoot_timer = 0.0\n\t\t_combat_approach_timer = 0.0\n\t\t# Randomize exposure duration between 2-3 seconds\n\t\t_combat_shoot_duration = randf_range(2.0, 3.0)\n\t\t_log_debug(\"COMBAT exposed phase started (distance: %.0f), will shoot for %.1fs\" % [distance_to_player, _combat_shoot_duration])\n\t\treturn\n\n\t# Need to approach player - move toward them\n\tif not _combat_approaching:\n\t\t_combat_approaching = true\n\t\t_combat_approach_timer = 0.0\n\t\t_log_debug(\"COMBAT approach phase started, moving toward player\")\n\n\t_combat_approach_timer += delta\n\n\t# Move toward player while approaching\n\tif _player:\n\t\tvar move_direction := direction_to_player\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = move_direction * combat_move_speed\n\t\trotation = direction_to_player.angle()  # Always face player\n\n\t\t# Can shoot while approaching (only after detection delay and if have clear shot)\n\t\tif has_clear_shot and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\n## Calculate a target position to exit cover and get a clear shot.\n## Returns a position that should allow the bullet spawn point to be unobstructed.\nfunc _calculate_clear_shot_exit_position(direction_to_player: Vector2) -> Vector2:\n\t# Calculate perpendicular directions to the player\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Try both perpendicular directions and pick the one that's more likely to work\n\t# Also blend with forward movement toward player to help navigate around cover\n\tvar best_position := global_position\n\tvar best_score := -1.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\t\t# Blend sidestep with forward movement for better cover navigation\n\t\tvar exit_dir: Vector2 = (sidestep_dir * 0.7 + direction_to_player * 0.3).normalized()\n\t\tvar test_position: Vector2 = global_position + exit_dir * CLEAR_SHOT_EXIT_DISTANCE\n\n\t\t# Score this position based on:\n\t\t# 1. Does it have a clear path? (no walls in the way)\n\t\t# 2. Would the bullet spawn be clear from there?\n\t\tvar score: float = 0.0\n\n\t\t# Check if we can move to this position\n\t\tif _has_clear_path_to(test_position):\n\t\t\tscore += 1.0\n\n\t\t# Check if bullet spawn would be clear from this position\n\t\t# This is a rough estimate - we check from the test position toward player\n\t\tvar world_2d := get_world_2d()\n\t\tif world_2d != null:\n\t\t\tvar space_state := world_2d.direct_space_state\n\t\t\tif space_state != null:\n\t\t\t\tvar check_distance := bullet_spawn_offset + 5.0\n\t\t\t\tvar query := PhysicsRayQueryParameters2D.new()\n\t\t\t\tquery.from = test_position\n\t\t\t\tquery.to = test_position + direction_to_player * check_distance\n\t\t\t\tquery.collision_mask = 4  # Only check obstacles\n\t\t\t\tquery.exclude = [get_rid()]\n\t\t\t\tvar result := space_state.intersect_ray(query)\n\t\t\t\tif result.is_empty():\n\t\t\t\t\tscore += 2.0  # Higher score for clear bullet spawn\n\n\t\tif score > best_score:\n\t\t\tbest_score = score\n\t\t\tbest_position = test_position\n\n\t# If no good position found, just move forward toward player\n\tif best_score < 0.5:\n\t\tbest_position = global_position + direction_to_player * CLEAR_SHOT_EXIT_DISTANCE\n\n\treturn best_position\n\n\n## Process SEEKING_COVER state - moving to cover position.\nfunc _process_seeking_cover_state(_delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, stay in combat\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're already hidden from the player (the main goal)\n\tif not _is_visible_from_player():\n\t\t_transition_to_in_cover()\n\t\t_log_debug(\"Hidden from player, entering cover state\")\n\t\treturn\n\n\t# Move towards cover\n\tvar direction := (_cover_position - global_position).normalized()\n\tvar distance := global_position.distance_to(_cover_position)\n\n\tif distance < 10.0:\n\t\t# Reached the cover position, but still visible - try to find better cover\n\t\tif _is_visible_from_player():\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\t# No better cover found, stay in combat\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\n\t# Apply wall avoidance\n\tvar avoidance := _check_wall_ahead(direction)\n\tif avoidance != Vector2.ZERO:\n\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\tvelocity = direction * combat_move_speed\n\trotation = direction.angle()\n\n\t# Can still shoot while moving to cover (only after detection delay)\n\tif _can_see_player and _player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t_aim_at_player()\n\t\t_shoot()\n\t\t_shoot_timer = 0.0\n\n\n## Process IN_COVER state - taking cover from enemy fire.\n## Decides next action based on:\n## 1. If under fire -> suppressed\n## 2. If player is close (can exit cover for direct contact) -> COMBAT\n## 3. If player is far but can hit from current position -> COMBAT (stay and shoot)\n## 4. If player is far and can't hit -> PURSUING (move cover-to-cover)\nfunc _process_in_cover_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# If still under fire, stay suppressed\n\tif _under_fire:\n\t\t_transition_to_suppressed()\n\t\treturn\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover\n\tif _is_visible_from_player():\n\t\t# If in alarm mode and can see player, fire a burst before escaping\n\t\tif _in_alarm_mode and _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"IN_COVER alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay in cover while firing burst\n\n\t\t# Burst complete or not in alarm mode, seek new cover\n\t\t_log_debug(\"Player flanked our cover position, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# Decision making based on player distance and visibility\n\tif _player:\n\t\tvar player_close := _is_player_close()\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\n\t\tif _can_see_player:\n\t\t\tif player_close:\n\t\t\t\t# Player is close - engage in combat (come out, shoot, go back)\n\t\t\t\t_log_debug(\"Player is close, transitioning to COMBAT\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\t# Player is far\n\t\t\t\tif can_hit:\n\t\t\t\t\t# Can hit from current position - come out and shoot\n\t\t\t\t\t# (Don't pursue, just transition to combat which will handle the cycling)\n\t\t\t\t\t_log_debug(\"Player is far but can hit from here, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\telse:\n\t\t\t\t\t# Can't hit from here - need to pursue (move cover-to-cover)\n\t\t\t\t\t_log_debug(\"Player is far and can't hit, transitioning to PURSUING\")\n\t\t\t\t\t_transition_to_pursuing()\n\t\t\t\t\treturn\n\n\t# If not under fire and can see player, engage (only shoot after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If player is no longer visible and not under fire, try pursuing\n\tif not _can_see_player and not _under_fire:\n\t\t_log_debug(\"Lost sight of player from cover, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\n\n## Process FLANKING state - attempting to flank the player using cover-to-cover movement.\n## Uses intermediate cover positions to navigate around obstacles instead of walking\n## directly toward the flank target.\nfunc _process_flanking_state(delta: float) -> void:\n\t# If under fire, retreat with shooting behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# If can see player, engage in combat\n\tif _can_see_player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\tif _player == null:\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# Recalculate flank position (player may have moved)\n\t_calculate_flank_position()\n\n\tvar distance_to_flank := global_position.distance_to(_flank_target)\n\n\t# Check if we've reached the flank target\n\tif distance_to_flank < 30.0:\n\t\t_log_debug(\"Reached flank position, engaging\")\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Check if we have direct line of sight to flank target (no obstacles)\n\tif _has_clear_path_to(_flank_target):\n\t\t# Direct path is clear - move directly toward flank target\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\t_has_flank_cover = false\n\t\treturn\n\n\t# Path is blocked - use cover-to-cover movement\n\n\t# If we're at a cover position, wait briefly before moving to next\n\tif _has_valid_cover and not _has_flank_cover:\n\t\t_flank_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _flank_cover_wait_timer >= FLANK_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover toward flank target\n\t\t\t_find_flank_cover_toward_target()\n\t\t\tif not _has_flank_cover:\n\t\t\t\t_log_debug(\"No flank cover found, attempting direct movement\")\n\t\t\t\t# No cover found - try direct movement with enhanced wall avoidance\n\t\t\t\tvar direction := (_flank_target - global_position).normalized()\n\t\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\t\tvelocity = direction * combat_move_speed\n\t\t\t\trotation = direction.angle()\n\t\t\t\t# Invalidate current cover to trigger new search next frame\n\t\t\t\t_has_valid_cover = false\n\t\treturn\n\n\t# If we have a flank cover target, move toward it\n\tif _has_flank_cover:\n\t\tvar direction := (_flank_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_flank_next_cover)\n\n\t\t# Check if we've reached the flank cover\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached flank cover at distance %.1f\" % distance)\n\t\t\t_has_flank_cover = false\n\t\t\t_flank_cover_wait_timer = 0.0\n\t\t\t_cover_position = _flank_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no flank cover target - find initial flank cover\n\t_find_flank_cover_toward_target()\n\tif not _has_flank_cover:\n\t\t# Can't find cover, try direct movement with wall avoidance\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\n\n## Process SUPPRESSED state - staying in cover under fire.\nfunc _process_suppressed_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover even while suppressed\n\tif _is_visible_from_player():\n\t\t# In suppressed state we're always in alarm mode - fire a burst before escaping if we can see player\n\t\tif _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"SUPPRESSED alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay suppressed while firing burst\n\n\t\t# Burst complete or can't see player, seek new cover\n\t\t_log_debug(\"Player flanked our cover position while suppressed, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Can still shoot while suppressed (only after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If no longer under fire, exit suppression\n\tif not _under_fire:\n\t\t_transition_to_in_cover()\n\n\n## Process RETREATING state - moving to cover with behavior based on damage taken.\nfunc _process_retreating_state(delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, transition to combat or suppressed\n\t\t\tif _under_fire:\n\t\t\t\t_transition_to_suppressed()\n\t\t\telse:\n\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we've reached cover and are hidden from player\n\tif not _is_visible_from_player():\n\t\t_log_debug(\"Reached cover during retreat\")\n\t\t# Reset encounter hits when successfully reaching cover\n\t\t_hits_taken_in_encounter = 0\n\t\t_transition_to_in_cover()\n\t\treturn\n\n\t# Calculate direction to cover\n\tvar direction_to_cover := (_cover_position - global_position).normalized()\n\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\n\t# Check if reached cover position\n\tif distance_to_cover < 10.0:\n\t\tif _is_visible_from_player():\n\t\t\t# Still visible, find better cover\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\tif _under_fire:\n\t\t\t\t\t_transition_to_suppressed()\n\t\t\t\telse:\n\t\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Apply retreat behavior based on mode\n\tmatch _retreat_mode:\n\t\tRetreatMode.FULL_HP:\n\t\t\t_process_retreat_full_hp(delta, direction_to_cover)\n\t\tRetreatMode.ONE_HIT:\n\t\t\t_process_retreat_one_hit(delta, direction_to_cover)\n\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t_process_retreat_multiple_hits(delta, direction_to_cover)\n\n\n## Process FULL_HP retreat: walk backwards facing player, shoot with reduced accuracy,\n## periodically turn toward cover.\nfunc _process_retreat_full_hp(delta: float, direction_to_cover: Vector2) -> void:\n\t_retreat_turn_timer += delta\n\n\tif _retreat_turning_to_cover:\n\t\t# Turning to face cover, don't shoot\n\t\tif _retreat_turn_timer >= RETREAT_TURN_DURATION:\n\t\t\t_retreat_turning_to_cover = false\n\t\t\t_retreat_turn_timer = 0.0\n\n\t\t# Face cover and move toward it\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\telse:\n\t\t# Face player and back up (walk backwards)\n\t\tif _retreat_turn_timer >= RETREAT_TURN_INTERVAL:\n\t\t\t_retreat_turning_to_cover = true\n\t\t\t_retreat_turn_timer = 0.0\n\t\t\t_log_debug(\"FULL_HP retreat: turning to check cover\")\n\n\t\tif _player:\n\t\t\t# Face the player\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\t_aim_at_player()\n\n\t\t\t# Move backwards (opposite of player direction = toward cover generally)\n\t\t\t# Use the negative of the direction we're facing for \"backing up\"\n\t\t\tvar move_direction := -direction_to_player\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed * 0.7  # Slower when backing up\n\n\t\t\t# Shoot with reduced accuracy (only after detection delay)\n\t\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot_with_inaccuracy()\n\t\t\t\t_shoot_timer = 0.0\n\n\n## Process ONE_HIT retreat: quick burst of 2-4 shots in an arc while turning, then face cover.\nfunc _process_retreat_one_hit(delta: float, direction_to_cover: Vector2) -> void:\n\tif not _retreat_burst_complete:\n\t\t# During burst phase\n\t\t_retreat_burst_timer += delta\n\n\t\tif _player and _retreat_burst_remaining > 0 and _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t# Fire a burst shot with arc spread\n\t\t\t_shoot_burst_shot()\n\t\t\t_retreat_burst_remaining -= 1\n\t\t\t_retreat_burst_timer = 0.0\n\n\t\t\t# Progress through the arc\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0  # Spread across 4 shots max\n\n\t\t# Gradually turn from player to cover during burst\n\t\tif _player:\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\tvar target_angle: float\n\n\t\t\t# Interpolate rotation from player direction to cover direction\n\t\t\tvar burst_progress := 1.0 - (float(_retreat_burst_remaining) / 4.0)\n\t\t\tvar player_angle := direction_to_player.angle()\n\t\t\tvar cover_angle := direction_to_cover.angle()\n\t\t\ttarget_angle = lerp_angle(player_angle, cover_angle, burst_progress * 0.7)\n\t\t\trotation = target_angle\n\n\t\t# Move toward cover (slower during burst)\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed * 0.5\n\n\t\t# Check if burst is complete\n\t\tif _retreat_burst_remaining <= 0:\n\t\t\t_retreat_burst_complete = true\n\t\t\t_log_debug(\"ONE_HIT retreat: burst complete, now running to cover\")\n\telse:\n\t\t# After burst, run to cover without shooting\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\n\n## Process MULTIPLE_HITS retreat: quick burst of 2-4 shots then run to cover (same as ONE_HIT).\nfunc _process_retreat_multiple_hits(delta: float, direction_to_cover: Vector2) -> void:\n\t# Same behavior as ONE_HIT - quick burst then escape\n\t_process_retreat_one_hit(delta, direction_to_cover)\n\n\n## Process PURSUING state - move cover-to-cover toward player.\n## Enemy moves between covers, waiting 1-2 seconds at each cover,\n## until they can see and hit the player.\nfunc _process_pursuing_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected during pursuit (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can see player and can hit them from current position, engage\n\tif _can_see_player and _player:\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\t\tif can_hit:\n\t\t\t_log_debug(\"Can see and hit player from pursuit, transitioning to COMBAT\")\n\t\t\t_has_pursuit_cover = false\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're waiting at cover\n\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t# Currently at cover, wait for 1-2 seconds before moving to next cover\n\t\t_pursuit_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _pursuit_cover_wait_timer >= PURSUIT_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover closer to player\n\t\t\t_log_debug(\"Pursuit wait complete, finding next cover\")\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_find_pursuit_cover_toward_player()\n\t\t\tif _has_pursuit_cover:\n\t\t\t\t_log_debug(\"Found pursuit cover at %s\" % _pursuit_next_cover)\n\t\t\telse:\n\t\t\t\t# No pursuit cover found - fallback behavior\n\t\t\t\t_log_debug(\"No pursuit cover found, checking fallback options\")\n\t\t\t\t# If we can now see the player, engage directly\n\t\t\t\tif _can_see_player:\n\t\t\t\t\t_log_debug(\"Can see player, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\t# Try flanking\n\t\t\t\tif enable_flanking and _player:\n\t\t\t\t\t_log_debug(\"Attempting flanking maneuver\")\n\t\t\t\t\t_transition_to_flanking()\n\t\t\t\t\treturn\n\t\t\t\t# Last resort: move directly toward player\n\t\t\t\t_log_debug(\"No cover options, moving directly toward player\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\treturn\n\n\t# If we have a pursuit cover target, move toward it\n\tif _has_pursuit_cover:\n\t\tvar direction := (_pursuit_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_pursuit_next_cover)\n\n\t\t# Check if we've reached the pursuit cover\n\t\t# Note: We only check distance here, NOT visibility from player.\n\t\t# If we checked visibility, the enemy would immediately consider themselves\n\t\t# \"at cover\" even before moving, since they start hidden from player.\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached pursuit cover at distance %.1f\" % distance)\n\t\t\t_has_pursuit_cover = false\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_cover_position = _pursuit_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no pursuit target - find initial pursuit cover\n\t_find_pursuit_cover_toward_player()\n\tif not _has_pursuit_cover:\n\t\t# Can't find cover to pursue, try flanking or combat\n\t\tif enable_flanking and _player:\n\t\t\t_transition_to_flanking()\n\t\telse:\n\t\t\t_transition_to_combat()\n\n\n## Process ASSAULT state - coordinated multi-enemy rush.\n## Wait at cover for 5 seconds, then all enemies rush the player simultaneously.\nfunc _process_assault_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover and not _assault_ready:\n\t\t_in_assault = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if we're the only enemy left in assault - switch back to combat\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat < 2 and not _assault_ready:\n\t\t_log_debug(\"Not enough enemies for assault, switching to COMBAT\")\n\t\t_in_assault = false\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Find closest cover to player if we don't have one\n\tif not _has_valid_cover:\n\t\t_find_cover_closest_to_player()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found assault cover at %s\" % _cover_position)\n\n\t# Move to cover position first\n\tif _has_valid_cover and not _in_assault:\n\t\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\t\tif distance_to_cover > 15.0 and _is_visible_from_player():\n\t\t\t# Still need to reach cover\n\t\t\tvar direction := (_cover_position - global_position).normalized()\n\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\tvelocity = direction * combat_move_speed\n\t\t\trotation = direction.angle()\n\t\t\treturn\n\n\t# At cover, wait for assault timer\n\tif not _assault_ready:\n\t\tvelocity = Vector2.ZERO\n\t\t_assault_wait_timer += delta\n\n\t\t# Check if all assault enemies are ready (synchronized assault)\n\t\tif _assault_wait_timer >= ASSAULT_WAIT_DURATION:\n\t\t\t# Check if situation has changed - player might have moved\n\t\t\tif _player and _is_player_close():\n\t\t\t\t_assault_ready = true\n\t\t\t\t_in_assault = true\n\t\t\t\t_log_debug(\"ASSAULT ready - rushing player!\")\n\t\t\telse:\n\t\t\t\t# Player moved away, reset timer and check if we should pursue\n\t\t\t\t_log_debug(\"Player moved away during assault wait, resetting\")\n\t\t\t\t_assault_wait_timer = 0.0\n\t\t\t\t_in_assault = false\n\t\t\t\t_transition_to_pursuing()\n\t\t\t\treturn\n\t\treturn\n\n\t# Assault phase - rush the player while shooting\n\tif _assault_ready and _player:\n\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction_to_player)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_player = (direction_to_player * 0.5 + avoidance * 0.5).normalized()\n\n\t\t# Rush at full speed\n\t\tvelocity = direction_to_player * combat_move_speed\n\t\trotation = direction_to_player.angle()\n\n\t\t# Update detection delay timer\n\t\tif not _detection_delay_elapsed:\n\t\t\t_detection_timer += delta\n\t\t\tif _detection_timer >= detection_delay:\n\t\t\t\t_detection_delay_elapsed = true\n\n\t\t# Shoot while rushing (only after detection delay)\n\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t\t# If very close to player, stay in combat\n\t\tif distance_to_player < 50.0:\n\t\t\t_log_debug(\"Assault complete - reached player\")\n\t\t\t_assault_ready = false\n\t\t\t_in_assault = false\n\t\t\t_transition_to_combat()\n\n\n## Shoot with reduced accuracy for retreat mode.\nfunc _shoot_with_inaccuracy() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Check if the shot should be taken\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Add inaccuracy spread\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD, RETREAT_INACCURACY_SPREAD)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the inaccurate shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Inaccurate shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Shoot a burst shot with arc spread for ONE_HIT retreat.\nfunc _shoot_burst_shot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Apply arc offset for burst spread\n\tdirection = direction.rotated(_retreat_burst_angle_offset)\n\n\t# Also add some random inaccuracy on top of the arc\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD * 0.5, RETREAT_INACCURACY_SPREAD * 0.5)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the burst shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Burst shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Transition to IDLE state.\nfunc _transition_to_idle() -> void:\n\t_current_state = AIState.IDLE\n\t# Reset encounter hit tracking when returning to idle\n\t_hits_taken_in_encounter = 0\n\t# Reset alarm mode when returning to idle\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\n\n## Transition to COMBAT state.\nfunc _transition_to_combat() -> void:\n\t_current_state = AIState.COMBAT\n\t# Reset detection delay timer when entering combat\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Reset combat phase variables\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_shoot_timer = 0.0\n\t_combat_approach_timer = 0.0\n\t# Reset clear shot seeking variables\n\t_seeking_clear_shot = false\n\t_clear_shot_timer = 0.0\n\t_clear_shot_target = Vector2.ZERO\n\n\n## Transition to SEEKING_COVER state.\nfunc _transition_to_seeking_cover() -> void:\n\t_current_state = AIState.SEEKING_COVER\n\t_find_cover_position()\n\n\n## Transition to IN_COVER state.\nfunc _transition_to_in_cover() -> void:\n\t_current_state = AIState.IN_COVER\n\n\n## Transition to FLANKING state.\nfunc _transition_to_flanking() -> void:\n\t_current_state = AIState.FLANKING\n\t_calculate_flank_position()\n\t_flank_cover_wait_timer = 0.0\n\t_has_flank_cover = false\n\t_has_valid_cover = false\n\n\n## Transition to SUPPRESSED state.\nfunc _transition_to_suppressed() -> void:\n\t_current_state = AIState.SUPPRESSED\n\t# Enter alarm mode when suppressed\n\t_in_alarm_mode = true\n\n\n## Transition to PURSUING state.\nfunc _transition_to_pursuing() -> void:\n\t_current_state = AIState.PURSUING\n\t_pursuit_cover_wait_timer = 0.0\n\t_has_pursuit_cover = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\n\n## Transition to ASSAULT state.\nfunc _transition_to_assault() -> void:\n\t_current_state = AIState.ASSAULT\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Find closest cover to player for assault position\n\t_find_cover_closest_to_player()\n\n\n## Transition to RETREATING state with appropriate retreat mode.\nfunc _transition_to_retreating() -> void:\n\t_current_state = AIState.RETREATING\n\t# Enter alarm mode when retreating\n\t_in_alarm_mode = true\n\n\t# Determine retreat mode based on hits taken\n\tif _hits_taken_in_encounter == 0:\n\t\t_retreat_mode = RetreatMode.FULL_HP\n\t\t_retreat_turn_timer = 0.0\n\t\t_retreat_turning_to_cover = false\n\t\t_log_debug(\"Entering RETREATING state: FULL_HP mode (shoot while backing up)\")\n\telif _hits_taken_in_encounter == 1:\n\t\t_retreat_mode = RetreatMode.ONE_HIT\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t# Calculate arc spread: shots will be distributed across the arc\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: ONE_HIT mode (burst of %d shots)\" % _retreat_burst_remaining)\n\telse:\n\t\t_retreat_mode = RetreatMode.MULTIPLE_HITS\n\t\t# Multiple hits also gets burst fire (same as ONE_HIT)\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: MULTIPLE_HITS mode (burst of %d shots)\" % _retreat_burst_remaining)\n\n\t# Find cover position for retreating\n\t_find_cover_position()\n\n\n## Check if the enemy is visible from the player's position.\n## Uses raycasting from player to enemy to determine if there are obstacles blocking line of sight.\n## This is the inverse of _can_see_player - it checks if the PLAYER can see the ENEMY.\n## Checks multiple points on the enemy body (center and corners) to account for enemy size.\nfunc _is_visible_from_player() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check visibility to multiple points on the enemy body\n\t# This accounts for the enemy's size - corners can stick out from cover\n\tvar check_points := _get_enemy_check_points(global_position)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Get multiple check points on the enemy body for visibility testing.\n## Returns center and 4 corner points offset by the enemy's radius.\nfunc _get_enemy_check_points(center: Vector2) -> Array[Vector2]:\n\t# Enemy collision radius is 24, sprite is 48x48\n\t# Use a slightly smaller radius to avoid edge cases\n\tconst ENEMY_RADIUS: float = 22.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := ENEMY_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point is visible from the player's position.\nfunc _is_point_visible_from_player(point: Vector2) -> bool:\n\tif _player == null:\n\t\treturn false\n\n\tvar player_pos := _player.global_position\n\tvar distance := player_pos.distance_to(point)\n\n\t# Use direct space state to check line of sight from player to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = player_pos\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = []\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between player and point - point is visible\n\t\treturn true\n\telse:\n\t\t# Check if we hit an obstacle before reaching the point\n\t\tvar hit_position: Vector2 = result[\"position\"]\n\t\tvar distance_to_hit := player_pos.distance_to(hit_position)\n\n\t\t# If we hit something closer than the point, the point is hidden\n\t\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t\treturn false\n\t\telse:\n\t\t\treturn true\n\n\n## Check if a specific position would make the enemy visible from the player's position.\n## Checks all enemy body points (center and corners) to account for enemy size.\n## Used to validate cover positions before moving to them.\nfunc _is_position_visible_from_player(pos: Vector2) -> bool:\n\tif _player == null:\n\t\treturn true  # Assume visible if no player\n\n\t# Check visibility for all enemy body points at the given position\n\tvar check_points := _get_enemy_check_points(pos)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Check if a target position is visible from the enemy's perspective.\n## Uses raycast to verify there are no obstacles between enemy and the target position.\n## This is used to validate lead prediction targets - enemies should only aim at\n## positions they can actually see.\nfunc _is_position_visible_to_enemy(target_pos: Vector2) -> bool:\n\tvar distance := global_position.distance_to(target_pos)\n\n\t# Use direct space state to check line of sight from enemy to target\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = target_pos\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and target - position is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t# Hit obstacle before target - position is NOT visible\n\t\t_log_debug(\"Position %s blocked by obstacle at distance %.1f (target at %.1f)\" % [target_pos, distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Get multiple check points on the player's body for visibility testing.\n## Returns center and 4 corner points offset by the player's radius.\n## The player has a collision radius of 16 pixels (from Player.tscn).\nfunc _get_player_check_points(center: Vector2) -> Array[Vector2]:\n\t# Player collision radius is 16, sprite is 32x32\n\t# Use a slightly smaller radius to be conservative\n\tconst PLAYER_RADIUS: float = 14.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := PLAYER_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point on the player is visible from the enemy's position.\n## Uses direct space state query to check for obstacles blocking line of sight.\nfunc _is_player_point_visible_to_enemy(point: Vector2) -> bool:\n\tvar distance := global_position.distance_to(point)\n\n\t# Use direct space state to check line of sight from enemy to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and point - point is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the point\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\t# If we hit something before the point, the point is blocked\n\tif distance_to_hit < distance - 5.0:  # 5 pixel tolerance\n\t\treturn false\n\n\treturn true\n\n\n## Calculate what fraction of the player's body is visible to the enemy.\n## Returns a value from 0.0 (completely hidden) to 1.0 (fully visible).\n## Checks multiple points on the player's body (center + corners).\nfunc _calculate_player_visibility_ratio() -> float:\n\tif _player == null:\n\t\treturn 0.0\n\n\tvar check_points := _get_player_check_points(_player.global_position)\n\tvar visible_count := 0\n\n\tfor point in check_points:\n\t\tif _is_player_point_visible_to_enemy(point):\n\t\t\tvisible_count += 1\n\n\treturn float(visible_count) / float(check_points.size())\n\n\n## Check if the line of fire to the target position is clear of other enemies.\n## Returns true if no other enemies would be hit by a bullet traveling to the target.\nfunc _is_firing_line_clear_of_friendlies(target_position: Vector2) -> bool:\n\tif not enable_friendly_fire_avoidance:\n\t\treturn true\n\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if any enemies are in the firing line\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 2  # Only check enemies (layer 2)\n\tquery.exclude = [get_rid()]  # Exclude self using RID\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No enemies in the way\n\n\t# Check if the hit position is before the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 20.0:  # 20 pixel tolerance\n\t\t_log_debug(\"Friendly in firing line at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if a bullet fired at the target position would be blocked by cover/obstacles.\n## Returns true if the shot would likely hit the target, false if blocked by cover.\nfunc _is_shot_clear_of_cover(target_position: Vector2) -> bool:\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if obstacles block the shot\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No obstacles in the way\n\n\t# Check if the obstacle is before the target position\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t_log_debug(\"Shot blocked by cover at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if there's an obstacle immediately in front of the enemy that would block bullets.\n## This prevents shooting into walls that the enemy is flush against or very close to.\n## Uses a single raycast from enemy center to the bullet spawn position.\nfunc _is_bullet_spawn_clear(direction: Vector2) -> bool:\n\t# Fail-open: allow shooting if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn true\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn true\n\n\t# Check from enemy center to bullet spawn position plus a small buffer\n\tvar check_distance := bullet_spawn_offset + 5.0\n\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = global_position + direction * check_distance\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]\n\n\tvar result := space_state.intersect_ray(query)\n\tif not result.is_empty():\n\t\t_log_debug(\"Bullet spawn blocked: wall at distance %.1f\" % [\n\t\t\tglobal_position.distance_to(result[\"position\"])])\n\t\treturn false\n\n\treturn true\n\n\n## Find a sidestep direction that would lead to a clear shot position.\n## Checks perpendicular directions to the player and returns the first one\n## that would allow the bullet spawn point to be clear.\n## Returns Vector2.ZERO if no clear direction is found.\nfunc _find_sidestep_direction_for_clear_shot(direction_to_player: Vector2) -> Vector2:\n\t# Fail-safe: allow normal behavior if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn Vector2.ZERO\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn Vector2.ZERO\n\n\t# Check perpendicular directions (left and right of the player direction)\n\tvar perpendicular := 
[2026-01-18T02:53:07.879Z] [INFO] Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Check both sidestep directions and pick the one that leads to clear shot faster\n\tvar check_distance := 50.0  # Check if moving 50 pixels in this direction would help\n\tvar bullet_check_distance := bullet_spawn_offset + 5.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:  # Try both sides\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\n\t\t# First check if we can actually move in this direction (no wall blocking movement)\n\t\tvar move_query := PhysicsRayQueryParameters2D.new()\n\t\tmove_query.from = global_position\n\t\tmove_query.to = global_position + sidestep_dir * 30.0\n\t\tmove_query.collision_mask = 4  # Only check obstacles\n\t\tmove_query.exclude = [get_rid()]\n\n\t\tvar move_result := space_state.intersect_ray(move_query)\n\t\tif not move_result.is_empty():\n\t\t\tcontinue  # Can't move this way, wall is blocking\n\n\t\t# Check if after sidestepping, we'd have a clear shot\n\t\tvar test_position: Vector2 = global_position + sidestep_dir * check_distance\n\t\tvar shot_query := PhysicsRayQueryParameters2D.new()\n\t\tshot_query.from = test_position\n\t\tshot_query.to = test_position + direction_to_player * bullet_check_distance\n\t\tshot_query.collision_mask = 4\n\t\tshot_query.exclude = [get_rid()]\n\n\t\tvar shot_result := space_state.intersect_ray(shot_query)\n\t\tif shot_result.is_empty():\n\t\t\t# Found a direction that leads to a clear shot\n\t\t\t_log_debug(\"Found sidestep direction: %s\" % sidestep_dir)\n\t\t\treturn sidestep_dir\n\n\treturn Vector2.ZERO  # No clear sidestep direction found\n\n\n## Check if the enemy should shoot at the current target.\n## Validates bullet spawn clearance, friendly fire avoidance, and cover blocking.\nfunc _should_shoot_at_target(target_position: Vector2) -> bool:\n\t# Check if the immediate path to bullet spawn is clear\n\t# This prevents shooting into walls the enemy is flush against\n\tvar direction := (target_position - global_position).normalized()\n\tif not _is_bullet_spawn_clear(direction):\n\t\treturn false\n\n\t# Check if friendlies are in the way\n\tif not _is_firing_line_clear_of_friendlies(target_position):\n\t\treturn false\n\n\t# Check if cover blocks the shot\n\tif not _is_shot_clear_of_cover(target_position):\n\t\treturn false\n\n\treturn true\n\n\n## Check if the player is \"close\" (within CLOSE_COMBAT_DISTANCE).\n## Used to determine if the enemy should engage directly or pursue.\nfunc _is_player_close() -> bool:\n\tif _player == null:\n\t\treturn false\n\treturn global_position.distance_to(_player.global_position) <= CLOSE_COMBAT_DISTANCE\n\n\n## Check if the enemy can hit the player from their current position.\n## Returns true if there's a clear line of fire to the player.\nfunc _can_hit_player_from_current_position() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check if we can see the player\n\tif not _can_see_player:\n\t\treturn false\n\n\t# Check if the shot would be blocked by cover\n\treturn _is_shot_clear_of_cover(_player.global_position)\n\n\n## Count the number of enemies currently in combat-related states.\n## Includes COMBAT, PURSUING, ASSAULT, IN_COVER (if can see player).\n## Used to determine if multi-enemy assault should be triggered.\nfunc _count_enemies_in_combat() -> int:\n\tvar count := 0\n\tvar enemies := get_tree().get_nodes_in_group(\"enemies\")\n\n\tfor enemy in enemies:\n\t\tif enemy == self:\n\t\t\tcontinue\n\t\tif not enemy.has_method(\"get_current_state\"):\n\t\t\tcontinue\n\n\t\tvar state: AIState = enemy.get_current_state()\n\t\t# Count enemies in combat-related states\n\t\tif state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\t\t# For IN_COVER, only count if they can see the player\n\t\t\tif state == AIState.IN_COVER:\n\t\t\t\tif enemy.has_method(\"is_in_combat_engagement\") and enemy.is_in_combat_engagement():\n\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tcount += 1\n\n\t# Count self if in a combat-related state\n\tif _current_state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\tcount += 1\n\n\treturn count\n\n\n## Check if this enemy is engaged in combat (can see player and in combat state).\nfunc is_in_combat_engagement() -> bool:\n\treturn _can_see_player and _current_state in [AIState.COMBAT, AIState.IN_COVER, AIState.ASSAULT]\n\n\n## Find cover position closer to the player for pursuit.\n## Used during PURSUING state to move cover-to-cover toward the player.\nfunc _find_pursuit_cover_toward_player() -> void:\n\tif _player == null:\n\t\t_has_pursuit_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For pursuit, we want cover that is:\n\t\t\t# 1. Closer to the player than we currently are\n\t\t\t# 2. Hidden from the player (or mostly hidden)\n\t\t\t# 3. Not too far from our current position\n\n\t\t\tvar my_distance_to_player := global_position.distance_to(player_pos)\n\t\t\tvar cover_distance_to_player := cover_pos.distance_to(player_pos)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to player\n\t\t\tif cover_distance_to_player >= my_distance_to_player:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if this position is hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Hidden from player (priority)\n\t\t\t# - Closer to player\n\t\t\t# - Not too far from current position\n\t\t\tvar hidden_score: float = 5.0 if is_hidden else 0.0\n\t\t\tvar approach_score: float = (my_distance_to_player - cover_distance_to_player) / CLOSE_COMBAT_DISTANCE\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = hidden_score + approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_pursuit_next_cover = best_cover\n\t\t_has_pursuit_cover = true\n\t\t_log_debug(\"Found pursuit cover at %s (score: %.2f)\" % [_pursuit_next_cover, best_score])\n\telse:\n\t\t_has_pursuit_cover = false\n\n\n## Find cover position closest to the player for assault positioning.\n## Used during ASSAULT state to take the nearest safe cover to the player.\nfunc _find_cover_closest_to_player() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_distance: float = INF\n\tvar found_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# Check if this position is hidden from player (safe cover)\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\tif is_hidden:\n\t\t\t\t# Calculate distance from this cover to the player\n\t\t\t\tvar distance_to_player := cover_pos.distance_to(player_pos)\n\n\t\t\t\t# We want the cover closest to the player\n\t\t\t\tif distance_to_player < best_distance:\n\t\t\t\t\tbest_distance = distance_to_player\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\t\tfound_cover = true\n\n\tif found_cover:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found assault cover at %s (distance to player: %.1f)\" % [_cover_position, best_distance])\n\telse:\n\t\t# Fall back to normal cover finding\n\t\t_find_cover_position()\n\n\n## Find a valid cover position relative to the player.\n## The cover position must be hidden from the player's line of sight.\nfunc _find_cover_position() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_hidden_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is on the opposite side of the obstacle from player\n\t\t\tvar direction_from_player := (collision_point - player_pos).normalized()\n\n\t\t\t# Position behind cover (offset from collision point along normal)\n\t\t\t# Offset must be large enough to hide the entire enemy body (radius ~24 pixels)\n\t\t\t# Using 35 pixels to provide some margin for the enemy's collision shape\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# First priority: Check if this position is actually hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Only consider hidden positions unless we have no choice\n\t\t\tif is_hidden or not found_hidden_cover:\n\t\t\t\t# Score based on:\n\t\t\t\t# 1. Whether position is hidden (highest priority)\n\t\t\t\t# 2. Distance from enemy (closer is better)\n\t\t\t\t# 3. Position relative to player (behind cover from player's view)\n\t\t\t\tvar hidden_score: float = 10.0 if is_hidden else 0.0  # Heavy weight for hidden positions\n\n\t\t\t\tvar distance_score := 1.0 - (global_position.distance_to(cover_pos) / COVER_CHECK_DISTANCE)\n\n\t\t\t\t# Check if this position is on the far side of obstacle from player\n\t\t\t\tvar cover_direction := (cover_pos - player_pos).normalized()\n\t\t\t\tvar dot_product := direction_from_player.dot(cover_direction)\n\t\t\t\tvar blocking_score: float = maxf(0.0, dot_product)\n\n\t\t\t\tvar total_score: float = hidden_score + distance_score * 0.3 + blocking_score * 0.7\n\n\t\t\t\t# If we find a hidden position, only accept other hidden positions\n\t\t\t\tif is_hidden and not found_hidden_cover:\n\t\t\t\t\tfound_hidden_cover = true\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\telif (is_hidden or not found_hidden_cover) and total_score > best_score:\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\n\tif best_score > 0:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found cover at: %s (hidden: %s)\" % [_cover_position, found_hidden_cover])\n\telse:\n\t\t_has_valid_cover = false\n\n\n## Calculate flank position based on player location.\nfunc _calculate_flank_position() -> void:\n\tif _player == null:\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar player_to_enemy := (global_position - player_pos).normalized()\n\n\t# Choose left or right flank based on current position\n\tvar flank_side := 1.0 if randf() > 0.5 else -1.0\n\tvar flank_direction := player_to_enemy.rotated(flank_angle * flank_side)\n\n\t_flank_target = player_pos + flank_direction * flank_distance\n\t_log_debug(\"Flank target: %s\" % _flank_target)\n\n\n## Check if there's a clear path (no obstacles) to the target position.\n## Uses a raycast to check for walls/obstacles between current position and target.\nfunc _has_clear_path_to(target: Vector2) -> bool:\n\tif _raycast == null:\n\t\treturn true  # Assume clear if no raycast available\n\n\tvar direction := (target - global_position).normalized()\n\tvar distance := global_position.distance_to(target)\n\n\t_raycast.target_position = direction * distance\n\t_raycast.force_raycast_update()\n\n\t# If we hit something, path is blocked\n\tif _raycast.is_colliding():\n\t\tvar collision_point := _raycast.get_collision_point()\n\t\tvar collision_distance := global_position.distance_to(collision_point)\n\t\t# Only consider it blocked if the collision is before the target\n\t\treturn collision_distance >= distance - 10.0\n\n\treturn true\n\n\n## Find cover position closer to the flank target.\n## Used during FLANKING state to move cover-to-cover toward the flank position.\nfunc _find_flank_cover_toward_target() -> void:\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For flanking, we want cover that is:\n\t\t\t# 1. Closer to the flank target than we currently are\n\t\t\t# 2. Not too far from our current position\n\t\t\t# 3. Reachable (has clear path)\n\n\t\t\tvar my_distance_to_target := global_position.distance_to(_flank_target)\n\t\t\tvar cover_distance_to_target := cover_pos.distance_to(_flank_target)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to flank target\n\t\t\tif cover_distance_to_target >= my_distance_to_target:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if we can reach this cover (has clear path)\n\t\t\tif not _has_clear_path_to(cover_pos):\n\t\t\t\t# Even if direct path is blocked, we might be able to reach\n\t\t\t\t# via another intermediate cover, but skip for now\n\t\t\t\tcontinue\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Closer to flank target (priority)\n\t\t\t# - Not too far from current position\n\t\t\tvar approach_score: float = (my_distance_to_target - cover_distance_to_target) / flank_distance\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_flank_next_cover = best_cover\n\t\t_has_flank_cover = true\n\t\t_log_debug(\"Found flank cover at %s (score: %.2f)\" % [_flank_next_cover, best_score])\n\telse:\n\t\t_has_flank_cover = false\n\n\n## Check if there's a wall ahead in the given direction and return avoidance direction.\n## Returns Vector2.ZERO if no wall detected, otherwise returns a vector to avoid the wall.\nfunc _check_wall_ahead(direction: Vector2) -> Vector2:\n\tif _wall_raycasts.is_empty():\n\t\treturn Vector2.ZERO\n\n\tvar avoidance := Vector2.ZERO\n\tvar perpendicular := Vector2(-direction.y, direction.x)  # 90 degrees rotation\n\n\t# Check center, left, and right raycasts\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar angle_offset := (i - 1) * 0.5  # -0.5, 0, 0.5 radians (~-28, 0, 28 degrees)\n\t\tvar check_direction := direction.rotated(angle_offset)\n\n\t\tvar raycast := _wall_raycasts[i]\n\t\traycast.target_position = check_direction * WALL_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\t# Calculate avoidance based on which raycast hit\n\t\t\tif i == 0:  # Left raycast hit\n\t\t\t\tavoidance += perpendicular  # Steer right\n\t\t\telif i == 1:  # Center raycast hit\n\t\t\t\tavoidance += perpendicular if randf() > 0.5 else -perpendicular  # Random steer\n\t\t\telif i == 2:  # Right raycast hit\n\t\t\t\tavoidance -= perpendicular  # Steer left\n\n\treturn avoidance.normalized() if avoidance.length() > 0 else Vector2.ZERO\n\n\n## Check if the player is visible using raycast.\n## If detection_range is 0 or negative, uses unlimited detection range (line-of-sight only).\n## This allows the enemy to see the player even outside the viewport if there's no obstacle.\n## Also updates the continuous visibility timer and visibility ratio for lead prediction control.\nfunc _check_player_visibility() -> void:\n\tvar was_visible := _can_see_player\n\t_can_see_player = false\n\t_player_visibility_ratio = 0.0\n\n\tif _player == null or not _raycast:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t# Check if player is within detection range (only if detection_range is positive)\n\t# If detection_range <= 0, detection is unlimited (line-of-sight only)\n\tif detection_range > 0 and distance_to_player > detection_range:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\t# Point raycast at player - use actual distance to player for the raycast length\n\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\tvar raycast_length := distance_to_player + 10.0  # Add small buffer to ensure we reach player\n\t_raycast.target_position = direction_to_player * raycast_length\n\t_raycast.force_raycast_update()\n\n\t# Check if raycast hit something\n\tif _raycast.is_colliding():\n\t\tvar collider := _raycast.get_collider()\n\t\t# If we hit the player, we can see them\n\t\tif collider == _player:\n\t\t\t_can_see_player = true\n\t\t# If we hit a wall/obstacle before the player, we can't see them\n\telse:\n\t\t# No collision between us and player - we have clear line of sight\n\t\t_can_see_player = true\n\n\t# Update continuous visibility timer and visibility ratio\n\tif _can_see_player:\n\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n\t\t# Calculate what fraction of the player's body is visible\n\t\t# This is used to determine if lead prediction should be enabled\n\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n\t\t# Update last known player position while we can see them\n\t\t_last_known_player_position = _player.global_position\n\t\t# Clear search zone when player is seen\n\t\tif _search_zone_active:\n\t\t\t_clear_search_zone()\n\telse:\n\t\t# Lost line of sight - reset the timer and visibility ratio\n\t\t_continuous_visibility_timer = 0.0\n\t\t_player_visibility_ratio = 0.0\n\t\t# If we just lost sight and were in combat, activate search zone\n\t\tif was_visible and _last_known_player_position != Vector2.ZERO:\n\t\t\t_log_debug(\"Player escaped from view at %s\" % _last_known_player_position)\n\n\n## Aim the enemy sprite/direction at the player using gradual rotation.\nfunc _aim_at_player() -> void:\n\tif _player == null:\n\t\treturn\n\tvar direction := (_player.global_position - global_position).normalized()\n\tvar target_angle := direction.angle()\n\n\t# Calculate the shortest rotation direction\n\tvar angle_diff := wrapf(target_angle - rotation, -PI, PI)\n\n\t# Get the delta time from the current physics process\n\tvar delta := get_physics_process_delta_time()\n\n\t# Apply gradual rotation based on rotation_speed\n\tif abs(angle_diff) <= rotation_speed * delta:\n\t\t# Close enough to snap to target\n\t\trotation = target_angle\n\telif angle_diff > 0:\n\t\trotation += rotation_speed * delta\n\telse:\n\t\trotation -= rotation_speed * delta\n\n\n## Shoot a bullet towards the player.\nfunc _shoot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\t# Check if we can shoot (have ammo and not reloading)\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Apply lead prediction if enabled\n\tif enable_lead_prediction:\n\t\ttarget_position = _calculate_lead_prediction()\n\n\t# Check if the shot should be taken (friendly fire and cover checks)\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Create bullet instance\n\tvar bullet := bullet_scene.instantiate()\n\n\t# Set bullet position with offset in shoot direction\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\n\t# Set bullet direction\n\tbullet.direction = direction\n\n\t# Set shooter ID to identify this enemy as the source\n\t# This prevents enemies from detecting their own bullets in the threat sphere\n\tbullet.shooter_id = get_instance_id()\n\n\t# Add bullet to the scene tree\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play shooting sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\n\t# Play shell casing sound with a small delay\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\t# Auto-reload when magazine is empty\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Play shell casing sound with a delay to simulate the casing hitting the ground.\nfunc _play_delayed_shell_sound() -> void:\n\tawait get_tree().create_timer(0.15).timeout\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_shell_rifle\"):\n\t\taudio_manager.play_shell_rifle(global_position)\n\n\n## Calculate lead prediction - aims where the player will be, not where they are.\n## Uses iterative approach for better accuracy with moving targets.\n## Only applies lead prediction if:\n## 1. The player has been continuously visible for at least lead_prediction_delay seconds\n## 2. At least lead_prediction_visibility_threshold of the player's body is visible\n## 3. The predicted position is also visible to the enemy (not behind cover)\n## This prevents enemies from \"knowing\" where the player will emerge from cover.\nfunc _calculate_lead_prediction() -> Vector2:\n\tif _player == null:\n\t\treturn global_position\n\n\tvar player_pos := _player.global_position\n\n\t# Only use lead prediction if the player has been continuously visible\n\t# for long enough. This prevents enemies from predicting player position\n\t# immediately when they emerge from cover.\n\tif _continuous_visibility_timer < lead_prediction_delay:\n\t\t_log_debug(\"Lead prediction disabled: visibility time %.2fs < %.2fs required\" % [_continuous_visibility_timer, lead_prediction_delay])\n\t\treturn player_pos\n\n\t# Only use lead prediction if enough of the player's body is visible.\n\t# This prevents pre-firing when the player is at the edge of cover with only\n\t# a small part of their body visible. The player must be significantly exposed\n\t# before the enemy can predict their movement.\n\tif _player_visibility_ratio < lead_prediction_visibility_threshold:\n\t\t_log_debug(\"Lead prediction disabled: visibility ratio %.2f < %.2f required (player at cover edge)\" % [_player_visibility_ratio, lead_prediction_visibility_threshold])\n\t\treturn player_pos\n\n\tvar player_velocity := Vector2.ZERO\n\n\t# Get player velocity if they are a CharacterBody2D\n\tif _player is CharacterBody2D:\n\t\tplayer_velocity = _player.velocity\n\n\t# If player is stationary, no need for prediction\n\tif player_velocity.length_squared() < 1.0:\n\t\treturn player_pos\n\n\t# Iterative lead prediction for better accuracy\n\t# Start with player's current position\n\tvar predicted_pos := player_pos\n\tvar distance := global_position.distance_to(predicted_pos)\n\n\t# Iterate 2-3 times for convergence\n\tfor i in range(3):\n\t\t# Time for bullet to reach the predicted position\n\t\tvar time_to_target := distance / bullet_speed\n\n\t\t# Predict where player will be at that time\n\t\tpredicted_pos = player_pos + player_velocity * time_to_target\n\n\t\t# Update distance for next iteration\n\t\tdistance = global_position.distance_to(predicted_pos)\n\n\t# CRITICAL: Validate that the predicted position is actually visible to the enemy.\n\t# If the predicted position is behind cover (e.g., player is running toward cover exit),\n\t# we should NOT aim there - it would feel like the enemy is \"cheating\" by knowing\n\t# where the player will emerge. Fall back to player's current visible position.\n\tif not _is_position_visible_to_enemy(predicted_pos):\n\t\t_log_debug(\"Lead prediction blocked: predicted position %s is not visible, using current position %s\" % [predicted_pos, player_pos])\n\t\treturn player_pos\n\n\t_log_debug(\"Lead prediction: player at %s moving %s, aiming at %s\" % [player_pos, player_velocity, predicted_pos])\n\n\treturn predicted_pos\n\n\n## Process patrol behavior - move between patrol points.\nfunc _process_patrol(delta: float) -> void:\n\tif _patrol_points.is_empty():\n\t\treturn\n\n\t# Handle waiting at patrol point\n\tif _is_waiting_at_patrol_point:\n\t\t_patrol_wait_timer += delta\n\t\tif _patrol_wait_timer >= patrol_wait_time:\n\t\t\t_is_waiting_at_patrol_point = false\n\t\t\t_patrol_wait_timer = 0.0\n\t\t\t_current_patrol_index = (_current_patrol_index + 1) % _patrol_points.size()\n\t\tvelocity = Vector2.ZERO\n\t\treturn\n\n\t# Move towards current patrol point\n\tvar target_point := _patrol_points[_current_patrol_index]\n\tvar direction := (target_point - global_position).normalized()\n\tvar distance := global_position.distance_to(target_point)\n\n\tif distance < 5.0:\n\t\t# Reached patrol point, start waiting\n\t\t_is_waiting_at_patrol_point = true\n\t\tvelocity = Vector2.ZERO\n\telse:\n\t\t# Check for walls and apply avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\t# Blend movement direction with avoidance\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * move_speed\n\t\t# Face movement direction when patrolling\n\t\trotation = direction.angle()\n\n\n## Process guard behavior - stand still and look around.\nfunc _process_guard(_delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\t# In guard mode, enemy doesn't move but can still aim at player when visible\n\n\n## Called when a bullet enters the threat sphere.\nfunc _on_threat_area_entered(area: Area2D) -> void:\n\t# Check if bullet has shooter_id property and if it's from this enemy\n\t# This prevents enemies from being suppressed by their own bullets\n\tif \"shooter_id\" in area and area.shooter_id == get_instance_id():\n\t\treturn  # Ignore own bullets\n\n\t_bullets_in_threat_sphere.append(area)\n\t# Set threat memory timer so enemy can react even after fast bullets exit\n\t# This allows the reaction delay to complete even if bullets pass through quickly\n\t_threat_memory_timer = THREAT_MEMORY_DURATION\n\t# Note: _under_fire is now set in _update_suppression after threat_reaction_delay\n\t# This gives the player more time before the enemy reacts to nearby gunfire\n\t_log_debug(\"Bullet entered threat sphere, starting reaction delay...\")\n\n\n## Called when a bullet exits the threat sphere.\nfunc _on_threat_area_exited(area: Area2D) -> void:\n\t_bullets_in_threat_sphere.erase(area)\n\n\n## Called when the enemy is hit (by bullet.gd).\nfunc on_hit() -> void:\n\tif not _is_alive:\n\t\treturn\n\n\thit.emit()\n\n\t# Track hits for retreat behavior\n\t_hits_taken_in_encounter += 1\n\t_log_debug(\"Hit taken! Total hits in encounter: %d\" % _hits_taken_in_encounter)\n\t_log_to_file(\"Hit taken, health: %d/%d\" % [_current_health - 1, _max_health])\n\n\t# Show hit flash effect\n\t_show_hit_flash()\n\n\t# Apply damage\n\t_current_health -= 1\n\n\t# Play appropriate hit sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif _current_health <= 0:\n\t\t# Play lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_lethal\"):\n\t\t\taudio_manager.play_hit_lethal(global_position)\n\t\t_on_death()\n\telse:\n\t\t# Play non-lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_non_lethal\"):\n\t\t\taudio_manager.play_hit_non_lethal(global_position)\n\t\t_update_health_visual()\n\n\n## Shows a brief flash effect when hit.\nfunc _show_hit_flash() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t_sprite.modulate = hit_flash_color\n\n\tawait get_tree().create_timer(hit_flash_duration).timeout\n\n\t# Restore color based on current health (if still alive)\n\tif _is_alive:\n\t\t_update_health_visual()\n\n\n## Updates the sprite color based on current health percentage.\nfunc _update_health_visual() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t# Interpolate color based on health percentage\n\tvar health_percent := _get_health_percent()\n\t_sprite.modulate = full_health_color.lerp(low_health_color, 1.0 - health_percent)\n\n\n## Returns the current health as a percentage (0.0 to 1.0).\nfunc _get_health_percent() -> float:\n\tif _max_health <= 0:\n\t\treturn 0.0\n\treturn float(_current_health) / float(_max_health)\n\n\n## Called when the enemy dies.\nfunc _on_death() -> void:\n\t_is_alive = false\n\t_log_to_file(\"Enemy died\")\n\tdied.emit()\n\n\tif destroy_on_death:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\tqueue_free()\n\telse:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\t_reset()\n\n\n## Resets the enemy to its initial state.\nfunc _reset() -> void:\n\tglobal_position = _initial_position\n\trotation = 0.0\n\t_current_patrol_index = 0\n\t_is_waiting_at_patrol_point = false\n\t_patrol_wait_timer = 0.0\n\t_current_state = AIState.IDLE\n\t_has_valid_cover = false\n\t_under_fire = false\n\t_suppression_timer = 0.0\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t_continuous_visibility_timer = 0.0\n\t_player_visibility_ratio = 0.0\n\t_threat_reaction_timer = 0.0\n\t_threat_reaction_delay_elapsed = false\n\t_threat_memory_timer = 0.0\n\t_bullets_in_threat_sphere.clear()\n\t# Reset retreat state variables\n\t_hits_taken_in_encounter = 0\n\t_retreat_mode = RetreatMode.FULL_HP\n\t_retreat_turn_timer = 0.0\n\t_retreat_turning_to_cover = false\n\t_retreat_burst_remaining = 0\n\t_retreat_burst_timer = 0.0\n\t_retreat_burst_complete = false\n\t_retreat_burst_angle_offset = 0.0\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\t# Reset combat state variables\n\t_combat_shoot_timer = 0.0\n\t_combat_shoot_duration = 2.5\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_approach_timer = 0.0\n\t# Reset pursuit state variables\n\t_pursuit_cover_wait_timer = 0.0\n\t_pursuit_next_cover = Vector2.ZERO\n\t_has_pursuit_cover = false\n\t# Reset assault state variables\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset flank state variables\n\t_flank_cover_wait_timer = 0.0\n\t_flank_next_cover = Vector2.ZERO\n\t_has_flank_cover = false\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_initialize_goap_state()\n\n\n## Log debu
[2026-01-18T02:53:07.894Z] [INFO] g message if debug_logging is enabled.\nfunc _log_debug(message: String) -> void:\n\tif debug_logging:\n\t\tprint(\"[Enemy %s] %s\" % [name, message])\n\n\n## Log a message to the file logger (always logs, regardless of debug_logging setting).\n## Use for important events like spawning, dying, or critical state changes.\nfunc _log_to_file(message: String) -> void:\n\tif not is_inside_tree():\n\t\treturn\n\tvar file_logger: Node = get_node_or_null(\"/root/FileLogger\")\n\tif file_logger and file_logger.has_method(\"log_enemy\"):\n\t\tfile_logger.log_enemy(name, message)\n\n\n## Log spawn info (called via call_deferred to ensure FileLogger is loaded).\nfunc _log_spawn_info() -> void:\n\t_log_to_file(\"Enemy spawned at %s, health: %d, behavior: %s, player_found: %s\" % [\n\t\tglobal_position, _max_health, BehaviorMode.keys()[behavior_mode],\n\t\t\"yes\" if _player != null else \"no\"])\n\n\n## Get AI state name as a human-readable string.\nfunc _get_state_name(state: AIState) -> String:\n\tmatch state:\n\t\tAIState.IDLE:\n\t\t\treturn \"IDLE\"\n\t\tAIState.COMBAT:\n\t\t\treturn \"COMBAT\"\n\t\tAIState.SEEKING_COVER:\n\t\t\treturn \"SEEKING_COVER\"\n\t\tAIState.IN_COVER:\n\t\t\treturn \"IN_COVER\"\n\t\tAIState.FLANKING:\n\t\t\treturn \"FLANKING\"\n\t\tAIState.SUPPRESSED:\n\t\t\treturn \"SUPPRESSED\"\n\t\tAIState.RETREATING:\n\t\t\treturn \"RETREATING\"\n\t\tAIState.PURSUING:\n\t\t\treturn \"PURSUING\"\n\t\tAIState.ASSAULT:\n\t\t\treturn \"ASSAULT\"\n\t\t_:\n\t\t\treturn \"UNKNOWN\"\n\n\n## Update the debug label with current AI state.\nfunc _update_debug_label() -> void:\n\tif _debug_label == null:\n\t\treturn\n\n\t_debug_label.visible = debug_label_enabled\n\tif not debug_label_enabled:\n\t\treturn\n\n\tvar state_text := _get_state_name(_current_state)\n\n\t# Add retreat mode info if retreating\n\tif _current_state == AIState.RETREATING:\n\t\tmatch _retreat_mode:\n\t\t\tRetreatMode.FULL_HP:\n\t\t\t\tstate_text += \"\\n(FULL_HP)\"\n\t\t\tRetreatMode.ONE_HIT:\n\t\t\t\tstate_text += \"\\n(ONE_HIT)\"\n\t\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t\tstate_text += \"\\n(MULTI_HITS)\"\n\n\t# Add assault timer info if in assault state\n\tif _current_state == AIState.ASSAULT:\n\t\tif _assault_ready:\n\t\t\tstate_text += \"\\n(RUSHING)\"\n\t\telse:\n\t\t\tvar time_left := ASSAULT_WAIT_DURATION - _assault_wait_timer\n\t\t\tstate_text += \"\\n(%.1fs)\" % time_left\n\n\t# Add combat phase info if in combat\n\tif _current_state == AIState.COMBAT:\n\t\tif _combat_exposed:\n\t\t\tvar time_left := _combat_shoot_duration - _combat_shoot_timer\n\t\t\tstate_text += \"\\n(EXPOSED %.1fs)\" % time_left\n\t\telif _seeking_clear_shot:\n\t\t\tvar time_left := CLEAR_SHOT_MAX_TIME - _clear_shot_timer\n\t\t\tstate_text += \"\\n(SEEK SHOT %.1fs)\" % time_left\n\t\telif _combat_approaching:\n\t\t\tstate_text += \"\\n(APPROACH)\"\n\n\t# Add pursuit timer info if pursuing and waiting at cover\n\tif _current_state == AIState.PURSUING:\n\t\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t\tvar time_left := PURSUIT_COVER_WAIT_DURATION - _pursuit_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_pursuit_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\n\t# Add flanking phase info if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_valid_cover and not _has_flank_cover:\n\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_flank_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\t\telse:\n\t\t\tstate_text += \"\\n(DIRECT)\"\n\n\t_debug_label.text = state_text\n\n\n## Get current AI state (for external access/debugging).\nfunc get_current_state() -> AIState:\n\treturn _current_state\n\n\n## Get GOAP world state (for GOAP planner).\nfunc get_goap_world_state() -> Dictionary:\n\treturn _goap_world_state.duplicate()\n\n\n## Check if enemy is currently under fire.\nfunc is_under_fire() -> bool:\n\treturn _under_fire\n\n\n## Check if enemy is in cover.\nfunc is_in_cover() -> bool:\n\treturn _current_state == AIState.IN_COVER or _current_state == AIState.SUPPRESSED\n\n\n## Get current ammo in magazine.\nfunc get_current_ammo() -> int:\n\treturn _current_ammo\n\n\n## Get reserve ammo.\nfunc get_reserve_ammo() -> int:\n\treturn _reserve_ammo\n\n\n## Get total ammo (current + reserve).\nfunc get_total_ammo() -> int:\n\treturn _current_ammo + _reserve_ammo\n\n\n## Check if enemy is currently reloading.\nfunc is_reloading() -> bool:\n\treturn _is_reloading\n\n\n## Check if enemy has any ammo left.\nfunc has_ammo() -> bool:\n\treturn _current_ammo > 0 or _reserve_ammo > 0\n\n\n## Get current player visibility ratio (for debugging).\n## Returns 0.0 if player is completely hidden, 1.0 if fully visible.\nfunc get_player_visibility_ratio() -> float:\n\treturn _player_visibility_ratio\n\n\n## Draw debug visualization when debug mode is enabled.\n## Shows: line to target (cover, clear shot, player), bullet spawn point status.\nfunc _draw() -> void:\n\tif not debug_label_enabled:\n\t\treturn\n\n\t# Colors for different debug elements\n\tvar color_to_cover := Color.CYAN  # Line to cover position\n\tvar color_to_player := Color.RED  # Line to player (when visible)\n\tvar color_clear_shot := Color.YELLOW  # Line to clear shot target\n\tvar color_pursuit := Color.ORANGE  # Line to pursuit cover\n\tvar color_flank := Color.MAGENTA  # Line to flank position\n\tvar color_bullet_spawn := Color.GREEN  # Bullet spawn point indicator\n\tvar color_blocked := Color.RED  # Blocked path indicator\n\n\t# Draw line to player if visible\n\tif _can_see_player and _player:\n\t\tvar to_player := _player.global_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_player, color_to_player, 1.5)\n\n\t\t# Draw bullet spawn point and check if blocked\n\t\tvar direction_to_player := to_player.normalized()\n\t\tvar spawn_point := direction_to_player * bullet_spawn_offset\n\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\tdraw_circle(spawn_point, 5.0, color_bullet_spawn)\n\t\telse:\n\t\t\t# Draw X for blocked spawn point\n\t\t\tdraw_line(spawn_point + Vector2(-5, -5), spawn_point + Vector2(5, 5), color_blocked, 2.0)\n\t\t\tdraw_line(spawn_point + Vector2(-5, 5), spawn_point + Vector2(5, -5), color_blocked, 2.0)\n\n\t# Draw line to cover position if we have one\n\tif _has_valid_cover:\n\t\tvar to_cover := _cover_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_cover, color_to_cover, 1.5)\n\t\t# Draw small circle at cover position\n\t\tdraw_circle(to_cover, 8.0, color_to_cover)\n\n\t# Draw line to clear shot target if seeking clear shot\n\tif _seeking_clear_shot and _clear_shot_target != Vector2.ZERO:\n\t\tvar to_target := _clear_shot_target - global_position\n\t\tdraw_line(Vector2.ZERO, to_target, color_clear_shot, 2.0)\n\t\t# Draw triangle at target position\n\t\tvar target_pos := to_target\n\t\tdraw_line(target_pos + Vector2(-6, 6), target_pos + Vector2(6, 6), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(6, 6), target_pos + Vector2(0, -8), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(0, -8), target_pos + Vector2(-6, 6), color_clear_shot, 2.0)\n\n\t# Draw line to pursuit cover if pursuing\n\tif _current_state == AIState.PURSUING and _has_pursuit_cover:\n\t\tvar to_pursuit := _pursuit_next_cover - global_position\n\t\tdraw_line(Vector2.ZERO, to_pursuit, color_pursuit, 2.0)\n\t\tdraw_circle(to_pursuit, 8.0, color_pursuit)\n\n\t# Draw line to flank target if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_flank_cover:\n\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n\t\telif _flank_target != Vector2.ZERO:\n\t\t\tvar to_flank := _flank_target - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n\t\t\t# Draw diamond at flank target\n\t\t\tvar flank_pos := to_flank\n\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)\n","structuredPatch":[{"oldStart":848,"oldLines":13,"newStart":848,"newLines":13,"lines":["     _transition_to_assault()","     return"," ","-  # If can't see player, pursue them (move cover-to-cover toward player)","+  # If can't see player, transition to SEARCHING to investigate last-known position","   if not _can_see_player:","     _combat_exposed = false","     _combat_approaching = false","     _seeking_clear_shot = false","-    _log_debug(\"Lost sight of player in COMBAT, transitioning to PURSUING\")","-    _transition_to_pursuing()","+    _log_debug(\"Lost sight of player in COMBAT, transitioning to SEARCHING\")","+    _transition_to_searching()","     return"," ","   # Update detection delay timer"]}],"userModified":false,"replaceAll":false}}
[2026-01-18T02:53:10.737Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01Ckcx7ixbfNvffTeFX2awaR",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me add the transition function for SEARCHING and all the search-related functions. Let me find where the other transition functions are:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 555,
      "cache_read_input_tokens": 87790,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 555,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 2,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "09b0d413-61a3-45df-a4e7-01c648a1c3b4"
}
[2026-01-18T02:53:11.748Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01Ckcx7ixbfNvffTeFX2awaR",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01PCEjkwiVTaSioKUk228MsA",
        "name": "Grep",
        "input": {
          "pattern": "func _transition_to_pursuing",
          "path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "output_mode": "content",
          "-n": true,
          "-A": 10
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 555,
      "cache_read_input_tokens": 87790,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 555,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 2,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "b21915d6-eeee-4fce-8b72-ca5d061d9e27"
}
[2026-01-18T02:53:11.801Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01PCEjkwiVTaSioKUk228MsA",
        "type": "tool_result",
        "content": "1835:func _transition_to_pursuing() -> void:\n1836-\t_current_state = AIState.PURSUING\n1837-\t_pursuit_cover_wait_timer = 0.0\n1838-\t_has_pursuit_cover = false\n1839-\t# Reset detection delay for new engagement\n1840-\t_detection_timer = 0.0\n1841-\t_detection_delay_elapsed = false\n1842-\n1843-\n1844-## Transition to ASSAULT state.\n1845-func _transition_to_assault() -> void:"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "1ca83591-18ac-4d10-abbe-43d025c5d6d7",
  "tool_use_result": {
    "mode": "content",
    "numFiles": 0,
    "filenames": [],
    "content": "1835:func _transition_to_pursuing() -> void:\n1836-\t_current_state = AIState.PURSUING\n1837-\t_pursuit_cover_wait_timer = 0.0\n1838-\t_has_pursuit_cover = false\n1839-\t# Reset detection delay for new engagement\n1840-\t_detection_timer = 0.0\n1841-\t_detection_delay_elapsed = false\n1842-\n1843-\n1844-## Transition to ASSAULT state.\n1845-func _transition_to_assault() -> void:",
    "numLines": 11
  }
}
[2026-01-18T02:53:14.521Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_0131qeBPrBKZc7v4vszQZfKv",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_0154VmCkZCEyqP2MUTCwkWhX",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "offset": 1872,
          "limit": 100
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 326,
      "cache_read_input_tokens": 88345,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 326,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 25,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "193a6e43-ea7a-45b0-b8c6-b0100c66956d"
}
[2026-01-18T02:53:14.551Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_0154VmCkZCEyqP2MUTCwkWhX",
        "type": "tool_result",
        "content": "  1872‚Üí\t\t_retreat_burst_timer = 0.0\n  1873‚Üí\t\t_retreat_burst_complete = false\n  1874‚Üí\t\t# Calculate arc spread: shots will be distributed across the arc\n  1875‚Üí\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n  1876‚Üí\t\t_log_debug(\"Entering RETREATING state: ONE_HIT mode (burst of %d shots)\" % _retreat_burst_remaining)\n  1877‚Üí\telse:\n  1878‚Üí\t\t_retreat_mode = RetreatMode.MULTIPLE_HITS\n  1879‚Üí\t\t# Multiple hits also gets burst fire (same as ONE_HIT)\n  1880‚Üí\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n  1881‚Üí\t\t_retreat_burst_timer = 0.0\n  1882‚Üí\t\t_retreat_burst_complete = false\n  1883‚Üí\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n  1884‚Üí\t\t_log_debug(\"Entering RETREATING state: MULTIPLE_HITS mode (burst of %d shots)\" % _retreat_burst_remaining)\n  1885‚Üí\n  1886‚Üí\t# Find cover position for retreating\n  1887‚Üí\t_find_cover_position()\n  1888‚Üí\n  1889‚Üí\n  1890‚Üí## Check if the enemy is visible from the player's position.\n  1891‚Üí## Uses raycasting from player to enemy to determine if there are obstacles blocking line of sight.\n  1892‚Üí## This is the inverse of _can_see_player - it checks if the PLAYER can see the ENEMY.\n  1893‚Üí## Checks multiple points on the enemy body (center and corners) to account for enemy size.\n  1894‚Üífunc _is_visible_from_player() -> bool:\n  1895‚Üí\tif _player == null:\n  1896‚Üí\t\treturn false\n  1897‚Üí\n  1898‚Üí\t# Check visibility to multiple points on the enemy body\n  1899‚Üí\t# This accounts for the enemy's size - corners can stick out from cover\n  1900‚Üí\tvar check_points := _get_enemy_check_points(global_position)\n  1901‚Üí\n  1902‚Üí\tfor point in check_points:\n  1903‚Üí\t\tif _is_point_visible_from_player(point):\n  1904‚Üí\t\t\treturn true\n  1905‚Üí\n  1906‚Üí\treturn false\n  1907‚Üí\n  1908‚Üí\n  1909‚Üí## Get multiple check points on the enemy body for visibility testing.\n  1910‚Üí## Returns center and 4 corner points offset by the enemy's radius.\n  1911‚Üífunc _get_enemy_check_points(center: Vector2) -> Array[Vector2]:\n  1912‚Üí\t# Enemy collision radius is 24, sprite is 48x48\n  1913‚Üí\t# Use a slightly smaller radius to avoid edge cases\n  1914‚Üí\tconst ENEMY_RADIUS: float = 22.0\n  1915‚Üí\n  1916‚Üí\tvar points: Array[Vector2] = []\n  1917‚Üí\tpoints.append(center)  # Center point\n  1918‚Üí\n  1919‚Üí\t# 4 corner points (diagonal directions)\n  1920‚Üí\tvar diagonal_offset := ENEMY_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n  1921‚Üí\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n  1922‚Üí\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n  1923‚Üí\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n  1924‚Üí\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n  1925‚Üí\n  1926‚Üí\treturn points\n  1927‚Üí\n  1928‚Üí\n  1929‚Üí## Check if a single point is visible from the player's position.\n  1930‚Üífunc _is_point_visible_from_player(point: Vector2) -> bool:\n  1931‚Üí\tif _player == null:\n  1932‚Üí\t\treturn false\n  1933‚Üí\n  1934‚Üí\tvar player_pos := _player.global_position\n  1935‚Üí\tvar distance := player_pos.distance_to(point)\n  1936‚Üí\n  1937‚Üí\t# Use direct space state to check line of sight from player to point\n  1938‚Üí\tvar space_state := get_world_2d().direct_space_state\n  1939‚Üí\tvar query := PhysicsRayQueryParameters2D.new()\n  1940‚Üí\tquery.from = player_pos\n  1941‚Üí\tquery.to = point\n  1942‚Üí\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n  1943‚Üí\tquery.exclude = []\n  1944‚Üí\n  1945‚Üí\tvar result := space_state.intersect_ray(query)\n  1946‚Üí\n  1947‚Üí\tif result.is_empty():\n  1948‚Üí\t\t# No obstacle between player and point - point is visible\n  1949‚Üí\t\treturn true\n  1950‚Üí\telse:\n  1951‚Üí\t\t# Check if we hit an obstacle before reaching the point\n  1952‚Üí\t\tvar hit_position: Vector2 = result[\"position\"]\n  1953‚Üí\t\tvar distance_to_hit := player_pos.distance_to(hit_position)\n  1954‚Üí\n  1955‚Üí\t\t# If we hit something closer than the point, the point is hidden\n  1956‚Üí\t\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n  1957‚Üí\t\t\treturn false\n  1958‚Üí\t\telse:\n  1959‚Üí\t\t\treturn true\n  1960‚Üí\n  1961‚Üí\n  1962‚Üí## Check if a specific position would make the enemy visible from the player's position.\n  1963‚Üí## Checks all enemy body points (center and corners) to account for enemy size.\n  1964‚Üí## Used to validate cover positions before moving to them.\n  1965‚Üífunc _is_position_visible_from_player(pos: Vector2) -> bool:\n  1966‚Üí\tif _player == null:\n  1967‚Üí\t\treturn true  # Assume visible if no player\n  1968‚Üí\n  1969‚Üí\t# Check visibility for all enemy body points at the given position\n  1970‚Üí\tvar check_points := _get_enemy_check_points(pos)\n  1971‚Üí\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "e925def6-94da-456f-b442-655845145751",
  "tool_use_result": {
    "type": "text",
    "file": {
      "filePath": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
      "content": "\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t# Calculate arc spread: shots will be distributed across the arc\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: ONE_HIT mode (burst of %d shots)\" % _retreat_burst_remaining)\n\telse:\n\t\t_retreat_mode = RetreatMode.MULTIPLE_HITS\n\t\t# Multiple hits also gets burst fire (same as ONE_HIT)\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: MULTIPLE_HITS mode (burst of %d shots)\" % _retreat_burst_remaining)\n\n\t# Find cover position for retreating\n\t_find_cover_position()\n\n\n## Check if the enemy is visible from the player's position.\n## Uses raycasting from player to enemy to determine if there are obstacles blocking line of sight.\n## This is the inverse of _can_see_player - it checks if the PLAYER can see the ENEMY.\n## Checks multiple points on the enemy body (center and corners) to account for enemy size.\nfunc _is_visible_from_player() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check visibility to multiple points on the enemy body\n\t# This accounts for the enemy's size - corners can stick out from cover\n\tvar check_points := _get_enemy_check_points(global_position)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Get multiple check points on the enemy body for visibility testing.\n## Returns center and 4 corner points offset by the enemy's radius.\nfunc _get_enemy_check_points(center: Vector2) -> Array[Vector2]:\n\t# Enemy collision radius is 24, sprite is 48x48\n\t# Use a slightly smaller radius to avoid edge cases\n\tconst ENEMY_RADIUS: float = 22.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := ENEMY_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point is visible from the player's position.\nfunc _is_point_visible_from_player(point: Vector2) -> bool:\n\tif _player == null:\n\t\treturn false\n\n\tvar player_pos := _player.global_position\n\tvar distance := player_pos.distance_to(point)\n\n\t# Use direct space state to check line of sight from player to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = player_pos\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = []\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between player and point - point is visible\n\t\treturn true\n\telse:\n\t\t# Check if we hit an obstacle before reaching the point\n\t\tvar hit_position: Vector2 = result[\"position\"]\n\t\tvar distance_to_hit := player_pos.distance_to(hit_position)\n\n\t\t# If we hit something closer than the point, the point is hidden\n\t\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t\treturn false\n\t\telse:\n\t\t\treturn true\n\n\n## Check if a specific position would make the enemy visible from the player's position.\n## Checks all enemy body points (center and corners) to account for enemy size.\n## Used to validate cover positions before moving to them.\nfunc _is_position_visible_from_player(pos: Vector2) -> bool:\n\tif _player == null:\n\t\treturn true  # Assume visible if no player\n\n\t# Check visibility for all enemy body points at the given position\n\tvar check_points := _get_enemy_check_points(pos)\n",
      "numLines": 100,
      "startLine": 1872,
      "totalLines": 3262
    }
  }
}
[2026-01-18T02:53:17.154Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_015P9BnbD4hon9Dw862fTWyg",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now I'll add the SEARCHING transition function and the process function after the RETREATING transition function:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 1761,
      "cache_read_input_tokens": 88671,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1761,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "81d54dc7-64d0-4f23-9bbc-b726524a7a5a"
}
[2026-01-18T02:53:43.504Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_015P9BnbD4hon9Dw862fTWyg",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01BAnqX9BSAG2vfKDmJq11HX",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "old_string": "\t# Find cover position for retreating\n\t_find_cover_position()\n\n\n## Check if the enemy is visible from the player's position.",
          "new_string": "\t# Find cover position for retreating\n\t_find_cover_position()\n\n\n## Transition to SEARCHING state.\n## Activates the search zone and generates inspection points.\nfunc _transition_to_searching() -> void:\n\t_current_state = AIState.SEARCHING\n\t_search_timer = 0.0\n\t_inspection_wait_timer = 0.0\n\t_inspecting_point = false\n\t_current_inspection_index = 0\n\n\t# Activate search zone at last known player position\n\tif _last_known_player_position != Vector2.ZERO:\n\t\t_search_zone_active = true\n\t\t_log_debug(\"Activating search zone at %s (radius: %.1f)\" % [_last_known_player_position, SEARCH_ZONE_RADIUS])\n\t\t# Generate inspection points within the search zone\n\t\t_generate_inspection_points()\n\telse:\n\t\t# No last known position - fall back to pursuing\n\t\t_log_debug(\"No last known position, falling back to PURSUING\")\n\t\t_transition_to_pursuing()\n\n\n## Clear the search zone when player is found or search is complete.\nfunc _clear_search_zone() -> void:\n\t_search_zone_active = false\n\t_inspection_points.clear()\n\t_current_inspection_index = 0\n\t_inspecting_point = false\n\t_log_debug(\"Search zone cleared\")\n\n\n## Generate inspection points within the search zone.\n## Finds hiding spots behind covers and at corners within the search area.\nfunc _generate_inspection_points() -> void:\n\t_inspection_points.clear()\n\n\tif _last_known_player_position == Vector2.ZERO:\n\t\treturn\n\n\tvar search_center := _last_known_player_position\n\n\t# Use raycasts from the search center to find obstacles and generate inspection points\n\tfor i in range(INSPECTION_POINT_CHECK_COUNT):\n\t\tvar angle := (float(i) / INSPECTION_POINT_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\t# Cast ray from search center outward to find obstacles\n\t\tvar space_state := get_world_2d().direct_space_state\n\t\tvar query := PhysicsRayQueryParameters2D.new()\n\t\tquery.from = search_center\n\t\tquery.to = search_center + direction * INSPECTION_CHECK_DISTANCE\n\t\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\n\t\tvar result := space_state.intersect_ray(query)\n\n\t\tif not result.is_empty():\n\t\t\tvar collision_point: Vector2 = result[\"position\"]\n\t\t\tvar collision_normal: Vector2 = result[\"normal\"]\n\n\t\t\t# Generate inspection point behind the obstacle (from enemy's perspective)\n\t\t\t# This is where a player might hide\n\t\t\tvar inspection_pos := collision_point + collision_normal * 40.0\n\n\t\t\t# Only add if within search zone radius\n\t\t\tif inspection_pos.distance_to(search_center) <= SEARCH_ZONE_RADIUS:\n\t\t\t\t# Avoid duplicate or too-close points\n\t\t\t\tvar is_duplicate := false\n\t\t\t\tfor existing_point in _inspection_points:\n\t\t\t\t\tif inspection_pos.distance_to(existing_point) < 50.0:\n\t\t\t\t\t\tis_duplicate = true\n\t\t\t\t\t\tbreak\n\t\t\t\tif not is_duplicate:\n\t\t\t\t\t_inspection_points.append(inspection_pos)\n\n\t# Add corners of the search zone as additional inspection points\n\tvar corner_offsets := [\n\t\tVector2(SEARCH_ZONE_RADIUS * 0.7, SEARCH_ZONE_RADIUS * 0.7),\n\t\tVector2(-SEARCH_ZONE_RADIUS * 0.7, SEARCH_ZONE_RADIUS * 0.7),\n\t\tVector2(SEARCH_ZONE_RADIUS * 0.7, -SEARCH_ZONE_RADIUS * 0.7),\n\t\tVector2(-SEARCH_ZONE_RADIUS * 0.7, -SEARCH_ZONE_RADIUS * 0.7),\n\t]\n\n\tfor offset in corner_offsets:\n\t\tvar corner_point := search_center + offset\n\t\t# Only add corner if we can reach it (no obstacle blocking direct path)\n\t\tif _has_clear_path_to(corner_point):\n\t\t\tvar is_duplicate := false\n\t\t\tfor existing_point in _inspection_points:\n\t\t\t\tif corner_point.distance_to(existing_point) < 50.0:\n\t\t\t\t\tis_duplicate = true\n\t\t\t\t\tbreak\n\t\t\tif not is_duplicate:\n\t\t\t\t_inspection_points.append(corner_point)\n\n\t# Sort inspection points by distance from current position (closest first)\n\t_inspection_points.sort_custom(func(a: Vector2, b: Vector2) -> bool:\n\t\treturn global_position.distance_to(a) < global_position.distance_to(b)\n\t)\n\n\t_log_debug(\"Generated %d inspection points in search zone\" % _inspection_points.size())\n\n\n## Process SEARCHING state - investigate last-known player position and check hiding spots.\n## Enemy moves to last-known position, then checks each inspection point within the search zone.\n## Returns to IDLE when all points are checked or timeout expires.\nfunc _process_searching_state(delta: float) -> void:\n\t# If player is spotted during search, immediately transition to combat\n\tif _can_see_player:\n\t\t_log_debug(\"Player found during search, transitioning to COMBAT\")\n\t\t_clear_search_zone()\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Check for suppression - if under fire, need to take cover\n\tif _under_fire and enable_cover:\n\t\t_log_debug(\"Under fire during search, transitioning to RETREATING\")\n\t\t_clear_search_zone()\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Update search timer\n\t_search_timer += delta\n\n\t# Timeout - give up searching and return to patrol/guard\n\tif _search_timer >= SEARCH_MAX_DURATION:\n\t\t_log_debug(\"Search timeout reached, returning to IDLE\")\n\t\t_clear_search_zone()\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# If no inspection points left, search is complete\n\tif _inspection_points.is_empty() or _current_inspection_index >= _inspection_points.size():\n\t\t_log_debug(\"All inspection points checked, search zone cleared\")\n\t\t_clear_search_zone()\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# Get current inspection point target\n\tvar current_target := _inspection_points[_current_inspection_index]\n\tvar distance_to_target := global_position.distance_to(current_target)\n\n\t# Check if we're at the current inspection point\n\tif distance_to_target < 20.0:\n\t\tif not _inspecting_point:\n\t\t\t# Just arrived at inspection point - start looking around\n\t\t\t_inspecting_point = true\n\t\t\t_inspection_wait_timer = 0.0\n\t\t\t_log_debug(\"Inspecting point %d/%d at %s\" % [_current_inspection_index + 1, _inspection_points.size(), current_target])\n\n\t\t# Wait at the inspection point, looking around\n\t\t_inspection_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\t# Rotate while inspecting (looking around)\n\t\trotation += rotation_speed * delta * 0.5\n\n\t\tif _inspection_wait_timer >= INSPECTION_WAIT_DURATION:\n\t\t\t# Done inspecting this point, move to next\n\t\t\t_current_inspection_index += 1\n\t\t\t_inspecting_point = false\n\t\t\t_inspection_wait_timer = 0.0\n\t\treturn\n\n\t# Move toward current inspection point\n\tvar direction := (current_target - global_position).normalized()\n\n\t# Apply wall avoidance\n\tvar avoidance := _check_wall_ahead(direction)\n\tif avoidance != Vector2.ZERO:\n\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\tvelocity = direction * combat_move_speed * 0.8  # Slightly slower when searching\n\trotation = direction.angle()\n\n\n## Check if the enemy is visible from the player's position."
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 1761,
      "cache_read_input_tokens": 88671,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1761,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "7a3b4d2d-c04e-4bd8-ae8d-e6299dc137d6"
}
[2026-01-18T02:53:43.555Z] [INFO] {"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BAnqX9BSAG2vfKDmJq11HX","type":"tool_result","content":"The file /tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1882‚Üí\t\t_retreat_burst_complete = false\n  1883‚Üí\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n  1884‚Üí\t\t_log_debug(\"Entering RETREATING state: MULTIPLE_HITS mode (burst of %d shots)\" % _retreat_burst_remaining)\n  1885‚Üí\n  1886‚Üí\t# Find cover position for retreating\n  1887‚Üí\t_find_cover_position()\n  1888‚Üí\n  1889‚Üí\n  1890‚Üí## Transition to SEARCHING state.\n  1891‚Üí## Activates the search zone and generates inspection points.\n  1892‚Üífunc _transition_to_searching() -> void:\n  1893‚Üí\t_current_state = AIState.SEARCHING\n  1894‚Üí\t_search_timer = 0.0\n  1895‚Üí\t_inspection_wait_timer = 0.0\n  1896‚Üí\t_inspecting_point = false\n  1897‚Üí\t_current_inspection_index = 0\n  1898‚Üí\n  1899‚Üí\t# Activate search zone at last known player position\n  1900‚Üí\tif _last_known_player_position != Vector2.ZERO:\n  1901‚Üí\t\t_search_zone_active = true\n  1902‚Üí\t\t_log_debug(\"Activating search zone at %s (radius: %.1f)\" % [_last_known_player_position, SEARCH_ZONE_RADIUS])\n  1903‚Üí\t\t# Generate inspection points within the search zone\n  1904‚Üí\t\t_generate_inspection_points()\n  1905‚Üí\telse:\n  1906‚Üí\t\t# No last known position - fall back to pursuing\n  1907‚Üí\t\t_log_debug(\"No last known position, falling back to PURSUING\")\n  1908‚Üí\t\t_transition_to_pursuing()\n  1909‚Üí\n  1910‚Üí\n  1911‚Üí## Clear the search zone when player is found or search is complete.\n  1912‚Üífunc _clear_search_zone() -> void:\n  1913‚Üí\t_search_zone_active = false\n  1914‚Üí\t_inspection_points.clear()\n  1915‚Üí\t_current_inspection_index = 0\n  1916‚Üí\t_inspecting_point = false\n  1917‚Üí\t_log_debug(\"Search zone cleared\")\n  1918‚Üí\n  1919‚Üí\n  1920‚Üí## Generate inspection points within the search zone.\n  1921‚Üí## Finds hiding spots behind covers and at corners within the search area.\n  1922‚Üífunc _generate_inspection_points() -> void:\n  1923‚Üí\t_inspection_points.clear()\n  1924‚Üí\n  1925‚Üí\tif _last_known_player_position == Vector2.ZERO:\n  1926‚Üí\t\treturn\n  1927‚Üí\n  1928‚Üí\tvar search_center := _last_known_player_position\n  1929‚Üí\n  1930‚Üí\t# Use raycasts from the search center to find obstacles and generate inspection points\n  1931‚Üí\tfor i in range(INSPECTION_POINT_CHECK_COUNT):\n  1932‚Üí\t\tvar angle := (float(i) / INSPECTION_POINT_CHECK_COUNT) * TAU\n  1933‚Üí\t\tvar direction := Vector2.from_angle(angle)\n  1934‚Üí\n  1935‚Üí\t\t# Cast ray from search center outward to find obstacles\n  1936‚Üí\t\tvar space_state := get_world_2d().direct_space_state\n  1937‚Üí\t\tvar query := PhysicsRayQueryParameters2D.new()\n  1938‚Üí\t\tquery.from = search_center\n  1939‚Üí\t\tquery.to = search_center + direction * INSPECTION_CHECK_DISTANCE\n  1940‚Üí\t\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n  1941‚Üí\n  1942‚Üí\t\tvar result := space_state.intersect_ray(query)\n  1943‚Üí\n  1944‚Üí\t\tif not result.is_empty():\n  1945‚Üí\t\t\tvar collision_point: Vector2 = result[\"position\"]\n  1946‚Üí\t\t\tvar collision_normal: Vector2 = result[\"normal\"]\n  1947‚Üí\n  1948‚Üí\t\t\t# Generate inspection point behind the obstacle (from enemy's perspective)\n  1949‚Üí\t\t\t# This is where a player might hide\n  1950‚Üí\t\t\tvar inspection_pos := collision_point + collision_normal * 40.0\n  1951‚Üí\n  1952‚Üí\t\t\t# Only add if within search zone radius\n  1953‚Üí\t\t\tif inspection_pos.distance_to(search_center) <= SEARCH_ZONE_RADIUS:\n  1954‚Üí\t\t\t\t# Avoid duplicate or too-close points\n  1955‚Üí\t\t\t\tvar is_duplicate := false\n  1956‚Üí\t\t\t\tfor existing_point in _inspection_points:\n  1957‚Üí\t\t\t\t\tif inspection_pos.distance_to(existing_point) < 50.0:\n  1958‚Üí\t\t\t\t\t\tis_duplicate = true\n  1959‚Üí\t\t\t\t\t\tbreak\n  1960‚Üí\t\t\t\tif not is_duplicate:\n  1961‚Üí\t\t\t\t\t_inspection_points.append(inspection_pos)\n  1962‚Üí\n  1963‚Üí\t# Add corners of the search zone as additional inspection points\n  1964‚Üí\tvar corner_offsets := [\n  1965‚Üí\t\tVector2(SEARCH_ZONE_RADIUS * 0.7, SEARCH_ZONE_RADIUS * 0.7),\n  1966‚Üí\t\tVector2(-SEARCH_ZONE_RADIUS * 0.7, SEARCH_ZONE_RADIUS * 0.7),\n  1967‚Üí\t\tVector2(SEARCH_ZONE_RADIUS * 0.7, -SEARCH_ZONE_RADIUS * 0.7),\n  1968‚Üí\t\tVector2(-SEARCH_ZONE_RADIUS * 0.7, -SEARCH_ZONE_RADIUS * 0.7),\n  1969‚Üí\t]\n  1970‚Üí\n  1971‚Üí\tfor offset in corner_offsets:\n  1972‚Üí\t\tvar corner_point := search_center + offset\n  1973‚Üí\t\t# Only add corner if we can reach it (no obstacle blocking direct path)\n  1974‚Üí\t\tif _has_clear_path_to(corner_point):\n  1975‚Üí\t\t\tvar is_duplicate := false\n  1976‚Üí\t\t\tfor existing_point in _inspection_points:\n  1977‚Üí\t\t\t\tif corner_point.distance_to(existing_point) < 50.0:\n  1978‚Üí\t\t\t\t\tis_duplicate = true\n  1979‚Üí\t\t\t\t\tbreak\n  1980‚Üí\t\t\tif not is_duplicate:\n  1981‚Üí\t\t\t\t_inspection_points.append(corner_point)\n  1982‚Üí\n  1983‚Üí\t# Sort inspection points by distance from current position (closest first)\n  1984‚Üí\t_inspection_points.sort_custom(func(a: Vector2, b: Vector2) -> bool:\n  1985‚Üí\t\treturn global_position.distance_to(a) < global_position.distance_to(b)\n  1986‚Üí\t)\n  1987‚Üí\n  1988‚Üí\t_log_debug(\"Generated %d inspection points in search zone\" % _inspection_points.size())\n  1989‚Üí\n  1990‚Üí\n  1991‚Üí## Process SEARCHING state - investigate last-known player position and check hiding spots.\n  1992‚Üí## Enemy moves to last-known position, then checks each inspection point within the search zone.\n  1993‚Üí## Returns to IDLE when all points are checked or timeout expires.\n  1994‚Üífunc _process_searching_state(delta: float) -> void:\n  1995‚Üí\t# If player is spotted during search, immediately transition to combat\n  1996‚Üí\tif _can_see_player:\n  1997‚Üí\t\t_log_debug(\"Player found during search, transitioning to COMBAT\")\n  1998‚Üí\t\t_clear_search_zone()\n  1999‚Üí\t\t_transition_to_combat()\n  2000‚Üí\t\treturn\n  2001‚Üí\n  2002‚Üí\t# Check for suppression - if under fire, need to take cover\n  2003‚Üí\tif _under_fire and enable_cover:\n  2004‚Üí\t\t_log_debug(\"Under fire during search, transitioning to RETREATING\")\n  2005‚Üí\t\t_clear_search_zone()\n  2006‚Üí\t\t_transition_to_retreating()\n  2007‚Üí\t\treturn\n  2008‚Üí\n  2009‚Üí\t# Update search timer\n  2010‚Üí\t_search_timer += delta\n  2011‚Üí\n  2012‚Üí\t# Timeout - give up searching and return to patrol/guard\n  2013‚Üí\tif _search_timer >= SEARCH_MAX_DURATION:\n  2014‚Üí\t\t_log_debug(\"Search timeout reached, returning to IDLE\")\n  2015‚Üí\t\t_clear_search_zone()\n  2016‚Üí\t\t_transition_to_idle()\n  2017‚Üí\t\treturn\n  2018‚Üí\n  2019‚Üí\t# If no inspection points left, search is complete\n  2020‚Üí\tif _inspection_points.is_empty() or _current_inspection_index >= _inspection_points.size():\n  2021‚Üí\t\t_log_debug(\"All inspection points checked, search zone cleared\")\n  2022‚Üí\t\t_clear_search_zone()\n  2023‚Üí\t\t_transition_to_idle()\n  2024‚Üí\t\treturn\n  2025‚Üí\n  2026‚Üí\t# Get current inspection point target\n  2027‚Üí\tvar current_target := _inspection_points[_current_inspection_index]\n  2028‚Üí\tvar distance_to_target := global_position.distance_to(current_target)\n  2029‚Üí\n  2030‚Üí\t# Check if we're at the current inspection point\n  2031‚Üí\tif distance_to_target < 20.0:\n  2032‚Üí\t\tif not _inspecting_point:\n  2033‚Üí\t\t\t# Just arrived at inspection point - start looking around\n  2034‚Üí\t\t\t_inspecting_point = true\n  2035‚Üí\t\t\t_inspection_wait_timer = 0.0\n  2036‚Üí\t\t\t_log_debug(\"Inspecting point %d/%d at %s\" % [_current_inspection_index + 1, _inspection_points.size(), current_target])\n  2037‚Üí\n  2038‚Üí\t\t# Wait at the inspection point, looking around\n  2039‚Üí\t\t_inspection_wait_timer += delta\n  2040‚Üí\t\tvelocity = Vector2.ZERO\n  2041‚Üí\n  2042‚Üí\t\t# Rotate while inspecting (looking around)\n  2043‚Üí\t\trotation += rotation_speed * delta * 0.5\n  2044‚Üí\n  2045‚Üí\t\tif _inspection_wait_timer >= INSPECTION_WAIT_DURATION:\n  2046‚Üí\t\t\t# Done inspecting this point, move to next\n  2047‚Üí\t\t\t_current_inspection_index += 1\n  2048‚Üí\t\t\t_inspecting_point = false\n  2049‚Üí\t\t\t_inspection_wait_timer = 0.0\n  2050‚Üí\t\treturn\n  2051‚Üí\n  2052‚Üí\t# Move toward current inspection point\n  2053‚Üí\tvar direction := (current_target - global_position).normalized()\n  2054‚Üí\n  2055‚Üí\t# Apply wall avoidance\n  2056‚Üí\tvar avoidance := _check_wall_ahead(direction)\n  2057‚Üí\tif avoidance != Vector2.ZERO:\n  2058‚Üí\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n  2059‚Üí\n  2060‚Üí\tvelocity = direction * combat_move_speed * 0.8  # Slightly slower when searching\n  2061‚Üí\trotation = direction.angle()\n  2062‚Üí\n  2063‚Üí\n  2064‚Üí## Check if the enemy is visible from the player's position.\n  2065‚Üí## Uses raycasting from player to enemy to determine if there are obstacles blocking line of sight.\n  2066‚Üí## This is the inverse of _can_see_player - it checks if the PLAYER can see the ENEMY.\n  2067‚Üí## Checks multiple points on the enemy body (center and corners) to account for enemy size.\n  2068‚Üífunc _is_visible_from_player() -> bool:"}]},"parent_tool_use_id":null,"session_id":"797fbac8-f5e6-4339-8fd2-77453410db49","uuid":"58e5eac0-8024-426f-a7e8-fe552b049537","tool_use_result":{"filePath":"/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd","oldString":"\t# Find cover position for retreating\n\t_find_cover_position()\n\n\n## Check if the enemy is visible from the player's position.","newString":"\t# Find cover position for retreating\n\t_find_cover_position()\n\n\n## Transition to SEARCHING state.\n## Activates the search zone and generates inspection points.\nfunc _transition_to_searching() -> void:\n\t_current_state = AIState.SEARCHING\n\t_search_timer = 0.0\n\t_inspection_wait_timer = 0.0\n\t_inspecting_point = false\n\t_current_inspection_index = 0\n\n\t# Activate search zone at last known player position\n\tif _last_known_player_position != Vector2.ZERO:\n\t\t_search_zone_active = true\n\t\t_log_debug(\"Activating search zone at %s (radius: %.1f)\" % [_last_known_player_position, SEARCH_ZONE_RADIUS])\n\t\t# Generate inspection points within the search zone\n\t\t_generate_inspection_points()\n\telse:\n\t\t# No last known position - fall back to pursuing\n\t\t_log_debug(\"No last known position, falling back to PURSUING\")\n\t\t_transition_to_pursuing()\n\n\n## Clear the search zone when player is found or search is complete.\nfunc _clear_search_zone() -> void:\n\t_search_zone_active = false\n\t_inspection_points.clear()\n\t_current_inspection_index = 0\n\t_inspecting_point = false\n\t_log_debug(\"Search zone cleared\")\n\n\n## Generate inspection points within the search zone.\n## Finds hiding spots behind covers and at corners within the search area.\nfunc _generate_inspection_points() -> void:\n\t_inspection_points.clear()\n\n\tif _last_known_player_position == Vector2.ZERO:\n\t\treturn\n\n\tvar search_center := _last_known_player_position\n\n\t# Use raycasts from the search center to find obstacles and generate inspection points\n\tfor i in range(INSPECTION_POINT_CHECK_COUNT):\n\t\tvar angle := (float(i) / INSPECTION_POINT_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\t# Cast ray from search center outward to find obstacles\n\t\tvar space_state := get_world_2d().direct_space_state\n\t\tvar query := PhysicsRayQueryParameters2D.new()\n\t\tquery.from = search_center\n\t\tquery.to = search_center + direction * INSPECTION_CHECK_DISTANCE\n\t\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\n\t\tvar result := space_state.intersect_ray(query)\n\n\t\tif not result.is_empty():\n\t\t\tvar collision_point: Vector2 = result[\"position\"]\n\t\t\tvar collision_normal: Vector2 = result[\"normal\"]\n\n\t\t\t# Generate inspection point behind the obstacle (from enemy's perspective)\n\t\t\t# This is where a player might hide\n\t\t\tvar inspection_pos := collision_point + collision_normal * 40.0\n\n\t\t\t# Only add if within search zone radius\n\t\t\tif inspection_pos.distance_to(search_center) <= SEARCH_ZONE_RADIUS:\n\t\t\t\t# Avoid duplicate or too-close points\n\t\t\t\tvar is_duplicate := false\n\t\t\t\tfor existing_point in _inspection_points:\n\t\t\t\t\tif inspection_pos.distance_to(existing_point) < 50.0:\n\t\t\t\t\t\tis_duplicate = true\n\t\t\t\t\t\tbreak\n\t\t\t\tif not is_duplicate:\n\t\t\t\t\t_inspection_points.append(inspection_pos)\n\n\t# Add corners of the search zone as additional inspection points\n\tvar corner_offsets := [\n\t\tVector2(SEARCH_ZONE_RADIUS * 0.7, SEARCH_ZONE_RADIUS * 0.7),\n\t\tVector2(-SEARCH_ZONE_RADIUS * 0.7, SEARCH_ZONE_RADIUS * 0.7),\n\t\tVector2(SEARCH_ZONE_RADIUS * 0.7, -SEARCH_ZONE_RADIUS * 0.7),\n\t\tVector2(-SEARCH_ZONE_RADIUS * 0.7, -SEARCH_ZONE_RADIUS * 0.7),\n\t]\n\n\tfor offset in corner_offsets:\n\t\tvar corner_point := search_center + offset\n\t\t# Only add corner if we can reach it (no obstacle blocking direct path)\n\t\tif _has_clear_path_to(corner_point):\n\t\t\tvar is_duplicate := false\n\t\t\tfor existing_point in _inspection_points:\n\t\t\t\tif corner_point.distance_to(existing_point) < 50.0:\n\t\t\t\t\tis_duplicate = true\n\t\t\t\t\tbreak\n\t\t\tif not is_duplicate:\n\t\t\t\t_inspection_points.append(corner_point)\n\n\t# Sort inspection points by distance from current position (closest first)\n\t_inspection_points.sort_custom(func(a: Vector2, b: Vector2) -> bool:\n\t\treturn global_position.distance_to(a) < global_position.distance_to(b)\n\t)\n\n\t_log_debug(\"Generated %d inspection points in search zone\" % _inspection_points.size())\n\n\n## Process SEARCHING state - investigate last-known player position and check hiding spots.\n## Enemy moves to last-known position, then checks each inspection point within the search zone.\n## Returns to IDLE when all points are checked or timeout expires.\nfunc _process_searching_state(delta: float) -> void:\n\t# If player is spotted during search, immediately transition to combat\n\tif _can_see_player:\n\t\t_log_debug(\"Player found during search, transitioning to COMBAT\")\n\t\t_clear_search_zone()\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Check for suppression - if under fire, need to take cover\n\tif _under_fire and enable_cover:\n\t\t_log_debug(\"Under fire during search, transitioning to RETREATING\")\n\t\t_clear_search_zone()\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Update search timer\n\t_search_timer += delta\n\n\t# Timeout - give up searching and return to patrol/guard\n\tif _search_timer >= SEARCH_MAX_DURATION:\n\t\t_log_debug(\"Search timeout reached, returning to IDLE\")\n\t\t_clear_search_zone()\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# If no inspection points left, search is complete\n\tif _inspection_points.is_empty() or _current_inspection_index >= _inspection_points.size():\n\t\t_log_debug(\"All inspection points checked, search zone cleared\")\n\t\t_clear_search_zone()\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# Get current inspection point target\n\tvar current_target := _inspection_points[_current_inspection_index]\n\tvar distance_to_target := global_position.distance_to(current_target)\n\n\t# Check if we're at the current inspection point\n\tif distance_to_target < 20.0:\n\t\tif not _inspecting_point:\n\t\t\t# Just arrived at inspection point - start looking around\n\t\t\t_inspecting_point = true\n\t\t\t_inspection_wait_timer = 0.0\n\t\t\t_log_debug(\"Inspecting point %d/%d at %s\" % [_current_inspection_index + 1, _inspection_points.size(), current_target])\n\n\t\t# Wait at the inspection point, looking around\n\t\t_inspection_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\t# Rotate while inspecting (looking around)\n\t\trotation += rotation_speed * delta * 0.5\n\n\t\tif _inspection_wait_timer >= INSPECTION_WAIT_DURATION:\n\t\t\t# Done inspecting this point, move to next\n\t\t\t_current_inspection_index += 1\n\t\t\t_inspecting_point = false\n\t\t\t_inspection_wait_timer = 0.0\n\t\treturn\n\n\t# Move toward current inspection point\n\tvar direction := (current_target - global_position).normalized()\n\n\t# Apply wall avoidance\n\tvar avoidance := _check_wall_ahead(direction)\n\tif avoidance != Vector2.ZERO:\n\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\tvelocity = direction * combat_move_speed * 0.8  # Slightly slower when searching\n\trotation = direction.angle()\n\n\n## Check if the enemy is visible from the player's position.","originalFile":"extends CharacterBody2D\n## Enemy AI with tactical behaviors including patrol, guard, cover, and flanking.\n##\n## Supports multiple behavior modes:\n## - PATROL: Moves between patrol points\n## - GUARD: Stands in place watching for the player\n##\n## Tactical features:\n## - Uses cover when under fire (suppression)\n## - Attempts to flank the player from the sides\n## - Coordinates with other enemies (optional)\n## - GOAP foundation for goal-oriented planning\n\n## AI States for tactical behavior.\nenum AIState {\n\tIDLE,       ## Default idle state (patrol or guard)\n\tCOMBAT,     ## Actively engaging the player (coming out of cover, shooting 2-3s, returning)\n\tSEEKING_COVER,  ## Moving to cover position\n\tIN_COVER,   ## Taking cover from player fire\n\tFLANKING,   ## Attempting to flank the player\n\tSUPPRESSED, ## Under fire, staying in cover\n\tRETREATING, ## Retreating to cover while possibly shooting\n\tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n\tASSAULT,    ## Coordinated multi-enemy assault (rush player after 5s wait)\n\tSEARCHING   ## Searching for player at last-known-position zone\n}\n\n## Retreat behavior modes based on damage taken.\nenum RetreatMode {\n\tFULL_HP,        ## No damage - retreat backwards while shooting, periodically turn to cover\n\tONE_HIT,        ## One hit taken - quick burst then retreat without shooting\n\tMULTIPLE_HITS   ## Multiple hits - quick burst then retreat without shooting (same as ONE_HIT)\n}\n\n## Behavior modes for the enemy.\nenum BehaviorMode {\n\tPATROL,  ## Moves between patrol points\n\tGUARD    ## Stands in one place\n}\n\n## Current behavior mode.\n@export var behavior_mode: BehaviorMode = BehaviorMode.GUARD\n\n## Maximum movement speed in pixels per second.\n@export var move_speed: float = 220.0\n\n## Combat movement speed (faster when flanking/seeking cover).\n@export var combat_move_speed: float = 320.0\n\n## Rotation speed in radians per second for gradual turning.\n## Default is 15 rad/sec for challenging but fair combat.\n@export var rotation_speed: float = 15.0\n\n## Detection range for spotting the player.\n## Set to 0 or negative to allow unlimited detection range (line-of-sight only).\n## This allows enemies to see the player even outside the viewport if no obstacles block view.\n@export var detection_range: float = 0.0\n\n## Time between shots in seconds.\n## Default matches assault rifle fire rate (10 shots/second = 0.1s cooldown).\n@export var shoot_cooldown: float = 0.1\n\n## Bullet scene to instantiate when shooting.\n@export var bullet_scene: PackedScene\n\n## Offset from enemy center for bullet spawn position.\n@export var bullet_spawn_offset: float = 30.0\n\n## Patrol points as offsets from the initial position.\n## Only used when behavior_mode is PATROL.\n@export var patrol_offsets: Array[Vector2] = [Vector2(100, 0), Vector2(-100, 0)]\n\n## Wait time at each patrol point in seconds.\n@export var patrol_wait_time: float = 1.5\n\n## Color when at full health.\n@export var full_health_color: Color = Color(0.9, 0.2, 0.2, 1.0)\n\n## Color when at low health (interpolates based on health percentage).\n@export var low_health_color: Color = Color(0.3, 0.1, 0.1, 1.0)\n\n## Color to flash when hit.\n@export var hit_flash_color: Color = Color(1.0, 1.0, 1.0, 1.0)\n\n## Duration of hit flash effect in seconds.\n@export var hit_flash_duration: float = 0.1\n\n## Whether to destroy the enemy after death.\n@export var destroy_on_death: bool = false\n\n## Delay before respawning or destroying (in seconds).\n@export var respawn_delay: float = 2.0\n\n## Minimum random health.\n@export var min_health: int = 2\n\n## Maximum random health.\n@export var max_health: int = 4\n\n## Threat sphere radius - bullets within this radius trigger suppression.\n@export var threat_sphere_radius: float = 100.0\n\n## Time to stay suppressed after bullets leave threat sphere.\n@export var suppression_cooldown: float = 2.0\n\n## Delay (in seconds) before reacting to bullets in the threat sphere.\n## This prevents instant reactions to nearby gunfire, giving the player more time.\n@export var threat_reaction_delay: float = 0.2\n\n## Flank angle from player's facing direction (radians).\n@export var flank_angle: float = PI / 3.0  # 60 degrees\n\n## Distance to maintain while flanking.\n@export var flank_distance: float = 200.0\n\n## Enable/disable flanking behavior.\n@export var enable_flanking: bool = true\n\n## Enable/disable cover behavior.\n@export var enable_cover: bool = true\n\n## Enable/disable debug logging.\n@export var debug_logging: bool = false\n\n## Enable/disable debug label above enemy showing current AI state.\n@export var debug_label_enabled: bool = false\n\n## Enable/disable friendly fire avoidance (don't shoot if other enemies are in the way).\n@export var enable_friendly_fire_avoidance: bool = true\n\n## Enable/disable lead prediction (shooting ahead of moving targets).\n@export var enable_lead_prediction: bool = true\n\n## Bullet speed for lead prediction calculation.\n## Should match the actual bullet speed (default is 2500 for assault rifle).\n@export var bullet_speed: float = 2500.0\n\n## Ammunition system - magazine size (bullets per magazine).\n@export var magazine_size: int = 30\n\n## Ammunition system - number of magazines the enemy carries.\n@export var total_magazines: int = 5\n\n## Ammunition system - time to reload in seconds.\n@export var reload_time: float = 3.0\n\n## Delay (in seconds) between spotting player and starting to shoot.\n## Gives player a brief reaction time when entering enemy line of sight.\n## This delay \"recharges\" each time the player breaks direct contact with the enemy.\n@export var detection_delay: float = 0.2\n\n## Minimum time (in seconds) the player must be continuously visible before\n## lead prediction is enabled. This prevents enemies from predicting player\n## position immediately when they emerge from cover.\n@export var lead_prediction_delay: float = 0.3\n\n## Minimum visibility ratio (0.0 to 1.0) of player body that must be visible\n## before lead prediction is enabled. At 1.0, the player's entire body must be\n## visible. At 0.5, at least half of the check points must be visible.\n## This prevents pre-firing at players who are at cover edges.\n@export var lead_prediction_visibility_threshold: float = 0.6\n\n## Signal emitted when the enemy is hit.\nsignal hit\n\n## Signal emitted when the enemy dies.\nsignal died\n\n## Signal emitted when AI state changes.\nsignal state_changed(new_state: AIState)\n\n## Signal emitted when ammunition changes.\nsignal ammo_changed(current_ammo: int, reserve_ammo: int)\n\n## Signal emitted when reloading starts.\nsignal reload_started\n\n## Signal emitted when reloading finishes.\nsignal reload_finished\n\n## Signal emitted when all ammunition is depleted.\nsignal ammo_depleted\n\n## Reference to the sprite for color changes.\n@onready var _sprite: Sprite2D = $Sprite2D\n\n## RayCast2D for line of sight detection.\n@onready var _raycast: RayCast2D = $RayCast2D\n\n## Debug label for showing current AI state above the enemy.\n@onready var _debug_label: Label = $DebugLabel\n\n## Wall detection raycasts for obstacle avoidance (created at runtime).\nvar _wall_raycasts: Array[RayCast2D] = []\n\n## Distance to check for walls ahead.\nconst WALL_CHECK_DISTANCE: float = 40.0\n\n## Number of raycasts for wall detection (spread around the enemy).\nconst WALL_CHECK_COUNT: int = 3\n\n## Cover detection raycasts (created at runtime).\nvar _cover_raycasts: Array[RayCast2D] = []\n\n## Number of raycasts for cover detection.\nconst COVER_CHECK_COUNT: int = 16\n\n## Distance to check for cover.\nconst COVER_CHECK_DISTANCE: float = 300.0\n\n## Current health of the enemy.\nvar _current_health: int = 0\n\n## Maximum health of the enemy (set at spawn).\nvar _max_health: int = 0\n\n## Whether the enemy is alive.\nvar _is_alive: bool = true\n\n## Reference to the player (found at runtime).\nvar _player: Node2D = null\n\n## Time since last shot.\nvar _shoot_timer: float = 0.0\n\n## Current ammo in the magazine.\nvar _current_ammo: int = 0\n\n## Reserve ammo (ammo in remaining magazines).\nvar _reserve_ammo: int = 0\n\n## Whether the enemy is currently reloading.\nvar _is_reloading: bool = false\n\n## Timer for reload progress.\nvar _reload_timer: float = 0.0\n\n## Patrol state variables.\nvar _patrol_points: Array[Vector2] = []\nvar _current_patrol_index: int = 0\nvar _is_waiting_at_patrol_point: bool = false\nvar _patrol_wait_timer: float = 0.0\nvar _initial_position: Vector2\n\n## Whether the enemy can currently see the player.\nvar _can_see_player: bool = false\n\n## Current AI state.\nvar _current_state: AIState = AIState.IDLE\n\n## Current cover position (if any).\nvar _cover_position: Vector2 = Vector2.ZERO\n\n## Is currently in a valid cover position.\nvar _has_valid_cover: bool = false\n\n## Timer for suppression cooldown.\nvar _suppression_timer: float = 0.0\n\n## Whether enemy is currently under fire (bullets in threat sphere).\nvar _under_fire: bool = false\n\n## Flank target position.\nvar _flank_target: Vector2 = Vector2.ZERO\n\n## Threat sphere Area2D for detecting nearby bullets.\nvar _threat_sphere: Area2D = null\n\n## Bullets currently in threat sphere.\nvar _bullets_in_threat_sphere: Array = []\n\n## Timer for threat reaction delay - time since first bullet entered threat sphere.\nvar _threat_reaction_timer: float = 0.0\n\n## Whether the threat reaction delay has elapsed (enemy can react to bullets).\nvar _threat_reaction_delay_elapsed: bool = false\n\n## Memory of bullets that have passed through the threat sphere recently.\n## This allows the enemy to react even after fast-moving bullets have exited.\nvar _threat_memory_timer: float = 0.0\n\n## Duration to remember that a bullet passed through the threat sphere.\n## This should be longer than the reaction delay to ensure enemies can complete\n## their reaction even after bullets have passed through quickly.\nconst THREAT_MEMORY_DURATION: float = 0.5\n\n## Current retreat mode determined by damage taken.\nvar _retreat_mode: RetreatMode = RetreatMode.FULL_HP\n\n## Number of hits taken during the current retreat/combat encounter.\n## Resets when enemy enters IDLE state or finishes retreating.\nvar _hits_taken_in_encounter: int = 0\n\n## Timer for periodic turning to cover during FULL_HP retreat.\nvar _retreat_turn_timer: float = 0.0\n\n## Duration to face cover during FULL_HP retreat turn (seconds).\nconst RETREAT_TURN_DURATION: float = 0.8\n\n## Interval between turns toward cover in FULL_HP retreat (seconds).\nconst RETREAT_TURN_INTERVAL: float = 1.5\n\n## Whether currently in the \"turn to cover\" phase of FULL_HP retreat.\nvar _retreat_turning_to_cover: bool = false\n\n## Burst fire counter for ONE_HIT retreat mode.\nvar _retreat_burst_remaining: int = 0\n\n## Timer for burst fire cooldown in ONE_HIT retreat.\nvar _retreat_burst_timer: float = 0.0\n\n## Fast cooldown between burst shots (seconds).\nconst RETREAT_BURST_COOLDOWN: float = 0.06\n\n## Whether burst fire phase is complete in ONE_HIT retreat.\nvar _retreat_burst_complete: bool = false\n\n## Accuracy reduction during retreat (multiplier for inaccuracy angle spread).\nconst RETREAT_INACCURACY_SPREAD: float = 0.15\n\n## Arc spread for ONE_HIT burst fire (radians, total spread).\nconst RETREAT_BURST_ARC: float = 0.4\n\n## Current angle offset within burst arc.\nvar _retreat_burst_angle_offset: float = 0.0\n\n## Whether enemy is in \"alarm\" mode (was suppressed/retreating and hasn't calmed down).\n## This persists until the enemy reaches safety in cover or returns to idle.\nvar _in_alarm_mode: bool = false\n\n## Whether the enemy needs to fire a cover burst (when leaving cover while in alarm).\nvar _cover_burst_pending: bool = false\n\n## --- Combat Cover Cycling (come out, shoot 2-3s, go back) ---\n## Timer for how long the enemy has been shooting while out of cover.\nvar _combat_shoot_timer: float = 0.0\n\n## Duration to shoot while out of cover (2-3 seconds, randomized).\nvar _combat_shoot_duration: float = 2.5\n\n## Whether the enemy is currently in the \"exposed shooting\" phase of combat.\nvar _combat_exposed: bool = false\n\n## Whether the enemy is in the \"approaching player\" phase of combat.\n## In this phase, the enemy moves toward the player to get into direct contact.\nvar _combat_approaching: bool = false\n\n## Timer for the approach phase of combat.\nvar _combat_approach_timer: float = 0.0\n\n## Maximum time to spend approaching player before starting to shoot (seconds).\nconst COMBAT_APPROACH_MAX_TIME: float = 2.0\n\n## Distance at which enemy is considered \"close enough\" to start shooting phase.\nconst COMBAT_DIRECT_CONTACT_DISTANCE: float = 250.0\n\n## --- Pursuit State (cover-to-cover movement) ---\n## Timer for waiting at cover during pursuit.\nvar _pursuit_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during pursuit (1-2 seconds, reduced for faster pursuit).\nconst PURSUIT_COVER_WAIT_DURATION: float = 1.5\n\n## Current pursuit target cover position.\nvar _pursuit_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid pursuit cover target.\nvar _has_pursuit_cover: bool = false\n\n## --- Flanking State (cover-to-cover movement toward flank target) ---\n## Timer for waiting at cover during flanking.\nvar _flank_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during flanking (seconds).\nconst FLANK_COVER_WAIT_DURATION: float = 0.8\n\n## Current flank cover position to move to.\nvar _flank_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid flank cover target.\nvar _has_flank_cover: bool = false\n\n## --- Assault State (coordinated multi-enemy rush) ---\n## Timer for assault wait period (5 seconds before rushing).\nvar _assault_wait_timer: float = 0.0\n\n## Duration to wait at cover before assault (5 seconds).\nconst ASSAULT_WAIT_DURATION: float = 5.0\n\n## Whether the assault wait period is complete.\nvar _assault_ready: bool = false\n\n## Whether this enemy is currently participating in an assault.\nvar _in_assault: bool = false\n\n## Distance threshold for \"close\" vs \"far\" from player.\n## Used to determine if enemy can engage from current position or needs to pursue.\nconst CLOSE_COMBAT_DISTANCE: float = 400.0\n\n## GOAP world state for goal-oriented planning.\nvar _goap_world_state: Dictionary = {}\n\n## --- Search/Investigation State (for when player escapes from view) ---\n## Last known position where the player was seen before escaping view.\nvar _last_known_player_position: Vector2 = Vector2.ZERO\n\n## Whether a search zone is currently active.\nvar _search_zone_active: bool = false\n\n## Radius of the potential player zone (area where player might be hiding).\nconst SEARCH_ZONE_RADIUS: float = 200.0\n\n## Timer for search timeout - enemy gives up searching after this time.\nvar _search_timer: float = 0.0\n\n## Maximum time to spend searching before giving up (seconds).\nconst SEARCH_MAX_DURATION: float = 15.0\n\n## Inspection points within the search zone (hiding spots behind covers and corners).\nvar _inspection_points: Array[Vector2] = []\n\n## Index of current inspection point being checked.\nvar _current_inspection_index: int = 0\n\n## Timer for waiting at each inspection point (looking around).\nvar _inspection_wait_timer: float = 0.0\n\n## Duration to wait at each inspection point (seconds).\nconst INSPECTION_WAIT_DURATION: float = 1.5\n\n## Whether currently waiting at an inspection point.\nvar _inspecting_point: bool = false\n\n## Number of raycasts for detecting inspection points (corners/hiding spots).\nconst INSPECTION_POINT_CHECK_COUNT: int = 24\n\n## Distance to check for inspection points from search zone center.\nconst INSPECTION_CHECK_DISTANCE: float = 250.0\n\n## Detection delay timer - tracks time since entering combat.\nvar _detection_timer: float = 0.0\n\n## Whether the detection delay has elapsed.\nvar _detection_delay_elapsed: bool = false\n\n## Continuous visibility timer - tracks how long the player has been continuously visible.\n## Resets when line of sight is lost.\nvar _continuous_visibility_timer: float = 0.0\n\n## Current visibility ratio of the player (0.0 to 1.0).\n## Represents what fraction of the player's body is visible to the enemy.\n## Used to determine if lead prediction should be enabled.\nvar _player_visibility_ratio: float = 0.0\n\n## --- Clear Shot Movement (move out from cover to get clear shot) ---\n## Target position to move to for getting a clear shot.\nvar _clear_shot_target: Vector2 = Vector2.ZERO\n\n## Whether we're currently moving to find a clear shot position.\nvar _seeking_clear_shot: bool = false\n\n## Timer for how long we've been trying to find a clear shot.\nvar _clear_shot_timer: float = 0.0\n\n## Maximum time to spend finding a clear shot before giving up (seconds).\nconst CLEAR_SHOT_MAX_TIME: float = 3.0\n\n## Distance to move when exiting cover to find a clear shot.\nconst CLEAR_SHOT_EXIT_DISTANCE: float = 60.0\n\n\n\nfunc _ready() -> void:\n\t_initial_position = global_position\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_setup_patrol_points()\n\t_find_player()\n\t_setup_wall_detection()\n\t_setup_cover_detection()\n\t_setup_threat_sphere()\n\t_initialize_goap_state()\n\t_connect_debug_mode_signal()\n\t_update_debug_label()\n\n\t# Log that this enemy is ready (use call_deferred to ensure FileLogger is loaded)\n\tcall_deferred(\"_log_spawn_info\")\n\n\t# Preload bullet scene if not set in inspector\n\tif bullet_scene == null:\n\t\tbullet_scene = preload(\"res://scenes/projectiles/Bullet.tscn\")\n\n\n## Initialize health with random value between min and max.\nfunc _initialize_health() -> void:\n\t_max_health = randi_range(min_health, max_health)\n\t_current_health = _max_health\n\t_is_alive = true\n\n\n## Initialize ammunition with full magazine and reserve ammo.\nfunc _initialize_ammo() -> void:\n\t_current_ammo = magazine_size\n\t# Reserve ammo is (total_magazines - 1) * magazine_size since one magazine is loaded\n\t_reserve_ammo = (total_magazines - 1) * magazine_size\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\n## Setup patrol points based on patrol offsets from initial position.\nfunc _setup_patrol_points() -> void:\n\t_patrol_points.clear()\n\t_patrol_points.append(_initial_position)\n\tfor offset in patrol_offsets:\n\t\t_patrol_points.append(_initial_position + offset)\n\n\n## Setup wall detection raycasts for obstacle avoidance.\nfunc _setup_wall_detection() -> void:\n\t# Create multiple raycasts spread in front of the enemy\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_wall_raycasts.append(raycast)\n\n\n## Setup cover detection raycasts for finding cover positions.\nfunc _setup_cover_detection() -> void:\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_cover_raycasts.append(raycast)\n\n\n## Setup threat sphere for detecting nearby bullets.\nfunc _setup_threat_sphere() -> void:\n\t_threat_sphere = Area2D.new()\n\t_threat_sphere.name = \"ThreatSphere\"\n\t_threat_sphere.collision_layer = 0\n\t_threat_sphere.collision_mask = 16  # Detect projectiles (layer 5)\n\n\tvar collision_shape := CollisionShape2D.new()\n\tvar circle_shape := CircleShape2D.new()\n\tcircle_shape.radius = threat_sphere_radius\n\tcollision_shape.shape = circle_shape\n\t_threat_sphere.add_child(collision_shape)\n\n\tadd_child(_threat_sphere)\n\n\t# Connect signals\n\t_threat_sphere.area_entered.connect(_on_threat_area_entered)\n\t_threat_sphere.area_exited.connect(_on_threat_area_exited)\n\n\n## Initialize GOAP world state.\nfunc _initialize_goap_state() -> void:\n\t_goap_world_state = {\n\t\t\"player_visible\": false,\n\t\t\"has_cover\": false,\n\t\t\"in_cover\": false,\n\t\t\"under_fire\": false,\n\t\t\"health_low\": false,\n\t\t\"can_flank\": false,\n\t\t\"at_flank_position\": false,\n\t\t\"is_retreating\": false,\n\t\t\"hits_taken\": 0,\n\t\t\"is_pursuing\": false,\n\t\t\"is_assaulting\": false,\n\t\t\"can_hit_from_cover\": false,\n\t\t\"player_close\": false,\n\t\t\"enemies_in_combat\": 0,\n\t\t\"has_search_zone\": false,\n\t\t\"search_zone_cleared\": false,\n\t\t\"inspection_points_remaining\": 0,\n\t\t\"is_searching\": false\n\t}\n\n\n## Connect to GameManager's debug mode signal for F7 toggle.\nfunc _connect_debug_mode_signal() -> void:\n\tvar game_manager: Node = get_node_or_null(\"/root/GameManager\")\n\tif game_manager:\n\t\t# Connect to debug mode toggle signal\n\t\tif game_manager.has_signal(\"debug_mode_toggled\"):\n\t\t\tgame_manager.debug_mode_toggled.connect(_on_debug_mode_toggled)\n\t\t# Sync with current debug mode state\n\t\tif game_manager.has_method(\"is_debug_mode_enabled\"):\n\t\t\tdebug_label_enabled = game_manager.is_debug_mode_enabled()\n\n\n## Called when debug mode is toggled via F7 key.\nfunc _on_debug_mode_toggled(enabled: bool) -> void:\n\tdebug_label_enabled = enabled\n\t_update_debug_label()\n\n\n## Find the player node in the scene tree.\nfunc _find_player() -> void:\n\t# Try to find the player by group first\n\tvar players := get_tree().get_nodes_in_group(\"player\")\n\tif players.size() > 0:\n\t\t_player = players[0]\n\t\treturn\n\n\t# Fallback: search for player by node name or type\n\tvar root := get_tree().current_scene\n\tif root:\n\t\t_player = _find_player_recursive(root)\n\n\n## Recursively search for a player node.\nfunc _find_player_recursive(node: Node) -> Node2D:\n\tif node.name == \"Player\" and node is Node2D:\n\t\treturn node\n\tfor child in node.get_children():\n\t\tvar result := _find_player_recursive(child)\n\t\tif result:\n\t\t\treturn result\n\treturn null\n\n\nfunc _physics_process(delta: float) -> void:\n\tif not _is_alive:\n\t\treturn\n\n\t# Update shoot cooldown timer\n\t_shoot_timer += delta\n\n\t# Update reload timer\n\t_update_reload(delta)\n\n\t# Check for player visibility and try to find player if not found\n\tif _player == null:\n\t\t_find_player()\n\n\t_check_player_visibility()\n\t_update_goap_state()\n\t_update_suppression(delta)\n\n\t# Process AI state machine\n\t_process_ai_state(delta)\n\n\t# Update debug label if enabled\n\t_update_debug_label()\n\n\t# Request redraw for debug visualization\n\tif debug_label_enabled:\n\t\tqueue_redraw()\n\n\tmove_and_slide()\n\n\n## Update GOAP world state based on current conditions.\nfunc _update_goap_state() -> void:\n\t_goap_world_state[\"player_visible\"] = _can_see_player\n\t_goap_world_state[\"under_fire\"] = _under_fire\n\t_goap_world_state[\"health_low\"] = _get_health_percent() < 0.5\n\t_goap_world_state[\"in_cover\"] = _current_state == AIState.IN_COVER\n\t_goap_world_state[\"has_cover\"] = _has_valid_cover\n\t_goap_world_state[\"is_retreating\"] = _current_state == AIState.RETREATING\n\t_goap_world_state[\"hits_taken\"] = _hits_taken_in_encounter\n\t_goap_world_state[\"is_pursuing\"] = _current_state == AIState.PURSUING\n\t_goap_world_state[\"is_assaulting\"] = _current_state == AIState.ASSAULT\n\t_goap_world_state[\"player_close\"] = _is_player_close()\n\t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n\t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()\n\t_goap_world_state[\"has_search_zone\"] = _search_zone_active\n\t_goap_world_state[\"search_zone_cleared\"] = not _search_zone_active and _last_known_player_position != Vector2.ZERO\n\t_goap_world_state[\"inspection_points_remaining\"] = _inspection_points.size() - _current_inspection_index\n\t_goap_world_state[\"is_searching\"] = _current_state == AIState.SEARCHING\n\n\n## Update suppression state.\nfunc _update_suppression(delta: float) -> void:\n\t# Clean up destroyed bullets from tracking\n\t_bullets_in_threat_sphere = _bullets_in_threat_sphere.filter(func(b): return is_instance_valid(b))\n\n\t# Determine if there's an active threat (bullets in sphere OR recent threat memory)\n\tvar has_active_threat := not _bullets_in_threat_sphere.is_empty() or _threat_memory_timer > 0.0\n\n\tif not has_active_threat:\n\t\tif _under_fire:\n\t\t\t_suppression_timer += delta\n\t\t\tif _suppression_timer >= suppression_cooldown:\n\t\t\t\t_under_fire = false\n\t\t\t\t_suppression_timer = 0.0\n\t\t\t\t_log_debug(\"Suppression ended\")\n\t\t# Reset threat reaction timer when no bullets are in threat sphere and no threat memory\n\t\t_threat_reaction_timer = 0.0\n\t\t_threat_reaction_delay_elapsed = false\n\telse:\n\t\t# Decrement threat memory timer if no bullets currently in sphere\n\t\tif _bullets_in_threat_sphere.is_empty() and _threat_memory_timer > 0.0:\n\t\t\t_threat_memory_timer -= delta\n\n\t\t# Update threat reaction timer\n\t\tif not _threat_reaction_delay_elapsed:\n\t\t\t_threat_reaction_timer += delta\n\t\t\tif _threat_reaction_timer >= threat_reaction_delay:\n\t\t\t\t_threat_reaction_delay_elapsed = true\n\t\t\t\t_log_debug(\"Threat reaction delay elapsed, now reacting to bullets\")\n\n\t\t# Only set under_fire after the reaction delay has elapsed\n\t\tif _threat_reaction_delay_elapsed:\n\t\t\t_under_fire = true\n\t\t\t_suppression_timer = 0.0\n\n\n## Update reload state.\nfunc _update_reload(delta: float) -> void:\n\tif not _is_reloading:\n\t\treturn\n\n\t_reload_timer += delta\n\tif _reload_timer >= reload_time:\n\t\t_finish_reload()\n\n\n## Start reloading the weapon.\nfunc _start_reload() -> void:\n\t# Can't reload if already reloading or no reserve ammo\n\tif _is_reloading or _reserve_ammo <= 0:\n\t\treturn\n\n\t_is_reloading = true\n\t_reload_timer = 0.0\n\treload_started.emit()\n\t_log_debug(\"Reloading... (%d reserve ammo)\" % _reserve_ammo)\n\n\n## Finish the reload process.\nfunc _finish_reload() -> void:\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\t# Calculate how many rounds to load\n\tvar ammo_needed := magazine_size - _current_ammo\n\tvar ammo_to_load := mini(ammo_needed, _reserve_ammo)\n\n\t_reserve_ammo -= ammo_to_load\n\t_current_ammo += ammo_to_load\n\n\treload_finished.emit()\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\t_log_debug(\"Reload complete. Magazine: %d/%d, Reserve: %d\" % [_current_ammo, magazine_size, _reserve_ammo])\n\n\n## Check if the enemy can shoot (has ammo and not reloading).\nfunc _can_shoot() -> bool:\n\t# Can't shoot if reloading\n\tif _is_reloading:\n\t\treturn false\n\n\t# Can't shoot if no ammo in magazine\n\tif _current_ammo <= 0:\n\t\t# Try to start reload if we have reserve ammo\n\t\tif _reserve_ammo > 0:\n\t\t\t_start_reload()\n\t\telse:\n\t\t\t# No ammo at all - emit depleted signal once\n\t\t\tif not _goap_world_state.get(\"ammo_depleted\", false):\n\t\t\t\t_goap_world_state[\"ammo_depleted\"] = true\n\t\t\t\tammo_depleted.emit()\n\t\t\t\t_log_debug(\"All ammunition depleted!\")\n\t\treturn false\n\n\treturn true\n\n\n## Process the AI state machine.\nfunc _process_ai_state(delta: float) -> void:\n\tvar previous_state := _current_state\n\n\t# State transitions based on conditions\n\tmatch _current_state:\n\t\tAIState.IDLE:\n\t\t\t_process_idle_state(delta)\n\t\tAIState.COMBAT:\n\t\t\t_process_combat_state(delta)\n\t\tAIState.SEEKING_COVER:\n\t\t\t_process_seeking_cover_state(delta)\n\t\tAIState.IN_COVER:\n\t\t\t_process_in_cover_state(delta)\n\t\tAIState.FLANKING:\n\t\t\t_process_flanking_state(delta)\n\t\tAIState.SUPPRESSED:\n\t\t\t_process_suppressed_state(delta)\n\t\tAIState.RETREATING:\n\t\t\t_process_retreating_state(delta)\n\t\tAIState.PURSUING:\n\t\t\t_process_pursuing_state(delta)\n\t\tAIState.ASSAULT:\n\t\t\t_process_assault_state(delta)\n\t\tAIState.SEARCHING:\n\t\t\t_process_searching_state(delta)\n\n\tif previous_state != _current_state:\n\t\tstate_changed.emit(_current_state)\n\t\t_log_debug(\"State changed: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\t\t# Also log to file for exported build debugging\n\t\t_log_to_file(\"State: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\n\n## Process IDLE state - patrol or guard behavior.\nfunc _process_idle_state(delta: float) -> void:\n\t# Transition to combat if player is visible\n\tif _can_see_player and _player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Execute idle behavior\n\tmatch behavior_mode:\n\t\tBehaviorMode.PATROL:\n\t\t\t_process_patrol(delta)\n\t\tBehaviorMode.GUARD:\n\t\t\t_process_guard(delta)\n\n\n## Process COMBAT state - approach player for direct contact, shoot for 2-3 seconds, return to cover.\n## Implements the combat cycling behavior: exit cover -> exposed shooting -> return to cover.\n## Phase 0 (seeking clear shot): If bullet spawn blocked, move out from cover to find clear shot.\n## Phase 1 (approaching): Move toward player to get into direct contact range.\n## Phase 2 (exposed): Stand and shoot for 2-3 seconds.\n## Phase 3: Return to cover via SEEKING_COVER state.\nfunc _process_combat_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies in combat (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can't see player, transition to SEARCHING to investigate last-known position\n\tif not _can_see_player:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to SEARCHING\")\n\t\t_transition_to_searching()\n\t\treturn\n\n\t# Update detection delay timer\n\tif not _detection_delay_elapsed:\n\t\t_detection_timer += delta\n\t\tif _detection_timer >= detection_delay:\n\t\t\t_detection_delay_elapsed = true\n\n\t# If we don't have cover, find some first (needed for returning later)\n\tif not _has_valid_cover and enable_cover:\n\t\t_find_cover_position()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found cover at %s for combat cycling\" % _cover_position)\n\n\t# Check player distance for approach/exposed phase decisions\n\tvar distance_to_player := INF\n\tif _player:\n\t\tdistance_to_player = global_position.distance_to(_player.global_position)\n\n\t# Check if we have a clear shot (no wall blocking bullet spawn)\n\tvar direction_to_player := Vector2.ZERO\n\tvar has_clear_shot := true\n\tif _player:\n\t\tdirection_to_player = (_player.global_position - global_position).normalized()\n\t\thas_clear_shot = _is_bullet_spawn_clear(direction_to_player)\n\n\t# If already exposed (shooting phase), handle shooting and timer\n\tif _combat_exposed:\n\t\t_combat_shoot_timer += delta\n\n\t\t# Check if exposure time is complete - go back to cover\n\t\tif _combat_shoot_timer >= _combat_shoot_duration and _has_valid_cover:\n\t\t\t_log_debug(\"Combat exposure time complete (%.1fs), returning to cover\" % _combat_shoot_duration)\n\t\t\t_combat_exposed = false\n\t\t\t_combat_approaching = false\n\t\t\t_combat_shoot_timer = 0.0\n\t\t\t_transition_to_seeking_cover()\n\t\t\treturn\n\n\t\t# Check if we still have a clear shot - if not, move sideways to find one\n\t\tif _player and not has_clear_shot:\n\t\t\t# Bullet spawn is blocked - move sideways to find a clear shot position\n\t\t\tvar sidestep_dir := _find_sidestep_direction_for_clear_shot(direction_to_player)\n\t\t\tif sidestep_dir != Vector2.ZERO:\n\t\t\t\tvelocity = sidestep_dir * combat_move_speed * 0.7\n\t\t\t\trotation = direction_to_player.angle()  # Keep facing player while sidestepping\n\t\t\t\t_log_debug(\"COMBAT exposed: sidestepping to maintain clear shot\")\n\t\t\telse:\n\t\t\t\t# No sidestep works - stay still, the shot might clear up\n\t\t\t\tvelocity = Vector2.ZERO\n\t\t\treturn\n\n\t\t# In exposed phase with clear shot, stand still and shoot\n\t\tvelocity = Vector2.ZERO\n\n\t\t# Aim and shoot at player (only shoot after detection delay)\n\t\tif _player:\n\t\t\t_aim_at_player()\n\t\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot()\n\t\t\t\t_shoot_timer = 0.0\n\t\treturn\n\n\t# --- CLEAR SHOT SEEKING PHASE ---\n\t# If bullet spawn is blocked and we're not already exposed, we need to move out from cover\n\tif not has_clear_shot and _player:\n\t\t# Start seeking clear shot if not already doing so\n\t\tif not _seeking_clear_shot:\n\t\t\t_seeking_clear_shot = true\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Calculate target position: move perpendicular to player direction (around cover edge)\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\t_log_debug(\"COMBAT: bullet spawn blocked, seeking clear shot at %s\" % _clear_shot_target)\n\n\t\t_clear_shot_timer += delta\n\n\t\t# Check if we've exceeded the max time trying to find a clear shot\n\t\tif _clear_shot_timer >= CLEAR_SHOT_MAX_TIME:\n\t\t\t_log_debug(\"COMBAT: clear shot timeout, trying flanking\")\n\t\t\t_seeking_clear_shot = false\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Try flanking to get around the obstacle\n\t\t\tif enable_flanking:\n\t\t\t\t_transition_to_flanking()\n\t\t\telse:\n\t\t\t\t_transition_to_pursuing()\n\t\t\treturn\n\n\t\t# Move toward the clear shot target position\n\t\tvar distance_to_target := global_position.distance_to(_clear_shot_target)\n\t\tif distance_to_target > 15.0:\n\t\t\tvar move_direction := (_clear_shot_target - global_position).normalized()\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed\n\t\t\trotation = direction_to_player.angle()  # Keep facing player\n\n\t\t\t# Check if the new position now has a clear shot\n\t\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\t\t_log_debug(\"COMBAT: found clear shot position while moving\")\n\t\t\t\t_seeking_clear_shot = false\n\t\t\t\t_clear_shot_timer = 0.0\n\t\t\t\t# Continue to exposed phase check below\n\t\t\telse:\n\t\t\t\treturn  # Keep moving toward target\n\t\telse:\n\t\t\t# Reached target but still no clear shot - recalculate target\n\t\t\t_log_debug(\"COMBAT: reached target but no clear shot, recalculating\")\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\treturn\n\n\t# Reset seeking state if we now have a clear shot\n\tif _seeking_clear_shot and has_clear_shot:\n\t\t_log_debug(\"COMBAT: clear shot acquired\")\n\t\t_seeking_clear_shot = false\n\t\t_clear_shot_timer = 0.0\n\n\t# Determine if we should be in approach phase or exposed shooting phase\n\tvar in_direct_contact := distance_to_player <= COMBAT_DIRECT_CONTACT_DISTANCE\n\n\t# Enter exposed phase if we have a clear shot and are either close enough or have approached long enough\n\tif has_clear_shot and (in_direct_contact or _combat_approach_timer >= COMBAT_APPROACH_MAX_TIME):\n\t\t# Close enough AND
[2026-01-18T02:53:43.585Z] [INFO]  have clear shot - start exposed shooting phase\n\t\t_combat_exposed = true\n\t\t_combat_approaching = false\n\t\t_combat_shoot_timer = 0.0\n\t\t_combat_approach_timer = 0.0\n\t\t# Randomize exposure duration between 2-3 seconds\n\t\t_combat_shoot_duration = randf_range(2.0, 3.0)\n\t\t_log_debug(\"COMBAT exposed phase started (distance: %.0f), will shoot for %.1fs\" % [distance_to_player, _combat_shoot_duration])\n\t\treturn\n\n\t# Need to approach player - move toward them\n\tif not _combat_approaching:\n\t\t_combat_approaching = true\n\t\t_combat_approach_timer = 0.0\n\t\t_log_debug(\"COMBAT approach phase started, moving toward player\")\n\n\t_combat_approach_timer += delta\n\n\t# Move toward player while approaching\n\tif _player:\n\t\tvar move_direction := direction_to_player\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = move_direction * combat_move_speed\n\t\trotation = direction_to_player.angle()  # Always face player\n\n\t\t# Can shoot while approaching (only after detection delay and if have clear shot)\n\t\tif has_clear_shot and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\n## Calculate a target position to exit cover and get a clear shot.\n## Returns a position that should allow the bullet spawn point to be unobstructed.\nfunc _calculate_clear_shot_exit_position(direction_to_player: Vector2) -> Vector2:\n\t# Calculate perpendicular directions to the player\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Try both perpendicular directions and pick the one that's more likely to work\n\t# Also blend with forward movement toward player to help navigate around cover\n\tvar best_position := global_position\n\tvar best_score := -1.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\t\t# Blend sidestep with forward movement for better cover navigation\n\t\tvar exit_dir: Vector2 = (sidestep_dir * 0.7 + direction_to_player * 0.3).normalized()\n\t\tvar test_position: Vector2 = global_position + exit_dir * CLEAR_SHOT_EXIT_DISTANCE\n\n\t\t# Score this position based on:\n\t\t# 1. Does it have a clear path? (no walls in the way)\n\t\t# 2. Would the bullet spawn be clear from there?\n\t\tvar score: float = 0.0\n\n\t\t# Check if we can move to this position\n\t\tif _has_clear_path_to(test_position):\n\t\t\tscore += 1.0\n\n\t\t# Check if bullet spawn would be clear from this position\n\t\t# This is a rough estimate - we check from the test position toward player\n\t\tvar world_2d := get_world_2d()\n\t\tif world_2d != null:\n\t\t\tvar space_state := world_2d.direct_space_state\n\t\t\tif space_state != null:\n\t\t\t\tvar check_distance := bullet_spawn_offset + 5.0\n\t\t\t\tvar query := PhysicsRayQueryParameters2D.new()\n\t\t\t\tquery.from = test_position\n\t\t\t\tquery.to = test_position + direction_to_player * check_distance\n\t\t\t\tquery.collision_mask = 4  # Only check obstacles\n\t\t\t\tquery.exclude = [get_rid()]\n\t\t\t\tvar result := space_state.intersect_ray(query)\n\t\t\t\tif result.is_empty():\n\t\t\t\t\tscore += 2.0  # Higher score for clear bullet spawn\n\n\t\tif score > best_score:\n\t\t\tbest_score = score\n\t\t\tbest_position = test_position\n\n\t# If no good position found, just move forward toward player\n\tif best_score < 0.5:\n\t\tbest_position = global_position + direction_to_player * CLEAR_SHOT_EXIT_DISTANCE\n\n\treturn best_position\n\n\n## Process SEEKING_COVER state - moving to cover position.\nfunc _process_seeking_cover_state(_delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, stay in combat\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're already hidden from the player (the main goal)\n\tif not _is_visible_from_player():\n\t\t_transition_to_in_cover()\n\t\t_log_debug(\"Hidden from player, entering cover state\")\n\t\treturn\n\n\t# Move towards cover\n\tvar direction := (_cover_position - global_position).normalized()\n\tvar distance := global_position.distance_to(_cover_position)\n\n\tif distance < 10.0:\n\t\t# Reached the cover position, but still visible - try to find better cover\n\t\tif _is_visible_from_player():\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\t# No better cover found, stay in combat\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\n\t# Apply wall avoidance\n\tvar avoidance := _check_wall_ahead(direction)\n\tif avoidance != Vector2.ZERO:\n\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\tvelocity = direction * combat_move_speed\n\trotation = direction.angle()\n\n\t# Can still shoot while moving to cover (only after detection delay)\n\tif _can_see_player and _player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t_aim_at_player()\n\t\t_shoot()\n\t\t_shoot_timer = 0.0\n\n\n## Process IN_COVER state - taking cover from enemy fire.\n## Decides next action based on:\n## 1. If under fire -> suppressed\n## 2. If player is close (can exit cover for direct contact) -> COMBAT\n## 3. If player is far but can hit from current position -> COMBAT (stay and shoot)\n## 4. If player is far and can't hit -> PURSUING (move cover-to-cover)\nfunc _process_in_cover_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# If still under fire, stay suppressed\n\tif _under_fire:\n\t\t_transition_to_suppressed()\n\t\treturn\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover\n\tif _is_visible_from_player():\n\t\t# If in alarm mode and can see player, fire a burst before escaping\n\t\tif _in_alarm_mode and _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"IN_COVER alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay in cover while firing burst\n\n\t\t# Burst complete or not in alarm mode, seek new cover\n\t\t_log_debug(\"Player flanked our cover position, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# Decision making based on player distance and visibility\n\tif _player:\n\t\tvar player_close := _is_player_close()\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\n\t\tif _can_see_player:\n\t\t\tif player_close:\n\t\t\t\t# Player is close - engage in combat (come out, shoot, go back)\n\t\t\t\t_log_debug(\"Player is close, transitioning to COMBAT\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\t# Player is far\n\t\t\t\tif can_hit:\n\t\t\t\t\t# Can hit from current position - come out and shoot\n\t\t\t\t\t# (Don't pursue, just transition to combat which will handle the cycling)\n\t\t\t\t\t_log_debug(\"Player is far but can hit from here, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\telse:\n\t\t\t\t\t# Can't hit from here - need to pursue (move cover-to-cover)\n\t\t\t\t\t_log_debug(\"Player is far and can't hit, transitioning to PURSUING\")\n\t\t\t\t\t_transition_to_pursuing()\n\t\t\t\t\treturn\n\n\t# If not under fire and can see player, engage (only shoot after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If player is no longer visible and not under fire, try pursuing\n\tif not _can_see_player and not _under_fire:\n\t\t_log_debug(\"Lost sight of player from cover, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\n\n## Process FLANKING state - attempting to flank the player using cover-to-cover movement.\n## Uses intermediate cover positions to navigate around obstacles instead of walking\n## directly toward the flank target.\nfunc _process_flanking_state(delta: float) -> void:\n\t# If under fire, retreat with shooting behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# If can see player, engage in combat\n\tif _can_see_player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\tif _player == null:\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# Recalculate flank position (player may have moved)\n\t_calculate_flank_position()\n\n\tvar distance_to_flank := global_position.distance_to(_flank_target)\n\n\t# Check if we've reached the flank target\n\tif distance_to_flank < 30.0:\n\t\t_log_debug(\"Reached flank position, engaging\")\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Check if we have direct line of sight to flank target (no obstacles)\n\tif _has_clear_path_to(_flank_target):\n\t\t# Direct path is clear - move directly toward flank target\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\t_has_flank_cover = false\n\t\treturn\n\n\t# Path is blocked - use cover-to-cover movement\n\n\t# If we're at a cover position, wait briefly before moving to next\n\tif _has_valid_cover and not _has_flank_cover:\n\t\t_flank_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _flank_cover_wait_timer >= FLANK_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover toward flank target\n\t\t\t_find_flank_cover_toward_target()\n\t\t\tif not _has_flank_cover:\n\t\t\t\t_log_debug(\"No flank cover found, attempting direct movement\")\n\t\t\t\t# No cover found - try direct movement with enhanced wall avoidance\n\t\t\t\tvar direction := (_flank_target - global_position).normalized()\n\t\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\t\tvelocity = direction * combat_move_speed\n\t\t\t\trotation = direction.angle()\n\t\t\t\t# Invalidate current cover to trigger new search next frame\n\t\t\t\t_has_valid_cover = false\n\t\treturn\n\n\t# If we have a flank cover target, move toward it\n\tif _has_flank_cover:\n\t\tvar direction := (_flank_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_flank_next_cover)\n\n\t\t# Check if we've reached the flank cover\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached flank cover at distance %.1f\" % distance)\n\t\t\t_has_flank_cover = false\n\t\t\t_flank_cover_wait_timer = 0.0\n\t\t\t_cover_position = _flank_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no flank cover target - find initial flank cover\n\t_find_flank_cover_toward_target()\n\tif not _has_flank_cover:\n\t\t# Can't find cover, try direct movement with wall avoidance\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\n\n## Process SUPPRESSED state - staying in cover under fire.\nfunc _process_suppressed_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover even while suppressed\n\tif _is_visible_from_player():\n\t\t# In suppressed state we're always in alarm mode - fire a burst before escaping if we can see player\n\t\tif _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"SUPPRESSED alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay suppressed while firing burst\n\n\t\t# Burst complete or can't see player, seek new cover\n\t\t_log_debug(\"Player flanked our cover position while suppressed, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Can still shoot while suppressed (only after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If no longer under fire, exit suppression\n\tif not _under_fire:\n\t\t_transition_to_in_cover()\n\n\n## Process RETREATING state - moving to cover with behavior based on damage taken.\nfunc _process_retreating_state(delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, transition to combat or suppressed\n\t\t\tif _under_fire:\n\t\t\t\t_transition_to_suppressed()\n\t\t\telse:\n\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we've reached cover and are hidden from player\n\tif not _is_visible_from_player():\n\t\t_log_debug(\"Reached cover during retreat\")\n\t\t# Reset encounter hits when successfully reaching cover\n\t\t_hits_taken_in_encounter = 0\n\t\t_transition_to_in_cover()\n\t\treturn\n\n\t# Calculate direction to cover\n\tvar direction_to_cover := (_cover_position - global_position).normalized()\n\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\n\t# Check if reached cover position\n\tif distance_to_cover < 10.0:\n\t\tif _is_visible_from_player():\n\t\t\t# Still visible, find better cover\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\tif _under_fire:\n\t\t\t\t\t_transition_to_suppressed()\n\t\t\t\telse:\n\t\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Apply retreat behavior based on mode\n\tmatch _retreat_mode:\n\t\tRetreatMode.FULL_HP:\n\t\t\t_process_retreat_full_hp(delta, direction_to_cover)\n\t\tRetreatMode.ONE_HIT:\n\t\t\t_process_retreat_one_hit(delta, direction_to_cover)\n\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t_process_retreat_multiple_hits(delta, direction_to_cover)\n\n\n## Process FULL_HP retreat: walk backwards facing player, shoot with reduced accuracy,\n## periodically turn toward cover.\nfunc _process_retreat_full_hp(delta: float, direction_to_cover: Vector2) -> void:\n\t_retreat_turn_timer += delta\n\n\tif _retreat_turning_to_cover:\n\t\t# Turning to face cover, don't shoot\n\t\tif _retreat_turn_timer >= RETREAT_TURN_DURATION:\n\t\t\t_retreat_turning_to_cover = false\n\t\t\t_retreat_turn_timer = 0.0\n\n\t\t# Face cover and move toward it\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\telse:\n\t\t# Face player and back up (walk backwards)\n\t\tif _retreat_turn_timer >= RETREAT_TURN_INTERVAL:\n\t\t\t_retreat_turning_to_cover = true\n\t\t\t_retreat_turn_timer = 0.0\n\t\t\t_log_debug(\"FULL_HP retreat: turning to check cover\")\n\n\t\tif _player:\n\t\t\t# Face the player\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\t_aim_at_player()\n\n\t\t\t# Move backwards (opposite of player direction = toward cover generally)\n\t\t\t# Use the negative of the direction we're facing for \"backing up\"\n\t\t\tvar move_direction := -direction_to_player\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed * 0.7  # Slower when backing up\n\n\t\t\t# Shoot with reduced accuracy (only after detection delay)\n\t\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot_with_inaccuracy()\n\t\t\t\t_shoot_timer = 0.0\n\n\n## Process ONE_HIT retreat: quick burst of 2-4 shots in an arc while turning, then face cover.\nfunc _process_retreat_one_hit(delta: float, direction_to_cover: Vector2) -> void:\n\tif not _retreat_burst_complete:\n\t\t# During burst phase\n\t\t_retreat_burst_timer += delta\n\n\t\tif _player and _retreat_burst_remaining > 0 and _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t# Fire a burst shot with arc spread\n\t\t\t_shoot_burst_shot()\n\t\t\t_retreat_burst_remaining -= 1\n\t\t\t_retreat_burst_timer = 0.0\n\n\t\t\t# Progress through the arc\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0  # Spread across 4 shots max\n\n\t\t# Gradually turn from player to cover during burst\n\t\tif _player:\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\tvar target_angle: float\n\n\t\t\t# Interpolate rotation from player direction to cover direction\n\t\t\tvar burst_progress := 1.0 - (float(_retreat_burst_remaining) / 4.0)\n\t\t\tvar player_angle := direction_to_player.angle()\n\t\t\tvar cover_angle := direction_to_cover.angle()\n\t\t\ttarget_angle = lerp_angle(player_angle, cover_angle, burst_progress * 0.7)\n\t\t\trotation = target_angle\n\n\t\t# Move toward cover (slower during burst)\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed * 0.5\n\n\t\t# Check if burst is complete\n\t\tif _retreat_burst_remaining <= 0:\n\t\t\t_retreat_burst_complete = true\n\t\t\t_log_debug(\"ONE_HIT retreat: burst complete, now running to cover\")\n\telse:\n\t\t# After burst, run to cover without shooting\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\n\n## Process MULTIPLE_HITS retreat: quick burst of 2-4 shots then run to cover (same as ONE_HIT).\nfunc _process_retreat_multiple_hits(delta: float, direction_to_cover: Vector2) -> void:\n\t# Same behavior as ONE_HIT - quick burst then escape\n\t_process_retreat_one_hit(delta, direction_to_cover)\n\n\n## Process PURSUING state - move cover-to-cover toward player.\n## Enemy moves between covers, waiting 1-2 seconds at each cover,\n## until they can see and hit the player.\nfunc _process_pursuing_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected during pursuit (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can see player and can hit them from current position, engage\n\tif _can_see_player and _player:\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\t\tif can_hit:\n\t\t\t_log_debug(\"Can see and hit player from pursuit, transitioning to COMBAT\")\n\t\t\t_has_pursuit_cover = false\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're waiting at cover\n\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t# Currently at cover, wait for 1-2 seconds before moving to next cover\n\t\t_pursuit_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _pursuit_cover_wait_timer >= PURSUIT_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover closer to player\n\t\t\t_log_debug(\"Pursuit wait complete, finding next cover\")\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_find_pursuit_cover_toward_player()\n\t\t\tif _has_pursuit_cover:\n\t\t\t\t_log_debug(\"Found pursuit cover at %s\" % _pursuit_next_cover)\n\t\t\telse:\n\t\t\t\t# No pursuit cover found - fallback behavior\n\t\t\t\t_log_debug(\"No pursuit cover found, checking fallback options\")\n\t\t\t\t# If we can now see the player, engage directly\n\t\t\t\tif _can_see_player:\n\t\t\t\t\t_log_debug(\"Can see player, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\t# Try flanking\n\t\t\t\tif enable_flanking and _player:\n\t\t\t\t\t_log_debug(\"Attempting flanking maneuver\")\n\t\t\t\t\t_transition_to_flanking()\n\t\t\t\t\treturn\n\t\t\t\t# Last resort: move directly toward player\n\t\t\t\t_log_debug(\"No cover options, moving directly toward player\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\treturn\n\n\t# If we have a pursuit cover target, move toward it\n\tif _has_pursuit_cover:\n\t\tvar direction := (_pursuit_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_pursuit_next_cover)\n\n\t\t# Check if we've reached the pursuit cover\n\t\t# Note: We only check distance here, NOT visibility from player.\n\t\t# If we checked visibility, the enemy would immediately consider themselves\n\t\t# \"at cover\" even before moving, since they start hidden from player.\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached pursuit cover at distance %.1f\" % distance)\n\t\t\t_has_pursuit_cover = false\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_cover_position = _pursuit_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no pursuit target - find initial pursuit cover\n\t_find_pursuit_cover_toward_player()\n\tif not _has_pursuit_cover:\n\t\t# Can't find cover to pursue, try flanking or combat\n\t\tif enable_flanking and _player:\n\t\t\t_transition_to_flanking()\n\t\telse:\n\t\t\t_transition_to_combat()\n\n\n## Process ASSAULT state - coordinated multi-enemy rush.\n## Wait at cover for 5 seconds, then all enemies rush the player simultaneously.\nfunc _process_assault_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover and not _assault_ready:\n\t\t_in_assault = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if we're the only enemy left in assault - switch back to combat\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat < 2 and not _assault_ready:\n\t\t_log_debug(\"Not enough enemies for assault, switching to COMBAT\")\n\t\t_in_assault = false\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Find closest cover to player if we don't have one\n\tif not _has_valid_cover:\n\t\t_find_cover_closest_to_player()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found assault cover at %s\" % _cover_position)\n\n\t# Move to cover position first\n\tif _has_valid_cover and not _in_assault:\n\t\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\t\tif distance_to_cover > 15.0 and _is_visible_from_player():\n\t\t\t# Still need to reach cover\n\t\t\tvar direction := (_cover_position - global_position).normalized()\n\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\tvelocity = direction * combat_move_speed\n\t\t\trotation = direction.angle()\n\t\t\treturn\n\n\t# At cover, wait for assault timer\n\tif not _assault_ready:\n\t\tvelocity = Vector2.ZERO\n\t\t_assault_wait_timer += delta\n\n\t\t# Check if all assault enemies are ready (synchronized assault)\n\t\tif _assault_wait_timer >= ASSAULT_WAIT_DURATION:\n\t\t\t# Check if situation has changed - player might have moved\n\t\t\tif _player and _is_player_close():\n\t\t\t\t_assault_ready = true\n\t\t\t\t_in_assault = true\n\t\t\t\t_log_debug(\"ASSAULT ready - rushing player!\")\n\t\t\telse:\n\t\t\t\t# Player moved away, reset timer and check if we should pursue\n\t\t\t\t_log_debug(\"Player moved away during assault wait, resetting\")\n\t\t\t\t_assault_wait_timer = 0.0\n\t\t\t\t_in_assault = false\n\t\t\t\t_transition_to_pursuing()\n\t\t\t\treturn\n\t\treturn\n\n\t# Assault phase - rush the player while shooting\n\tif _assault_ready and _player:\n\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction_to_player)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_player = (direction_to_player * 0.5 + avoidance * 0.5).normalized()\n\n\t\t# Rush at full speed\n\t\tvelocity = direction_to_player * combat_move_speed\n\t\trotation = direction_to_player.angle()\n\n\t\t# Update detection delay timer\n\t\tif not _detection_delay_elapsed:\n\t\t\t_detection_timer += delta\n\t\t\tif _detection_timer >= detection_delay:\n\t\t\t\t_detection_delay_elapsed = true\n\n\t\t# Shoot while rushing (only after detection delay)\n\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t\t# If very close to player, stay in combat\n\t\tif distance_to_player < 50.0:\n\t\t\t_log_debug(\"Assault complete - reached player\")\n\t\t\t_assault_ready = false\n\t\t\t_in_assault = false\n\t\t\t_transition_to_combat()\n\n\n## Shoot with reduced accuracy for retreat mode.\nfunc _shoot_with_inaccuracy() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Check if the shot should be taken\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Add inaccuracy spread\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD, RETREAT_INACCURACY_SPREAD)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the inaccurate shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Inaccurate shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Shoot a burst shot with arc spread for ONE_HIT retreat.\nfunc _shoot_burst_shot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Apply arc offset for burst spread\n\tdirection = direction.rotated(_retreat_burst_angle_offset)\n\n\t# Also add some random inaccuracy on top of the arc\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD * 0.5, RETREAT_INACCURACY_SPREAD * 0.5)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the burst shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Burst shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Transition to IDLE state.\nfunc _transition_to_idle() -> void:\n\t_current_state = AIState.IDLE\n\t# Reset encounter hit tracking when returning to idle\n\t_hits_taken_in_encounter = 0\n\t# Reset alarm mode when returning to idle\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\n\n## Transition to COMBAT state.\nfunc _transition_to_combat() -> void:\n\t_current_state = AIState.COMBAT\n\t# Reset detection delay timer when entering combat\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Reset combat phase variables\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_shoot_timer = 0.0\n\t_combat_approach_timer = 0.0\n\t# Reset clear shot seeking variables\n\t_seeking_clear_shot = false\n\t_clear_shot_timer = 0.0\n\t_clear_shot_target = Vector2.ZERO\n\n\n## Transition to SEEKING_COVER state.\nfunc _transition_to_seeking_cover() -> void:\n\t_current_state = AIState.SEEKING_COVER\n\t_find_cover_position()\n\n\n## Transition to IN_COVER state.\nfunc _transition_to_in_cover() -> void:\n\t_current_state = AIState.IN_COVER\n\n\n## Transition to FLANKING state.\nfunc _transition_to_flanking() -> void:\n\t_current_state = AIState.FLANKING\n\t_calculate_flank_position()\n\t_flank_cover_wait_timer = 0.0\n\t_has_flank_cover = false\n\t_has_valid_cover = false\n\n\n## Transition to SUPPRESSED state.\nfunc _transition_to_suppressed() -> void:\n\t_current_state = AIState.SUPPRESSED\n\t# Enter alarm mode when suppressed\n\t_in_alarm_mode = true\n\n\n## Transition to PURSUING state.\nfunc _transition_to_pursuing() -> void:\n\t_current_state = AIState.PURSUING\n\t_pursuit_cover_wait_timer = 0.0\n\t_has_pursuit_cover = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\n\n## Transition to ASSAULT state.\nfunc _transition_to_assault() -> void:\n\t_current_state = AIState.ASSAULT\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Find closest cover to player for assault position\n\t_find_cover_closest_to_player()\n\n\n## Transition to RETREATING state with appropriate retreat mode.\nfunc _transition_to_retreating() -> void:\n\t_current_state = AIState.RETREATING\n\t# Enter alarm mode when retreating\n\t_in_alarm_mode = true\n\n\t# Determine retreat mode based on hits taken\n\tif _hits_taken_in_encounter == 0:\n\t\t_retreat_mode = RetreatMode.FULL_HP\n\t\t_retreat_turn_timer = 0.0\n\t\t_retreat_turning_to_cover = false\n\t\t_log_debug(\"Entering RETREATING state: FULL_HP mode (shoot while backing up)\")\n\telif _hits_taken_in_encounter == 1:\n\t\t_retreat_mode = RetreatMode.ONE_HIT\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t# Calculate arc spread: shots will be distributed across the arc\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: ONE_HIT mode (burst of %d shots)\" % _retreat_burst_remaining)\n\telse:\n\t\t_retreat_mode = RetreatMode.MULTIPLE_HITS\n\t\t# Multiple hits also gets burst fire (same as ONE_HIT)\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: MULTIPLE_HITS mode (burst of %d shots)\" % _retreat_burst_remaining)\n\n\t# Find cover position for retreating\n\t_find_cover_position()\n\n\n## Check if the enemy is visible from the player's position.\n## Uses raycasting from player to enemy to determine if there are obstacles blocking line of sight.\n## This is the inverse of _can_see_player - it checks if the PLAYER can see the ENEMY.\n## Checks multiple points on the enemy body (center and corners) to account for enemy size.\nfunc _is_visible_from_player() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check visibility to multiple points on the enemy body\n\t# This accounts for the enemy's size - corners can stick out from cover\n\tvar check_points := _get_enemy_check_points(global_position)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Get multiple check points on the enemy body for visibility testing.\n## Returns center and 4 corner points offset by the enemy's radius.\nfunc _get_enemy_check_points(center: Vector2) -> Array[Vector2]:\n\t# Enemy collision radius is 24, sprite is 48x48\n\t# Use a slightly smaller radius to avoid edge cases\n\tconst ENEMY_RADIUS: float = 22.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := ENEMY_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point is visible from the player's position.\nfunc _is_point_visible_from_player(point: Vector2) -> bool:\n\tif _player == null:\n\t\treturn false\n\n\tvar player_pos := _player.global_position\n\tvar distance := player_pos.distance_to(point)\n\n\t# Use direct space state to check line of sight from player to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = player_pos\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = []\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between player and point - point is visible\n\t\treturn true\n\telse:\n\t\t# Check if we hit an obstacle before reaching the point\n\t\tvar hit_position: Vector2 = result[\"position\"]\n\t\tvar distance_to_hit := player_pos.distance_to(hit_position)\n\n\t\t# If we hit something closer than the point, the point is hidden\n\t\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t\treturn false\n\t\telse:\n\t\t\treturn true\n\n\n## Check if a specific position would make the enemy visible from the player's position.\n## Checks all enemy body points (center and corners) to account for enemy size.\n## Used to validate cover positions before moving to them.\nfunc _is_position_visible_from_player(pos: Vector2) -> bool:\n\tif _player == null:\n\t\treturn true  # Assume visible if no player\n\n\t# Check visibility for all enemy body points at the given position\n\tvar check_points := _get_enemy_check_points(pos)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Check if a target position is visible from the enemy's perspective.\n## Uses raycast to verify there are no obstacles between enemy and the target position.\n## This is used to validate lead prediction targets - enemies should only aim at\n## positions they can actually see.\nfunc _is_position_visible_to_enemy(target_pos: Vector2) -> bool:\n\tvar distance := global_position.distance_to(target_pos)\n\n\t# Use direct space state to check line of sight from enemy to target\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = target_pos\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and target - position is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t# Hit obstacle before target - position is NOT visible\n\t\t_log_debug(\"Position %s blocked by obstacle at distance %.1f (target at %.1f)\" % [target_pos, distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Get multiple check points on the player's body for visibility testing.\n## Returns center and 4 corner points offset by the player's radius.\n## The player has a collision radius of 16 pixels (from Player.tscn).\nfunc _get_player_check_points(center: Vector2) -> Array[Vector2]:\n\t# Player collision radius is 16, sprite is 32x32\n\t# Use a slightly smaller radius to be conservative\n\tconst PLAYER_RADIUS: float = 14.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := PLAYER_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point on the player is visible from the enemy's position.\n## Uses direct space state query to check for obstacles blocking line of sight.\nfunc _is_player_point_visible_to_enemy(point: Vector2) -> bool:\n\tvar distance := global_position.distance_to(point)\n\n\t# Use direct space state to check line of sight from enemy to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and point - point is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the point\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\t# If we hit something before the point, the point is blocked\n\tif distance_to_hit < distance - 5.0:  # 5 pixel tolerance\n\t\treturn false\n\n\treturn true\n\n\n## Calculate what fraction of the player's body is visible to the enemy.\n## Returns a value from 0.0 (completely hidden) to 1.0 (fully visible).\n## Checks multiple points on the player's body (center + corners).\nfunc _calculate_player_visibility_ratio() -> float:\n\tif _player == null:\n\t\treturn 0.0\n\n\tvar check_points := _get_player_check_points(_player.global_position)\n\tvar visible_count := 0\n\n\tfor point in check_points:\n\t\tif _is_player_point_visible_to_enemy(point):\n\t\t\tvisible_count += 1\n\n\treturn float(visible_count) / float(check_points.size())\n\n\n## Check if the line of fire to the target position is clear of other enemies.\n## Returns true if no other enemies would be hit by a bullet traveling to the target.\nfunc _is_firing_line_clear_of_friendlies(target_position: Vector2) -> bool:\n\tif not enable_friendly_fire_avoidance:\n\t\treturn true\n\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if any enemies are in the firing line\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 2  # Only check enemies (layer 2)\n\tquery.exclude = [get_rid()]  # Exclude self using RID\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No enemies in the way\n\n\t# Check if the hit position is before the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 20.0:  # 20 pixel tolerance\n\t\t_log_debug(\"Friendly in firing line at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if a bullet fired at the target position would be blocked by cover/obstacles.\n## Returns true if the shot would likely hit the target, false if blocked by cover.\nfunc _is_shot_clear_of_cover(target_position: Vector2) -> bool:\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if obstacles block the shot\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No obstacles in the way\n\n\t# Check if the obstacle is before the target position\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t_log_debug(\"Shot blocked by cover at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if there's an obstacle immediately in front of the enemy that would block bullets.\n## This prevents shooting into walls that the enemy is flush against or very close to.\n## Uses a single raycast from enemy center to the bullet spawn position.\nfunc _is_bullet_spawn_clear(direction: Vector2) -> bool:\n\t# Fail-open: allow shooting if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn true\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn true\n\n\t# Check from enemy center to bullet spawn position plus a small buffer\n\tvar check_distance := bullet_spawn_offset + 5.0\n\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = global_position + direction * check_distance\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]\n\n\tvar result := space_state.intersect_ray(query)\n\tif not result.is_empty():\n\t\t_log_debug(\"Bullet spawn blocked: wall at distance %.1f\" % [\n\t\t\tglobal_position.distance_to(result[\"position\"])])\n\t\treturn false\n\n\treturn true\n\n\n## Find a sidestep direction that would lead to a clear shot position.\n## Checks perpendicular directions to the player and returns the first one\n## that would allow the bullet spawn point to be clear.\n## Returns Vector2.ZERO if no clear direction is found.\nfunc _find_sidestep_direction_for_clear_shot(direction_to_player: Vector2) -> Vector2:\n\t# Fail-safe: allow normal behavior if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn Vector2.ZERO\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn Vector2.ZERO\n\n\t# Check perpendicular directions (left and right of the player direction)\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Check both sidestep directions and pick the one that leads to clear shot faster\n\tvar check_distance := 50.0  # Check if moving 50 pixels in this direction would help\n\tvar bullet_check_distance := bullet_spawn_offset + 5.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:  # Try both sides\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\n\t\t# First check if we can actually move in this direction (no wall blocking movement)\n\t\tvar move_query := PhysicsRayQueryParameters2D.new()\n\t\tmove_query.from = global_position\n\t\tmove_query.to = global_position + sidestep_dir * 30.0\n\t\tmove_query.collision_mask = 4  # Only check obstacles\n\t\tmove_query.exclude = [get_rid()]\n\n\t\tvar move_result := space_state.intersect_ray(move_query)\n\t\tif not move_result.is_empty():\n\t\t\tcontinue  # Can't move this way, wall is blocking\n\n\t\t# Check if after sidestepping, we'd have a clear shot\n\t\tvar test_position: Vector2 = global_position + sidestep_dir * check_distance\n\t\tvar shot_query := PhysicsRayQueryParameters2D.new()\n\t\tshot_query.from = test_position\n\t\tshot_query.to = test_position + direction_to_player * bullet_check_distance\n\t\tshot_query.collision_mask = 4\n\t\tshot_query.exclude = [get_rid()]\n\n\t\tvar shot_result := space_state.intersect_ray(shot_query)\n\t\tif shot_result.is_empty():\n\t\t\t# Found a direction that leads to a clear shot\n\t\t\t_log_debug(\"Found sidestep direction: %s\" % sidestep_dir)\n\t\t\treturn sidestep_dir\n\n\treturn Vector2.ZERO  # No clear sidestep direction found\n\n\n## Check if the enemy should shoot at the current target.\n## Validates bullet spawn clearance, friendly fire avoidance, and cover blocking.\nfunc _should_shoot_at_target(target_position: Vector2) -> bool:\n\t# Check if the immediate path to bullet spawn is clear\n\t# This prevents shooting into walls the enemy is flush against\n\tvar direction := (target_position - global_position).normalized()\n\tif not _is_bullet_spawn_clear(direction):\n\t\treturn false\n\n\t# Check if friendlies are in the way\n\tif not _is_firing_line_clear_of_friendlies(target_position):\n\t\treturn false\n\n\t# Check if cover blocks the shot\n\tif not _is_shot_clear_of_cover(target_position):\n\t\treturn false\n\n\treturn true\n\n\n## Check if the player is \"close\" (within CLOSE_COMBAT_DISTANCE).\n## Used to determine if the enemy should engage directly or pursue.\nfunc _is_player_close() -> bool:\n\tif _player == null:\n\t\treturn false\n\treturn global_position.distance_to(_player.global_position) <= CLOSE_COMBAT_DISTANCE\n\n\n## Check if the enemy can hit the player from their current position.\n## Returns true if there's a clear line of fire to the player.\nfunc _can_hit_player_from_current_position() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check if we can see the player\n\tif not _can_see_player:\n\t\treturn false\n\n\t# Check if the shot would be blocked by cover\n\treturn _is_shot_clear_of_cover(_player.global_position)\n\n\n## Count the number of enemies currently in combat-related states.\n## Includes COMBAT, PURSUING, ASSAULT, IN_COVER (if can see player).\n## Used to determine if multi-enemy assault should be triggered.\nfunc _count_enemies_in_combat() -> int:\n\tvar count := 0\n\tvar enemies := get_tree().get_nodes_in_group(\"enemies\")\n\n\tfor enemy in enemies:\n\t\tif enemy == self:\n\t\t\tcontinue\n\t\tif not enemy.has_method(\"get_current_state\"):\n\t\t\tcontinue\n\n\t\tvar state: AIState = enemy.get_current_state()\n\t\t# Count enemies in combat-related states\n\t\tif state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\t\t# For IN_COVER, only count if they can see the player\n\t\t\tif state == AIState.IN_COVER:\n\t\t\t\tif enemy.has_method(\"is_in_combat_engagement\") and enemy.is_in_combat_engagement():\n\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tcount += 1\n\n\t# Count self if in a combat-related state\n\tif _current_state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\tcount += 1\n\n\treturn count\n\n\n## Check if this enemy is engaged in combat (can see player and in combat state).\nfunc is_in_combat_engagement() -> bool:\n\treturn _can_see_player and _current_state in [AIState.COMBAT, AIState.IN_COVER, AIState.ASSAULT]\n\n\n## Find cover position closer to the player for pursuit.\n## Used during PURSUING state to move cover-to-cover toward the player.\nfunc _find_pursuit_cover_toward_player() -> void:\n\tif _player == null:\n\t\t_has_pursuit_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For pursuit, we want cover that is:\n\t\t\t# 1. Closer to the player than we currently are\n\t\t\t# 2. Hidden from the player (or mostly hidden)\n\t\t\t# 3. Not too far from our current position\n\n\t\t\tvar my_distance_to_player := global_position.distance_to(player_pos)\n\t\t\tvar cover_distance_to_player := cover_pos.distance_to(player_pos)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to player\n\t\t\tif cover_distance_to_player >= my_distance_to_player:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if this position is hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Hidden from player (priority)\n\t\t\t# - Closer to player\n\t\t\t# - Not too far from current position\n\t\t\tvar hidden_score: float = 5.0 if is_hidden else 0.0\n\t\t\tvar approach_score: float = (my_distance_to_player - cover_distance_to_player) / CLOSE_COMBAT_DISTANCE\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = hidden_score + approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_pursuit_next_cover = best_cover\n\t\t_has_pursuit_cover = true\n\t\t_log_debug(\"Found pursuit cover at %s (score: %.2f)\" % [_pursuit_next_cover, best_score])\n\telse:\n\t\t_has_pursuit_cover = false\n\n\n## Find cover position closest to the player for assault positioning.\n## Used during ASSAULT state to take the nearest safe cover to the player.\nfunc _find_cover_closest_to_player() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_distance: float = INF\n\tvar found_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# Check if this position is hidden from player (safe cover)\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\tif is_hidden:\n\t\t\t\t# Calculate distance from this cover to the player\n\t\t\t\tvar distance_to_player := cover_pos.distance_to(player_pos)\n\n\t\t\t\t# We want the cover closest to the player\n\t\t\t\tif distance_to_player < best_distance:\n\t\t\t\t\tbest_distance = distance_to_player\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\t\tfound_cover = true\n\n\tif found_cover:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found assault cover at %s (distance to player: %.1f)\" % [_cover_position, best_distance])\n\telse:\n\t\t# Fall back to normal cover finding\n\t\t_find_cover_position()\n\n\n## Find a valid cover position relative to the player.\n## The cover position must be hidden from the player's line of sight.\nfunc _find_cover_position() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_hidden_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is on the opposite side of the obstacle from player\n\t\t\tvar direction_from_player := (collision_point - player_pos).normalized()\n\n\t\t\t# Position behind cover (offset from collision point along normal)\n\t\t\t# Offset must be large enough to hide the entire enemy body (radius ~24 pixels)\n\t\t\t# Using 35 pixels to provide some margin for the enemy's collision shape\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# First priority: Check if this position is actually hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Only consider hidden positions unless we have no choice\n\t\t\tif is_hidden or not found_hidden_cover:\n\t\t\t\t# Score based on:\n\t\t\t\t# 1. Whether position is hidden (highest priority)\n\t\t\t\t# 2. Distance from enemy (closer is better)\n\t\t\t\t# 3. Position relative to player (behind cover from player's view)\n\t\t\t\tvar hidden_score: float = 10.0 if is_hidden else 0.0  # Heavy weight for hidden positions\n\n\t\t\t\tvar distance_score := 1.0 - (global_position.distance_to(cover_pos) / COVER_CHECK_DISTANCE)\n\n\t\t\t\t# Check if this position is on the far side of obstacle from player\n\t\t\t\tvar cover_direction := (cover_pos - player_pos).normalized()\n\t\t\t\tvar dot_product := direction_from_player.dot(cover_direction)\n\t\t\t\tvar blocking_score: float = maxf(0.0, dot_product)\n\n\t\t\t\tvar total_score: float = hidden_score + distance_score * 0.3 + blocking_score * 0.7\n\n\t\t\t\t# If we find a hidden position, only accept other hidden positions\n\t\t\t\tif is_hidden and not found_hidden_cover:\n\t\t\t\t\tfound_hidden_cover = true\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\telif (is_hidden or not found_hidden_cover) and total_score > best_score:\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\n\tif best_score > 0:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found cover at: %s (hidden: %s)\" % [_cover_position, found_hidden_cover])\n\telse:\n\t\t_has_valid_cover = false\n\n\n## Calculate flank position based on player location.\nfunc _calculate_flank_position() -> void:\n\tif _player == null:\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar player_to_enemy := (global_position - player_pos).normalized()\n\n\t# Choose left or right flank based on current position\n\tvar flank_side := 1.0 if randf() > 0.5 else -1.0\n\tvar flank_direction := player_to_enemy.rotated(flank_angle * flank_side)\n\n\t_flank_target = player_pos + flank_direction * flank_distance\n\t_log_debug(\"Flank target: %s\" % _flank_target)\n\n\n## Check if there's a clear path (no obstacles) to the target position.\n## Uses a raycast to check for walls/obstacles between current position and target.\nfunc _has_clear_path_to(target: Vector2) -> bool:\n\tif _raycast == null:\n\t\treturn true  # Assume clear if no raycast available\n\n\tvar direction := (target - global_position).normalized()\n\tvar distance := global_position.distance_to(target)\n\n\t_raycast.target_position = direction * distance\n\t_raycast.force_raycast_update()\n\n\t# If we hit something, path is blocked\n\tif _raycast.is_colliding():\n\t\tvar collision_point := _raycast.get_collision_point()\n\t\tvar collision_distance := global_position.distance_to(collision_point)\n\t\t# Only consider it blocked if the collision is before the target\n\t\treturn collision_distance >= distance - 10.0\n\n\treturn true\n\n\n## Find cover position closer to the flank target.\n## Used during FLANKING state to move cover-to-cover toward the flank position.\nfunc _find_flank_cover_toward_target() -> void:\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For flanking, we want cover that is:\n\t\t\t# 1. Closer to the flank target than we currently are\n\t\t\t# 2. Not too far from our current position\n\t\t\t# 3. Reachable (has clear path)\n\n\t\t\tvar my_distance_to_target := global_position.distance_to(_flank_target)\n\t\t\tvar cover_distance_to_target := cover_pos.distance_to(_flank_target)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to flank target\n\t\t\tif cover_distance_to_target >= my_distance_to_target:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if we can reach this cover (has clear path)\n\t\t\tif not _has_clear_path_to(cover_pos):\n\t\t\t\t# Even if direct path is blocked, we might be able to reach\n\t\t\t\t# via another intermediate cover, but skip for now\n\t\t\t\tcontinue\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Closer to flank target (priority)\n\t\t\t# - Not too far from current position\n\t\t\tvar approach_score: float = (my_distance_to_target - cover_distance_to_target) / flank_distance\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_flank_next_cover = best_cover\n\t\t_has_flank_cover = true\n\t\t_log_debug(\"Found flank cover at %s (score: %.2f)\" % [_flank_next_cover, best_score])\n\telse:\n\t\t_has_flank_cover = false\n\n\n## Check if there's a wall ahead in the given direction and return avoidance direction.\n## Returns Vector2.ZERO if no wall detected, otherwise returns a vector to avoid the wall.\nfunc _check_wall_ahead(direction: Vector2) -> Vector2:\n\tif _wall_raycasts.is_empty():\n\t\treturn Vector2.ZERO\n\n\tvar avoidance := Vector2.ZERO\n\tvar perpendicular := Vector2(-direction.y, direction.x)  # 90 degrees rotation\n\n\t# Check center, left, and right raycasts\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar angle_offset := (i - 1) * 0.5  # -0.5, 0, 0.5 radians (~-28, 0, 28 degrees)\n\t\tvar check_direction := direction.rotated(angle_offset)\n\n\t\tvar raycast := _wall_raycasts[i]\n\t\traycast.target_position = check_direction * WALL_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\t# Calculate avoidance based on which raycast hit\n\t\t\tif i == 0:  # Left raycast hit\n\t\t\t\tavoidance += perpendicular  # Steer right\n\t\t\telif i == 1:  # Center raycast hit\n\t\t\t\tavoidance += perpendicular if randf() > 0.5 else -perpendicular  # Random steer\n\t\t\telif i == 2:  # Right raycast hit\n\t\t\t\tavoidance -= perpendicular  # Steer left\n\n\treturn avoidance.normalized() if avoidance.length() > 0 else Vector2.ZERO\n\n\n## Check if the player is visible using raycast.\n## If detection_range is 0 or negative, uses unlimited detection range (line-of-sight only).\n## This allows the enemy to see the player even outside the viewport if there's no obstacle.\n## Also updates the continuous visibility timer and visibility ratio for lead prediction control.\nfunc _check_player_visibility() -> void:\n\tvar was_visible := _can_see_player\n\t_can_see_player = false\n\t_player_visibility_ratio = 0.0\n\n\tif _player == null or not _raycast:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t# Check if player is within detection range (only if detection_range is positive)\n\t# If detection_range <= 0, detection is unlimited (line-of-sight only)\n\tif detection_range > 0 and distance_to_player > detection_range:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\t# Point raycast at player - use actual distance to player for the raycast length\n\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\tvar raycast_length := distance_to_player + 10.0  # Add small buffer to ensure we reach player\n\t_raycast.target_position = direction_to_player * raycast_length\n\t_raycast.force_raycast_update()\n\n\t# Check if raycast hit something\n\tif _raycast.is_colliding():\n\t\tvar collider := _raycast.get_collider()\n\t\t# If we hit the player, we can see them\n\t\tif collider == _player:\n\t\t\t_can_see_player = true\n\t\t# If we hit a wall/obstacle before the player, we can't see them\n\telse:\n\t\t# No collision between us and player - we have clear line of sight\n\t\t_can_see_player = true\n\n\t# Update continuous visibility timer and visibility ratio\n\tif _can_see_player:\n\t\t_continuous_visi
[2026-01-18T02:53:43.612Z] [INFO] bility_timer += get_physics_process_delta_time()\n\t\t# Calculate what fraction of the player's body is visible\n\t\t# This is used to determine if lead prediction should be enabled\n\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n\t\t# Update last known player position while we can see them\n\t\t_last_known_player_position = _player.global_position\n\t\t# Clear search zone when player is seen\n\t\tif _search_zone_active:\n\t\t\t_clear_search_zone()\n\telse:\n\t\t# Lost line of sight - reset the timer and visibility ratio\n\t\t_continuous_visibility_timer = 0.0\n\t\t_player_visibility_ratio = 0.0\n\t\t# If we just lost sight and were in combat, activate search zone\n\t\tif was_visible and _last_known_player_position != Vector2.ZERO:\n\t\t\t_log_debug(\"Player escaped from view at %s\" % _last_known_player_position)\n\n\n## Aim the enemy sprite/direction at the player using gradual rotation.\nfunc _aim_at_player() -> void:\n\tif _player == null:\n\t\treturn\n\tvar direction := (_player.global_position - global_position).normalized()\n\tvar target_angle := direction.angle()\n\n\t# Calculate the shortest rotation direction\n\tvar angle_diff := wrapf(target_angle - rotation, -PI, PI)\n\n\t# Get the delta time from the current physics process\n\tvar delta := get_physics_process_delta_time()\n\n\t# Apply gradual rotation based on rotation_speed\n\tif abs(angle_diff) <= rotation_speed * delta:\n\t\t# Close enough to snap to target\n\t\trotation = target_angle\n\telif angle_diff > 0:\n\t\trotation += rotation_speed * delta\n\telse:\n\t\trotation -= rotation_speed * delta\n\n\n## Shoot a bullet towards the player.\nfunc _shoot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\t# Check if we can shoot (have ammo and not reloading)\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Apply lead prediction if enabled\n\tif enable_lead_prediction:\n\t\ttarget_position = _calculate_lead_prediction()\n\n\t# Check if the shot should be taken (friendly fire and cover checks)\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Create bullet instance\n\tvar bullet := bullet_scene.instantiate()\n\n\t# Set bullet position with offset in shoot direction\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\n\t# Set bullet direction\n\tbullet.direction = direction\n\n\t# Set shooter ID to identify this enemy as the source\n\t# This prevents enemies from detecting their own bullets in the threat sphere\n\tbullet.shooter_id = get_instance_id()\n\n\t# Add bullet to the scene tree\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play shooting sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\n\t# Play shell casing sound with a small delay\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\t# Auto-reload when magazine is empty\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Play shell casing sound with a delay to simulate the casing hitting the ground.\nfunc _play_delayed_shell_sound() -> void:\n\tawait get_tree().create_timer(0.15).timeout\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_shell_rifle\"):\n\t\taudio_manager.play_shell_rifle(global_position)\n\n\n## Calculate lead prediction - aims where the player will be, not where they are.\n## Uses iterative approach for better accuracy with moving targets.\n## Only applies lead prediction if:\n## 1. The player has been continuously visible for at least lead_prediction_delay seconds\n## 2. At least lead_prediction_visibility_threshold of the player's body is visible\n## 3. The predicted position is also visible to the enemy (not behind cover)\n## This prevents enemies from \"knowing\" where the player will emerge from cover.\nfunc _calculate_lead_prediction() -> Vector2:\n\tif _player == null:\n\t\treturn global_position\n\n\tvar player_pos := _player.global_position\n\n\t# Only use lead prediction if the player has been continuously visible\n\t# for long enough. This prevents enemies from predicting player position\n\t# immediately when they emerge from cover.\n\tif _continuous_visibility_timer < lead_prediction_delay:\n\t\t_log_debug(\"Lead prediction disabled: visibility time %.2fs < %.2fs required\" % [_continuous_visibility_timer, lead_prediction_delay])\n\t\treturn player_pos\n\n\t# Only use lead prediction if enough of the player's body is visible.\n\t# This prevents pre-firing when the player is at the edge of cover with only\n\t# a small part of their body visible. The player must be significantly exposed\n\t# before the enemy can predict their movement.\n\tif _player_visibility_ratio < lead_prediction_visibility_threshold:\n\t\t_log_debug(\"Lead prediction disabled: visibility ratio %.2f < %.2f required (player at cover edge)\" % [_player_visibility_ratio, lead_prediction_visibility_threshold])\n\t\treturn player_pos\n\n\tvar player_velocity := Vector2.ZERO\n\n\t# Get player velocity if they are a CharacterBody2D\n\tif _player is CharacterBody2D:\n\t\tplayer_velocity = _player.velocity\n\n\t# If player is stationary, no need for prediction\n\tif player_velocity.length_squared() < 1.0:\n\t\treturn player_pos\n\n\t# Iterative lead prediction for better accuracy\n\t# Start with player's current position\n\tvar predicted_pos := player_pos\n\tvar distance := global_position.distance_to(predicted_pos)\n\n\t# Iterate 2-3 times for convergence\n\tfor i in range(3):\n\t\t# Time for bullet to reach the predicted position\n\t\tvar time_to_target := distance / bullet_speed\n\n\t\t# Predict where player will be at that time\n\t\tpredicted_pos = player_pos + player_velocity * time_to_target\n\n\t\t# Update distance for next iteration\n\t\tdistance = global_position.distance_to(predicted_pos)\n\n\t# CRITICAL: Validate that the predicted position is actually visible to the enemy.\n\t# If the predicted position is behind cover (e.g., player is running toward cover exit),\n\t# we should NOT aim there - it would feel like the enemy is \"cheating\" by knowing\n\t# where the player will emerge. Fall back to player's current visible position.\n\tif not _is_position_visible_to_enemy(predicted_pos):\n\t\t_log_debug(\"Lead prediction blocked: predicted position %s is not visible, using current position %s\" % [predicted_pos, player_pos])\n\t\treturn player_pos\n\n\t_log_debug(\"Lead prediction: player at %s moving %s, aiming at %s\" % [player_pos, player_velocity, predicted_pos])\n\n\treturn predicted_pos\n\n\n## Process patrol behavior - move between patrol points.\nfunc _process_patrol(delta: float) -> void:\n\tif _patrol_points.is_empty():\n\t\treturn\n\n\t# Handle waiting at patrol point\n\tif _is_waiting_at_patrol_point:\n\t\t_patrol_wait_timer += delta\n\t\tif _patrol_wait_timer >= patrol_wait_time:\n\t\t\t_is_waiting_at_patrol_point = false\n\t\t\t_patrol_wait_timer = 0.0\n\t\t\t_current_patrol_index = (_current_patrol_index + 1) % _patrol_points.size()\n\t\tvelocity = Vector2.ZERO\n\t\treturn\n\n\t# Move towards current patrol point\n\tvar target_point := _patrol_points[_current_patrol_index]\n\tvar direction := (target_point - global_position).normalized()\n\tvar distance := global_position.distance_to(target_point)\n\n\tif distance < 5.0:\n\t\t# Reached patrol point, start waiting\n\t\t_is_waiting_at_patrol_point = true\n\t\tvelocity = Vector2.ZERO\n\telse:\n\t\t# Check for walls and apply avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\t# Blend movement direction with avoidance\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * move_speed\n\t\t# Face movement direction when patrolling\n\t\trotation = direction.angle()\n\n\n## Process guard behavior - stand still and look around.\nfunc _process_guard(_delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\t# In guard mode, enemy doesn't move but can still aim at player when visible\n\n\n## Called when a bullet enters the threat sphere.\nfunc _on_threat_area_entered(area: Area2D) -> void:\n\t# Check if bullet has shooter_id property and if it's from this enemy\n\t# This prevents enemies from being suppressed by their own bullets\n\tif \"shooter_id\" in area and area.shooter_id == get_instance_id():\n\t\treturn  # Ignore own bullets\n\n\t_bullets_in_threat_sphere.append(area)\n\t# Set threat memory timer so enemy can react even after fast bullets exit\n\t# This allows the reaction delay to complete even if bullets pass through quickly\n\t_threat_memory_timer = THREAT_MEMORY_DURATION\n\t# Note: _under_fire is now set in _update_suppression after threat_reaction_delay\n\t# This gives the player more time before the enemy reacts to nearby gunfire\n\t_log_debug(\"Bullet entered threat sphere, starting reaction delay...\")\n\n\n## Called when a bullet exits the threat sphere.\nfunc _on_threat_area_exited(area: Area2D) -> void:\n\t_bullets_in_threat_sphere.erase(area)\n\n\n## Called when the enemy is hit (by bullet.gd).\nfunc on_hit() -> void:\n\tif not _is_alive:\n\t\treturn\n\n\thit.emit()\n\n\t# Track hits for retreat behavior\n\t_hits_taken_in_encounter += 1\n\t_log_debug(\"Hit taken! Total hits in encounter: %d\" % _hits_taken_in_encounter)\n\t_log_to_file(\"Hit taken, health: %d/%d\" % [_current_health - 1, _max_health])\n\n\t# Show hit flash effect\n\t_show_hit_flash()\n\n\t# Apply damage\n\t_current_health -= 1\n\n\t# Play appropriate hit sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif _current_health <= 0:\n\t\t# Play lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_lethal\"):\n\t\t\taudio_manager.play_hit_lethal(global_position)\n\t\t_on_death()\n\telse:\n\t\t# Play non-lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_non_lethal\"):\n\t\t\taudio_manager.play_hit_non_lethal(global_position)\n\t\t_update_health_visual()\n\n\n## Shows a brief flash effect when hit.\nfunc _show_hit_flash() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t_sprite.modulate = hit_flash_color\n\n\tawait get_tree().create_timer(hit_flash_duration).timeout\n\n\t# Restore color based on current health (if still alive)\n\tif _is_alive:\n\t\t_update_health_visual()\n\n\n## Updates the sprite color based on current health percentage.\nfunc _update_health_visual() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t# Interpolate color based on health percentage\n\tvar health_percent := _get_health_percent()\n\t_sprite.modulate = full_health_color.lerp(low_health_color, 1.0 - health_percent)\n\n\n## Returns the current health as a percentage (0.0 to 1.0).\nfunc _get_health_percent() -> float:\n\tif _max_health <= 0:\n\t\treturn 0.0\n\treturn float(_current_health) / float(_max_health)\n\n\n## Called when the enemy dies.\nfunc _on_death() -> void:\n\t_is_alive = false\n\t_log_to_file(\"Enemy died\")\n\tdied.emit()\n\n\tif destroy_on_death:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\tqueue_free()\n\telse:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\t_reset()\n\n\n## Resets the enemy to its initial state.\nfunc _reset() -> void:\n\tglobal_position = _initial_position\n\trotation = 0.0\n\t_current_patrol_index = 0\n\t_is_waiting_at_patrol_point = false\n\t_patrol_wait_timer = 0.0\n\t_current_state = AIState.IDLE\n\t_has_valid_cover = false\n\t_under_fire = false\n\t_suppression_timer = 0.0\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t_continuous_visibility_timer = 0.0\n\t_player_visibility_ratio = 0.0\n\t_threat_reaction_timer = 0.0\n\t_threat_reaction_delay_elapsed = false\n\t_threat_memory_timer = 0.0\n\t_bullets_in_threat_sphere.clear()\n\t# Reset retreat state variables\n\t_hits_taken_in_encounter = 0\n\t_retreat_mode = RetreatMode.FULL_HP\n\t_retreat_turn_timer = 0.0\n\t_retreat_turning_to_cover = false\n\t_retreat_burst_remaining = 0\n\t_retreat_burst_timer = 0.0\n\t_retreat_burst_complete = false\n\t_retreat_burst_angle_offset = 0.0\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\t# Reset combat state variables\n\t_combat_shoot_timer = 0.0\n\t_combat_shoot_duration = 2.5\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_approach_timer = 0.0\n\t# Reset pursuit state variables\n\t_pursuit_cover_wait_timer = 0.0\n\t_pursuit_next_cover = Vector2.ZERO\n\t_has_pursuit_cover = false\n\t# Reset assault state variables\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset flank state variables\n\t_flank_cover_wait_timer = 0.0\n\t_flank_next_cover = Vector2.ZERO\n\t_has_flank_cover = false\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_initialize_goap_state()\n\n\n## Log debug message if debug_logging is enabled.\nfunc _log_debug(message: String) -> void:\n\tif debug_logging:\n\t\tprint(\"[Enemy %s] %s\" % [name, message])\n\n\n## Log a message to the file logger (always logs, regardless of debug_logging setting).\n## Use for important events like spawning, dying, or critical state changes.\nfunc _log_to_file(message: String) -> void:\n\tif not is_inside_tree():\n\t\treturn\n\tvar file_logger: Node = get_node_or_null(\"/root/FileLogger\")\n\tif file_logger and file_logger.has_method(\"log_enemy\"):\n\t\tfile_logger.log_enemy(name, message)\n\n\n## Log spawn info (called via call_deferred to ensure FileLogger is loaded).\nfunc _log_spawn_info() -> void:\n\t_log_to_file(\"Enemy spawned at %s, health: %d, behavior: %s, player_found: %s\" % [\n\t\tglobal_position, _max_health, BehaviorMode.keys()[behavior_mode],\n\t\t\"yes\" if _player != null else \"no\"])\n\n\n## Get AI state name as a human-readable string.\nfunc _get_state_name(state: AIState) -> String:\n\tmatch state:\n\t\tAIState.IDLE:\n\t\t\treturn \"IDLE\"\n\t\tAIState.COMBAT:\n\t\t\treturn \"COMBAT\"\n\t\tAIState.SEEKING_COVER:\n\t\t\treturn \"SEEKING_COVER\"\n\t\tAIState.IN_COVER:\n\t\t\treturn \"IN_COVER\"\n\t\tAIState.FLANKING:\n\t\t\treturn \"FLANKING\"\n\t\tAIState.SUPPRESSED:\n\t\t\treturn \"SUPPRESSED\"\n\t\tAIState.RETREATING:\n\t\t\treturn \"RETREATING\"\n\t\tAIState.PURSUING:\n\t\t\treturn \"PURSUING\"\n\t\tAIState.ASSAULT:\n\t\t\treturn \"ASSAULT\"\n\t\t_:\n\t\t\treturn \"UNKNOWN\"\n\n\n## Update the debug label with current AI state.\nfunc _update_debug_label() -> void:\n\tif _debug_label == null:\n\t\treturn\n\n\t_debug_label.visible = debug_label_enabled\n\tif not debug_label_enabled:\n\t\treturn\n\n\tvar state_text := _get_state_name(_current_state)\n\n\t# Add retreat mode info if retreating\n\tif _current_state == AIState.RETREATING:\n\t\tmatch _retreat_mode:\n\t\t\tRetreatMode.FULL_HP:\n\t\t\t\tstate_text += \"\\n(FULL_HP)\"\n\t\t\tRetreatMode.ONE_HIT:\n\t\t\t\tstate_text += \"\\n(ONE_HIT)\"\n\t\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t\tstate_text += \"\\n(MULTI_HITS)\"\n\n\t# Add assault timer info if in assault state\n\tif _current_state == AIState.ASSAULT:\n\t\tif _assault_ready:\n\t\t\tstate_text += \"\\n(RUSHING)\"\n\t\telse:\n\t\t\tvar time_left := ASSAULT_WAIT_DURATION - _assault_wait_timer\n\t\t\tstate_text += \"\\n(%.1fs)\" % time_left\n\n\t# Add combat phase info if in combat\n\tif _current_state == AIState.COMBAT:\n\t\tif _combat_exposed:\n\t\t\tvar time_left := _combat_shoot_duration - _combat_shoot_timer\n\t\t\tstate_text += \"\\n(EXPOSED %.1fs)\" % time_left\n\t\telif _seeking_clear_shot:\n\t\t\tvar time_left := CLEAR_SHOT_MAX_TIME - _clear_shot_timer\n\t\t\tstate_text += \"\\n(SEEK SHOT %.1fs)\" % time_left\n\t\telif _combat_approaching:\n\t\t\tstate_text += \"\\n(APPROACH)\"\n\n\t# Add pursuit timer info if pursuing and waiting at cover\n\tif _current_state == AIState.PURSUING:\n\t\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t\tvar time_left := PURSUIT_COVER_WAIT_DURATION - _pursuit_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_pursuit_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\n\t# Add flanking phase info if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_valid_cover and not _has_flank_cover:\n\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_flank_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\t\telse:\n\t\t\tstate_text += \"\\n(DIRECT)\"\n\n\t_debug_label.text = state_text\n\n\n## Get current AI state (for external access/debugging).\nfunc get_current_state() -> AIState:\n\treturn _current_state\n\n\n## Get GOAP world state (for GOAP planner).\nfunc get_goap_world_state() -> Dictionary:\n\treturn _goap_world_state.duplicate()\n\n\n## Check if enemy is currently under fire.\nfunc is_under_fire() -> bool:\n\treturn _under_fire\n\n\n## Check if enemy is in cover.\nfunc is_in_cover() -> bool:\n\treturn _current_state == AIState.IN_COVER or _current_state == AIState.SUPPRESSED\n\n\n## Get current ammo in magazine.\nfunc get_current_ammo() -> int:\n\treturn _current_ammo\n\n\n## Get reserve ammo.\nfunc get_reserve_ammo() -> int:\n\treturn _reserve_ammo\n\n\n## Get total ammo (current + reserve).\nfunc get_total_ammo() -> int:\n\treturn _current_ammo + _reserve_ammo\n\n\n## Check if enemy is currently reloading.\nfunc is_reloading() -> bool:\n\treturn _is_reloading\n\n\n## Check if enemy has any ammo left.\nfunc has_ammo() -> bool:\n\treturn _current_ammo > 0 or _reserve_ammo > 0\n\n\n## Get current player visibility ratio (for debugging).\n## Returns 0.0 if player is completely hidden, 1.0 if fully visible.\nfunc get_player_visibility_ratio() -> float:\n\treturn _player_visibility_ratio\n\n\n## Draw debug visualization when debug mode is enabled.\n## Shows: line to target (cover, clear shot, player), bullet spawn point status.\nfunc _draw() -> void:\n\tif not debug_label_enabled:\n\t\treturn\n\n\t# Colors for different debug elements\n\tvar color_to_cover := Color.CYAN  # Line to cover position\n\tvar color_to_player := Color.RED  # Line to player (when visible)\n\tvar color_clear_shot := Color.YELLOW  # Line to clear shot target\n\tvar color_pursuit := Color.ORANGE  # Line to pursuit cover\n\tvar color_flank := Color.MAGENTA  # Line to flank position\n\tvar color_bullet_spawn := Color.GREEN  # Bullet spawn point indicator\n\tvar color_blocked := Color.RED  # Blocked path indicator\n\n\t# Draw line to player if visible\n\tif _can_see_player and _player:\n\t\tvar to_player := _player.global_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_player, color_to_player, 1.5)\n\n\t\t# Draw bullet spawn point and check if blocked\n\t\tvar direction_to_player := to_player.normalized()\n\t\tvar spawn_point := direction_to_player * bullet_spawn_offset\n\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\tdraw_circle(spawn_point, 5.0, color_bullet_spawn)\n\t\telse:\n\t\t\t# Draw X for blocked spawn point\n\t\t\tdraw_line(spawn_point + Vector2(-5, -5), spawn_point + Vector2(5, 5), color_blocked, 2.0)\n\t\t\tdraw_line(spawn_point + Vector2(-5, 5), spawn_point + Vector2(5, -5), color_blocked, 2.0)\n\n\t# Draw line to cover position if we have one\n\tif _has_valid_cover:\n\t\tvar to_cover := _cover_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_cover, color_to_cover, 1.5)\n\t\t# Draw small circle at cover position\n\t\tdraw_circle(to_cover, 8.0, color_to_cover)\n\n\t# Draw line to clear shot target if seeking clear shot\n\tif _seeking_clear_shot and _clear_shot_target != Vector2.ZERO:\n\t\tvar to_target := _clear_shot_target - global_position\n\t\tdraw_line(Vector2.ZERO, to_target, color_clear_shot, 2.0)\n\t\t# Draw triangle at target position\n\t\tvar target_pos := to_target\n\t\tdraw_line(target_pos + Vector2(-6, 6), target_pos + Vector2(6, 6), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(6, 6), target_pos + Vector2(0, -8), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(0, -8), target_pos + Vector2(-6, 6), color_clear_shot, 2.0)\n\n\t# Draw line to pursuit cover if pursuing\n\tif _current_state == AIState.PURSUING and _has_pursuit_cover:\n\t\tvar to_pursuit := _pursuit_next_cover - global_position\n\t\tdraw_line(Vector2.ZERO, to_pursuit, color_pursuit, 2.0)\n\t\tdraw_circle(to_pursuit, 8.0, color_pursuit)\n\n\t# Draw line to flank target if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_flank_cover:\n\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n\t\telif _flank_target != Vector2.ZERO:\n\t\t\tvar to_flank := _flank_target - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n\t\t\t# Draw diamond at flank target\n\t\t\tvar flank_pos := to_flank\n\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)\n","structuredPatch":[{"oldStart":1887,"oldLines":6,"newStart":1887,"newLines":180,"lines":["   _find_cover_position()"," "," ","+## Transition to SEARCHING state.","+## Activates the search zone and generates inspection points.","+func _transition_to_searching() -> void:","+  _current_state = AIState.SEARCHING","+  _search_timer = 0.0","+  _inspection_wait_timer = 0.0","+  _inspecting_point = false","+  _current_inspection_index = 0","+","+  # Activate search zone at last known player position","+  if _last_known_player_position != Vector2.ZERO:","+    _search_zone_active = true","+    _log_debug(\"Activating search zone at %s (radius: %.1f)\" % [_last_known_player_position, SEARCH_ZONE_RADIUS])","+    # Generate inspection points within the search zone","+    _generate_inspection_points()","+  else:","+    # No last known position - fall back to pursuing","+    _log_debug(\"No last known position, falling back to PURSUING\")","+    _transition_to_pursuing()","+","+","+## Clear the search zone when player is found or search is complete.","+func _clear_search_zone() -> void:","+  _search_zone_active = false","+  _inspection_points.clear()","+  _current_inspection_index = 0","+  _inspecting_point = false","+  _log_debug(\"Search zone cleared\")","+","+","+## Generate inspection points within the search zone.","+## Finds hiding spots behind covers and at corners within the search area.","+func _generate_inspection_points() -> void:","+  _inspection_points.clear()","+","+  if _last_known_player_position == Vector2.ZERO:","+    return","+","+  var search_center := _last_known_player_position","+","+  # Use raycasts from the search center to find obstacles and generate inspection points","+  for i in range(INSPECTION_POINT_CHECK_COUNT):","+    var angle := (float(i) / INSPECTION_POINT_CHECK_COUNT) * TAU","+    var direction := Vector2.from_angle(angle)","+","+    # Cast ray from search center outward to find obstacles","+    var space_state := get_world_2d().direct_space_state","+    var query := PhysicsRayQueryParameters2D.new()","+    query.from = search_center","+    query.to = search_center + direction * INSPECTION_CHECK_DISTANCE","+    query.collision_mask = 4  # Only check obstacles (layer 3)","+","+    var result := space_state.intersect_ray(query)","+","+    if not result.is_empty():","+      var collision_point: Vector2 = result[\"position\"]","+      var collision_normal: Vector2 = result[\"normal\"]","+","+      # Generate inspection point behind the obstacle (from enemy's perspective)","+      # This is where a player might hide","+      var inspection_pos := collision_point + collision_normal * 40.0","+","+      # Only add if within search zone radius","+      if inspection_pos.distance_to(search_center) <= SEARCH_ZONE_RADIUS:","+        # Avoid duplicate or too-close points","+        var is_duplicate := false","+        for existing_point in _inspection_points:","+          if inspection_pos.distance_to(existing_point) < 50.0:","+            is_duplicate = true","+            break","+        if not is_duplicate:","+          _inspection_points.append(inspection_pos)","+","+  # Add corners of the search zone as additional inspection points","+  var corner_offsets := [","+    Vector2(SEARCH_ZONE_RADIUS * 0.7, SEARCH_ZONE_RADIUS * 0.7),","+    Vector2(-SEARCH_ZONE_RADIUS * 0.7, SEARCH_ZONE_RADIUS * 0.7),","+    Vector2(SEARCH_ZONE_RADIUS * 0.7, -SEARCH_ZONE_RADIUS * 0.7),","+    Vector2(-SEARCH_ZONE_RADIUS * 0.7, -SEARCH_ZONE_RADIUS * 0.7),","+  ]","+","+  for offset in corner_offsets:","+    var corner_point := search_center + offset","+    # Only add corner if we can reach it (no obstacle blocking direct path)","+    if _has_clear_path_to(corner_point):","+      var is_duplicate := false","+      for existing_point in _inspection_points:","+        if corner_point.distance_to(existing_point) < 50.0:","+          is_duplicate = true","+          break","+      if not is_duplicate:","+        _inspection_points.append(corner_point)","+","+  # Sort inspection points by distance from current position (closest first)","+  _inspection_points.sort_custom(func(a: Vector2, b: Vector2) -> bool:","+    return global_position.distance_to(a) < global_position.distance_to(b)","+  )","+","+  _log_debug(\"Generated %d inspection points in search zone\" % _inspection_points.size())","+","+","+## Process SEARCHING state - investigate last-known player position and check hiding spots.","+## Enemy moves to last-known position, then checks each inspection point within the search zone.","+## Returns to IDLE when all points are checked or timeout expires.","+func _process_searching_state(delta: float) -> void:","+  # If player is spotted during search, immediately transition to combat","+  if _can_see_player:","+    _log_debug(\"Player found during search, transitioning to COMBAT\")","+    _clear_search_zone()","+    _transition_to_combat()","+    return","+","+  # Check for suppression - if under fire, need to take cover","+  if _under_fire and enable_cover:","+    _log_debug(\"Under fire during search, transitioning to RETREATING\")","+    _clear_search_zone()","+    _transition_to_retreating()","+    return","+","+  # Update search timer","+  _search_timer += delta","+","+  # Timeout - give up searching and return to patrol/guard","+  if _search_timer >= SEARCH_MAX_DURATION:","+    _log_debug(\"Search timeout reached, returning to IDLE\")","+    _clear_search_zone()","+    _transition_to_idle()","+    return","+","+  # If no inspection points left, search is complete","+  if _inspection_points.is_empty() or _current_inspection_index >= _inspection_points.size():","+    _log_debug(\"All inspection points checked, search zone cleared\")","+    _clear_search_zone()","+    _transition_to_idle()","+    return","+","+  # Get current inspection point target","+  var current_target := _inspection_points[_current_inspection_index]","+  var distance_to_target := global_position.distance_to(current_target)","+","+  # Check if we're at the current inspection point","+  if distance_to_target < 20.0:","+    if not _inspecting_point:","+      # Just arrived at inspection point - start looking around","+      _inspecting_point = true","+      _inspection_wait_timer = 0.0","+      _log_debug(\"Inspecting point %d/%d at %s\" % [_current_inspection_index + 1, _inspection_points.size(), current_target])","+","+    # Wait at the inspection point, looking around","+    _inspection_wait_timer += delta","+    velocity = Vector2.ZERO","+","+    # Rotate while inspecting (looking around)","+    rotation += rotation_speed * delta * 0.5","+","+    if _inspection_wait_timer >= INSPECTION_WAIT_DURATION:","+      # Done inspecting this point, move to next","+      _current_inspection_index += 1","+      _inspecting_point = false","+      _inspection_wait_timer = 0.0","+    return","+","+  # Move toward current inspection point","+  var direction := (current_target - global_position).normalized()","+","+  # Apply wall avoidance","+  var avoidance := _check_wall_ahead(direction)","+  if avoidance != Vector2.ZERO:","+    direction = (direction * 0.5 + avoidance * 0.5).normalized()","+","+  velocity = direction * combat_move_speed * 0.8  # Slightly slower when searching","+  rotation = direction.angle()","+","+"," ## Check if the enemy is visible from the player's position."," ## Uses raycasting from player to enemy to determine if there are obstacles blocking line of sight."," ## This is the inverse of _can_see_player - it checks if the PLAYER can see the ENEMY."]}],"userModified":false,"replaceAll":false}}
[2026-01-18T02:53:46.311Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01DL74zqU4ac4pUNUGQHdBiA",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me update the `_get_state_name` function to include SEARCHING:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 5077,
      "cache_read_input_tokens": 90432,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 5077,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 3,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "ae4e67b3-58ea-443b-a435-2f0d9e151b1d"
}
[2026-01-18T02:53:50.502Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01DL74zqU4ac4pUNUGQHdBiA",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_017ojXXJenYbu9KkFx1qzzcQ",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "old_string": "## Get AI state name as a human-readable string.\nfunc _get_state_name(state: AIState) -> String:\n\tmatch state:\n\t\tAIState.IDLE:\n\t\t\treturn \"IDLE\"\n\t\tAIState.COMBAT:\n\t\t\treturn \"COMBAT\"\n\t\tAIState.SEEKING_COVER:\n\t\t\treturn \"SEEKING_COVER\"\n\t\tAIState.IN_COVER:\n\t\t\treturn \"IN_COVER\"\n\t\tAIState.FLANKING:\n\t\t\treturn \"FLANKING\"\n\t\tAIState.SUPPRESSED:\n\t\t\treturn \"SUPPRESSED\"\n\t\tAIState.RETREATING:\n\t\t\treturn \"RETREATING\"\n\t\tAIState.PURSUING:\n\t\t\treturn \"PURSUING\"\n\t\tAIState.ASSAULT:\n\t\t\treturn \"ASSAULT\"\n\t\t_:\n\t\t\treturn \"UNKNOWN\"",
          "new_string": "## Get AI state name as a human-readable string.\nfunc _get_state_name(state: AIState) -> String:\n\tmatch state:\n\t\tAIState.IDLE:\n\t\t\treturn \"IDLE\"\n\t\tAIState.COMBAT:\n\t\t\treturn \"COMBAT\"\n\t\tAIState.SEEKING_COVER:\n\t\t\treturn \"SEEKING_COVER\"\n\t\tAIState.IN_COVER:\n\t\t\treturn \"IN_COVER\"\n\t\tAIState.FLANKING:\n\t\t\treturn \"FLANKING\"\n\t\tAIState.SUPPRESSED:\n\t\t\treturn \"SUPPRESSED\"\n\t\tAIState.RETREATING:\n\t\t\treturn \"RETREATING\"\n\t\tAIState.PURSUING:\n\t\t\treturn \"PURSUING\"\n\t\tAIState.ASSAULT:\n\t\t\treturn \"ASSAULT\"\n\t\tAIState.SEARCHING:\n\t\t\treturn \"SEARCHING\"\n\t\t_:\n\t\t\treturn \"UNKNOWN\""
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 5077,
      "cache_read_input_tokens": 90432,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 5077,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 3,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "b8ad5a83-1010-4a62-886a-dc6fa9bfa55e"
}
[2026-01-18T02:53:50.534Z] [INFO] {"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017ojXXJenYbu9KkFx1qzzcQ","type":"tool_result","content":"The file /tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  3227‚Üí\t\tglobal_position, _max_health, BehaviorMode.keys()[behavior_mode],\n  3228‚Üí\t\t\"yes\" if _player != null else \"no\"])\n  3229‚Üí\n  3230‚Üí\n  3231‚Üí## Get AI state name as a human-readable string.\n  3232‚Üífunc _get_state_name(state: AIState) -> String:\n  3233‚Üí\tmatch state:\n  3234‚Üí\t\tAIState.IDLE:\n  3235‚Üí\t\t\treturn \"IDLE\"\n  3236‚Üí\t\tAIState.COMBAT:\n  3237‚Üí\t\t\treturn \"COMBAT\"\n  3238‚Üí\t\tAIState.SEEKING_COVER:\n  3239‚Üí\t\t\treturn \"SEEKING_COVER\"\n  3240‚Üí\t\tAIState.IN_COVER:\n  3241‚Üí\t\t\treturn \"IN_COVER\"\n  3242‚Üí\t\tAIState.FLANKING:\n  3243‚Üí\t\t\treturn \"FLANKING\"\n  3244‚Üí\t\tAIState.SUPPRESSED:\n  3245‚Üí\t\t\treturn \"SUPPRESSED\"\n  3246‚Üí\t\tAIState.RETREATING:\n  3247‚Üí\t\t\treturn \"RETREATING\"\n  3248‚Üí\t\tAIState.PURSUING:\n  3249‚Üí\t\t\treturn \"PURSUING\"\n  3250‚Üí\t\tAIState.ASSAULT:\n  3251‚Üí\t\t\treturn \"ASSAULT\"\n  3252‚Üí\t\tAIState.SEARCHING:\n  3253‚Üí\t\t\treturn \"SEARCHING\"\n  3254‚Üí\t\t_:\n  3255‚Üí\t\t\treturn \"UNKNOWN\"\n  3256‚Üí\n  3257‚Üí\n  3258‚Üí## Update the debug label with current AI state.\n  3259‚Üífunc _update_debug_label() -> void:"}]},"parent_tool_use_id":null,"session_id":"797fbac8-f5e6-4339-8fd2-77453410db49","uuid":"0f0f3f16-23a5-40a3-9d31-0a25e32bceba","tool_use_result":{"filePath":"/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd","oldString":"## Get AI state name as a human-readable string.\nfunc _get_state_name(state: AIState) -> String:\n\tmatch state:\n\t\tAIState.IDLE:\n\t\t\treturn \"IDLE\"\n\t\tAIState.COMBAT:\n\t\t\treturn \"COMBAT\"\n\t\tAIState.SEEKING_COVER:\n\t\t\treturn \"SEEKING_COVER\"\n\t\tAIState.IN_COVER:\n\t\t\treturn \"IN_COVER\"\n\t\tAIState.FLANKING:\n\t\t\treturn \"FLANKING\"\n\t\tAIState.SUPPRESSED:\n\t\t\treturn \"SUPPRESSED\"\n\t\tAIState.RETREATING:\n\t\t\treturn \"RETREATING\"\n\t\tAIState.PURSUING:\n\t\t\treturn \"PURSUING\"\n\t\tAIState.ASSAULT:\n\t\t\treturn \"ASSAULT\"\n\t\t_:\n\t\t\treturn \"UNKNOWN\"","newString":"## Get AI state name as a human-readable string.\nfunc _get_state_name(state: AIState) -> String:\n\tmatch state:\n\t\tAIState.IDLE:\n\t\t\treturn \"IDLE\"\n\t\tAIState.COMBAT:\n\t\t\treturn \"COMBAT\"\n\t\tAIState.SEEKING_COVER:\n\t\t\treturn \"SEEKING_COVER\"\n\t\tAIState.IN_COVER:\n\t\t\treturn \"IN_COVER\"\n\t\tAIState.FLANKING:\n\t\t\treturn \"FLANKING\"\n\t\tAIState.SUPPRESSED:\n\t\t\treturn \"SUPPRESSED\"\n\t\tAIState.RETREATING:\n\t\t\treturn \"RETREATING\"\n\t\tAIState.PURSUING:\n\t\t\treturn \"PURSUING\"\n\t\tAIState.ASSAULT:\n\t\t\treturn \"ASSAULT\"\n\t\tAIState.SEARCHING:\n\t\t\treturn \"SEARCHING\"\n\t\t_:\n\t\t\treturn \"UNKNOWN\"","originalFile":"extends CharacterBody2D\n## Enemy AI with tactical behaviors including patrol, guard, cover, and flanking.\n##\n## Supports multiple behavior modes:\n## - PATROL: Moves between patrol points\n## - GUARD: Stands in place watching for the player\n##\n## Tactical features:\n## - Uses cover when under fire (suppression)\n## - Attempts to flank the player from the sides\n## - Coordinates with other enemies (optional)\n## - GOAP foundation for goal-oriented planning\n\n## AI States for tactical behavior.\nenum AIState {\n\tIDLE,       ## Default idle state (patrol or guard)\n\tCOMBAT,     ## Actively engaging the player (coming out of cover, shooting 2-3s, returning)\n\tSEEKING_COVER,  ## Moving to cover position\n\tIN_COVER,   ## Taking cover from player fire\n\tFLANKING,   ## Attempting to flank the player\n\tSUPPRESSED, ## Under fire, staying in cover\n\tRETREATING, ## Retreating to cover while possibly shooting\n\tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n\tASSAULT,    ## Coordinated multi-enemy assault (rush player after 5s wait)\n\tSEARCHING 
[2026-01-18T02:53:50.536Z] [INFO]   ## Searching for player at last-known-position zone\n}\n\n## Retreat behavior modes based on damage taken.\nenum RetreatMode {\n\tFULL_HP,        ## No damage - retreat backwards while shooting, periodically turn to cover\n\tONE_HIT,        ## One hit taken - quick burst then retreat without shooting\n\tMULTIPLE_HITS   ## Multiple hits - quick burst then retreat without shooting (same as ONE_HIT)\n}\n\n## Behavior modes for the enemy.\nenum BehaviorMode {\n\tPATROL,  ## Moves between patrol points\n\tGUARD    ## Stands in one place\n}\n\n## Current behavior mode.\n@export var behavior_mode: BehaviorMode = BehaviorMode.GUARD\n\n## Maximum movement speed in pixels per second.\n@export var move_speed: float = 220.0\n\n## Combat movement speed (faster when flanking/seeking cover).\n@export var combat_move_speed: float = 320.0\n\n## Rotation speed in radians per second for gradual turning.\n## Default is 15 rad/sec for challenging but fair combat.\n@export var rotation_speed: float = 15.0\n\n## Detection range for spotting the player.\n## Set to 0 or negative to allow unlimited detection range (line-of-sight only).\n## This allows enemies to see the player even outside the viewport if no obstacles block view.\n@export var detection_range: float = 0.0\n\n## Time between shots in seconds.\n## Default matches assault rifle fire rate (10 shots/second = 0.1s cooldown).\n@export var shoot_cooldown: float = 0.1\n\n## Bullet scene to instantiate when shooting.\n@export var bullet_scene: PackedScene\n\n## Offset from enemy center for bullet spawn position.\n@export var bullet_spawn_offset: float = 30.0\n\n## Patrol points as offsets from the initial position.\n## Only used when behavior_mode is PATROL.\n@export var patrol_offsets: Array[Vector2] = [Vector2(100, 0), Vector2(-100, 0)]\n\n## Wait time at each patrol point in seconds.\n@export var patrol_wait_time: float = 1.5\n\n## Color when at full health.\n@export var full_health_color: Color = Color(0.9, 0.2, 0.2, 1.0)\n\n## Color when at low health (interpolates based on health percentage).\n@export var low_health_color: Color = Color(0.3, 0.1, 0.1, 1.0)\n\n## Color to flash when hit.\n@export var hit_flash_color: Color = Color(1.0, 1.0, 1.0, 1.0)\n\n## Duration of hit flash effect in seconds.\n@export var hit_flash_duration: float = 0.1\n\n## Whether to destroy the enemy after death.\n@export var destroy_on_death: bool = false\n\n## Delay before respawning or destroying (in seconds).\n@export var respawn_delay: float = 2.0\n\n## Minimum random health.\n@export var min_health: int = 2\n\n## Maximum random health.\n@export var max_health: int = 4\n\n## Threat sphere radius - bullets within this radius trigger suppression.\n@export var threat_sphere_radius: float = 100.0\n\n## Time to stay suppressed after bullets leave threat sphere.\n@export var suppression_cooldown: float = 2.0\n\n## Delay (in seconds) before reacting to bullets in the threat sphere.\n## This prevents instant reactions to nearby gunfire, giving the player more time.\n@export var threat_reaction_delay: float = 0.2\n\n## Flank angle from player's facing direction (radians).\n@export var flank_angle: float = PI / 3.0  # 60 degrees\n\n## Distance to maintain while flanking.\n@export var flank_distance: float = 200.0\n\n## Enable/disable flanking behavior.\n@export var enable_flanking: bool = true\n\n## Enable/disable cover behavior.\n@export var enable_cover: bool = true\n\n## Enable/disable debug logging.\n@export var debug_logging: bool = false\n\n## Enable/disable debug label above enemy showing current AI state.\n@export var debug_label_enabled: bool = false\n\n## Enable/disable friendly fire avoidance (don't shoot if other enemies are in the way).\n@export var enable_friendly_fire_avoidance: bool = true\n\n## Enable/disable lead prediction (shooting ahead of moving targets).\n@export var enable_lead_prediction: bool = true\n\n## Bullet speed for lead prediction calculation.\n## Should match the actual bullet speed (default is 2500 for assault rifle).\n@export var bullet_speed: float = 2500.0\n\n## Ammunition system - magazine size (bullets per magazine).\n@export var magazine_size: int = 30\n\n## Ammunition system - number of magazines the enemy carries.\n@export var total_magazines: int = 5\n\n## Ammunition system - time to reload in seconds.\n@export var reload_time: float = 3.0\n\n## Delay (in seconds) between spotting player and starting to shoot.\n## Gives player a brief reaction time when entering enemy line of sight.\n## This delay \"recharges\" each time the player breaks direct contact with the enemy.\n@export var detection_delay: float = 0.2\n\n## Minimum time (in seconds) the player must be continuously visible before\n## lead prediction is enabled. This prevents enemies from predicting player\n## position immediately when they emerge from cover.\n@export var lead_prediction_delay: float = 0.3\n\n## Minimum visibility ratio (0.0 to 1.0) of player body that must be visible\n## before lead prediction is enabled. At 1.0, the player's entire body must be\n## visible. At 0.5, at least half of the check points must be visible.\n## This prevents pre-firing at players who are at cover edges.\n@export var lead_prediction_visibility_threshold: float = 0.6\n\n## Signal emitted when the enemy is hit.\nsignal hit\n\n## Signal emitted when the enemy dies.\nsignal died\n\n## Signal emitted when AI state changes.\nsignal state_changed(new_state: AIState)\n\n## Signal emitted when ammunition changes.\nsignal ammo_changed(current_ammo: int, reserve_ammo: int)\n\n## Signal emitted when reloading starts.\nsignal reload_started\n\n## Signal emitted when reloading finishes.\nsignal reload_finished\n\n## Signal emitted when all ammunition is depleted.\nsignal ammo_depleted\n\n## Reference to the sprite for color changes.\n@onready var _sprite: Sprite2D = $Sprite2D\n\n## RayCast2D for line of sight detection.\n@onready var _raycast: RayCast2D = $RayCast2D\n\n## Debug label for showing current AI state above the enemy.\n@onready var _debug_label: Label = $DebugLabel\n\n## Wall detection raycasts for obstacle avoidance (created at runtime).\nvar _wall_raycasts: Array[RayCast2D] = []\n\n## Distance to check for walls ahead.\nconst WALL_CHECK_DISTANCE: float = 40.0\n\n## Number of raycasts for wall detection (spread around the enemy).\nconst WALL_CHECK_COUNT: int = 3\n\n## Cover detection raycasts (created at runtime).\nvar _cover_raycasts: Array[RayCast2D] = []\n\n## Number of raycasts for cover detection.\nconst COVER_CHECK_COUNT: int = 16\n\n## Distance to check for cover.\nconst COVER_CHECK_DISTANCE: float = 300.0\n\n## Current health of the enemy.\nvar _current_health: int = 0\n\n## Maximum health of the enemy (set at spawn).\nvar _max_health: int = 0\n\n## Whether the enemy is alive.\nvar _is_alive: bool = true\n\n## Reference to the player (found at runtime).\nvar _player: Node2D = null\n\n## Time since last shot.\nvar _shoot_timer: float = 0.0\n\n## Current ammo in the magazine.\nvar _current_ammo: int = 0\n\n## Reserve ammo (ammo in remaining magazines).\nvar _reserve_ammo: int = 0\n\n## Whether the enemy is currently reloading.\nvar _is_reloading: bool = false\n\n## Timer for reload progress.\nvar _reload_timer: float = 0.0\n\n## Patrol state variables.\nvar _patrol_points: Array[Vector2] = []\nvar _current_patrol_index: int = 0\nvar _is_waiting_at_patrol_point: bool = false\nvar _patrol_wait_timer: float = 0.0\nvar _initial_position: Vector2\n\n## Whether the enemy can currently see the player.\nvar _can_see_player: bool = false\n\n## Current AI state.\nvar _current_state: AIState = AIState.IDLE\n\n## Current cover position (if any).\nvar _cover_position: Vector2 = Vector2.ZERO\n\n## Is currently in a valid cover position.\nvar _has_valid_cover: bool = false\n\n## Timer for suppression cooldown.\nvar _suppression_timer: float = 0.0\n\n## Whether enemy is currently under fire (bullets in threat sphere).\nvar _under_fire: bool = false\n\n## Flank target position.\nvar _flank_target: Vector2 = Vector2.ZERO\n\n## Threat sphere Area2D for detecting nearby bullets.\nvar _threat_sphere: Area2D = null\n\n## Bullets currently in threat sphere.\nvar _bullets_in_threat_sphere: Array = []\n\n## Timer for threat reaction delay - time since first bullet entered threat sphere.\nvar _threat_reaction_timer: float = 0.0\n\n## Whether the threat reaction delay has elapsed (enemy can react to bullets).\nvar _threat_reaction_delay_elapsed: bool = false\n\n## Memory of bullets that have passed through the threat sphere recently.\n## This allows the enemy to react even after fast-moving bullets have exited.\nvar _threat_memory_timer: float = 0.0\n\n## Duration to remember that a bullet passed through the threat sphere.\n## This should be longer than the reaction delay to ensure enemies can complete\n## their reaction even after bullets have passed through quickly.\nconst THREAT_MEMORY_DURATION: float = 0.5\n\n## Current retreat mode determined by damage taken.\nvar _retreat_mode: RetreatMode = RetreatMode.FULL_HP\n\n## Number of hits taken during the current retreat/combat encounter.\n## Resets when enemy enters IDLE state or finishes retreating.\nvar _hits_taken_in_encounter: int = 0\n\n## Timer for periodic turning to cover during FULL_HP retreat.\nvar _retreat_turn_timer: float = 0.0\n\n## Duration to face cover during FULL_HP retreat turn (seconds).\nconst RETREAT_TURN_DURATION: float = 0.8\n\n## Interval between turns toward cover in FULL_HP retreat (seconds).\nconst RETREAT_TURN_INTERVAL: float = 1.5\n\n## Whether currently in the \"turn to cover\" phase of FULL_HP retreat.\nvar _retreat_turning_to_cover: bool = false\n\n## Burst fire counter for ONE_HIT retreat mode.\nvar _retreat_burst_remaining: int = 0\n\n## Timer for burst fire cooldown in ONE_HIT retreat.\nvar _retreat_burst_timer: float = 0.0\n\n## Fast cooldown between burst shots (seconds).\nconst RETREAT_BURST_COOLDOWN: float = 0.06\n\n## Whether burst fire phase is complete in ONE_HIT retreat.\nvar _retreat_burst_complete: bool = false\n\n## Accuracy reduction during retreat (multiplier for inaccuracy angle spread).\nconst RETREAT_INACCURACY_SPREAD: float = 0.15\n\n## Arc spread for ONE_HIT burst fire (radians, total spread).\nconst RETREAT_BURST_ARC: float = 0.4\n\n## Current angle offset within burst arc.\nvar _retreat_burst_angle_offset: float = 0.0\n\n## Whether enemy is in \"alarm\" mode (was suppressed/retreating and hasn't calmed down).\n## This persists until the enemy reaches safety in cover or returns to idle.\nvar _in_alarm_mode: bool = false\n\n## Whether the enemy needs to fire a cover burst (when leaving cover while in alarm).\nvar _cover_burst_pending: bool = false\n\n## --- Combat Cover Cycling (come out, shoot 2-3s, go back) ---\n## Timer for how long the enemy has been shooting while out of cover.\nvar _combat_shoot_timer: float = 0.0\n\n## Duration to shoot while out of cover (2-3 seconds, randomized).\nvar _combat_shoot_duration: float = 2.5\n\n## Whether the enemy is currently in the \"exposed shooting\" phase of combat.\nvar _combat_exposed: bool = false\n\n## Whether the enemy is in the \"approaching player\" phase of combat.\n## In this phase, the enemy moves toward the player to get into direct contact.\nvar _combat_approaching: bool = false\n\n## Timer for the approach phase of combat.\nvar _combat_approach_timer: float = 0.0\n\n## Maximum time to spend approaching player before starting to shoot (seconds).\nconst COMBAT_APPROACH_MAX_TIME: float = 2.0\n\n## Distance at which enemy is considered \"close enough\" to start shooting phase.\nconst COMBAT_DIRECT_CONTACT_DISTANCE: float = 250.0\n\n## --- Pursuit State (cover-to-cover movement) ---\n## Timer for waiting at cover during pursuit.\nvar _pursuit_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during pursuit (1-2 seconds, reduced for faster pursuit).\nconst PURSUIT_COVER_WAIT_DURATION: float = 1.5\n\n## Current pursuit target cover position.\nvar _pursuit_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid pursuit cover target.\nvar _has_pursuit_cover: bool = false\n\n## --- Flanking State (cover-to-cover movement toward flank target) ---\n## Timer for waiting at cover during flanking.\nvar _flank_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during flanking (seconds).\nconst FLANK_COVER_WAIT_DURATION: float = 0.8\n\n## Current flank cover position to move to.\nvar _flank_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid flank cover target.\nvar _has_flank_cover: bool = false\n\n## --- Assault State (coordinated multi-enemy rush) ---\n## Timer for assault wait period (5 seconds before rushing).\nvar _assault_wait_timer: float = 0.0\n\n## Duration to wait at cover before assault (5 seconds).\nconst ASSAULT_WAIT_DURATION: float = 5.0\n\n## Whether the assault wait period is complete.\nvar _assault_ready: bool = false\n\n## Whether this enemy is currently participating in an assault.\nvar _in_assault: bool = false\n\n## Distance threshold for \"close\" vs \"far\" from player.\n## Used to determine if enemy can engage from current position or needs to pursue.\nconst CLOSE_COMBAT_DISTANCE: float = 400.0\n\n## GOAP world state for goal-oriented planning.\nvar _goap_world_state: Dictionary = {}\n\n## --- Search/Investigation State (for when player escapes from view) ---\n## Last known position where the player was seen before escaping view.\nvar _last_known_player_position: Vector2 = Vector2.ZERO\n\n## Whether a search zone is currently active.\nvar _search_zone_active: bool = false\n\n## Radius of the potential player zone (area where player might be hiding).\nconst SEARCH_ZONE_RADIUS: float = 200.0\n\n## Timer for search timeout - enemy gives up searching after this time.\nvar _search_timer: float = 0.0\n\n## Maximum time to spend searching before giving up (seconds).\nconst SEARCH_MAX_DURATION: float = 15.0\n\n## Inspection points within the search zone (hiding spots behind covers and corners).\nvar _inspection_points: Array[Vector2] = []\n\n## Index of current inspection point being checked.\nvar _current_inspection_index: int = 0\n\n## Timer for waiting at each inspection point (looking around).\nvar _inspection_wait_timer: float = 0.0\n\n## Duration to wait at each inspection point (seconds).\nconst INSPECTION_WAIT_DURATION: float = 1.5\n\n## Whether currently waiting at an inspection point.\nvar _inspecting_point: bool = false\n\n## Number of raycasts for detecting inspection points (corners/hiding spots).\nconst INSPECTION_POINT_CHECK_COUNT: int = 24\n\n## Distance to check for inspection points from search zone center.\nconst INSPECTION_CHECK_DISTANCE: float = 250.0\n\n## Detection delay timer - tracks time since entering combat.\nvar _detection_timer: float = 0.0\n\n## Whether the detection delay has elapsed.\nvar _detection_delay_elapsed: bool = false\n\n## Continuous visibility timer - tracks how long the player has been continuously visible.\n## Resets when line of sight is lost.\nvar _continuous_visibility_timer: float = 0.0\n\n## Current visibility ratio of the player (0.0 to 1.0).\n## Represents what fraction of the player's body is visible to the enemy.\n## Used to determine if lead prediction should be enabled.\nvar _player_visibility_ratio: float = 0.0\n\n## --- Clear Shot Movement (move out from cover to get clear shot) ---\n## Target position to move to for getting a clear shot.\nvar _clear_shot_target: Vector2 = Vector2.ZERO\n\n## Whether we're currently moving to find a clear shot position.\nvar _seeking_clear_shot: bool = false\n\n## Timer for how long we've been trying to find a clear shot.\nvar _clear_shot_timer: float = 0.0\n\n## Maximum time to spend finding a clear shot before giving up (seconds).\nconst CLEAR_SHOT_MAX_TIME: float = 3.0\n\n## Distance to move when exiting cover to find a clear shot.\nconst CLEAR_SHOT_EXIT_DISTANCE: float = 60.0\n\n\n\nfunc _ready() -> void:\n\t_initial_position = global_position\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_setup_patrol_points()\n\t_find_player()\n\t_setup_wall_detection()\n\t_setup_cover_detection()\n\t_setup_threat_sphere()\n\t_initialize_goap_state()\n\t_connect_debug_mode_signal()\n\t_update_debug_label()\n\n\t# Log that this enemy is ready (use call_deferred to ensure FileLogger is loaded)\n\tcall_deferred(\"_log_spawn_info\")\n\n\t# Preload bullet scene if not set in inspector\n\tif bullet_scene == null:\n\t\tbullet_scene = preload(\"res://scenes/projectiles/Bullet.tscn\")\n\n\n## Initialize health with random value between min and max.\nfunc _initialize_health() -> void:\n\t_max_health = randi_range(min_health, max_health)\n\t_current_health = _max_health\n\t_is_alive = true\n\n\n## Initialize ammunition with full magazine and reserve ammo.\nfunc _initialize_ammo() -> void:\n\t_current_ammo = magazine_size\n\t# Reserve ammo is (total_magazines - 1) * magazine_size since one magazine is loaded\n\t_reserve_ammo = (total_magazines - 1) * magazine_size\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\n## Setup patrol points based on patrol offsets from initial position.\nfunc _setup_patrol_points() -> void:\n\t_patrol_points.clear()\n\t_patrol_points.append(_initial_position)\n\tfor offset in patrol_offsets:\n\t\t_patrol_points.append(_initial_position + offset)\n\n\n## Setup wall detection raycasts for obstacle avoidance.\nfunc _setup_wall_detection() -> void:\n\t# Create multiple raycasts spread in front of the enemy\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_wall_raycasts.append(raycast)\n\n\n## Setup cover detection raycasts for finding cover positions.\nfunc _setup_cover_detection() -> void:\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_cover_raycasts.append(raycast)\n\n\n## Setup threat sphere for detecting nearby bullets.\nfunc _setup_threat_sphere() -> void:\n\t_threat_sphere = Area2D.new()\n\t_threat_sphere.name = \"ThreatSphere\"\n\t_threat_sphere.collision_layer = 0\n\t_threat_sphere.collision_mask = 16  # Detect projectiles (layer 5)\n\n\tvar collision_shape := CollisionShape2D.new()\n\tvar circle_shape := CircleShape2D.new()\n\tcircle_shape.radius = threat_sphere_radius\n\tcollision_shape.shape = circle_shape\n\t_threat_sphere.add_child(collision_shape)\n\n\tadd_child(_threat_sphere)\n\n\t# Connect signals\n\t_threat_sphere.area_entered.connect(_on_threat_area_entered)\n\t_threat_sphere.area_exited.connect(_on_threat_area_exited)\n\n\n## Initialize GOAP world state.\nfunc _initialize_goap_state() -> void:\n\t_goap_world_state = {\n\t\t\"player_visible\": false,\n\t\t\"has_cover\": false,\n\t\t\"in_cover\": false,\n\t\t\"under_fire\": false,\n\t\t\"health_low\": false,\n\t\t\"can_flank\": false,\n\t\t\"at_flank_position\": false,\n\t\t\"is_retreating\": false,\n\t\t\"hits_taken\": 0,\n\t\t\"is_pursuing\": false,\n\t\t\"is_assaulting\": false,\n\t\t\"can_hit_from_cover\": false,\n\t\t\"player_close\": false,\n\t\t\"enemies_in_combat\": 0,\n\t\t\"has_search_zone\": false,\n\t\t\"search_zone_cleared\": false,\n\t\t\"inspection_points_remaining\": 0,\n\t\t\"is_searching\": false\n\t}\n\n\n## Connect to GameManager's debug mode signal for F7 toggle.\nfunc _connect_debug_mode_signal() -> void:\n\tvar game_manager: Node = get_node_or_null(\"/root/GameManager\")\n\tif game_manager:\n\t\t# Connect to debug mode toggle signal\n\t\tif game_manager.has_signal(\"debug_mode_toggled\"):\n\t\t\tgame_manager.debug_mode_toggled.connect(_on_debug_mode_toggled)\n\t\t# Sync with current debug mode state\n\t\tif game_manager.has_method(\"is_debug_mode_enabled\"):\n\t\t\tdebug_label_enabled = game_manager.is_debug_mode_enabled()\n\n\n## Called when debug mode is toggled via F7 key.\nfunc _on_debug_mode_toggled(enabled: bool) -> void:\n\tdebug_label_enabled = enabled\n\t_update_debug_label()\n\n\n## Find the player node in the scene tree.\nfunc _find_player() -> void:\n\t# Try to find the player by group first\n\tvar players := get_tree().get_nodes_in_group(\"player\")\n\tif players.size() > 0:\n\t\t_player = players[0]\n\t\treturn\n\n\t# Fallback: search for player by node name or type\n\tvar root := get_tree().current_scene\n\tif root:\n\t\t_player = _find_player_recursive(root)\n\n\n## Recursively search for a player node.\nfunc _find_player_recursive(node: Node) -> Node2D:\n\tif node.name == \"Player\" and node is Node2D:\n\t\treturn node\n\tfor child in node.get_children():\n\t\tvar result := _find_player_recursive(child)\n\t\tif result:\n\t\t\treturn result\n\treturn null\n\n\nfunc _physics_process(delta: float) -> void:\n\tif not _is_alive:\n\t\treturn\n\n\t# Update shoot cooldown timer\n\t_shoot_timer += delta\n\n\t# Update reload timer\n\t_update_reload(delta)\n\n\t# Check for player visibility and try to find player if not found\n\tif _player == null:\n\t\t_find_player()\n\n\t_check_player_visibility()\n\t_update_goap_state()\n\t_update_suppression(delta)\n\n\t# Process AI state machine\n\t_process_ai_state(delta)\n\n\t# Update debug label if enabled\n\t_update_debug_label()\n\n\t# Request redraw for debug visualization\n\tif debug_label_enabled:\n\t\tqueue_redraw()\n\n\tmove_and_slide()\n\n\n## Update GOAP world state based on current conditions.\nfunc _update_goap_state() -> void:\n\t_goap_world_state[\"player_visible\"] = _can_see_player\n\t_goap_world_state[\"under_fire\"] = _under_fire\n\t_goap_world_state[\"health_low\"] = _get_health_percent() < 0.5\n\t_goap_world_state[\"in_cover\"] = _current_state == AIState.IN_COVER\n\t_goap_world_state[\"has_cover\"] = _has_valid_cover\n\t_goap_world_state[\"is_retreating\"] = _current_state == AIState.RETREATING\n\t_goap_world_state[\"hits_taken\"] = _hits_taken_in_encounter\n\t_goap_world_state[\"is_pursuing\"] = _current_state == AIState.PURSUING\n\t_goap_world_state[\"is_assaulting\"] = _current_state == AIState.ASSAULT\n\t_goap_world_state[\"player_close\"] = _is_player_close()\n\t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n\t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()\n\t_goap_world_state[\"has_search_zone\"] = _search_zone_active\n\t_goap_world_state[\"search_zone_cleared\"] = not _search_zone_active and _last_known_player_position != Vector2.ZERO\n\t_goap_world_state[\"inspection_points_remaining\"] = _inspection_points.size() - _current_inspection_index\n\t_goap_world_state[\"is_searching\"] = _current_state == AIState.SEARCHING\n\n\n## Update suppression state.\nfunc _update_suppression(delta: float) -> void:\n\t# Clean up destroyed bullets from tracking\n\t_bullets_in_threat_sphere = _bullets_in_threat_sphere.filter(func(b): return is_instance_valid(b))\n\n\t# Determine if there's an active threat (bullets in sphere OR recent threat memory)\n\tvar has_active_threat := not _bullets_in_threat_sphere.is_empty() or _threat_memory_timer > 0.0\n\n\tif not has_active_threat:\n\t\tif _under_fire:\n\t\t\t_suppression_timer += delta\n\t\t\tif _suppression_timer >= suppression_cooldown:\n\t\t\t\t_under_fire = false\n\t\t\t\t_suppression_timer = 0.0\n\t\t\t\t_log_debug(\"Suppression ended\")\n\t\t# Reset threat reaction timer when no bullets are in threat sphere and no threat memory\n\t\t_threat_reaction_timer = 0.0\n\t\t_threat_reaction_delay_elapsed = false\n\telse:\n\t\t# Decrement threat memory timer if no bullets currently in sphere\n\t\tif _bullets_in_threat_sphere.is_empty() and _threat_memory_timer > 0.0:\n\t\t\t_threat_memory_timer -= delta\n\n\t\t# Update threat reaction timer\n\t\tif not _threat_reaction_delay_elapsed:\n\t\t\t_threat_reaction_timer += delta\n\t\t\tif _threat_reaction_timer >= threat_reaction_delay:\n\t\t\t\t_threat_reaction_delay_elapsed = true\n\t\t\t\t_log_debug(\"Threat reaction delay elapsed, now reacting to bullets\")\n\n\t\t# Only set under_fire after the reaction delay has elapsed\n\t\tif _threat_reaction_delay_elapsed:\n\t\t\t_under_fire = true\n\t\t\t_suppression_timer = 0.0\n\n\n## Update reload state.\nfunc _update_reload(delta: float) -> void:\n\tif not _is_reloading:\n\t\treturn\n\n\t_reload_timer += delta\n\tif _reload_timer >= reload_time:\n\t\t_finish_reload()\n\n\n## Start reloading the weapon.\nfunc _start_reload() -> void:\n\t# Can't reload if already reloading or no reserve ammo\n\tif _is_reloading or _reserve_ammo <= 0:\n\t\treturn\n\n\t_is_reloading = true\n\t_reload_timer = 0.0\n\treload_started.emit()\n\t_log_debug(\"Reloading... (%d reserve ammo)\" % _reserve_ammo)\n\n\n## Finish the reload process.\nfunc _finish_reload() -> void:\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\t# Calculate how many rounds to load\n\tvar ammo_needed := magazine_size - _current_ammo\n\tvar ammo_to_load := mini(ammo_needed, _reserve_ammo)\n\n\t_reserve_ammo -= ammo_to_load\n\t_current_ammo += ammo_to_load\n\n\treload_finished.emit()\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\t_log_debug(\"Reload complete. Magazine: %d/%d, Reserve: %d\" % [_current_ammo, magazine_size, _reserve_ammo])\n\n\n## Check if the enemy can shoot (has ammo and not reloading).\nfunc _can_shoot() -> bool:\n\t# Can't shoot if reloading\n\tif _is_reloading:\n\t\treturn false\n\n\t# Can't shoot if no ammo in magazine\n\tif _current_ammo <= 0:\n\t\t# Try to start reload if we have reserve ammo\n\t\tif _reserve_ammo > 0:\n\t\t\t_start_reload()\n\t\telse:\n\t\t\t# No ammo at all - emit depleted signal once\n\t\t\tif not _goap_world_state.get(\"ammo_depleted\", false):\n\t\t\t\t_goap_world_state[\"ammo_depleted\"] = true\n\t\t\t\tammo_depleted.emit()\n\t\t\t\t_log_debug(\"All ammunition depleted!\")\n\t\treturn false\n\n\treturn true\n\n\n## Process the AI state machine.\nfunc _process_ai_state(delta: float) -> void:\n\tvar previous_state := _current_state\n\n\t# State transitions based on conditions\n\tmatch _current_state:\n\t\tAIState.IDLE:\n\t\t\t_process_idle_state(delta)\n\t\tAIState.COMBAT:\n\t\t\t_process_combat_state(delta)\n\t\tAIState.SEEKING_COVER:\n\t\t\t_process_seeking_cover_state(delta)\n\t\tAIState.IN_COVER:\n\t\t\t_process_in_cover_state(delta)\n\t\tAIState.FLANKING:\n\t\t\t_process_flanking_state(delta)\n\t\tAIState.SUPPRESSED:\n\t\t\t_process_suppressed_state(delta)\n\t\tAIState.RETREATING:\n\t\t\t_process_retreating_state(delta)\n\t\tAIState.PURSUING:\n\t\t\t_process_pursuing_state(delta)\n\t\tAIState.ASSAULT:\n\t\t\t_process_assault_state(delta)\n\t\tAIState.SEARCHING:\n\t\t\t_process_searching_state(delta)\n\n\tif previous_state != _current_state:\n\t\tstate_changed.emit(_current_state)\n\t\t_log_debug(\"State changed: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\t\t# Also log to file for exported build debugging\n\t\t_log_to_file(\"State: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\n\n## Process IDLE state - patrol or guard behavior.\nfunc _process_idle_state(delta: float) -> void:\n\t# Transition to combat if player is visible\n\tif _can_see_player and _player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Execute idle behavior\n\tmatch behavior_mode:\n\t\tBehaviorMode.PATROL:\n\t\t\t_process_patrol(delta)\n\t\tBehaviorMode.GUARD:\n\t\t\t_process_guard(delta)\n\n\n## Process COMBAT state - approach player for direct contact, shoot for 2-3 seconds, return to cover.\n## Implements the combat cycling behavior: exit cover -> exposed shooting -> return to cover.\n## Phase 0 (seeking clear shot): If bullet spawn blocked, move out from cover to find clear shot.\n## Phase 1 (approaching): Move toward player to get into direct contact range.\n## Phase 2 (exposed): Stand and shoot for 2-3 seconds.\n## Phase 3: Return to cover via SEEKING_COVER state.\nfunc _process_combat_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies in combat (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can't see player, transition to SEARCHING to investigate last-known position\n\tif not _can_see_player:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to SEARCHING\")\n\t\t_transition_to_searching()\n\t\treturn\n\n\t# Update detection delay timer\n\tif not _detection_delay_elapsed:\n\t\t_detection_timer += delta\n\t\tif _detection_timer >= detection_delay:\n\t\t\t_detection_delay_elapsed = true\n\n\t# If we don't have cover, find some first (needed for returning later)\n\tif not _has_valid_cover and enable_cover:\n\t\t_find_cover_position()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found cover at %s for combat cycling\" % _cover_position)\n\n\t# Check player distance for approach/exposed phase decisions\n\tvar distance_to_player := INF\n\tif _player:\n\t\tdistance_to_player = global_position.distance_to(_player.global_position)\n\n\t# Check if we have a clear shot (no wall blocking bullet spawn)\n\tvar direction_to_player := Vector2.ZERO\n\tvar has_clear_shot := true\n\tif _player:\n\t\tdirection_to_player = (_player.global_position - global_position).normalized()\n\t\thas_clear_shot = _is_bullet_spawn_clear(direction_to_player)\n\n\t# If already exposed (shooting phase), handle shooting and timer\n\tif _combat_exposed:\n\t\t_combat_shoot_timer += delta\n\n\t\t# Check if exposure time is complete - go back to cover\n\t\tif _combat_shoot_timer >= _combat_shoot_duration and _has_valid_cover:\n\t\t\t_log_debug(\"Combat exposure time complete (%.1fs), returning to cover\" % _combat_shoot_duration)\n\t\t\t_combat_exposed = false\n\t\t\t_combat_approaching = false\n\t\t\t_combat_shoot_timer = 0.0\n\t\t\t_transition_to_seeking_cover()\n\t\t\treturn\n\n\t\t# Check if we still have a clear shot - if not, move sideways to find one\n\t\tif _player and not has_clear_shot:\n\t\t\t# Bullet spawn is blocked - move sideways to find a clear shot position\n\t\t\tvar sidestep_dir := _find_sidestep_direction_for_clear_shot(direction_to_player)\n\t\t\tif sidestep_dir != Vector2.ZERO:\n\t\t\t\tvelocity = sidestep_dir * combat_move_speed * 0.7\n\t\t\t\trotation = direction_to_player.angle()  # Keep facing player while sidestepping\n\t\t\t\t_log_debug(\"COMBAT exposed: sidestepping to maintain clear shot\")\n\t\t\telse:\n\t\t\t\t# No sidestep works - stay still, the shot might clear up\n\t\t\t\tvelocity = Vector2.ZERO\n\t\t\treturn\n\n\t\t# In exposed phase with clear shot, stand still and shoot\n\t\tvelocity = Vector2.ZERO\n\n\t\t# Aim and shoot at player (only shoot after detection delay)\n\t\tif _player:\n\t\t\t_aim_at_player()\n\t\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot()\n\t\t\t\t_shoot_timer = 0.0\n\t\treturn\n\n\t# --- CLEAR SHOT SEEKING PHASE ---\n\t# If bullet spawn is blocked and we're not already exposed, we need to move out from cover\n\tif not has_clear_shot and _player:\n\t\t# Start seeking clear shot if not already doing so\n\t\tif not _seeking_clear_shot:\n\t\t\t_seeking_clear_shot = true\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Calculate target position: move perpendicular to player direction (around cover edge)\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\t_log_debug(\"COMBAT: bullet spawn blocked, seeking clear shot at %s\" % _clear_shot_target)\n\n\t\t_clear_shot_timer += delta\n\n\t\t# Check if we've exceeded the max time trying to find a clear shot\n\t\tif _clear_shot_timer >= CLEAR_SHOT_MAX_TIME:\n\t\t\t_log_debug(\"COMBAT: clear shot timeout, trying flanking\")\n\t\t\t_seeking_clear_shot = false\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Try flanking to get around the obstacle\n\t\t\tif enable_flanking:\n\t\t\t\t_transition_to_flanking()\n\t\t\telse:\n\t\t\t\t_transition_to_pursuing()\n\t\t\treturn\n\n\t\t# Move toward the clear shot target position\n\t\tvar distance_to_target := global_position.distance_to(_clear_shot_target)\n\t\tif distance_to_target > 15.0:\n\t\t\tvar move_direction := (_clear_shot_target - global_position).normalized()\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed\n\t\t\trotation = direction_to_player.angle()  # Keep facing player\n\n\t\t\t# Check if the new position now has a clear shot\n\t\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\t\t_log_debug(\"COMBAT: found clear shot position while moving\")\n\t\t\t\t_seeking_clear_shot = false\n\t\t\t\t_clear_shot_timer = 0.0\n\t\t\t\t# Continue to exposed phase check below\n\t\t\telse:\n\t\t\t\treturn  # Keep moving toward target\n\t\telse:\n\t\t\t# Reached target but still no clear shot - recalculate target\n\t\t\t_log_debug(\"COMBAT: reached target but no clear shot, recalculating\")\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\treturn\n\n\t# Reset seeking state if we now have a clear shot\n\tif _seeking_clear_shot and has_clear_shot:\n\t\t_log_debug(\"COMBAT: clear shot acquired\")\n\t\t_seeking_clear_shot = false\n\t\t_clear_shot_timer = 0.0\n\n\t# Determine if we should be in approach phase or exposed shooting phase\n\tvar in_direct_contact := distance_to_player <= COMBAT_DIRECT_CONTACT_DISTANCE\n\n\t# Enter exposed phase if we have a clear shot and are either close enough or have approached long enough\n\tif has_clear_shot and (in_direct_contact or _combat_approach_timer >= COMBAT_APPROACH_MAX_TIME):\n\t\t# Close enough AND have clear shot - start exposed shooting phase\n\t\t_combat_exposed = true\n\t\t_combat_approaching = false\n\t\t_combat_shoot_timer = 0.0\n\t\t_combat_approach_timer = 0.0\n\t\t# Randomize exposure duration between 2-3 seconds\n\t\t_combat_shoot_duration = randf_range(2.0, 3.0)\n\t\t_log_debug(\"COMBAT exposed phase started (distance: %.0f), will shoot for %.1fs\" % [distance_to_player, _combat_shoot_duration])\n\t\treturn\n\n\t# Need to approach player - move toward them\n\tif not _combat_approaching:\n\t\t_combat_approaching = true\n\t\t_combat_approach_timer = 0.0\n\t\t_log_debug(\"COMBAT approach phase started, moving toward player\")\n\n\t_combat_approach_timer += delta\n\n\t# Move toward player while approaching\n\tif _player:\n\t\tvar move_direction := direction_to_player\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = move_direction * combat_move_speed\n\t\trotation = direction_to_player.angle()  # Always face player\n\n\t\t# Can shoot while approaching (only after detection delay and if have clear shot)\n\t\tif has_clear_shot and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\n## Calculate a target position to exit cover and get a clear shot.\n## Returns a position that should allow the bullet spawn point to be unobstructed.\nfunc _calculate_clear_shot_exit_position(direction_to_player: Vector2) -> Vector2:\n\t# Calculate perpendicular directions to the player\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Try both perpendicular directions and pick the one that's more likely to work\n\t# Also blend with forward movement toward player to help navigate around cover\n\tvar best_position := global_position\n\tvar best_score := -1.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\t\t# Blend sidestep with forward movement for better cover navigation\n\t\tvar exit_dir: Vector2 = (sidestep_dir * 0.7 + direction_to_player * 0.3).normalized()\n\t\tvar test_position: Vector2 = global_position + exit_dir * CLEAR_SHOT_EXIT_DISTANCE\n\n\t\t# Score this position based on:\n\t\t# 1. Does it have a clear path? (no walls in the way)\n\t\t# 2. Would the bullet spawn be clear from there?\n\t\tvar score: float = 0.0\n\n\t\t# Check if we can move to this position\n\t\tif _has_clear_path_to(test_position):\n\t\t\tscore += 1.0\n\n\t\t# Check if bullet spawn would be clear from this position\n\t\t# This is a rough estimate - we check from the test position toward player\n\t\tvar world_2d := get_world_2d()\n\t\tif world_2d != null:\n\t\t\tvar space_state := world_2d.direct_space_state\n\t\t\tif space_state != null:\n\t\t\t\tvar check_distance := bullet_spawn_offset + 5.0\n\t\t\t\tvar query := PhysicsRayQueryParameters2D.new()\n\t\t\t\tquery.from = test_position\n\t\t\t\tquery.to = test_position + direction_to_player * check_distance\n\t\t\t\tquery.collision_mask = 4  # Only check obstacles\n\t\t\t\tquery.exclude = [get_rid()]\n\t\t\t\tvar result := space_state.intersect_ray(query)\n\t\t\t\tif result.is_empty():\n\t\t\t\t\tscore += 2.0  # Higher score for clear bullet spawn\n\n\t\tif score > best_score:\n\t\t\tbest_score = score\n\t\t\tbest_position = test_position\n\n\t# If no good position found, just move forward toward player\n\tif best_score < 0.5:\n\t\tbest_position = global_position + direction_to_player * CLEAR_SHOT_EXIT_DISTANCE\n\n\treturn best_position\n\n\n## Process SEEKING_COVER state - moving to cover position.\nfunc _process_seeking_cover_state(_delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, stay in combat\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're already hidden from the player (the main goal)\n\tif not _is_visible_from_player():\n\t\t_transition_to_in_cover()\n\t\t_log_debug(\"Hidden from player, entering cover state\")\n\t\treturn\n\n\t# Move towards cover\n\tvar direction := (_cover_position - global_position).normalized()\n\tvar distance := global_position.distance_to(_cover_position)\n\n\tif distance < 10.0:\n\t\t# Reached the cover position, but still visible - try to find better cover\n\t\tif _is_visible_from_player():\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\t# No better cover found, stay in combat\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\n\t# Apply wall avoidance\n\tvar avoidance := _check_wall_ahead(direction)\n\tif avoidance != Vector2.ZERO:\n\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\tvelocity = direction * combat_move_speed\n\trotation = direction.angle()\n\n\t# Can still shoot while moving to cover (only after detection delay)\n\tif _can_see_player and _player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t_aim_at_player()\n\t\t_shoot()\n\t\t_shoot_timer = 0.0\n\n\n## Process IN_COVER state - taking cover from enemy fire.\n## Decides next action based on:\n## 1. If under fire -> suppressed\n## 2. If player is close (can exit cover for direct contact) -> COMBAT\n## 3. If player is far but can hit from current position -> COMBAT (stay and shoot)\n## 4. If player is far and can't hit -> PURSUING (move cover-to-cover)\nfunc _process_in_cover_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# If still under fire, stay suppressed\n\tif _under_fire:\n\t\t_transition_to_suppressed()\n\t\treturn\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover\n\tif _is_visible_from_player():\n\t\t# If in alarm mode and can see player, fire a burst before escaping\n\t\tif _in_alarm_mode and _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"IN_COVER alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay in cover while firing burst\n\n\t\t# Burst complete or not in alarm mode, seek new cover\n\t\t_log_debug(\"Player flanked our cover position, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# Decision making based on player distance and visibility\n\tif _player:\n\t\tvar player_close := _is_player_close()\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\n\t\tif _can_see_player:\n\t\t\tif player_close:\n\t\t\t\t# Player is close - engage in combat (come out, shoot, go back)\n\t\t\t\t_log_debug(\"Player is close, transitioning to COMBAT\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\t# Player is far\n\t\t\t\tif can_hit:\n\t\t\t\t\t# Can hit from current position - come out and shoot\n\t\t\t\t\t# (Don't pursue, just transition to combat which will handle the cycling)\n\t\t\t\t\t_log_debug(\"Player is far but can hit from here, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\telse:\n\t\t\t\t\t# Can't hit from here - need to pursue (move cover-to-cover)\n\t\t\t\t\t_log_debug(\"Player is far and can't hit, transitioning to PURSUING\")\n\t\t\t\t\t_transition_to_pursuing()\n\t\t\t\t\treturn\n\n\t# If not under fire and can see player, engage (only shoot after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If player is no longer visible and not under fire, try pursuing\n\tif not _can_see_player and not _under_fire:\n\t\t_log_debug(\"Lost sight of player from cover, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\n\n## Process FLANKING state - attempting to flank the player using cover-to-cover movement.\n## Uses intermediate cover positions to navigate around obstacles instead of walking\n## directly toward the flank target.\nfunc _process_flanking_state(delta: float) -> void:\n\t# If under fire, retreat with shooting behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# If can see player, engage in combat\n\tif _can_see_player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\tif _player == null:\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# Recalculate flank position (player may have moved)\n\t_calculate_flank_position()\n\n\tvar distance_to_flank := global_position.distance_to(_flank_target)\n\n\t# Check if we've reached the flank target\n\tif distance_to_flank < 30.0:\n\t\t_log_debug(\"Reached flank position, engaging\")\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Check if we have direct line of sight to flank target (no obstacles)\n\tif _has_clear_path_to(_flank_target):\n\t\t# Direct path is clear - move directly toward flank target\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\t_has_flank_cover = false\n\t\treturn\n\n\t# Path is blocked - use cover-to-cover movement\n\n\t# If we're at a cover position, wait briefly before moving to next\n\tif _has_valid_cover and not _has_flank_cover:\n\t\t_flank_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _flank_cover_wait_timer >= FLANK_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover toward flank target\n\t\t\t_find_flank_cover_toward_target()\n\t\t\tif not _has_flank_cover:\n\t\t\t\t_log_debug(\"No flank cover found, attempting direct movement\")\n\t\t\t\t# No cover found - try direct movement with enhanced wall avoidance\n\t\t\t\tvar direction := (_flank_target - global_position).normalized()\n\t\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\t\tvelocity = direction * combat_move_speed\n\t\t\t\trotation = direction.angle()\n\t\t\t\t# Invalidate current cover to trigger new search next frame\n\t\t\t\t_has_valid_cover = false\n\t\treturn\n\n\t# If we have a flank cover target, move toward it\n\tif _has_flank_cover:\n\t\tvar direction := (_flank_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_flank_next_cover)\n\n\t\t# Check if we've reached the flank cover\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached flank cover at distance %.1f\" % distance)\n\t\t\t_has_flank_cover = false\n\t\t\t_flank_cover_wait_timer = 0.0\n\t\t\t_cover_position = _flank_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no flank cover target - find initial flank cover\n\t_find_flank_cover_toward_target()\n\tif not _has_flank_cover:\n\t\t# Can't find cover, try direct movement with wall avoidance\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\n\n## Process SUPPRESSED state - staying in cover under fire.\nfunc _process_suppressed_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover even while suppressed\n\tif _is_visible_from_player():\n\t\t# In suppressed state we're always in alarm mode - fire a burst before escaping if we can see player\n\t\tif _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"SUPPRESSED alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay suppressed while firing burst\n\n\t\t# Burst complete or can't see player, seek new cover\n\t\t_log_debug(\"Player flanked our cover position while suppressed, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Can still shoot while suppressed (only after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If no longer under fire, exit suppression\n\tif not _under_fire:\n\t\t_transition_to_in_cover()\n\n\n## Process RETREATING state - moving to cover with behavior based on damage taken.\nfunc _process_retreating_state(delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, transition to combat or suppressed\n\t\t\tif _under_fire:\n\t\t\t\t_transition_to_suppressed()\n\t\t\telse:\n\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we've reached cover and are hidden from player\n\tif not _is_visible_from_player():\n\t\t_log_debug(\"Reached cover during retreat\")\n\t\t# Reset encounter hits when successfully reaching cover\n\t\t_hits_taken_in_encounter = 0\n\t\t_transition_to_in_cover()\n\t\treturn\n\n\t# Calculate direction to cover\n\tvar direction_to_cover := (_cover_position - global_position).normalized()\n\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\n\t# Check if reached cover position\n\tif distance_to_cover < 10.0:\n\t\tif _is_visible_from_player():\n\t\t\t# Still visible, find better cover\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\tif _under_fire:\n\t\t\t\t\t_transition_to_suppressed()\n\t\t\t\telse:\n\t\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Apply retreat behavior based on mode\n\tmatch _retreat_mode:\n\t\tRetreatMode.FULL_HP:\n\t\t\t_process_retreat_full_hp(delta, direction_to_cover)\n\t\tRetreatMode.ONE_HIT:\n\t\t\t_process_retreat_one_hit(delta, direction_to_cover)\n\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t_process_retreat_multiple_hits(delta, direction_to_cover)\n\n\n## Process FULL_HP retreat: walk backwards facing player, shoot with reduced accuracy,\n## periodically turn toward cover.\nfunc _process_retreat_full_hp(delta: float, direction_to_cover: Vector2) -> void:\n\t_retreat_turn_timer += delta\n\n\tif _retreat_turning_to_cover:\n\t\t# Turning to face cover, don't shoot\n\t\tif _retreat_turn_timer >= RETREAT_TURN_DURATION:\n\t\t\t_retreat_turning_to_cover = false\n\t\t\t_retreat_turn_timer = 0.0\n\n\t\t# Face cover and move toward it\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\telse:\n\t\t# Face player and back up (walk backwards)\n\t\tif _retreat_turn_timer >= RETREAT_TURN_INTERVAL:\n\t\t\t_retreat_turning_to_cover = true\n\t\t\t_retreat_turn_timer = 0.0\n\t\t\t_log_debug(\"FULL_HP retreat: turning to check cover\")\n\n\t\tif _player:\n\t\t\t# Face the player\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\t_aim_at_player()\n\n\t\t\t# Move backwards (opposite of player direction = toward cover generally)\n\t\t\t# Use the negative of the direction we're facing for \"backing up\"\n\t\t\tvar move_direction := -direction_to_player\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed * 0.7  # Slower when backing up\n\n\t\t\t# Shoot with reduced accuracy (only after detection delay)\n\t\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot_with_inaccuracy()\n\t\t\t\t_shoot_timer = 0.0\n\n\n## Process ONE_HIT retreat: quick burst of 2-4 shots in an arc while turning, then face cover.\nfunc _process_retreat_one_hit(delta: float, direction_to_cover: Vector2) -> void:\n\tif not _retreat_burst_complete:\n\t\t# During burst phase\n\t\t_retreat_burst_timer += delta\n\n\t\tif _player and _retreat_burst_remaining > 0 and _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t# Fire a burst shot with arc spread\n\t\t\t_shoot_burst_shot()\n\t\t\t_retreat_burst_remaining -= 1\n\t\t\t_retreat_burst_timer = 0.0\n\n\t\t\t# Progress through the arc\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0  # Spread across 4 shots max\n\n\t\t# Gradually turn from player to cover during burst\n\t\tif _player:\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\tvar target_angle: float\n\n\t\t\t# Interpolate rotation from player direction to cover direction\n\t\t\tvar burst_progress := 1.0 - (float(_retreat_burst_remaining) / 4.0)\n\t\t\tvar player_angle := direction_to_player.angle()\n\t\t\tvar cover_angle := direction_to_cover.angle()\n\t\t\ttarget_angle = lerp_angle(player_angle, cover_angle, burst_progress * 0.7)\n\t\t\trotation = target_angle\n\n\t\t# Move toward cover (slower during burst)\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed * 0.5\n\n\t\t# Check if burst is complete\n\t\tif _retreat_burst_remaining <= 0:\n\t\t\t_retreat_burst_complete = true\n\t\t\t_log_debug(\"ONE_HIT retreat: burst complete, now running to cover\")\n\telse:\n\t\t# After burst, run to cover without shooting\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\n\n## Process MULTIPLE_HITS retreat: quick burst of 2-4 shots then run to cover (same as ONE_HIT).\nfunc _process_retreat_multiple_hits(delta: float, direction_to_cover: Vector2) -> void:\n\t# Same behavior as ONE_HIT - quick burst then escape\n\t_process_retreat_one_hit(delta, direction_to_cover)\n\n\n## Process PURSUING state - move cover-to-cover toward player.\n## Enemy moves between covers, waiting 1-2 seconds at each cover,\n## until they can see and hit the player.\nfunc _process_pursuing_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected during pursuit (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can see player and can hit them from current position, engage\n\tif _can_see_player and _player:\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\t\tif can_hit:\n\t\t\t_log_debug(\"Can see and hit player from pursuit, transitioning to COMBAT\")\n\t\t\t_has_pursuit_cover = false\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're waiting at cover\n\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t# Currently at cover, wait for 1-2 seconds before moving to next cover\n\t\t_pursuit_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _pursuit_cover_wait_timer >= PURSUIT_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover closer to player\n\t\t\t_log_debug(\"Pursuit wait complete, finding next cover\")\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_find_pursuit_cover_toward_player()\n\t\t\tif _has_pursuit_cover:\n\t\t\t\t_log_debug(\"Found pursuit cover at %s\" % _pursuit_next_cover)\n\t\t\telse:\n\t\t\t\t# No pursuit cover found - fallback behavior\n\t\t\t\t_log_debug(\"No pursuit cover found, checking fallback options\")\n\t\t\t\t# If we can now see the player, engage directly\n\t\t\t\tif _can_see_player:\n\t\t\t\t\t_log_debug(\"Can see player, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\t# Try flanking\n\t\t\t\tif enable_flanking and _player:\n\t\t\t\t\t_log_debug(\"Attempting flanking maneuver\")\n\t\t\t\t\t_transition_to_flanking()\n\t\t\t\t\treturn\n\t\t\t\t# Last resort: move directly toward player\n\t\t\t\t_log_debug(\"No cover options, moving directly toward player\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\treturn\n\n\t# If we have a pursuit cover target, move toward it\n\tif _has_pursuit_cover:\n\t\tvar direction := (_pursuit_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_pursuit_next_cover)\n\n\t\t# Check if we've reached the pursuit cover\n\t\t# Note: We only check distance here, NOT visibility from player.\n\t\t# If we checked visibility, the enemy would immediately consider themselves\n\t\t# \"at cover\" even before moving, since they start hidden from player.\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached pursuit cover at distance %.1f\" % distance)\n\t\t\t_has_pursuit_cover = false\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_cover_position = _pursuit_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no pursuit target - find initial pursuit cover\n\t_find_pursuit_cover_toward_player()\n\tif not _has_pursuit_cover:\n\t\t# Can't find cover to pursue, try flanking or combat\n\t\tif enable_flanking and _player:\n\t\t\t_transition_to_flanking()\n\t\telse:\n\t\t\t_transition_to_combat()\n\n\n## Process ASSAULT state - coordinated multi-enemy rush.\n## Wait at cover for 5 seconds, then all enemies rush the player simultaneously.\nfunc _process_assault_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover and not _assault_ready:\n\t\t_in_assault = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if we're the only enemy left in assault - switch back to combat\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat < 2 and not _assault_ready:\n\t\t_log_debug(\"Not enough enemies for assault, switching to COMBAT\")\n\t\t_in_assault = false\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Find closest cover to player if we don't have one\n\tif not _has_valid_cover:\n\t\t_find_cover_closest_to_player()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found assault cover at %s\" % _cover_position)\n\n\t# Move to cover position first\n\tif _has_valid_cover and not _in_assault:\n\t\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\t\tif distance_to_cover > 15.0 and _is_visible_from_player():\n\t\t\t# Still need to reach cover\n\t\t\tvar direction := (_cover_position - global_position).normalized()\n\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\tvelocity = direction * combat_move_speed\n\t\t\trotation = direction.angle()\n\t\t\treturn\n\n\t# At cover, wait for assault timer\n\tif not _assault_ready:\n\t\tvelocity = Vector2.ZERO\n\t\t_assault_wait_timer += delta\n\n\t\t# Check if all assault enemies are ready (synchronized assault)\n\t\tif _assault_wait_timer >= ASSAULT_WAIT_DURATION:\n\t\t\t# Check if situation has changed - player might have moved\n\t\t\tif _player and _is_player_close():\n\t\t\t\t_assault_ready = true\n\t\t\t\t_in_assault = true\n\t\t\t\t_log_debug(\"ASSAULT ready - rushing player!\")\n\t\t\telse:\n\t\t\t\t# Player moved away, reset timer and check if we should pursue\n\t\t\t\t_log_debug(\"Player moved away during assault wait, resetting\")\n\t\t\t\t_assault_wait_timer = 0.0\n\t\t\t\t_in_assault = false\n\t\t\t\t_transition_to_pursuing()\n\t\t\t\treturn\n\t\treturn\n\n\t# Assault phase - rush the player while shooting\n\tif _assault_ready and _player:\n\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction_to_player)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_player = (direction_to_player * 0.5 + avoidance * 0.5).normalized()\n\n\t\t# Rush at full speed\n\t\tvelocity = direction_to_player * combat_move_speed\n\t\trotation = direction_to_player.angle()\n\n\t\t# Update detection delay timer\n\t\tif not _detection_delay_elapsed:\n\t\t\t_detection_timer += delta\n\t\t\tif _detection_timer >= detection_delay:\n\t\t\t\t_detection_delay_elapsed = true\n\n\t\t# Shoot while rushing (only after detection delay)\n\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t\t# If very close to player, stay in combat\n\t\tif distance_to_player < 50.0:\n\t\t\t_log_debug(\"Assault complete - reached player\")\n\t\t\t_assault_ready = false\n\t\t\t_in_assault = false\n\t\t\t_transition_to_combat()\n\n\n## Shoot with reduced accuracy for retreat mode.\nfunc _shoot_with_inaccuracy() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Check if the shot should be taken\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Add inaccuracy spread\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD, RETREAT_INACCURACY_SPREAD)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the inaccurate shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Inaccurate shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Shoot a burst shot with arc spread for ONE_HIT retreat.\nfunc _shoot_burst_shot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Apply arc offset for burst spread\n\tdirection = direction.rotated(_retreat_burst_angle_offset)\n\n\t# Also add some random inaccuracy on top of the arc\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD * 0.5, RETREAT_INACCURACY_SPREAD * 0.5)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the burst shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Burst shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Transition to IDLE state.\nfunc _transition_to_idle() -> void:\n\t_current_state = AIState.IDLE\n\t# Reset encounter hit tracking when returning to idle\n\t_hits_taken_in_encounter = 0\n\t# Reset alarm mode when returning to idle\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\n\n## Transition to COMBAT state.\nfunc _transition_
[2026-01-18T02:53:50.539Z] [INFO] to_combat() -> void:\n\t_current_state = AIState.COMBAT\n\t# Reset detection delay timer when entering combat\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Reset combat phase variables\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_shoot_timer = 0.0\n\t_combat_approach_timer = 0.0\n\t# Reset clear shot seeking variables\n\t_seeking_clear_shot = false\n\t_clear_shot_timer = 0.0\n\t_clear_shot_target = Vector2.ZERO\n\n\n## Transition to SEEKING_COVER state.\nfunc _transition_to_seeking_cover() -> void:\n\t_current_state = AIState.SEEKING_COVER\n\t_find_cover_position()\n\n\n## Transition to IN_COVER state.\nfunc _transition_to_in_cover() -> void:\n\t_current_state = AIState.IN_COVER\n\n\n## Transition to FLANKING state.\nfunc _transition_to_flanking() -> void:\n\t_current_state = AIState.FLANKING\n\t_calculate_flank_position()\n\t_flank_cover_wait_timer = 0.0\n\t_has_flank_cover = false\n\t_has_valid_cover = false\n\n\n## Transition to SUPPRESSED state.\nfunc _transition_to_suppressed() -> void:\n\t_current_state = AIState.SUPPRESSED\n\t# Enter alarm mode when suppressed\n\t_in_alarm_mode = true\n\n\n## Transition to PURSUING state.\nfunc _transition_to_pursuing() -> void:\n\t_current_state = AIState.PURSUING\n\t_pursuit_cover_wait_timer = 0.0\n\t_has_pursuit_cover = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\n\n## Transition to ASSAULT state.\nfunc _transition_to_assault() -> void:\n\t_current_state = AIState.ASSAULT\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Find closest cover to player for assault position\n\t_find_cover_closest_to_player()\n\n\n## Transition to RETREATING state with appropriate retreat mode.\nfunc _transition_to_retreating() -> void:\n\t_current_state = AIState.RETREATING\n\t# Enter alarm mode when retreating\n\t_in_alarm_mode = true\n\n\t# Determine retreat mode based on hits taken\n\tif _hits_taken_in_encounter == 0:\n\t\t_retreat_mode = RetreatMode.FULL_HP\n\t\t_retreat_turn_timer = 0.0\n\t\t_retreat_turning_to_cover = false\n\t\t_log_debug(\"Entering RETREATING state: FULL_HP mode (shoot while backing up)\")\n\telif _hits_taken_in_encounter == 1:\n\t\t_retreat_mode = RetreatMode.ONE_HIT\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t# Calculate arc spread: shots will be distributed across the arc\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: ONE_HIT mode (burst of %d shots)\" % _retreat_burst_remaining)\n\telse:\n\t\t_retreat_mode = RetreatMode.MULTIPLE_HITS\n\t\t# Multiple hits also gets burst fire (same as ONE_HIT)\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: MULTIPLE_HITS mode (burst of %d shots)\" % _retreat_burst_remaining)\n\n\t# Find cover position for retreating\n\t_find_cover_position()\n\n\n## Transition to SEARCHING state.\n## Activates the search zone and generates inspection points.\nfunc _transition_to_searching() -> void:\n\t_current_state = AIState.SEARCHING\n\t_search_timer = 0.0\n\t_inspection_wait_timer = 0.0\n\t_inspecting_point = false\n\t_current_inspection_index = 0\n\n\t# Activate search zone at last known player position\n\tif _last_known_player_position != Vector2.ZERO:\n\t\t_search_zone_active = true\n\t\t_log_debug(\"Activating search zone at %s (radius: %.1f)\" % [_last_known_player_position, SEARCH_ZONE_RADIUS])\n\t\t# Generate inspection points within the search zone\n\t\t_generate_inspection_points()\n\telse:\n\t\t# No last known position - fall back to pursuing\n\t\t_log_debug(\"No last known position, falling back to PURSUING\")\n\t\t_transition_to_pursuing()\n\n\n## Clear the search zone when player is found or search is complete.\nfunc _clear_search_zone() -> void:\n\t_search_zone_active = false\n\t_inspection_points.clear()\n\t_current_inspection_index = 0\n\t_inspecting_point = false\n\t_log_debug(\"Search zone cleared\")\n\n\n## Generate inspection points within the search zone.\n## Finds hiding spots behind covers and at corners within the search area.\nfunc _generate_inspection_points() -> void:\n\t_inspection_points.clear()\n\n\tif _last_known_player_position == Vector2.ZERO:\n\t\treturn\n\n\tvar search_center := _last_known_player_position\n\n\t# Use raycasts from the search center to find obstacles and generate inspection points\n\tfor i in range(INSPECTION_POINT_CHECK_COUNT):\n\t\tvar angle := (float(i) / INSPECTION_POINT_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\t# Cast ray from search center outward to find obstacles\n\t\tvar space_state := get_world_2d().direct_space_state\n\t\tvar query := PhysicsRayQueryParameters2D.new()\n\t\tquery.from = search_center\n\t\tquery.to = search_center + direction * INSPECTION_CHECK_DISTANCE\n\t\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\n\t\tvar result := space_state.intersect_ray(query)\n\n\t\tif not result.is_empty():\n\t\t\tvar collision_point: Vector2 = result[\"position\"]\n\t\t\tvar collision_normal: Vector2 = result[\"normal\"]\n\n\t\t\t# Generate inspection point behind the obstacle (from enemy's perspective)\n\t\t\t# This is where a player might hide\n\t\t\tvar inspection_pos := collision_point + collision_normal * 40.0\n\n\t\t\t# Only add if within search zone radius\n\t\t\tif inspection_pos.distance_to(search_center) <= SEARCH_ZONE_RADIUS:\n\t\t\t\t# Avoid duplicate or too-close points\n\t\t\t\tvar is_duplicate := false\n\t\t\t\tfor existing_point in _inspection_points:\n\t\t\t\t\tif inspection_pos.distance_to(existing_point) < 50.0:\n\t\t\t\t\t\tis_duplicate = true\n\t\t\t\t\t\tbreak\n\t\t\t\tif not is_duplicate:\n\t\t\t\t\t_inspection_points.append(inspection_pos)\n\n\t# Add corners of the search zone as additional inspection points\n\tvar corner_offsets := [\n\t\tVector2(SEARCH_ZONE_RADIUS * 0.7, SEARCH_ZONE_RADIUS * 0.7),\n\t\tVector2(-SEARCH_ZONE_RADIUS * 0.7, SEARCH_ZONE_RADIUS * 0.7),\n\t\tVector2(SEARCH_ZONE_RADIUS * 0.7, -SEARCH_ZONE_RADIUS * 0.7),\n\t\tVector2(-SEARCH_ZONE_RADIUS * 0.7, -SEARCH_ZONE_RADIUS * 0.7),\n\t]\n\n\tfor offset in corner_offsets:\n\t\tvar corner_point := search_center + offset\n\t\t# Only add corner if we can reach it (no obstacle blocking direct path)\n\t\tif _has_clear_path_to(corner_point):\n\t\t\tvar is_duplicate := false\n\t\t\tfor existing_point in _inspection_points:\n\t\t\t\tif corner_point.distance_to(existing_point) < 50.0:\n\t\t\t\t\tis_duplicate = true\n\t\t\t\t\tbreak\n\t\t\tif not is_duplicate:\n\t\t\t\t_inspection_points.append(corner_point)\n\n\t# Sort inspection points by distance from current position (closest first)\n\t_inspection_points.sort_custom(func(a: Vector2, b: Vector2) -> bool:\n\t\treturn global_position.distance_to(a) < global_position.distance_to(b)\n\t)\n\n\t_log_debug(\"Generated %d inspection points in search zone\" % _inspection_points.size())\n\n\n## Process SEARCHING state - investigate last-known player position and check hiding spots.\n## Enemy moves to last-known position, then checks each inspection point within the search zone.\n## Returns to IDLE when all points are checked or timeout expires.\nfunc _process_searching_state(delta: float) -> void:\n\t# If player is spotted during search, immediately transition to combat\n\tif _can_see_player:\n\t\t_log_debug(\"Player found during search, transitioning to COMBAT\")\n\t\t_clear_search_zone()\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Check for suppression - if under fire, need to take cover\n\tif _under_fire and enable_cover:\n\t\t_log_debug(\"Under fire during search, transitioning to RETREATING\")\n\t\t_clear_search_zone()\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Update search timer\n\t_search_timer += delta\n\n\t# Timeout - give up searching and return to patrol/guard\n\tif _search_timer >= SEARCH_MAX_DURATION:\n\t\t_log_debug(\"Search timeout reached, returning to IDLE\")\n\t\t_clear_search_zone()\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# If no inspection points left, search is complete\n\tif _inspection_points.is_empty() or _current_inspection_index >= _inspection_points.size():\n\t\t_log_debug(\"All inspection points checked, search zone cleared\")\n\t\t_clear_search_zone()\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# Get current inspection point target\n\tvar current_target := _inspection_points[_current_inspection_index]\n\tvar distance_to_target := global_position.distance_to(current_target)\n\n\t# Check if we're at the current inspection point\n\tif distance_to_target < 20.0:\n\t\tif not _inspecting_point:\n\t\t\t# Just arrived at inspection point - start looking around\n\t\t\t_inspecting_point = true\n\t\t\t_inspection_wait_timer = 0.0\n\t\t\t_log_debug(\"Inspecting point %d/%d at %s\" % [_current_inspection_index + 1, _inspection_points.size(), current_target])\n\n\t\t# Wait at the inspection point, looking around\n\t\t_inspection_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\t# Rotate while inspecting (looking around)\n\t\trotation += rotation_speed * delta * 0.5\n\n\t\tif _inspection_wait_timer >= INSPECTION_WAIT_DURATION:\n\t\t\t# Done inspecting this point, move to next\n\t\t\t_current_inspection_index += 1\n\t\t\t_inspecting_point = false\n\t\t\t_inspection_wait_timer = 0.0\n\t\treturn\n\n\t# Move toward current inspection point\n\tvar direction := (current_target - global_position).normalized()\n\n\t# Apply wall avoidance\n\tvar avoidance := _check_wall_ahead(direction)\n\tif avoidance != Vector2.ZERO:\n\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\tvelocity = direction * combat_move_speed * 0.8  # Slightly slower when searching\n\trotation = direction.angle()\n\n\n## Check if the enemy is visible from the player's position.\n## Uses raycasting from player to enemy to determine if there are obstacles blocking line of sight.\n## This is the inverse of _can_see_player - it checks if the PLAYER can see the ENEMY.\n## Checks multiple points on the enemy body (center and corners) to account for enemy size.\nfunc _is_visible_from_player() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check visibility to multiple points on the enemy body\n\t# This accounts for the enemy's size - corners can stick out from cover\n\tvar check_points := _get_enemy_check_points(global_position)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Get multiple check points on the enemy body for visibility testing.\n## Returns center and 4 corner points offset by the enemy's radius.\nfunc _get_enemy_check_points(center: Vector2) -> Array[Vector2]:\n\t# Enemy collision radius is 24, sprite is 48x48\n\t# Use a slightly smaller radius to avoid edge cases\n\tconst ENEMY_RADIUS: float = 22.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := ENEMY_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point is visible from the player's position.\nfunc _is_point_visible_from_player(point: Vector2) -> bool:\n\tif _player == null:\n\t\treturn false\n\n\tvar player_pos := _player.global_position\n\tvar distance := player_pos.distance_to(point)\n\n\t# Use direct space state to check line of sight from player to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = player_pos\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = []\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between player and point - point is visible\n\t\treturn true\n\telse:\n\t\t# Check if we hit an obstacle before reaching the point\n\t\tvar hit_position: Vector2 = result[\"position\"]\n\t\tvar distance_to_hit := player_pos.distance_to(hit_position)\n\n\t\t# If we hit something closer than the point, the point is hidden\n\t\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t\treturn false\n\t\telse:\n\t\t\treturn true\n\n\n## Check if a specific position would make the enemy visible from the player's position.\n## Checks all enemy body points (center and corners) to account for enemy size.\n## Used to validate cover positions before moving to them.\nfunc _is_position_visible_from_player(pos: Vector2) -> bool:\n\tif _player == null:\n\t\treturn true  # Assume visible if no player\n\n\t# Check visibility for all enemy body points at the given position\n\tvar check_points := _get_enemy_check_points(pos)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Check if a target position is visible from the enemy's perspective.\n## Uses raycast to verify there are no obstacles between enemy and the target position.\n## This is used to validate lead prediction targets - enemies should only aim at\n## positions they can actually see.\nfunc _is_position_visible_to_enemy(target_pos: Vector2) -> bool:\n\tvar distance := global_position.distance_to(target_pos)\n\n\t# Use direct space state to check line of sight from enemy to target\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = target_pos\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and target - position is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t# Hit obstacle before target - position is NOT visible\n\t\t_log_debug(\"Position %s blocked by obstacle at distance %.1f (target at %.1f)\" % [target_pos, distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Get multiple check points on the player's body for visibility testing.\n## Returns center and 4 corner points offset by the player's radius.\n## The player has a collision radius of 16 pixels (from Player.tscn).\nfunc _get_player_check_points(center: Vector2) -> Array[Vector2]:\n\t# Player collision radius is 16, sprite is 32x32\n\t# Use a slightly smaller radius to be conservative\n\tconst PLAYER_RADIUS: float = 14.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := PLAYER_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point on the player is visible from the enemy's position.\n## Uses direct space state query to check for obstacles blocking line of sight.\nfunc _is_player_point_visible_to_enemy(point: Vector2) -> bool:\n\tvar distance := global_position.distance_to(point)\n\n\t# Use direct space state to check line of sight from enemy to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and point - point is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the point\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\t# If we hit something before the point, the point is blocked\n\tif distance_to_hit < distance - 5.0:  # 5 pixel tolerance\n\t\treturn false\n\n\treturn true\n\n\n## Calculate what fraction of the player's body is visible to the enemy.\n## Returns a value from 0.0 (completely hidden) to 1.0 (fully visible).\n## Checks multiple points on the player's body (center + corners).\nfunc _calculate_player_visibility_ratio() -> float:\n\tif _player == null:\n\t\treturn 0.0\n\n\tvar check_points := _get_player_check_points(_player.global_position)\n\tvar visible_count := 0\n\n\tfor point in check_points:\n\t\tif _is_player_point_visible_to_enemy(point):\n\t\t\tvisible_count += 1\n\n\treturn float(visible_count) / float(check_points.size())\n\n\n## Check if the line of fire to the target position is clear of other enemies.\n## Returns true if no other enemies would be hit by a bullet traveling to the target.\nfunc _is_firing_line_clear_of_friendlies(target_position: Vector2) -> bool:\n\tif not enable_friendly_fire_avoidance:\n\t\treturn true\n\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if any enemies are in the firing line\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 2  # Only check enemies (layer 2)\n\tquery.exclude = [get_rid()]  # Exclude self using RID\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No enemies in the way\n\n\t# Check if the hit position is before the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 20.0:  # 20 pixel tolerance\n\t\t_log_debug(\"Friendly in firing line at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if a bullet fired at the target position would be blocked by cover/obstacles.\n## Returns true if the shot would likely hit the target, false if blocked by cover.\nfunc _is_shot_clear_of_cover(target_position: Vector2) -> bool:\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if obstacles block the shot\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No obstacles in the way\n\n\t# Check if the obstacle is before the target position\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t_log_debug(\"Shot blocked by cover at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if there's an obstacle immediately in front of the enemy that would block bullets.\n## This prevents shooting into walls that the enemy is flush against or very close to.\n## Uses a single raycast from enemy center to the bullet spawn position.\nfunc _is_bullet_spawn_clear(direction: Vector2) -> bool:\n\t# Fail-open: allow shooting if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn true\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn true\n\n\t# Check from enemy center to bullet spawn position plus a small buffer\n\tvar check_distance := bullet_spawn_offset + 5.0\n\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = global_position + direction * check_distance\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]\n\n\tvar result := space_state.intersect_ray(query)\n\tif not result.is_empty():\n\t\t_log_debug(\"Bullet spawn blocked: wall at distance %.1f\" % [\n\t\t\tglobal_position.distance_to(result[\"position\"])])\n\t\treturn false\n\n\treturn true\n\n\n## Find a sidestep direction that would lead to a clear shot position.\n## Checks perpendicular directions to the player and returns the first one\n## that would allow the bullet spawn point to be clear.\n## Returns Vector2.ZERO if no clear direction is found.\nfunc _find_sidestep_direction_for_clear_shot(direction_to_player: Vector2) -> Vector2:\n\t# Fail-safe: allow normal behavior if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn Vector2.ZERO\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn Vector2.ZERO\n\n\t# Check perpendicular directions (left and right of the player direction)\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Check both sidestep directions and pick the one that leads to clear shot faster\n\tvar check_distance := 50.0  # Check if moving 50 pixels in this direction would help\n\tvar bullet_check_distance := bullet_spawn_offset + 5.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:  # Try both sides\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\n\t\t# First check if we can actually move in this direction (no wall blocking movement)\n\t\tvar move_query := PhysicsRayQueryParameters2D.new()\n\t\tmove_query.from = global_position\n\t\tmove_query.to = global_position + sidestep_dir * 30.0\n\t\tmove_query.collision_mask = 4  # Only check obstacles\n\t\tmove_query.exclude = [get_rid()]\n\n\t\tvar move_result := space_state.intersect_ray(move_query)\n\t\tif not move_result.is_empty():\n\t\t\tcontinue  # Can't move this way, wall is blocking\n\n\t\t# Check if after sidestepping, we'd have a clear shot\n\t\tvar test_position: Vector2 = global_position + sidestep_dir * check_distance\n\t\tvar shot_query := PhysicsRayQueryParameters2D.new()\n\t\tshot_query.from = test_position\n\t\tshot_query.to = test_position + direction_to_player * bullet_check_distance\n\t\tshot_query.collision_mask = 4\n\t\tshot_query.exclude = [get_rid()]\n\n\t\tvar shot_result := space_state.intersect_ray(shot_query)\n\t\tif shot_result.is_empty():\n\t\t\t# Found a direction that leads to a clear shot\n\t\t\t_log_debug(\"Found sidestep direction: %s\" % sidestep_dir)\n\t\t\treturn sidestep_dir\n\n\treturn Vector2.ZERO  # No clear sidestep direction found\n\n\n## Check if the enemy should shoot at the current target.\n## Validates bullet spawn clearance, friendly fire avoidance, and cover blocking.\nfunc _should_shoot_at_target(target_position: Vector2) -> bool:\n\t# Check if the immediate path to bullet spawn is clear\n\t# This prevents shooting into walls the enemy is flush against\n\tvar direction := (target_position - global_position).normalized()\n\tif not _is_bullet_spawn_clear(direction):\n\t\treturn false\n\n\t# Check if friendlies are in the way\n\tif not _is_firing_line_clear_of_friendlies(target_position):\n\t\treturn false\n\n\t# Check if cover blocks the shot\n\tif not _is_shot_clear_of_cover(target_position):\n\t\treturn false\n\n\treturn true\n\n\n## Check if the player is \"close\" (within CLOSE_COMBAT_DISTANCE).\n## Used to determine if the enemy should engage directly or pursue.\nfunc _is_player_close() -> bool:\n\tif _player == null:\n\t\treturn false\n\treturn global_position.distance_to(_player.global_position) <= CLOSE_COMBAT_DISTANCE\n\n\n## Check if the enemy can hit the player from their current position.\n## Returns true if there's a clear line of fire to the player.\nfunc _can_hit_player_from_current_position() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check if we can see the player\n\tif not _can_see_player:\n\t\treturn false\n\n\t# Check if the shot would be blocked by cover\n\treturn _is_shot_clear_of_cover(_player.global_position)\n\n\n## Count the number of enemies currently in combat-related states.\n## Includes COMBAT, PURSUING, ASSAULT, IN_COVER (if can see player).\n## Used to determine if multi-enemy assault should be triggered.\nfunc _count_enemies_in_combat() -> int:\n\tvar count := 0\n\tvar enemies := get_tree().get_nodes_in_group(\"enemies\")\n\n\tfor enemy in enemies:\n\t\tif enemy == self:\n\t\t\tcontinue\n\t\tif not enemy.has_method(\"get_current_state\"):\n\t\t\tcontinue\n\n\t\tvar state: AIState = enemy.get_current_state()\n\t\t# Count enemies in combat-related states\n\t\tif state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\t\t# For IN_COVER, only count if they can see the player\n\t\t\tif state == AIState.IN_COVER:\n\t\t\t\tif enemy.has_method(\"is_in_combat_engagement\") and enemy.is_in_combat_engagement():\n\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tcount += 1\n\n\t# Count self if in a combat-related state\n\tif _current_state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\tcount += 1\n\n\treturn count\n\n\n## Check if this enemy is engaged in combat (can see player and in combat state).\nfunc is_in_combat_engagement() -> bool:\n\treturn _can_see_player and _current_state in [AIState.COMBAT, AIState.IN_COVER, AIState.ASSAULT]\n\n\n## Find cover position closer to the player for pursuit.\n## Used during PURSUING state to move cover-to-cover toward the player.\nfunc _find_pursuit_cover_toward_player() -> void:\n\tif _player == null:\n\t\t_has_pursuit_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For pursuit, we want cover that is:\n\t\t\t# 1. Closer to the player than we currently are\n\t\t\t# 2. Hidden from the player (or mostly hidden)\n\t\t\t# 3. Not too far from our current position\n\n\t\t\tvar my_distance_to_player := global_position.distance_to(player_pos)\n\t\t\tvar cover_distance_to_player := cover_pos.distance_to(player_pos)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to player\n\t\t\tif cover_distance_to_player >= my_distance_to_player:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if this position is hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Hidden from player (priority)\n\t\t\t# - Closer to player\n\t\t\t# - Not too far from current position\n\t\t\tvar hidden_score: float = 5.0 if is_hidden else 0.0\n\t\t\tvar approach_score: float = (my_distance_to_player - cover_distance_to_player) / CLOSE_COMBAT_DISTANCE\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = hidden_score + approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_pursuit_next_cover = best_cover\n\t\t_has_pursuit_cover = true\n\t\t_log_debug(\"Found pursuit cover at %s (score: %.2f)\" % [_pursuit_next_cover, best_score])\n\telse:\n\t\t_has_pursuit_cover = false\n\n\n## Find cover position closest to the player for assault positioning.\n## Used during ASSAULT state to take the nearest safe cover to the player.\nfunc _find_cover_closest_to_player() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_distance: float = INF\n\tvar found_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# Check if this position is hidden from player (safe cover)\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\tif is_hidden:\n\t\t\t\t# Calculate distance from this cover to the player\n\t\t\t\tvar distance_to_player := cover_pos.distance_to(player_pos)\n\n\t\t\t\t# We want the cover closest to the player\n\t\t\t\tif distance_to_player < best_distance:\n\t\t\t\t\tbest_distance = distance_to_player\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\t\tfound_cover = true\n\n\tif found_cover:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found assault cover at %s (distance to player: %.1f)\" % [_cover_position, best_distance])\n\telse:\n\t\t# Fall back to normal cover finding\n\t\t_find_cover_position()\n\n\n## Find a valid cover position relative to the player.\n## The cover position must be hidden from the player's line of sight.\nfunc _find_cover_position() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_hidden_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is on the opposite side of the obstacle from player\n\t\t\tvar direction_from_player := (collision_point - player_pos).normalized()\n\n\t\t\t# Position behind cover (offset from collision point along normal)\n\t\t\t# Offset must be large enough to hide the entire enemy body (radius ~24 pixels)\n\t\t\t# Using 35 pixels to provide some margin for the enemy's collision shape\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# First priority: Check if this position is actually hidden from player\n\t\t\tvar is_hidd
[2026-01-18T02:53:50.556Z] [INFO] en := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Only consider hidden positions unless we have no choice\n\t\t\tif is_hidden or not found_hidden_cover:\n\t\t\t\t# Score based on:\n\t\t\t\t# 1. Whether position is hidden (highest priority)\n\t\t\t\t# 2. Distance from enemy (closer is better)\n\t\t\t\t# 3. Position relative to player (behind cover from player's view)\n\t\t\t\tvar hidden_score: float = 10.0 if is_hidden else 0.0  # Heavy weight for hidden positions\n\n\t\t\t\tvar distance_score := 1.0 - (global_position.distance_to(cover_pos) / COVER_CHECK_DISTANCE)\n\n\t\t\t\t# Check if this position is on the far side of obstacle from player\n\t\t\t\tvar cover_direction := (cover_pos - player_pos).normalized()\n\t\t\t\tvar dot_product := direction_from_player.dot(cover_direction)\n\t\t\t\tvar blocking_score: float = maxf(0.0, dot_product)\n\n\t\t\t\tvar total_score: float = hidden_score + distance_score * 0.3 + blocking_score * 0.7\n\n\t\t\t\t# If we find a hidden position, only accept other hidden positions\n\t\t\t\tif is_hidden and not found_hidden_cover:\n\t\t\t\t\tfound_hidden_cover = true\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\telif (is_hidden or not found_hidden_cover) and total_score > best_score:\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\n\tif best_score > 0:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found cover at: %s (hidden: %s)\" % [_cover_position, found_hidden_cover])\n\telse:\n\t\t_has_valid_cover = false\n\n\n## Calculate flank position based on player location.\nfunc _calculate_flank_position() -> void:\n\tif _player == null:\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar player_to_enemy := (global_position - player_pos).normalized()\n\n\t# Choose left or right flank based on current position\n\tvar flank_side := 1.0 if randf() > 0.5 else -1.0\n\tvar flank_direction := player_to_enemy.rotated(flank_angle * fla
[2026-01-18T02:53:50.557Z] [INFO] nk_side)\n\n\t_flank_target = player_pos + flank_direction * flank_distance\n\t_log_debug(\"Flank target: %s\" % _flank_target)\n\n\n## Check if there's a clear path (no obstacles) to the target position.\n## Uses a raycast to check for walls/obstacles between current position and target.\nfunc _has_clear_path_to(target: Vector2) -> bool:\n\tif _raycast == null:\n\t\treturn true  # Assume clear if no raycast available\n\n\tvar direction := (target - global_position).normalized()\n\tvar distance := global_position.distance_to(target)\n\n\t_raycast.target_position = direction * distance\n\t_raycast.force_raycast_update()\n\n\t# If we hit something, path is blocked\n\tif _raycast.is_colliding():\n\t\tvar collision_point := _raycast.get_collision_point()\n\t\tvar collision_distance := global_position.distance_to(collision_point)\n\t\t# Only consider it blocked if the collision is before the target\n\t\treturn collision_distance >= distance - 10.0\n\n\treturn true\n\n\n## Find cover position closer to the flank target.\n## Used during FLANKING state to move cover-to-cover toward the flank position.\nfunc _find_flank_cover_toward_target() -> void:\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For flanking, we want cover that is:\n\t\t\t# 1. Closer to the flank target than we currently are\n\t\t\t# 2. Not too far from our current position\n\t\t\t# 3. Reachable (has clear path)\n\n\t\t\tvar my_distance_to_target := global_position.distance_to(_flank_target)\n\t\t\tvar cover_distance_to_target := cover_pos.distance_to(_flank_target)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to flank target\n\t\t\tif cover_distance_to_target >= my_distance_to_target:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if we can reach this cover (has clear path)\n\t\t\tif not _has_clear_path_to(cover_pos):\n\t\t\t\t# Even if direct path is blocked, we might be able to reach\n\t\t\t\t# via another intermediate cover, but skip for now\n\t\t\t\tcontinue\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Closer to flank target (priority)\n\t\t\t# - Not too far from current position\n\t\t\tvar approach_score: float = (my_distance_to_target - cover_distance_to_target) / flank_distance\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_flank_next_cover = best_cover\n\t\t_has_flank_cover = true\n\t\t_log_debug(\"Found flank cover at %s (score: %.2f)\" % [_flank_next_cover, best_score])\n\telse:\n\t\t_has_flank_cover = false\n\n\n## Check if there's a wall ahead in the given direction and return avoidance direction.\n## Returns Vector2.ZERO if no wall detected, otherwise returns a vector to avoid the wall.\nfunc _check_wall_ahead(direction: Vector2) -> Vector2:\n\tif _wall_raycasts.is_empty():\n\t\treturn Vector2.ZERO\n\n\tvar avoidance := Vector2.ZERO\n\tvar perpendicular := Vector2(-direction.y, direction.x)  # 90 degrees rotation\n\n\t# Check center, left, and right raycasts\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar angle_offset := (i - 1) * 0.5  # -0.5, 0, 0.5 radians (~-28, 0, 28 degrees)\n\t\tvar check_direction := direction.rotated(angle_offset)\n\n\t\tvar raycast := _wall_raycasts[i]\n\t\traycast.target_position = check_direction * WALL_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\t# Calculate avoidance based on which raycast hit\n\t\t\tif i == 0:  # Left raycast hit\n\t\t\t\tavoidance += perpendicular  # Steer right\n\t\t\telif i == 1:  # Center raycast hit\n\t\t\t\tavoidance += perpendicular if randf() > 0.5 else -perpendicular  # Random steer\n\t\t\telif i == 2:  # Right raycast hit\n\t\t\t\tavoidance -= perpendicular  # Steer left\n\n\treturn avoidance.normalized() if avoidance.length() > 0 else Vector2.ZERO\n\n\n## Check if the player is visible using raycast.\n## If detection_range is 0 or negative, uses unlimited detection range (line-of-sight only).\n## This allows the enemy to see the player even outside the viewport if there's no obstacle.\n## Also updates the continuous visibility timer and visibility ratio for lead prediction control.\nfunc _check_player_visibility() -> void:\n\tvar was_visible := _can_see_player\n\t_can_see_player = false\n\t_player_visibility_ratio = 0.0\n\n\tif _player == null or not _raycast:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t# Check if player is within detection range (only if detection_range is positive)\n\t# If detection_range <= 0, detection is unlimited (line-of-sight only)\n\tif detection_range > 0 and distance_to_player > detection_range:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\t# Point raycast at player - use actual distance to player for the raycast length\n\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\tvar raycast_length := distance_to_player + 10.0  # Add small buffer to ensure we reach player\n\t_raycast.target_position = direction_to_player * raycast_length\n\t_raycast.force_raycast_update()\n\n\t# Check if raycast hit something\n\tif _raycast.is_colliding():\n\t\tvar collider := _raycast.get_collider()\n\t\t# If we hit the player, we can see them\n\t\tif collider == _player:\n\t\t\t_can_see_player = true\n\t\t# If we hit a wall/obstacle before the player, we can't see them\n\telse:\n\t\t# No collision between us and player - we have clear line of sight\n\t\t_can_see_player = true\n\n\t# Update continuous visibility timer and visibility ratio\n\tif _can_see_player:\n\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n\t\t# Calculate what fraction of the player's body is visible\n\t\t# This is used to determine if lead prediction should be enabled\n\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n\t\t# Update last known player position while we can see them\n\t\t_last_known_player_position = _player.global_position\n\t\t# Clear search zone when player is seen\n\t\tif _search_zone_active:\n\t\t\t_clear_search_zone()\n\telse:\n\t\t# Lost line of sight - reset the timer and visibility ratio\n\t\t_continuous_visibility_timer = 0.0\n\t\t_player_visibility_ratio = 0.0\n\t\t# If we just lost sight and were in combat, activate search zone\n\t\tif was_visible and _last_known_player_position != Vector2.ZERO:\n\t\t\t_log_debug(\"Player escaped from view at %s\" % _last_known_player_position)\n\n\n## Aim the enemy sprite/direction at the player using gradual rotation.\nfunc _aim_at_player() -> void:\n\tif _player == null:\n\t\treturn\n\tvar direction := (_player.global_position - global_position).normalized()\n\tvar target_angle := direction.angle()\n\n\t# Calculate the shortest rotation direction\n\tvar angle_diff := wrapf(target_angle - rotation, -PI, PI)\n\n\t# Get the delta time from the current physics process\n\tvar delta := get_physics_process_delta_time()\n\n\t# Apply gradual rotation based on rotation_speed\n\tif abs(angle_diff) <= rotation_speed * delta:\n\t\t# Close enough to snap to target\n\t\trotation = target_angle\n\telif angle_diff > 0:\n\t\trotation += rotation_speed * delta\n\telse:\n\t\trotation -= rotation_speed * delta\n\n\n## Shoot a bullet towards the player.\nfunc _shoot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\t# Check if we can shoot (have ammo and not reloading)\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Apply lead prediction if enabled\n\tif enable_lead_prediction:\n\t\ttarget_position = _calculate_lead_prediction()\n\n\t# Check if the shot should be taken (friendly fire and cover checks)\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Create bullet instance\n\tvar bullet := bullet_scene.instantiate()\n\n\t# Set bullet position with offset in shoot direction\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\n\t# Set bullet direction\n\tbullet.direction = direction\n\n\t# Set shooter ID to identify this enemy as the source\n\t# This prevents enemies from detecting their own bullets in the threat sphere\n\tbullet.shooter_id = get_instance_id()\n\n\t# Add bullet to the scene tree\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play shooting sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\n\t# Play shell casing sound with a small delay\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\t# Auto-reload when magazine is empty\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Play shell casing sound with a delay to simulate the casing hitting the ground.\nfunc _play_delayed_shell_sound() -> void:\n\tawait get_tree().create_timer(0.15).timeout\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_shell_rifle\"):\n\t\taudio_manager.play_shell_rifle(global_position)\n\n\n## Calculate lead prediction - aims where the player will be, not where they are.\n## Uses iterative approach for better accuracy with moving targets.\n## Only applies lead prediction if:\n## 1. The player has been continuously visible for at least lead_prediction_delay seconds\n## 2. At least lead_prediction_visibility_threshold of the player's body is visible\n## 3. The predicted position is also visible to the enemy (not behind cover)\n## This prevents enemies from \"knowing\" where the player will emerge from cover.\nfunc _calculate_lead_prediction() -> Vector2:\n\tif _player == null:\n\t\treturn global_position\n\n\tvar player_pos := _player.global_position\n\n\t# Only use lead prediction if the player has been continuously visible\n\t# for long enough. This prevents enemies from predicting player position\n\t# immediately when they emerge from cover.\n\tif _continuous_visibility_timer < lead_prediction_delay:\n\t\t_log_debug(\"Lead prediction disabled: visibility time %.2fs < %.2fs required\" % [_continuous_visibility_timer, lead_prediction_delay])\n\t\treturn player_pos\n\n\t# Only use lead prediction if enough of the player's body is visible.\n\t# This prevents pre-firing when the player is at the edge of cover with only\n\t# a small part of their body visible. The player must be significantly exposed\n\t# before the enemy can predict their movement.\n\tif _player_visibility_ratio < lead_prediction_visibility_threshold:\n\t\t_log_debug(\"Lead prediction disabled: visibility ratio %.2f < %.2f required (player at cover edge)\" % [_player_visibility_ratio, lead_prediction_visibility_threshold])\n\t\treturn player_pos\n\n\tvar player_velocity := Vector2.ZERO\n\n\t# Get player velocity if they are a CharacterBody2D\n\tif _player is CharacterBody2D:\n\t\tplayer_velocity = _player.velocity\n\n\t# If player is stationary, no need for prediction\n\tif player_velocity.length_squared() < 1.0:\n\t\treturn player_pos\n\n\t# Iterative lead prediction for better accuracy\n\t# Start with player's current position\n\tvar predicted_pos := player_pos\n\tvar distance := global_position.distance_to(predicted_pos)\n\n\t# Iterate 2-3 times for convergence\n\tfor i in range(3):\n\t\t# Time for bullet to reach the predicted position\n\t\tvar time_to_target := distance / bullet_speed\n\n\t\t# Predict where player will be at that time\n\t\tpredicted_pos = player_pos + player_velocity * time_to_target\n\n\t\t# Update distance for next iteration\n\t\tdistance = global_position.distance_to(predicted_pos)\n\n\t# CRITICAL: Validate that the predicted position is actually visible to the enemy.\n\t# If the predicted position is behind cover (e.g., player is running toward cover exit),\n\t# we should NOT aim there - it would feel like the enemy is \"cheating\" by knowing\n\t# where the player will emerge. Fall back to player's current visible position.\n\tif not _is_position_visible_to_enemy(predicted_pos):\n\t\t_log_debug(\"Lead prediction blocked: predicted position %s is not visible, using current position %s\" % [predicted_pos, player_pos])\n\t\treturn player_pos\n\n\t_log_debug(\"Lead prediction: player at %s moving %s, aiming at %s\" % [player_pos, player_velocity, predicted_pos])\n\n\treturn predicted_pos\n\n\n## Process patrol behavior - move between patrol points.\nfunc _process_patrol(delta: float) -> void:\n\tif _patrol_points.is_empty():\n\t\treturn\n\n\t# Handle waiting at patrol point\n\tif _is_waiting_at_patrol_point:\n\t\t_patrol_wait_timer += delta\n\t\tif _patrol_wait_timer >= patrol_wait_time:\n\t\t\t_is_waiting_at_patrol_point = false\n\t\t\t_patrol_wait_timer = 0.0\n\t\t\t_current_patrol_index = (_current_patrol_index + 1) % _patrol_points.size()\n\t\tvelocity = Vector2.ZERO\n\t\treturn\n\n\t# Move towards current patrol point\n\tvar target_point := _patrol_points[_current_patrol_index]\n\tvar direction := (target_point - global_position).normalized()\n\tvar distance := global_position.distance_to(target_point)\n\n\tif distance < 5.0:\n\t\t# Reached patrol point, start waiting\n\t\t_is_waiting_at_patrol_point = true\n\t\tvelocity = Vector2.ZERO\n\telse:\n\t\t# Check for walls and apply avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\t# Blend movement direction with avoidance\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * move_speed\n\t\t# Face movement direction when patrolling\n\t\trotation = direction.angle()\n\n\n## Process guard behavior - stand still and look around.\nfunc _process_guard(_delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\t# In guard mode, enemy doesn't move but can still aim at player when visible\n\n\n## Called when a bullet enters the threat sphere.\nfunc _on_threat_area_entered(area: Area2D) -> void:\n\t# Check if bullet has shooter_id property and if it's from this enemy\n\t# This prevents enemies from being suppressed by their own bullets\n\tif \"shooter_id\" in area and area.shooter_id == get_instance_id():\n\t\treturn  # Ignore own bullets\n\n\t_bullets_in_threat_sphere.append(area)\n\t# Set threat memory timer so enemy can react even after fast bullets exit\n\t# This allows the reaction delay to complete even if bullets pass through quickly\n\t_threat_memory_timer = THREAT_MEMORY_DURATION\n\t# Note: _under_fire is now set in _update_suppression after threat_reaction_delay\n\t# This gives the player more time before the enemy reacts to nearby gunfire\n\t_log_debug(\"Bullet entered threat sphere, starting reaction delay...\")\n\n\n## Called when a bullet exits the threat sphere.\nfunc _on_threat_area_exited(area: Area2D) -> void:\n\t_bullets_in_threat_sphere.erase(area)\n\n\n## Called when the enemy is hit (by bullet.gd).\nfunc on_hit() -> void:\n\tif not _is_alive:\n\t\treturn\n\n\thit.emit()\n\n\t# Track hits for retreat behavior\n\t_hits_taken_in_encounter += 1\n\t_log_debug(\"Hit taken! Total hits in encounter: %d\" % _hits_taken_in_encounter)\n\t_log_to_file(\"Hit taken, health: %d/%d\" % [_current_health - 1, _max_health])\n\n\t# Show hit flash effect\n\t_show_hit_flash()\n\n\t# Apply damage\n\t_current_health -= 1\n\n\t# Play appropriate hit sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif _current_health <= 0:\n\t\t# Play lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_lethal\"):\n\t\t\taudio_manager.play_hit_lethal(global_position)\n\t\t_on_death()\n\telse:\n\t\t# Play non-lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_non_lethal\"):\n\t\t\taudio_manager.play_hit_non_lethal(global_position)\n\t\t_update_health_visual()\n\n\n## Shows a brief flash effect when hit.\nfunc _show_hit_flash() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t_sprite.modulate = hit_flash_color\n\n\tawait get_tree().create_timer(hit_flash_duration).timeout\n\n\t# Restore color based on current health (if still alive)\n\tif _is_alive:\n\t\t_update_health_visual()\n\n\n## Updates the sprite color based on current health percentage.\nfunc _update_health_visual() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t# Interpolate color based on health percentage\n\tvar health_percent := _get_health_percent()\n\t_sprite.modulate = full_health_color.lerp(low_health_color, 1.0 - health_percent)\n\n\n## Returns the current health as a percentage (0.0 to 1.0).\nfunc _get_health_percent() -> float:\n\tif _max_health <= 0:\n\t\treturn 0.0\n\treturn float(_current_health) / float(_max_health)\n\n\n## Called when the enemy dies.\nfunc _on_death() -> void:\n\t_is_alive = false\n\t_log_to_file(\"Enemy died\")\n\tdied.emit()\n\n\tif destroy_on_death:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\tqueue_free()\n\telse:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\t_reset()\n\n\n## Resets the enemy to its initial state.\nfunc _reset() -> void:\n\tglobal_position = _initial_position\n\trotation = 0.0\n\t_current_patrol_index = 0\n\t_is_waiting_at_patrol_point = false\n\t_patrol_wait_timer = 0.0\n\t_current_state = AIState.IDLE\n\t_has_valid_cover = false\n\t_under_fire = false\n\t_suppression_timer = 0.0\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t_continuous_visibility_timer = 0.0\n\t_player_visibility_ratio = 0.0\n\t_threat_reaction_timer = 0.0\n\t_threat_reaction_delay_elapsed = false\n\t_threat_memory_timer = 0.0\n\t_bullets_in_threat_sphere.clear()\n\t# Reset retreat state variables\n\t_hits_taken_in_encounter = 0\n\t_retreat_mode = RetreatMode.FULL_HP\n\t_retreat_turn_timer = 0.0\n\t_retreat_turning_to_cover = false\n\t_retreat_burst_remaining = 0\n\t_retreat_burst_timer = 0.0\n\t_retreat_burst_complete = false\n\t_retreat_burst_angle_offset = 0.0\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\t# Reset combat state variables\n\t_combat_shoot_timer = 0.0\n\t_combat_shoot_duration = 2.5\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_approach_timer = 0.0\n\t# Reset pursuit state variables\n\t_pursuit_cover_wait_timer = 0.0\n\t_pursuit_next_cover = Vector2.ZERO\n\t_has_pursuit_cover = false\n\t# Reset assault state variables\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset flank state variables\n\t_flank_cover_wait_timer = 0.0\n\t_flank_next_cover = Vector2.ZERO\n\t_has_flank_cover = false\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_initialize_goap_state()\n\n\n## Log debug message if debug_logging is enabled.\nfunc _log_debug(message: String) -> void:\n\tif debug_logging:\n\t\tprint(\"[Enemy %s] %s\" % [name, message])\n\n\n## Log a message to the file logger (always logs, regardless of debug_logging setting).\n## Use for important events like spawning, dying, or critical state changes.\nfunc _log_to_file(message: String) -> void:\n\tif not is_inside_tree():\n\t\treturn\n\tvar file_logger: Node = get_node_or_null(\"/root/FileLogger\")\n\tif file_logger and file_logger.has_method(\"log_enemy\"):\n\t\tfile_logger.log_enemy(name, message)\n\n\n## Log spawn info (called via call_deferred to ensure FileLogger is loaded).\nfunc _log_spawn_info() -> void:\n\t_log_to_file(\"Enemy spawned at %s, health: %d, behavior: %s, player_found: %s\" % [\n\t\tglobal_position, _max_health, BehaviorMode.keys()[behavior_mode],\n\t\t\"yes\" if _player != null else \"no\"])\n\n\n## Get AI state name as a human-readable string.\nfunc _get_state_name(state: AIState) -> String:\n\tmatch state:\n\t\tAIState.IDLE:\n\t\t\treturn \"IDLE\"\n\t\tAIState.COMBAT:\n\t\t\treturn \"COMBAT\"\n\t\tAIState.SEEKING_COVER:\n\t\t\treturn \"SEEKING_COVER\"\n\t\tAIState.IN_COVER:\n\t\t\treturn \"IN_COVER\"\n\t\tAIState.FLANKING:\n\t\t\treturn \"FLANKING\"\n\t\tAIState.SUPPRESSED:\n\t\t\treturn \"SUPPRESSED\"\n\t\tAIState.RETREATING:\n\t\t\treturn \"RETREATING\"\n\t\tAIState.PURSUING:\n\t\t\treturn \"PURSUING\"\n\t\tAIState.ASSAULT:\n\t\t\treturn \"ASSAULT\"\n\t\t_:\n\t\t\treturn \"UNKNOWN\"\n\n\n## Update the debug label with current AI state.\nfunc _update_debug_label() -> void:\n\tif _debug_label == null:\n\t\treturn\n\n\t_debug_label.visible = debug_label_enabled\n\tif not debug_label_enabled:\n\t\treturn\n\n\tvar state_text := _get_state_name(_current_state)\n\n\t# Add retreat mode info if retreating\n\tif _current_state == AIState.RETREATING:\n\t\tmatch _retreat_mode:\n\t\t\tRetreatMode.FULL_HP:\n\t\t\t\tstate_text += \"\\n(FULL_HP)\"\n\t\t\tRetreatMode.ONE_HIT:\n\t\t\t\tstate_text += \"\\n(ONE_HIT)\"\n\t\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t\tstate_text += \"\\n(MULTI_HITS)\"\n\n\t# Add assault timer info if in assault state\n\tif _current_state == AIState.ASSAULT:\n\t\tif _assault_ready:\n\t\t\tstate_text += \"\\n(RUSHING)\"\n\t\telse:\n\t\t\tvar time_left := ASSAULT_WAIT_DURATION - _assault_wait_timer\n\t\t\tstate_text += \"\\n(%.1fs)\" % time_left\n\n\t# Add combat phase info if in combat\n\tif _current_state == AIState.COMBAT:\n\t\tif _combat_exposed:\n\t\t\tvar time_left := _combat_shoot_duration - _combat_shoot_timer\n\t\t\tstate_text += \"\\n(EXPOSED %.1fs)\" % time_left\n\t\telif _seeking_clear_shot:\n\t\t\tvar time_left := CLEAR_SHOT_MAX_TIME - _clear_shot_timer\n\t\t\tstate_text += \"\\n(SEEK SHOT %.1fs)\" % time_left\n\t\telif _combat_approaching:\n\t\t\tstate_text += \"\\n(APPROACH)\"\n\n\t# Add pursuit timer info if pursuing and waiting at cover\n\tif _current_state == AIState.PURSUING:\n\t\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t\tvar time_left := PURSUIT_COVER_WAIT_DURATION - _pursuit_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_pursuit_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\n\t# Add flanking phase info if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_valid_cover and not _has_flank_cover:\n\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_flank_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\t\telse:\n\t\t\tstate_text += \"\\n(DIRECT)\"\n\n\t_debug_label.text = state_text\n\n\n## Get current AI state (for external access/debugging).\nfunc get_current_state() -> AIState:\n\treturn _current_state\n\n\n## Get GOAP world state (for GOAP planner).\nfunc get_goap_world_state() -> Dictionary:\n\treturn _goap_world_state.duplicate()\n\n\n## Check if enemy is currently under fire.\nfunc is_under_fire() -> bool:\n\treturn _under_fire\n\n\n## Check if enemy is in cover.\nfunc is_in_cover() -> bool:\n\treturn _current_state == AIState.IN_COVER or _current_state == AIState.SUPPRESSED\n\n\n## Get current ammo in magazine.\nfunc get_current_ammo() -> int:\n\treturn _current_ammo\n\n\n## Get reserve ammo.\nfunc get_reserve_ammo() -> int:\n\treturn _reserve_ammo\n\n\n## Get total ammo (current + reserve).\nfunc get_total_ammo() -> int:\n\treturn _current_ammo + _reserve_ammo\n\n\n## Check if enemy is currently reloading.\nfunc is_reloading() -> bool:\n\treturn _is_reloading\n\n\n## Check if enemy has any ammo left.\nfunc has_ammo() -> bool:\n\treturn _current_ammo > 0 or _reserve_ammo > 0\n\n\n## Get current player visibility ratio (for debugging).\n## Returns 0.0 if player is completely hidden, 1.0 if fully visible.\nfunc get_player_visibility_ratio() -> float:\n\treturn _player_visibility_ratio\n\n\n## Draw debug visualization when debug mode is enabled.\n## Shows: line to target (cover, clear shot, player), bullet spawn point status.\nfunc _draw() -> void:\n\tif not debug_label_enabled:\n\t\treturn\n\n\t# Colors for different debug elements\n\tvar color_to_cover := Color.CYAN  # Line to cover position\n\tvar color_to_player := Color.RED  # Line to player (when visible)\n\tvar color_clear_shot := Color.YELLOW  # Line to clear shot target\n\tvar color_pursuit := Color.ORANGE  # Line to pursuit cover\n\tvar color_flank := Color.MAGENTA  # Line to flank position\n\tvar color_bullet_spawn := Color.GREEN  # Bullet spawn point indicator\n\tvar color_blocked := Color.RED  # Blocked path indicator\n\n\t# Draw line to player if visible\n\tif _can_see_player and _player:\n\t\tvar to_player := _player.global_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_player, color_to_player, 1.5)\n\n\t\t# Draw bullet spawn point and check if blocked\n\t\tvar direction_to_player := to_player.normalized()\n\t\tvar spawn_point := direction_to_player * bullet_spawn_offset\n\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\tdraw_circle(spawn_point, 5.0, color_bullet_spawn)\n\t\telse:\n\t\t\t# Draw X for blocked spawn point\n\t\t\tdraw_line(spawn_point + Vector2(-5, -5), spawn_point + Vector2(5, 5), color_blocked, 2.0)\n\t\t\tdraw_line(spawn_point + Vector2(-5, 5), spawn_point + Vector2(5, -5), color_blocked, 2.0)\n\n\t# Draw line to cover position if we have one\n\tif _has_valid_cover:\n\t\tvar to_cover := _cover_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_cover, color_to_cover, 1.5)\n\t\t# Draw small circle at cover position\n\t\tdraw_circle(to_cover, 8.0, color_to_cover)\n\n\t# Draw line to clear shot target if seeking clear shot\n\tif _seeking_clear_shot and _clear_shot_target != Vector2.ZERO:\n\t\tvar to_target := _clear_shot_target - global_position\n\t\tdraw_line(Vector2.ZERO, to_target, color_clear_shot, 2.0)\n\t\t# Draw triangle at target position\n\t\tvar target_pos := to_target\n\t\tdraw_line(target_pos + Vector2(-6, 6), target_pos + Vector2(6, 6), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(6, 6), target_pos + Vector2(0, -8), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(0, -8), target_pos + Vector2(-6, 6), color_clear_shot, 2.0)\n\n\t# Draw line to pursuit cover if pursuing\n\tif _current_state == AIState.PURSUING and _has_pursuit_cover:\n\t\tvar to_pursuit := _pursuit_next_cover - global_position\n\t\tdraw_line(Vector2.ZERO, to_pursuit, color_pursuit, 2.0)\n\t\tdraw_circle(to_pursuit, 8.0, color_pursuit)\n\n\t# Draw line to flank target if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_flank_cover:\n\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n\t\telif _flank_target != Vector2.ZERO:\n\t\t\tvar to_flank := _flank_target - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n\t\t\t# Draw diamond at flank target\n\t\t\tvar flank_pos := to_flank\n\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)\n","structuredPatch":[{"oldStart":3249,"oldLines":6,"newStart":3249,"newLines":8,"lines":["       return \"PURSUING\"","     AIState.ASSAULT:","       return \"ASSAULT\"","+    AIState.SEARCHING:","+      return \"SEARCHING\"","     _:","       return \"UNKNOWN\""," "]}],"userModified":false,"replaceAll":false}}
[2026-01-18T02:53:53.147Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01AVerkrb7i18XJeueDHYpsR",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me update the debug label function to show SEARCHING state info:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 1023,
      "cache_read_input_tokens": 95509,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1023,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 6,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "af5381b3-5a28-4a14-840b-e194e5b3b4d8"
}
[2026-01-18T02:53:53.907Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01AVerkrb7i18XJeueDHYpsR",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01TLWacXTG5zqgg8wNmKYWbG",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "offset": 3290,
          "limit": 60
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 1023,
      "cache_read_input_tokens": 95509,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1023,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 6,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "e954596f-a0a5-431a-bce5-c838cebde6bf"
}
[2026-01-18T02:53:53.969Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01TLWacXTG5zqgg8wNmKYWbG",
        "type": "tool_result",
        "content": "  3290‚Üí\t\t\tvar time_left := _combat_shoot_duration - _combat_shoot_timer\n  3291‚Üí\t\t\tstate_text += \"\\n(EXPOSED %.1fs)\" % time_left\n  3292‚Üí\t\telif _seeking_clear_shot:\n  3293‚Üí\t\t\tvar time_left := CLEAR_SHOT_MAX_TIME - _clear_shot_timer\n  3294‚Üí\t\t\tstate_text += \"\\n(SEEK SHOT %.1fs)\" % time_left\n  3295‚Üí\t\telif _combat_approaching:\n  3296‚Üí\t\t\tstate_text += \"\\n(APPROACH)\"\n  3297‚Üí\n  3298‚Üí\t# Add pursuit timer info if pursuing and waiting at cover\n  3299‚Üí\tif _current_state == AIState.PURSUING:\n  3300‚Üí\t\tif _has_valid_cover and not _has_pursuit_cover:\n  3301‚Üí\t\t\tvar time_left := PURSUIT_COVER_WAIT_DURATION - _pursuit_cover_wait_timer\n  3302‚Üí\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n  3303‚Üí\t\telif _has_pursuit_cover:\n  3304‚Üí\t\t\tstate_text += \"\\n(MOVING)\"\n  3305‚Üí\n  3306‚Üí\t# Add flanking phase info if flanking\n  3307‚Üí\tif _current_state == AIState.FLANKING:\n  3308‚Üí\t\tif _has_valid_cover and not _has_flank_cover:\n  3309‚Üí\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n  3310‚Üí\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n  3311‚Üí\t\telif _has_flank_cover:\n  3312‚Üí\t\t\tstate_text += \"\\n(MOVING)\"\n  3313‚Üí\t\telse:\n  3314‚Üí\t\t\tstate_text += \"\\n(DIRECT)\"\n  3315‚Üí\n  3316‚Üí\t_debug_label.text = state_text\n  3317‚Üí\n  3318‚Üí\n  3319‚Üí## Get current AI state (for external access/debugging).\n  3320‚Üífunc get_current_state() -> AIState:\n  3321‚Üí\treturn _current_state\n  3322‚Üí\n  3323‚Üí\n  3324‚Üí## Get GOAP world state (for GOAP planner).\n  3325‚Üífunc get_goap_world_state() -> Dictionary:\n  3326‚Üí\treturn _goap_world_state.duplicate()\n  3327‚Üí\n  3328‚Üí\n  3329‚Üí## Check if enemy is currently under fire.\n  3330‚Üífunc is_under_fire() -> bool:\n  3331‚Üí\treturn _under_fire\n  3332‚Üí\n  3333‚Üí\n  3334‚Üí## Check if enemy is in cover.\n  3335‚Üífunc is_in_cover() -> bool:\n  3336‚Üí\treturn _current_state == AIState.IN_COVER or _current_state == AIState.SUPPRESSED\n  3337‚Üí\n  3338‚Üí\n  3339‚Üí## Get current ammo in magazine.\n  3340‚Üífunc get_current_ammo() -> int:\n  3341‚Üí\treturn _current_ammo\n  3342‚Üí\n  3343‚Üí\n  3344‚Üí## Get reserve ammo.\n  3345‚Üífunc get_reserve_ammo() -> int:\n  3346‚Üí\treturn _reserve_ammo\n  3347‚Üí\n  3348‚Üí\n  3349‚Üí## Get total ammo (current + reserve).\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "e7bf391e-b481-4292-8633-0791d5ec0274",
  "tool_use_result": {
    "type": "text",
    "file": {
      "filePath": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
      "content": "\t\t\tvar time_left := _combat_shoot_duration - _combat_shoot_timer\n\t\t\tstate_text += \"\\n(EXPOSED %.1fs)\" % time_left\n\t\telif _seeking_clear_shot:\n\t\t\tvar time_left := CLEAR_SHOT_MAX_TIME - _clear_shot_timer\n\t\t\tstate_text += \"\\n(SEEK SHOT %.1fs)\" % time_left\n\t\telif _combat_approaching:\n\t\t\tstate_text += \"\\n(APPROACH)\"\n\n\t# Add pursuit timer info if pursuing and waiting at cover\n\tif _current_state == AIState.PURSUING:\n\t\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t\tvar time_left := PURSUIT_COVER_WAIT_DURATION - _pursuit_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_pursuit_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\n\t# Add flanking phase info if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_valid_cover and not _has_flank_cover:\n\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_flank_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\t\telse:\n\t\t\tstate_text += \"\\n(DIRECT)\"\n\n\t_debug_label.text = state_text\n\n\n## Get current AI state (for external access/debugging).\nfunc get_current_state() -> AIState:\n\treturn _current_state\n\n\n## Get GOAP world state (for GOAP planner).\nfunc get_goap_world_state() -> Dictionary:\n\treturn _goap_world_state.duplicate()\n\n\n## Check if enemy is currently under fire.\nfunc is_under_fire() -> bool:\n\treturn _under_fire\n\n\n## Check if enemy is in cover.\nfunc is_in_cover() -> bool:\n\treturn _current_state == AIState.IN_COVER or _current_state == AIState.SUPPRESSED\n\n\n## Get current ammo in magazine.\nfunc get_current_ammo() -> int:\n\treturn _current_ammo\n\n\n## Get reserve ammo.\nfunc get_reserve_ammo() -> int:\n\treturn _reserve_ammo\n\n\n## Get total ammo (current + reserve).",
      "numLines": 60,
      "startLine": 3290,
      "totalLines": 3438
    }
  }
}
[2026-01-18T02:54:00.446Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01ENZUqKDkKxZdTDNPvVdTtX",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01CsEYaFH2qMCDKTJrjohZD1",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "old_string": "\t# Add flanking phase info if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_valid_cover and not _has_flank_cover:\n\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_flank_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\t\telse:\n\t\t\tstate_text += \"\\n(DIRECT)\"\n\n\t_debug_label.text = state_text",
          "new_string": "\t# Add flanking phase info if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_valid_cover and not _has_flank_cover:\n\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_flank_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\t\telse:\n\t\t\tstate_text += \"\\n(DIRECT)\"\n\n\t# Add searching phase info if searching\n\tif _current_state == AIState.SEARCHING:\n\t\tvar time_left := SEARCH_MAX_DURATION - _search_timer\n\t\tif _inspecting_point:\n\t\t\tstate_text += \"\\n(INSPECT %d/%d)\" % [_current_inspection_index + 1, _inspection_points.size()]\n\t\telse:\n\t\t\tstate_text += \"\\n(%d pts %.1fs)\" % [_inspection_points.size() - _current_inspection_index, time_left]\n\n\t_debug_label.text = state_text"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 1312,
      "cache_read_input_tokens": 96532,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1312,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 25,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "f4f65494-7468-4faf-8247-0b0d2815d7bb"
}
[2026-01-18T02:54:00.479Z] [INFO] {"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CsEYaFH2qMCDKTJrjohZD1","type":"tool_result","content":"The file /tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  3302‚Üí\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n  3303‚Üí\t\telif _has_pursuit_cover:\n  3304‚Üí\t\t\tstate_text += \"\\n(MOVING)\"\n  3305‚Üí\n  3306‚Üí\t# Add flanking phase info if flanking\n  3307‚Üí\tif _current_state == AIState.FLANKING:\n  3308‚Üí\t\tif _has_valid_cover and not _has_flank_cover:\n  3309‚Üí\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n  3310‚Üí\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n  3311‚Üí\t\telif _has_flank_cover:\n  3312‚Üí\t\t\tstate_text += \"\\n(MOVING)\"\n  3313‚Üí\t\telse:\n  3314‚Üí\t\t\tstate_text += \"\\n(DIRECT)\"\n  3315‚Üí\n  3316‚Üí\t# Add searching phase info if searching\n  3317‚Üí\tif _current_state == AIState.SEARCHING:\n  3318‚Üí\t\tvar time_left := SEARCH_MAX_DURATION - _search_timer\n  3319‚Üí\t\tif _inspecting_point:\n  3320‚Üí\t\t\tstate_text += \"\\n(INSPECT %d/%d)\" % [_current_inspection_index + 1, _inspection_points.size()]\n  3321‚Üí\t\telse:\n  3322‚Üí\t\t\tstate_text += \"\\n(%d pts %.1fs)\" % [_inspection_points.size() - _current_inspection_index, time_left]\n  3323‚Üí\n  3324‚Üí\t_debug_label.text = state_text\n  3325‚Üí\n  3326‚Üí\n  3327‚Üí## Get current AI state (for external access/debugging).\n  3328‚Üífunc get_current_state() -> AIState:"}]},"parent_tool_use_id":null,"session_id":"797fbac8-f5e6-4339-8fd2-77453410db49","uuid":"4c276172-9c50-4ff3-a105-217e5ace01b3","tool_use_result":{"filePath":"/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd","oldString":"\t# Add flanking phase info if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_valid_cover and not _has_flank_cover:\n\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_flank_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\t\telse:\n\t\t\tstate_text += \"\\n(DIRECT)\"\n\n\t_debug_label.text = state_text","newString":"\t# Add flanking phase info if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_valid_cover and not _has_flank_cover:\n\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_flank_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\t\telse:\n\t\t\tstate_text += \"\\n(DIRECT)\"\n\n\t# Add searching phase info if searching\n\tif _current_state == AIState.SEARCHING:\n\t\tvar time_left := SEARCH_MAX_DURATION - _search_timer\n\t\tif _inspecting_point:\n\t\t\tstate_text += \"\\n(INSPECT %d/%d)\" % [_current_inspection_index + 1, _inspection_points.size()]\n\t\telse:\n\t\t\tstate_text += \"\\n(%d pts %.1fs)\" % [_inspection_points.size() - _current_inspection_index, time_left]\n\n\t_debug_label.text = state_text","originalFile":"extends CharacterBody2D\n## Enemy AI with tactical behaviors including patrol, guard, cover, and flanking.\n##\n## Supports multiple behavior modes:\n## - PATROL: Moves between patrol points\n## - GUARD: Stands in place watching for the player\n##\n## Tactical features:\n## - Uses cover when under fire (suppression)\n## - Attempts to flank the player from the sides\n## - Coordinates with other enemies (optional)\n## - GOAP foundation for goal-oriented planning\n\n## AI States for tactical behavior.\nenum AIState {\n\tIDLE,       ## Default idle state (patrol or guard)\n\tCOMBAT,     ## Actively engaging the player (coming out of cover, shooting 2-3s, returning)\n\tSEEKING_COVER,  ## Moving to cover position\n\tIN_COVER,   ## Taking cover from player fire\n\tFLANKING,   ## Attempting to flank the player\n\tSUPPRESSED, ## Under fire, staying in cover\n\tRETREATING, ## Retreating to cover while possibly shooting\n\tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n\tASSAULT,    ## Coordinated multi-enemy assault (rush player after 5s wait)\n\tSEARCHING   ## Searching for player at last-known-position zone\n}\n\n## Retreat behavior modes based on damage taken.\nenum RetreatMode {\n\tFULL_HP,        ## No damage - retreat backwards while shooting, periodically turn to cover\n\tONE_HIT,        ## One hit taken - quick burst then retreat without shooting\n\tMULTIPLE_HITS   ## Multiple hits - quick burst then retreat without shooting (same as ONE_HIT)\n}\n\n## Behavior modes for the enemy.\nenum BehaviorMode {\n\tPATROL,  ## Moves between patrol points\n\tGUARD    ## Stands in one place\n}\n\n## Current behavior mode.\n@export var behavior_mode: BehaviorMode = BehaviorMode.GUARD\n\n## Maximum movement speed in pixels per second.\n@export var move_speed: float = 220.0\n\n## Combat movement speed (faster when flanking/seeking cover).\n@export var combat_move_speed: float = 320.0\n\n## Rotation speed in radians per second for gradual turning.\n## Default is 15 rad/sec for challenging but fair combat.\n@export var rotation_speed: float = 15.0\n\n## Detection range for spotting the player.\n## Set to 0 or negative to allow unlimited detection range (line-of-sight only).\n## This allows enemies to see the player even outside the viewport if no obstacles block view.\n@export var detection_range: float = 0.0\n\n## Time between shots in seconds.\n## Default matches assault rifle fire rate (10 shots/second = 0.1s cooldown).\n@export var shoot_cooldown: float = 0.1\n\n## Bullet scene to instantiate when shooting.\n@export var bullet_scene: PackedScene\n\n## Offset from enemy center for bullet spawn position.\n@export var bullet_spawn_offset: float = 30.0\n\n## Patrol points as offsets from the initial position.\n## Only used when behavior_mode is PATROL.\n@export var patrol_offsets: Array[Vector2] = [Vector2(100, 0), Vector2(-100, 0)]\n\n## Wait time at each patrol point in seconds.\n@export var patrol_wait_time: float = 1.5\n\n## Color when at full health.\n@export var full_health_color: Color = Color(0.9, 0.2, 0.2, 1.0)\n\n## Color when at low health (interpolates based on health percentage).\n@export var low_health_color: Color = Color(0.3, 0.1, 0.1, 1.0)\n\n## Color to flash when hit.\n@export var hit_flash_color: Color = Color(1.0, 1.0, 1.0, 1.0)\n\n## Duration of hit flash effect in seconds.\n@export var hit_flash_duration: float = 0.1\n\n## Whether to destroy the enemy after death.\n@export var destroy_on_death: bool = false\n\n## Delay before respawning or destroying (in seconds).\n@export var respawn_delay: float = 2.0\n\n## Minimum random health.\n@export var min_health: int = 2\n\n## Maximum random health.\n@export var max_health: int = 4\n\n## Threat sphere radius - bullets within this radius trigger suppression.\n@export var threat_sphere_radius: float = 100.0\n\n## Time to stay suppressed after bullets leave threat sphere.\n@export var suppression_cooldown: float = 2.0\n\n## Delay (in seconds) before reacting to bullets in the threat sphere.\n## This prevents instant reactions to nearby gunfire, giving the player more time.\n@export var threat_reaction_delay: float = 0.2\n\n## Flank angle from player's facing direction (radians).\n@export var flank_angle: float = PI / 3.0  # 60 degrees\n\n## Distance to maintain while flanking.\n@export var flank_distance: float = 200.0\n\n## Enable/disable flanking behavior.\n@export var enable_flanking: bool = true\n\n## Enable/disable cover behavior.\n@export var enable_cover: bool = true\n\n## Enable/disable debug logging.\n@export var debug_logging: bool = false\n\n## Enable/disable debug label above enemy showing current AI state.\n@export var debug_label_enabled: bool = false\n\n## Enable/disable friendly fire avoidance (don't shoot if other enemies are in the way).\n@export var enable_friendly_fire_avoidance: bool = true\n\n## Enable/disable lead prediction (shooting ahead of moving targets).\n@export var enable_lead_prediction: bool = true\n\n## Bullet speed for lead prediction calculation.\n## Should match the actual bullet speed (default is 2500 for assault rifle).\n@export var bullet_speed: float = 2500.0\n\n## Ammunition system - magazine size (bullets per magazine).\n@export var magazine_size: int = 30\n\n## Ammunition system - number of magazines the enemy carries.\n@export var total_magazines: int = 5\n\n## Ammunition system - time to reload in seconds.\n@export var reload_time: float = 3.0\n\n## Delay (in seconds) between spotting player and starting to shoot.\n## Gives player a brief reaction time when entering enemy line of sight.\n## This delay \"recharges\" each time the player breaks direct contact with the enemy.\n@export var detection_delay: float = 0.2\n\n## Minimum time (in seconds) the player must be continuously visible before\n## lead prediction is enabled. This prevents enemies from predicting player\n## position immediately when they emerge from cover.\n@export var lead_prediction_delay: float = 0.3\n\n## Minimum visibility ratio (0.0 to 1.0) of player body that must be visible\n## before lead prediction is enabled. At 1.0, the player's entire body must be\n## visible. At 0.5, at least half of the check points must be visible.\n## This prevents pre-firing at players who are at cover edges.\n@export var lead_prediction_visibility_threshold: float = 0.6\n\n## Signal emitted when the enemy is hit.\nsignal hit\n\n## Signal emitted when the enemy dies.\nsignal died\n\n## Signal emitted when AI state changes.\nsignal state_changed(new_state: AIState)\n\n## Signal emitted when ammunition changes.\nsignal ammo_changed(current_ammo: int, reserve_ammo: int)\n\n## Signal emitted when reloading starts.\nsignal reload_started\n\n## Signal emitted when reloading finishes.\nsignal reload_finished\n\n## Signal emitted when all ammunition is depleted.\nsignal ammo_depleted\n\n## Reference to the sprite for color changes.\n@onready var _sprite: Sprite2D = $Sprite2D\n\n## RayCast2D for line of sight detection.\n@onready var _raycast: RayCast2D = $RayCast2D\n\n## Debug label for showing current AI state above the enemy.\n@onready var _debug_label: Label = $DebugLabel\n\n## Wall detection raycasts for obstacle avoidance (created at runtime).\nvar _wall_raycasts: Array[RayCast2D] = []\n\n## Distance to check for walls ahead.\nconst WALL_CHECK_DISTANCE: float = 40.0\n\n## Number of raycasts for wall detection (spread around the enemy).\nconst WALL_CHECK_COUNT: int = 3\n\n## Cover detection raycasts (created at runtime).\nvar _cover_raycasts: Array[RayCast2D] = []\n\n## Number of raycasts for cover detection.\nconst COVER_CHECK_COUNT: int = 16\n\n## Distance to check for cover.\nconst COVER_CHECK_DISTANCE: float = 300.0\n\n## Current health of the enemy.\nvar _current_health: int = 0\n\n## Maximum health of the enemy (set at spawn).\nvar _max_health: int = 0\n\n## Whether the enemy is alive.\nvar _is_alive: bool = true\n\n## Reference to the player (found at runtime).\nvar _player: Node2D = null\n\n## Time since last shot.\nvar _shoot_timer: float = 0.0\n\n## Current ammo in the magazine.\nvar _current_ammo: int = 0\n\n## Reserve ammo (ammo in remaining magazines).\nvar _reserve_ammo: int = 0\n\n## Whether the enemy is currently reloading.\nvar _is_reloading: bool = false\n\n## Timer for reload progress.\nvar _reload_timer: float = 0.0\n\n## Patrol state variables.\nvar _patrol_points: Array[Vector2] = []\nvar _current_patrol_index: int = 0\nvar _is_waiting_at_patrol_point: bool = false\nvar _patrol_wait_timer: float = 0.0\nvar _initial_position: Vector2\n\n## Whether the enemy can currently see the player.\nvar _can_see_player: bool = false\n\n## Current AI state.\nvar _current_state: AIState = AIState.IDLE\n\n## Current cover position (if any).\nvar _cover_position: Vector2 = Vector2.ZERO\n\n## Is currently in a valid cover position.\nvar _has_valid_cover: bool = false\n\n## Timer for suppression cooldown.\nvar _suppression_timer: float = 0.0\n\n## Whether enemy is currently under fire (bullets in threat sphere).\nvar _under_fire: bool = false\n\n## Flank target position.\nvar _flank_target: Vector2 = Vector2.ZERO\n\n## Threat sphere Area2D for detecting nearby bullets.\nvar _threat_sphere: Area2D = null\n\n## Bullets currently in threat sphere.\nvar _bullets_in_threat_sphere: Array = []\n\n## Timer for threat reaction delay - time since first bullet entered threat sphere.\nvar _threat_reaction_timer: float = 0.0\n\n## Whether the threat reaction delay has elapsed (enemy can react to bullets).\nvar _threat_reaction_delay_elapsed: bool = false\n\n## Memory of bullets that have passed through the threat sphere recently.\n## This allows the enemy to react even after fast-moving bullets have exited.\nvar _threat_memory_timer: float = 0.0\n\n## Duration to remember that a bullet passed through the threat sphere.\n## This should be longer than the reaction delay to ensure enemies can complete\n## their reaction even after bullets have passed through quickly.\nconst THREAT_MEMORY_DURATION: float = 0.5\n\n## Current retreat mode determined by damage taken.\nvar _retreat_mode: RetreatMode = RetreatMode.FULL_HP\n\n## Number of hits taken during the current retreat/combat encounter.\n## Resets when enemy enters IDLE state or finishes retreating.\nvar _hits_taken_in_encounter: int = 0\n\n## Timer for periodic turning to cover during FULL_HP retreat.\nvar _retreat_turn_timer: float = 0.0\n\n## Duration to face cover during FULL_HP retreat turn (seconds).\nconst RETREAT_TURN_DURATION: float = 0.8\n\n## Interval between turns toward cover in FULL_HP retreat (seconds).\nconst RETREAT_TURN_INTERVAL: float = 1.5\n\n## Whether currently in the \"turn to cover\" phase of FULL_HP retreat.\nvar _retreat_turning_to_cover: bool = false\n\n## Burst fire counter for ONE_HIT retreat mode.\nvar _retreat_burst_remaining: int = 0\n\n## Timer for burst fire cooldown in ONE_HIT retreat.\nvar _retreat_burst_timer: float = 0.0\n\n## Fast cooldown between burst shots (seconds).\nconst RETREAT_BURST_COOLDOWN: float = 0.06\n\n## Whether burst fire phase is complete in ONE_HIT retreat.\nvar _retreat_burst_complete: bool = false\n\n## Accuracy reduction during retreat (multiplier for inaccuracy angle spread).\nconst RETREAT_INACCURACY_SPREAD: float = 0.15\n\n## Arc spread for ONE_HIT burst fire (radians, total spread).\nconst RETREAT_BURST_ARC: float = 0.4\n\n## Current angle offset within burst arc.\nvar _retreat_burst_angle_offset: float = 0.0\n\n## Whether enemy is in \"alarm\" mode (was suppressed/retreating and hasn't calmed down).\n## This persists until the enemy reaches safety in cover or returns to idle.\nvar _in_alarm_mode: bool = false\n\n## Whether the enemy needs to fire a cover burst (when leaving cover while in alarm).\nvar _cover_burst_pending: bool = false\n\n## --- Combat Cover Cycling (come out, shoot 2-3s, go back) ---\n## Timer for how long the enemy has been shooting while out of cover.\nvar _combat_shoot_timer: float = 0.0\n\n## Duration to shoot while out of cover (2-3 seconds, randomized).\nvar _combat_shoot_duration: float = 2.5\n\n## Whether the enemy is currently in the \"exposed shooting\" phase of combat.\nvar _combat_exposed: bool = false\n\n## Whether the enemy is in the \"approaching player\" phase of combat.\n## In this phase, the enemy moves toward the player to get into direct contact.\nvar _combat_approaching: bool = false\n\n## Timer for the approach phase of combat.\nvar _combat_approach_timer: float = 0.0\n\n## Maximum time to spend approaching player before starting to shoot (seconds).\nconst COMBAT_APPROACH_MAX_TIME: float = 2.0\n\n## Distance at which enemy is considered \"close enough\" to start shooting phase.\nconst COMBAT_DIRECT_CONTACT_DISTANCE: float = 250.0\n\n## --- Pursuit State (cover-to-cover movement) ---\n## Timer for waiting at cover during pursuit.\nvar _pursuit_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during pursuit (1-2 seconds, reduced for faster pursuit).\nconst PURSUIT_COVER_WAIT_DURATION: float = 1.5\n\n## Current pursuit target cover position.\nvar _pursuit_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid pursuit cover target.\nvar _has_pursuit_cover: bool = false\n\n## --- Flanking State (cover-to-cover movement toward flank target) ---\n## Timer for waiting at cover during flanking.\nvar _flank_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during flanking (seconds).\nconst FLANK_COVER_WAIT_DURATION: float = 0.8\n\n## Current flank cover position to move to.\nvar _flank_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid flank cover target.\nvar _has_flank_cover: bool = false\n\n## --- Assault State (coordinated multi-enemy rush) ---\n## Timer for assault wait period (5 seconds before rushing).\nvar _assault_wait_timer: float = 0.0\n\n## Duration to wait at cover before assault (5 seconds).\nconst ASSAULT_WAIT_DURATION: float = 5.0\n\n## Whether the assault wait period is complete.\nvar _assault_ready: bool = false\n\n## Whether this enemy is currently participating in an assault.\nvar _in_assault: bool = false\n\n## Distance threshold for \"close\" vs \"far\" from player.\n## Used to determine if enemy can engage from current position or needs to pursue.\nconst CLOSE_COMBAT_DISTANCE: float = 400.0\n\n## GOAP world state for goal-oriented planning.\nvar _goap_world_state: Dictionary = {}\n\n## --- Search/Investigation State (for when player escapes from view) ---\n## Last known position where the player was seen before escaping view.\nvar _last_known_player_position: Vector2 = Vector2.ZERO\n\n## Whether a search zone is currently active.\nvar _search_zone_active: bool = false\n\n## Radius of the potential player zone (area where player might be hiding).\nconst SEARCH_ZONE_RADIUS: float = 200.0\n\n## Timer for search timeout - enemy gives up searching after this time.\nvar _search_timer: float = 0.0\n\n## Maximum time to spend searching before giving up (seconds).\nconst SEARCH_MAX_DURATION: float = 15.0\n\n## Inspection points within the search zone (hiding spots behind covers and corners).\nvar _inspection_points: Array[Vector2] = []\n\n## Index of current inspection point being checked.\nvar _current_inspection_index: int = 0\n\n## Timer for waiting at each inspection point (looking around).\nvar _inspection_wait_timer: float = 0.0\n\n## Duration to wait at each inspection point (seconds).\nconst INSPECTION_WAIT_DURATION: float = 1.5\n\n## Whether currently waiting at an inspection point.\nvar _inspecting_point: bool = false\n\n## Number of raycasts for detecting inspection points (corners/hiding spots).\nconst INSPECTION_POINT_CHECK_COUNT: int = 24\n\n## Distance to check for inspection points from search zone center.\nconst INSPECTION_CHECK_DISTANCE: float = 250.0\n\n## Detection delay timer - tracks time since entering combat.\nvar _detection_timer: float = 0.0\n\n## Whether the detection delay has elapsed.\nvar _detection_delay_elapsed: bool = false\n\n## Continuous visibility timer - tracks how long the player has been continuously visible.\n## Resets when line of sight is lost.\nvar _continuous_visibility_timer: float = 0.0\n\n## Current visibility ratio of the player (0.0 to 1.0).\n## Represents what fraction of the player's body is visible to the enemy.\n## Used to determine if lead prediction should be enabled.\nvar _player_visibility_ratio: float = 0.0\n\n## --- Clear Shot Movement (move out from cover to get clear shot) ---\n## Target position to move to for getting a clear shot.\nvar _clear_shot_target: Vector2 = Vector2.ZERO\n\n## Whether we're currently moving to find a clear shot position.\nvar _seeking_clear_shot: bool = false\n\n## Timer for how long we've been trying to find a clear shot.\nvar _clear_shot_timer: float = 0.0\n\n## Maximum time to spend finding a clear shot before giving up (seconds).\nconst CLEAR_SHOT_MAX_TIME: float = 3.0\n\n## Distance to move when exiting cover to find a clear shot.\nconst CLEAR_SHOT_EXIT_DISTANCE: float = 60.0\n\n\n\nfunc _ready() -> void:\n\t_initial_position = global_position\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_setup_patrol_points()\n\t_find_player()\n\t_setup_wall_detection()\n\t_setup_cover_detection()\n\t_setup_threat_sphere()\n\t_initialize_goap_state()\n\t_connect_debug_mode_signal()\n\t_update_debug_label()\n\n\t# Log that this enemy is ready (use call_deferred to ensure FileLogger is loaded)\n\tcall_deferred(\"_log_spawn_info\")\n\n\t# Preload bullet scene if not set in inspector\n\tif bullet_scene == null:\n\t\tbullet_scene = preload(\"res://scenes/projectiles/Bullet.tscn\")\n\n\n## Initialize health with random value between min and max.\nfunc _initialize_health() -> void:\n\t_max_health = randi_range(min_health, max_health)\n\t_current_health = _max_health\n\t_is_alive = true\n\n\n## Initialize ammunition with full magazine and reserve ammo.\nfunc _initialize_ammo() -> void:\n\t_current_ammo = magazine_size\n\t# Reserve ammo is (total_magazines - 1) * magazine_size since one magazine is loaded\n\t_reserve_ammo = (total_magazines - 1) * magazine_size\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\n## Setup patrol points based on patrol offsets from initial position.\nfunc _setup_patrol_points() -> void:\n\t_patrol_points.clear()\n\t_patrol_points.append(_initial_position)\n\tfor offset in patrol_offsets:\n\t\t_patrol_points.append(_initial_position + offset)\n\n\n## Setup wall detection raycasts for obstacle avoidance.\nfunc _setup_wall_detection() -> void:\n\t# Create multiple raycasts spread in front of the enemy\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_wall_raycasts.append(raycast)\n\n\n## Setup cover detection raycasts for finding cover positions.\nfunc _setup_cover_detection() -> void:\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_cover_raycasts.append(raycast)\n\n\n## Setup threat sphere for detecting nearby bullets.\nfunc _setup_threat_sphere() -> void:\n\t_threat_sphere = Area2D.new()\n\t_threat_sphere.name = \"ThreatSphere\"\n\t_threat_sphere.collision_layer = 0\n\t_threat_sphere.collision_mask = 16  # Detect projectiles (layer 5)\n\n\tvar collision_shape := CollisionShape2D.new()\n\tvar circle_shape := CircleShape2D.new()\n\tcircle_shape.radius = threat_sphere_radius\n\tcollision_shape.shape = circle_shape\n\t_threat_sphere.add_child(collision_shape)\n\n\tadd_child(_threat_sphere)\n\n\t# Connect signals\n\t_threat_sphere.area_entered.connect(_on_threat_area_entered)\n\t_threat_sphere.area_exited.connect(_on_threat_area_exited)\n\n\n## Initialize GOAP world state.\nfunc _initialize_goap_state() -> void:\n\t_goap_world_state = {\n\t\t\"player_visible\": false,\n\t\t\"has_cover\": false,\n\t\t\"in_cover\": false,\n\t\t\"under_fire\": false,\n\t\t\"health_low\": false,\n\t\t\"can_flank\": false,\n\t\t\"at_flank_position\": false,\n\t\t\"is_retreating\": false,\n\t\t\"hits_taken\": 0,\n\t\t\"is_pursuing\": false,\n\t\t\"is_assaulting\": false,\n\t\t\"can_hit_from_cover\": false,\n\t\t\"player_close\": false,\n\t\t\"enemies_in_combat\": 0,\n\t\t\"has_search_zone\": false,\n\t\t\"search_zone_cleared\": false,\n\t\t\"inspection_points_remaining\": 0,\n\t\t\"is_searching\": false\n\t}\n\n\n## Connect to GameManager's debug mode signal for F7 toggle.\nfunc _connect_debug_mode_signal() -> void:\n\tvar game_manager: Node = get_node_or_null(\"/root/GameManager\")\n\tif game_manager:\n\t\t# Connect to debug mode toggle signal\n\t\tif game_manager.has_signal(\"debug_mode_toggled\"):\n\t\t\tgame_manager.debug_mode_toggled.connect(_on_debug_mode_toggled)\n\t\t# Sync with current debug mode state\n\t\tif game_manager.has_method(\"is_debug_mode_enabled\"):\n\t\t\tdebug_label_enabled = game_manager.is_debug_mode_enabled()\n\n\n## Called when debug mode is toggled via F7 key.\nfunc _on_debug_mode_toggled(enabled: bool) -> void:\n\tdebug_label_enabled = enabled\n\t_update_debug_label()\n\n\n## Find the player node in the scene tree.\nfunc _find_player() -> void:\n\t# Try to find the player by group first\n\tvar players := get_tree().get_nodes_in_group(\"player\")\n\tif players.size() > 0:\n\t\t_player = players[0]\n\t\treturn\n\n\t# Fallback: search for player by node name or type\n\tvar root := get_tree().current_scene\n\tif root:\n\t\t_player = _find_player_recursive(root)\n\n\n## Recursively search for a player node.\nfunc _find_player_recursive(node: Node) -> Node2D:\n\tif node.name == \"Player\" and node is Node2D:\n\t\treturn node\n\tfor child in node.get_children():\n\t\tvar result := _find_player_recursive(child)\n\t\tif result:\n\t\t\treturn result\n\treturn null\n\n\nfunc _physics_process(delta: float) -> void:\n\tif not _is_alive:\n\t\treturn\n\n\t# Update shoot cooldown timer\n\t_shoot_timer += delta\n\n\t# Update reload timer\n\t_update_reload(delta)\n\n\t# Check for player visibility and try to find player if not found\n\tif _player == null:\n\t\t_find_player()\n\n\t_check_player_visibility()\n\t_update_goap_state()\n\t_update_suppression(delta)\n\n\t# Process AI state machine\n\t_process_ai_state(delta)\n\n\t# Update debug label if enabled\n\t_update_debug_label()\n\n\t# Request redraw for debug visualization\n\tif debug_label_enabled:\n\t\tqueue_redraw()\n\n\tmove_and_slide()\n\n\n## Update GOAP world state based on current conditions.\nfunc _update_goap_state() -> void:\n\t_goap_world_state[\"player_visible\"] = _can_see_player\n\t_goap_world_state[\"under_fire\"] = _under_fire\n\t_goap_world_state[\"health_low\"] = _get_health_percent() < 0.5\n\t_goap_world_state[\"in_cover\"] = _current_state == AIState.IN_COVER\n\t_goap_world_state[\"has_cover\"] = _has_valid_cover\n\t_goap_world_state[\"is_retreating\"] = _current_state == AIState.RETREATING\n\t_goap_world_state[\"hits_taken\"] = _hits_taken_in_encounter\n\t_goap_world_state[\"is_pursuing\"] = _current_state == AIState.PURSUING\n\t_goap_world_state[\"is_assaulting\"] = _current_state == AIState.ASSAULT\n\t_goap_world_state[\"player_close\"] = _is_player_close()\n\t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n\t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()\n\t_goap_world_state[\"has_search_zone\"] = _search_zone_active\n\t_goap_world_state[\"search_zone_cleared\"] = not _search_zone_active and _last_known_player_position != Vector2.ZERO\n\t_goap_world_state[\"inspection_points_remaining\"] = _inspection_points.size() - _current_inspection_index\n\t_goap_world_state[\"is_searching\"] = _current_state == AIState.SEARCHING\n\n\n## Update suppression state.\nfunc _update_suppression(delta: float) -> void:\n\t# Clean up destroyed bullets from tracking\n\t_bullets_in_threat_sphere = _bullets_in_threat_sphere.filter(func(b): return is_instance_valid(b))\n\n\t# Determine if there's an active threat (bullets in sphere OR recent threat memory)\n\tvar has_active_threat := not _bullets_in_threat_sphere.is_empty() or _threat_memory_timer > 0.0\n\n\tif not has_active_threat:\n\t\tif _under_fire:\n\t\t\t_suppression_timer += delta\n\t\t\tif _suppression_timer >= suppression_cooldown:\n\t\t\t\t_under_fire = false\n\t\t\t\t_suppression_timer = 0.0\n\t\t\t\t_log_debug(\"Suppression ended\")\n\t\t# Reset threat reaction timer when no bullets are in threat sphere and no threat memory\n\t\t_threat_reaction_timer = 0.0\n\t\t_threat_reaction_delay_elapsed = false\n\telse:\n\t\t# Decrement threat memory timer if no bullets currently in sphere\n\t\tif _bullets_in_threat_sphere.is_empty() and _threat_memory_timer > 0.0:\n\t\t\t_threat_memory_timer -= delta\n\n\t\t# Update threat reaction timer\n\t\tif not _threat_reaction_delay_elapsed:\n\t\t\t_threat_reaction_timer += delta\n\t\t\tif _threat_reaction_timer >= threat_reaction_delay:\n\t\t\t\t_threat_reaction_delay_elapsed = true\n\t\t\t\t_log_debug(\"Threat reaction delay elapsed, now reacting to bullets\")\n\n\t\t# Only set under_fire after the reaction delay has elapsed\n\t\tif _threat_reaction_delay_elapsed:\n\t\t\t_under_fire = true\n\t\t\t_suppression_timer = 0.0\n\n\n## Update reload state.\nfunc _update_reload(delta: float) -> void:\n\tif not _is_reloading:\n\t\treturn\n\n\t_reload_timer += delta\n\tif _reload_timer >= reload_time:\n\t\t_finish_reload()\n\n\n## Start reloading the weapon.\nfunc _start_reload() -> void:\n\t# Can't reload if already reloading or no reserve ammo\n\tif _is_reloading or _reserve_ammo <= 0:\n\t\treturn\n\n\t_is_reloading = true\n\t_reload_timer = 0.0\n\treload_started.emit()\n\t_log_debug(\"Reloading... (%d reserve ammo)\" % _reserve_ammo)\n\n\n## Finish the reload process.\nfunc _finish_reload() -> void:\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\t# Calculate how many rounds to load\n\tvar ammo_needed := magazine_size - _current_ammo\n\tvar ammo_to_load := mini(ammo_needed, _reserve_ammo)\n\n\t_reserve_ammo -= ammo_to_load\n\t_current_ammo += ammo_to_load\n\n\treload_finished.emit()\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\t_log_debug(\"Reload complete. Magazine: %d/%d, Reserve: %d\" % [_current_ammo, magazine_size, _reserve_ammo])\n\n\n## Check if the enemy can shoot (has ammo and not reloading).\nfunc _can_shoot() -> bool:\n\t# Can't shoot if reloading\n\tif _is_reloading:\n\t\treturn false\n\n\t# Can't shoot if no ammo in magazine\n\tif _current_ammo <= 0:\n\t\t# Try to start reload if we have reserve ammo\n\t\tif _reserve_ammo > 0:\n\t\t\t_start_reload()\n\t\telse:\n\t\t\t# No ammo at all - emit depleted signal once\n\t\t\tif not _goap_world_state.get(\"ammo_depleted\", false):\n\t\t\t\t_goap_world_state[\"ammo_depleted\"] = true\n\t\t\t\tammo_depleted.emit()\n\t\t\t\t_log_debug(\"All ammunition depleted!\")\n\t\treturn false\n\n\treturn true\n\n\n## Process the AI state machine.\nfunc _process_ai_state(delta: float) -> void:\n\tvar previous_state := _current_state\n\n\t# State transitions based on conditions\n\tmatch _current_state:\n\t\tAIState.IDLE:\n\t\t\t_process_idle_state(delta)\n\t\tAIState.COMBAT:\n\t\t\t_process_combat_state(delta)\n\t\tAIState.SEEKING_COVER:\n\t\t\t_process_seeking_cover_state(delta)\n\t\tAIState.IN_COVER:\n\t\t\t_process_in_cover_state(delta)\n\t\tAIState.FLANKING:\n\t\t\t_process_flanking_state(delta)\n\t\tAIState.SUPPRESSED:\n\t\t\t_process_suppressed_state(delta)\n\t\tAIState.RETREATING:\n\t\t\t_process_retreating_state(delta)\n\t\tAIState.PURSUING:\n\t\t\t_process_pursuing_state(delta)\n\t\tAIState.ASSAULT:\n\t\t\t_process_assault_state(delta)\n\t\tAIState.SEARCHING:\n\t\t\t_process_searching_state(delta)\n\n\tif previous_state != _current_state:\n\t\tstate_changed.emit(_current_state)\n\t\t_log_debug(\"State changed: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\t\t# Also log to file for exported build debugging\n\t\t_log_to_file(\"State: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\n\n## Process IDLE state - patrol or guard behavior.\nfunc _process_idle_state(delta: float) -> void:\n\t# Transition to combat if player is visible\n\tif _can_see_player and _player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Execute idle behavior\n\tmatch behavior_mode:\n\t\tBehaviorMode.PATROL:\n\t\t\t_process_patrol(delta)\n\t\tBehaviorMode.GUARD:\n\t\t\t_process_guard(delta)\n\n\n## Process COMBAT state - approach player for direct contact, shoot for 2-3 seconds, return to cover.\n## Implements the combat cycling behavior: exit cover -> exposed shooting -> return to cover.\n## Phase 0 (seeking clear shot): If bullet spawn blocked, move out from cover to find clear shot.\n## Phase 1 (approaching): Move toward player to get into direct contact range.\n## Phase 2 (exposed): Stand and shoot for 2-3 seconds.\n## Phase 3: Return to cover via SEEKING_COVER state.\nfunc _process_combat_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies in combat (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can't see player, transition to SEARCHING to investigate last-known position\n\tif not _can_see_player:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to SEARCHING\")\n\t\t_transition_to_searching()\n\t\treturn\n\n\t# Update detection delay timer\n\tif not _detection_delay_elapsed:\n\t\t_detection_timer += delta\n\t\tif _detection_timer >= detection_delay:\n\t\t\t_detection_delay_elapsed = true\n\n\t# If we don't have cover, find some first (needed for returning later)\n\tif not _has_valid_cover and enable_cover:\n\t\t_find_cover_position()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found cover at %s for combat cycling\" % _cover_position)\n\n\t# Check player distance for approach/exposed phase decisions\n\tvar distance_to_player := INF\n\tif _player:\n\t\tdistance_to_player = global_position.distance_to(_player.global_position)\n\n\t# Check if we have a clear shot (no wall blocking bullet spawn)\n\tvar direction_to_player := Vector2.ZERO\n\tvar has_clear_shot := true\n\tif _player:\n\t\tdirection_to_player = (_player.global_position - global_position).normalized()\n\t\thas_clear_shot = _is_bullet_spawn_clear(direction_to_player)\n\n\t# If already exposed (shooting phase), handle shooting and timer\n\tif _combat_exposed:\n\t\t_combat_shoot_timer += delta\n\n\t\t# Check if exposure time is complete - go back to cover\n\t\tif _combat_shoot_timer >= _combat_shoot_duration and _has_valid_cover:\n\t\t\t_log_debug(\"Combat exposure time complete (%.1fs), returning to cover\" % _combat_shoot_duration)\n\t\t\t_combat_exposed = false\n\t\t\t_combat_approaching = false\n\t\t\t_combat_shoot_timer = 0.0\n\t\t\t_transition_to_seeking_cover()\n\t\t\treturn\n\n\t\t# Check if we still have a clear shot - if not, move sideways to find one\n\t\tif _player and not has_clear_shot:\n\t\t\t# Bullet spawn is blocked - move sideways to find a clear shot position\n\t\t\tvar sidestep_dir := _find_sidestep_direction_for_clear_shot(direction_to_player)\n\t\t\tif sidestep_dir != Vector2.ZERO:\n\t\t\t\tvelocity = sidestep_dir * combat_move_speed * 0.7\n\t\t\t\trotation = direction_to_player.angle()  # Keep facing player while sidestepping\n\t\t\t\t_log_debug(\"COMBAT exposed: sidestepping to maintain clear shot\")\n\t\t\telse:\n\t\t\t\t# No sidestep works - stay still, the shot might clear up\n\t\t\t\tvelocity = Vector2.ZERO\n\t\t\treturn\n\n\t\t# In exposed phase with clear shot, stand still and shoot\n\t\tvelocity = Vector2.ZERO\n\n\t\t# Aim and shoot at player (only shoot after detection delay)\n\t\tif _player:\n\t\t\t_aim_at_player()\n\t\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot()\n\t\t\t\t_shoot_timer = 0.0\n\t\treturn\n\n\t# --- CLEAR SHOT SEEKING PHASE ---\n\t# If bullet spawn is blocked and we're not already exposed, we need to move out from cover\n\tif not has_clear_shot and _player:\n\t\t# Start seeking clear shot if not already doing so\n\t\tif not _seeking_clear_shot:\n\t\t\t_seeking_clear_shot = true\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Calculate target position: move perpendicular to player direction (around cover edge)\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\t_log_debug(\"COMBAT: bullet spawn blocked, seeking clear shot at %s\" % _clear_shot_target)\n\n\t\t_clear_shot_timer += delta\n\n\t\t# Check if we've exceeded the max time trying to find a clear shot\n\t\tif _clear_shot_timer >= CLEAR_SHOT_MAX_TIME:\n\t\t\t_log_debug(\"COMBAT: clear shot timeout, trying flanking\")\n\t\t\t_seeking_clear_shot = false\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Try flanking to get around the obstacle\n\t\t\tif enable_flanking:\n\t\t\t\t_transition_to_flanking()\n\t\t\telse:\n\t\t\t\t_transition_to_pursuing()\n\t\t\treturn\n\n\t\t# Move toward the clear shot target position\n\t\tvar distance_to_target := global_position.distance_to(_clear_shot_target)\n\t\tif distance_to_target > 15.0:\n\t\t\tvar move_direction := (_clear_shot_target - global_position).normalized()\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed\n\t\t\trotation = direction_to_player.angle()  # Keep facing player\n\n\t\t\t# Check if the new position now has a clear shot\n\t\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\t\t_log_debug(\"COMBAT: found clear shot position while moving\")\n\t\t\t\t_seeking_clear_shot = false\n\t\t\t\t_clear_shot_timer = 0.0\n\t\t\t\t# Continue to exposed phase check below\n\t\t\telse:\n\t\t\t\treturn  # Keep moving toward target\n\t\telse:\n\t\t\t# Reached target but still no clear shot - recalculate target\n\t\t\t_log_debug(\"COMBAT: reached target but no clear shot, recalculating\")\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\treturn\n\n\t# Reset seeking state if we now have a clear shot\n\tif _seeking_clear_shot and has_clear_shot:\n\t\t_log_debug(\"COMBAT: clear shot acquired\")\n\t\t_seeking_clear_shot = false\n\t\t_clear_shot_timer = 0.0\n\n\t# Determine if we should be in approach phase or exposed shooting phase\n\tvar in_direct_contact := distance_to_player <= COMBAT_DIRECT_CONTACT_DISTANCE\n\n\t# Enter exposed phase if we have a clear shot and are either close enough or have approached long enough\n\tif has_clear_shot and (in_direct_contact or _combat_approach_timer >= COMBAT_APPROACH_MAX_TIME):\n\t\t# Close enough AND have clear shot - start exposed shooting phase\n\t\t_combat_exposed = true\n\t\t_combat_approaching = false\n\t\t_combat_shoot_timer = 0.0\n\t\t_combat_approach_timer = 0.0\n\t\t# Randomize exposure duration between 2-3 seconds\n\t\t_combat_shoot_duration = randf_range(2.0, 3.0)\n\t\t_log_debug(\"COMBAT exposed phase started (distance: %.0f), will shoot for %.1fs\" % [distance_to_player, _combat_shoot_duration])\n\t\treturn\n\n\t# Need to approach player - move toward them\n\tif not _combat_approaching:\n\t\t_combat_approaching = true\n\t\t_combat_approach_timer = 0.0\n\t\t_log_debug(\"COMBAT approach phase started, moving toward player\")\n\n\t_combat_approach_timer += delta\n\n\t# Move toward player while approaching\n\tif _player:\n\t\tvar move_direction := direction_to_player\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = move_direction * combat_move_speed\n\t\trotation = direction_to_player.angle()  # Always face player\n\n\t\t# Can shoot while approaching (only after detection delay and if have clear shot)\n\t\tif has_clear_shot and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\n## Calculate a target position to exit cover and get a clear shot.\n## Returns a position that s
[2026-01-18T02:54:00.484Z] [INFO] hould allow the bullet spawn point to be unobstructed.\nfunc _calculate_clear_shot_exit_position(direction_to_player: Vector2) -> Vector2:\n\t# Calculate perpendicular directions to the player\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Try both perpendicular directions and pick the one that's more likely to work\n\t# Also blend with forward movement toward player to help navigate around cover\n\tvar best_position := global_position\n\tvar best_score := -1.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\t\t# Blend sidestep with forward movement for better cover navigation\n\t\tvar exit_dir: Vector2 = (sidestep_dir * 0.7 + direction_to_player * 0.3).normalized()\n\t\tvar test_position: Vector2 = global_position + exit_dir * CLEAR_SHOT_EXIT_DISTANCE\n\n\t\t# Score this position based on:\n\t\t# 1. Does it have a clear path? (no walls in the way)\n\t\t# 2. Would the bullet spawn be clear from there?\n\t\tvar score: float = 0.0\n\n\t\t# Check if we can move to this position\n\t\tif _has_clear_path_to(test_position):\n\t\t\tscore += 1.0\n\n\t\t# Check if bullet spawn would be clear from this position\n\t\t# This is a rough estimate - we check from the test position toward player\n\t\tvar world_2d := get_world_2d()\n\t\tif world_2d != null:\n\t\t\tvar space_state := world_2d.direct_space_state\n\t\t\tif space_state != null:\n\t\t\t\tvar check_distance := bullet_spawn_offset + 5.0\n\t\t\t\tvar query := PhysicsRayQueryParameters2D.new()\n\t\t\t\tquery.from = test_position\n\t\t\t\tquery.to = test_position + direction_to_player * check_distance\n\t\t\t\tquery.collision_mask = 4  # Only check obstacles\n\t\t\t\tquery.exclude = [get_rid()]\n\t\t\t\tvar result := space_state.intersect_ray(query)\n\t\t\t\tif result.is_empty():\n\t\t\t\t\tscore += 2.0  # Higher score for clear bullet spawn\n\n\t\tif score > best_score:\n\t\t\tbest_score = score\n\t\t\tbest_position = test_position\n\n\t# If no good position found, just move forward toward player\n\tif best_score < 0.5:\n\t\tbest_position = global_position + direction_to_player * CLEAR_SHOT_EXIT_DISTANCE\n\n\treturn best_position\n\n\n## Process SEEKING_COVER state - moving to cover position.\nfunc _process_seeking_cover_state(_delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, stay in combat\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're already hidden from the player (the main goal)\n\tif not _is_visible_from_player():\n\t\t_transition_to_in_cover()\n\t\t_log_debug(\"Hidden from player, entering cover state\")\n\t\treturn\n\n\t# Move towards cover\n\tvar direction := (_cover_position - global_position).normalized()\n\tvar distance := global_position.distance_to(_cover_position)\n\n\tif distance < 10.0:\n\t\t# Reached the cover position, but still visible - try to find better cover\n\t\tif _is_visible_from_player():\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\t# No better cover found, stay in combat\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\n\t# Apply wall avoidance\n\tvar avoidance := _check_wall_ahead(direction)\n\tif avoidance != Vector2.ZERO:\n\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\tvelocity = direction * combat_move_speed\n\trotation = direction.angle()\n\n\t# Can still shoot while moving to cover (only after detection delay)\n\tif _can_see_player and _player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t_aim_at_player()\n\t\t_shoot()\n\t\t_shoot_timer = 0.0\n\n\n## Process IN_COVER state - taking cover from enemy fire.\n## Decides next action based on:\n## 1. If under fire -> suppressed\n## 2. If player is close (can exit cover for direct contact) -> COMBAT\n## 3. If player is far but can hit from current position -> COMBAT (stay and shoot)\n## 4. If player is far and can't hit -> PURSUING (move cover-to-cover)\nfunc _process_in_cover_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# If still under fire, stay suppressed\n\tif _under_fire:\n\t\t_transition_to_suppressed()\n\t\treturn\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover\n\tif _is_visible_from_player():\n\t\t# If in alarm mode and can see player, fire a burst before escaping\n\t\tif _in_alarm_mode and _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"IN_COVER alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay in cover while firing burst\n\n\t\t# Burst complete or not in alarm mode, seek new cover\n\t\t_log_debug(\"Player flanked our cover position, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# Decision making based on player distance and visibility\n\tif _player:\n\t\tvar player_close := _is_player_close()\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\n\t\tif _can_see_player:\n\t\t\tif player_close:\n\t\t\t\t# Player is close - engage in combat (come out, shoot, go back)\n\t\t\t\t_log_debug(\"Player is close, transitioning to COMBAT\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\t# Player is far\n\t\t\t\tif can_hit:\n\t\t\t\t\t# Can hit from current position - come out and shoot\n\t\t\t\t\t# (Don't pursue, just transition to combat which will handle the cycling)\n\t\t\t\t\t_log_debug(\"Player is far but can hit from here, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\telse:\n\t\t\t\t\t# Can't hit from here - need to pursue (move cover-to-cover)\n\t\t\t\t\t_log_debug(\"Player is far and can't hit, transitioning to PURSUING\")\n\t\t\t\t\t_transition_to_pursuing()\n\t\t\t\t\treturn\n\n\t# If not under fire and can see player, engage (only shoot after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If player is no longer visible and not under fire, try pursuing\n\tif not _can_see_player and not _under_fire:\n\t\t_log_debug(\"Lost sight of player from cover, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\n\n## Process FLANKING state - attempting to flank the player using cover-to-cover movement.\n## Uses intermediate cover positions to navigate around obstacles instead of walking\n## directly toward the flank target.\nfunc _process_flanking_state(delta: float) -> void:\n\t# If under fire, retreat with shooting behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# If can see player, engage in combat\n\tif _can_see_player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\tif _player == null:\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# Recalculate flank position (player may have moved)\n\t_calculate_flank_position()\n\n\tvar distance_to_flank := global_position.distance_to(_flank_target)\n\n\t# Check if we've reached the flank target\n\tif distance_to_flank < 30.0:\n\t\t_log_debug(\"Reached flank position, engaging\")\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Check if we have direct line of sight to flank target (no obstacles)\n\tif _has_clear_path_to(_flank_target):\n\t\t# Direct path is clear - move directly toward flank target\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\t_has_flank_cover = false\n\t\treturn\n\n\t# Path is blocked - use cover-to-cover movement\n\n\t# If we're at a cover position, wait briefly before moving to next\n\tif _has_valid_cover and not _has_flank_cover:\n\t\t_flank_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _flank_cover_wait_timer >= FLANK_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover toward flank target\n\t\t\t_find_flank_cover_toward_target()\n\t\t\tif not _has_flank_cover:\n\t\t\t\t_log_debug(\"No flank cover found, attempting direct movement\")\n\t\t\t\t# No cover found - try direct movement with enhanced wall avoidance\n\t\t\t\tvar direction := (_flank_target - global_position).normalized()\n\t\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\t\tvelocity = direction * combat_move_speed\n\t\t\t\trotation = direction.angle()\n\t\t\t\t# Invalidate current cover to trigger new search next frame\n\t\t\t\t_has_valid_cover = false\n\t\treturn\n\n\t# If we have a flank cover target, move toward it\n\tif _has_flank_cover:\n\t\tvar direction := (_flank_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_flank_next_cover)\n\n\t\t# Check if we've reached the flank cover\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached flank cover at distance %.1f\" % distance)\n\t\t\t_has_flank_cover = false\n\t\t\t_flank_cover_wait_timer = 0.0\n\t\t\t_cover_position = _flank_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no flank cover target - find initial flank cover\n\t_find_flank_cover_toward_target()\n\tif not _has_flank_cover:\n\t\t# Can't find cover, try direct movement with wall avoidance\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\n\n## Process SUPPRESSED state - staying in cover under fire.\nfunc _process_suppressed_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover even while suppressed\n\tif _is_visible_from_player():\n\t\t# In suppressed state we're always in alarm mode - fire a burst before escaping if we can see player\n\t\tif _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"SUPPRESSED alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay suppressed while firing burst\n\n\t\t# Burst complete or can't see player, seek new cover\n\t\t_log_debug(\"Player flanked our cover position while suppressed, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Can still shoot while suppressed (only after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If no longer under fire, exit suppression\n\tif not _under_fire:\n\t\t_transition_to_in_cover()\n\n\n## Process RETREATING state - moving to cover with behavior based on damage taken.\nfunc _process_retreating_state(delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, transition to combat or suppressed\n\t\t\tif _under_fire:\n\t\t\t\t_transition_to_suppressed()\n\t\t\telse:\n\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we've reached cover and are hidden from player\n\tif not _is_visible_from_player():\n\t\t_log_debug(\"Reached cover during retreat\")\n\t\t# Reset encounter hits when successfully reaching cover\n\t\t_hits_taken_in_encounter = 0\n\t\t_transition_to_in_cover()\n\t\treturn\n\n\t# Calculate direction to cover\n\tvar direction_to_cover := (_cover_position - global_position).normalized()\n\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\n\t# Check if reached cover position\n\tif distance_to_cover < 10.0:\n\t\tif _is_visible_from_player():\n\t\t\t# Still visible, find better cover\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\tif _under_fire:\n\t\t\t\t\t_transition_to_suppressed()\n\t\t\t\telse:\n\t\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Apply retreat behavior based on mode\n\tmatch _retreat_mode:\n\t\tRetreatMode.FULL_HP:\n\t\t\t_process_retreat_full_hp(delta, direction_to_cover)\n\t\tRetreatMode.ONE_HIT:\n\t\t\t_process_retreat_one_hit(delta, direction_to_cover)\n\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t_process_retreat_multiple_hits(delta, direction_to_cover)\n\n\n## Process FULL_HP retreat: walk backwards facing player, shoot with reduced accuracy,\n## periodically turn toward cover.\nfunc _process_retreat_full_hp(delta: float, direction_to_cover: Vector2) -> void:\n\t_retreat_turn_timer += delta\n\n\tif _retreat_turning_to_cover:\n\t\t# Turning to face cover, don't shoot\n\t\tif _retreat_turn_timer >= RETREAT_TURN_DURATION:\n\t\t\t_retreat_turning_to_cover = false\n\t\t\t_retreat_turn_timer = 0.0\n\n\t\t# Face cover and move toward it\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\telse:\n\t\t# Face player and back up (walk backwards)\n\t\tif _retreat_turn_timer >= RETREAT_TURN_INTERVAL:\n\t\t\t_retreat_turning_to_cover = true\n\t\t\t_retreat_turn_timer = 0.0\n\t\t\t_log_debug(\"FULL_HP retreat: turning to check cover\")\n\n\t\tif _player:\n\t\t\t# Face the player\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\t_aim_at_player()\n\n\t\t\t# Move backwards (opposite of player direction = toward cover generally)\n\t\t\t# Use the negative of the direction we're facing for \"backing up\"\n\t\t\tvar move_direction := -direction_to_player\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed * 0.7  # Slower when backing up\n\n\t\t\t# Shoot with reduced accuracy (only after detection delay)\n\t\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot_with_inaccuracy()\n\t\t\t\t_shoot_timer = 0.0\n\n\n## Process ONE_HIT retreat: quick burst of 2-4 shots in an arc while turning, then face cover.\nfunc _process_retreat_one_hit(delta: float, direction_to_cover: Vector2) -> void:\n\tif not _retreat_burst_complete:\n\t\t# During burst phase\n\t\t_retreat_burst_timer += delta\n\n\t\tif _player and _retreat_burst_remaining > 0 and _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t# Fire a burst shot with arc spread\n\t\t\t_shoot_burst_shot()\n\t\t\t_retreat_burst_remaining -= 1\n\t\t\t_retreat_burst_timer = 0.0\n\n\t\t\t# Progress through the arc\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0  # Spread across 4 shots max\n\n\t\t# Gradually turn from player to cover during burst\n\t\tif _player:\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\tvar target_angle: float\n\n\t\t\t# Interpolate rotation from player direction to cover direction\n\t\t\tvar burst_progress := 1.0 - (float(_retreat_burst_remaining) / 4.0)\n\t\t\tvar player_angle := direction_to_player.angle()\n\t\t\tvar cover_angle := direction_to_cover.angle()\n\t\t\ttarget_angle = lerp_angle(player_angle, cover_angle, burst_progress * 0.7)\n\t\t\trotation = target_angle\n\n\t\t# Move toward cover (slower during burst)\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed * 0.5\n\n\t\t# Check if burst is complete\n\t\tif _retreat_burst_remaining <= 0:\n\t\t\t_retreat_burst_complete = true\n\t\t\t_log_debug(\"ONE_HIT retreat: burst complete, now running to cover\")\n\telse:\n\t\t# After burst, run to cover without shooting\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\n\n## Process MULTIPLE_HITS retreat: quick burst of 2-4 shots then run to cover (same as ONE_HIT).\nfunc _process_retreat_multiple_hits(delta: float, direction_to_cover: Vector2) -> void:\n\t# Same behavior as ONE_HIT - quick burst then escape\n\t_process_retreat_one_hit(delta, direction_to_cover)\n\n\n## Process PURSUING state - move cover-to-cover toward player.\n## Enemy moves between covers, waiting 1-2 seconds at each cover,\n## until they can see and hit the player.\nfunc _process_pursuing_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected during pursuit (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can see player and can hit them from current position, engage\n\tif _can_see_player and _player:\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\t\tif can_hit:\n\t\t\t_log_debug(\"Can see and hit player from pursuit, transitioning to COMBAT\")\n\t\t\t_has_pursuit_cover = false\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're waiting at cover\n\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t# Currently at cover, wait for 1-2 seconds before moving to next cover\n\t\t_pursuit_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _pursuit_cover_wait_timer >= PURSUIT_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover closer to player\n\t\t\t_log_debug(\"Pursuit wait complete, finding next cover\")\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_find_pursuit_cover_toward_player()\n\t\t\tif _has_pursuit_cover:\n\t\t\t\t_log_debug(\"Found pursuit cover at %s\" % _pursuit_next_cover)\n\t\t\telse:\n\t\t\t\t# No pursuit cover found - fallback behavior\n\t\t\t\t_log_debug(\"No pursuit cover found, checking fallback options\")\n\t\t\t\t# If we can now see the player, engage directly\n\t\t\t\tif _can_see_player:\n\t\t\t\t\t_log_debug(\"Can see player, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\t# Try flanking\n\t\t\t\tif enable_flanking and _player:\n\t\t\t\t\t_log_debug(\"Attempting flanking maneuver\")\n\t\t\t\t\t_transition_to_flanking()\n\t\t\t\t\treturn\n\t\t\t\t# Last resort: move directly toward player\n\t\t\t\t_log_debug(\"No cover options, moving directly toward player\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\treturn\n\n\t# If we have a pursuit cover target, move toward it\n\tif _has_pursuit_cover:\n\t\tvar direction := (_pursuit_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_pursuit_next_cover)\n\n\t\t# Check if we've reached the pursuit cover\n\t\t# Note: We only check distance here, NOT visibility from player.\n\t\t# If we checked visibility, the enemy would immediately consider themselves\n\t\t# \"at cover\" even before moving, since they start hidden from player.\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached pursuit cover at distance %.1f\" % distance)\n\t\t\t_has_pursuit_cover = false\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_cover_position = _pursuit_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no pursuit target - find initial pursuit cover\n\t_find_pursuit_cover_toward_player()\n\tif not _has_pursuit_cover:\n\t\t# Can't find cover to pursue, try flanking or combat\n\t\tif enable_flanking and _player:\n\t\t\t_transition_to_flanking()\n\t\telse:\n\t\t\t_transition_to_combat()\n\n\n## Process ASSAULT state - coordinated multi-enemy rush.\n## Wait at cover for 5 seconds, then all enemies rush the player simultaneously.\nfunc _process_assault_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover and not _assault_ready:\n\t\t_in_assault = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if we're the only enemy left in assault - switch back to combat\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat < 2 and not _assault_ready:\n\t\t_log_debug(\"Not enough enemies for assault, switching to COMBAT\")\n\t\t_in_assault = false\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Find closest cover to player if we don't have one\n\tif not _has_valid_cover:\n\t\t_find_cover_closest_to_player()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found assault cover at %s\" % _cover_position)\n\n\t# Move to cover position first\n\tif _has_valid_cover and not _in_assault:\n\t\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\t\tif distance_to_cover > 15.0 and _is_visible_from_player():\n\t\t\t# Still need to reach cover\n\t\t\tvar direction := (_cover_position - global_position).normalized()\n\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\tvelocity = direction * combat_move_speed\n\t\t\trotation = direction.angle()\n\t\t\treturn\n\n\t# At cover, wait for assault timer\n\tif not _assault_ready:\n\t\tvelocity = Vector2.ZERO\n\t\t_assault_wait_timer += delta\n\n\t\t# Check if all assault enemies are ready (synchronized assault)\n\t\tif _assault_wait_timer >= ASSAULT_WAIT_DURATION:\n\t\t\t# Check if situation has changed - player might have moved\n\t\t\tif _player and _is_player_close():\n\t\t\t\t_assault_ready = true\n\t\t\t\t_in_assault = true\n\t\t\t\t_log_debug(\"ASSAULT ready - rushing player!\")\n\t\t\telse:\n\t\t\t\t# Player moved away, reset timer and check if we should pursue\n\t\t\t\t_log_debug(\"Player moved away during assault wait, resetting\")\n\t\t\t\t_assault_wait_timer = 0.0\n\t\t\t\t_in_assault = false\n\t\t\t\t_transition_to_pursuing()\n\t\t\t\treturn\n\t\treturn\n\n\t# Assault phase - rush the player while shooting\n\tif _assault_ready and _player:\n\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction_to_player)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_player = (direction_to_player * 0.5 + avoidance * 0.5).normalized()\n\n\t\t# Rush at full speed\n\t\tvelocity = direction_to_player * combat_move_speed\n\t\trotation = direction_to_player.angle()\n\n\t\t# Update detection delay timer\n\t\tif not _detection_delay_elapsed:\n\t\t\t_detection_timer += delta\n\t\t\tif _detection_timer >= detection_delay:\n\t\t\t\t_detection_delay_elapsed = true\n\n\t\t# Shoot while rushing (only after detection delay)\n\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t\t# If very close to player, stay in combat\n\t\tif distance_to_player < 50.0:\n\t\t\t_log_debug(\"Assault complete - reached player\")\n\t\t\t_assault_ready = false\n\t\t\t_in_assault = false\n\t\t\t_transition_to_combat()\n\n\n## Shoot with reduced accuracy for retreat mode.\nfunc _shoot_with_inaccuracy() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Check if the shot should be taken\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Add inaccuracy spread\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD, RETREAT_INACCURACY_SPREAD)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the inaccurate shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Inaccurate shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Shoot a burst shot with arc spread for ONE_HIT retreat.\nfunc _shoot_burst_shot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Apply arc offset for burst spread\n\tdirection = direction.rotated(_retreat_burst_angle_offset)\n\n\t# Also add some random inaccuracy on top of the arc\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD * 0.5, RETREAT_INACCURACY_SPREAD * 0.5)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the burst shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Burst shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Transition to IDLE state.\nfunc _transition_to_idle() -> void:\n\t_current_state = AIState.IDLE\n\t# Reset encounter hit tracking when returning to idle\n\t_hits_taken_in_encounter = 0\n\t# Reset alarm mode when returning to idle\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\n\n## Transition to COMBAT state.\nfunc _transition_to_combat() -> void:\n\t_current_state = AIState.COMBAT\n\t# Reset detection delay timer when entering combat\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Reset combat phase variables\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_shoot_timer = 0.0\n\t_combat_approach_timer = 0.0\n\t# Reset clear shot seeking variables\n\t_seeking_clear_shot = false\n\t_clear_shot_timer = 0.0\n\t_clear_shot_target = Vector2.ZERO\n\n\n## Transition to SEEKING_COVER state.\nfunc _transition_to_seeking_cover() -> void:\n\t_current_state = AIState.SEEKING_COVER\n\t_find_cover_position()\n\n\n## Transition to IN_COVER state.\nfunc _transition_to_in_cover() -> void:\n\t_current_state = AIState.IN_COVER\n\n\n## Transition to FLANKING state.\nfunc _transition_to_flanking() -> void:\n\t_current_state = AIState.FLANKING\n\t_calculate_flank_position()\n\t_flank_cover_wait_timer = 0.0\n\t_has_flank_cover = false\n\t_has_valid_cover = false\n\n\n## Transition to SUPPRESSED state.\nfunc _transition_to_suppressed() -> void:\n\t_current_state = AIState.SUPPRESSED\n\t# Enter alarm mode when suppressed\n\t_in_alarm_mode = true\n\n\n## Transition to PURSUING state.\nfunc _transition_to_pursuing() -> void:\n\t_current_state = AIState.PURSUING\n\t_pursuit_cover_wait_timer = 0.0\n\t_has_pursuit_cover = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\n\n## Transition to ASSAULT state.\nfunc _transition_to_assault() -> void:\n\t_current_state = AIState.ASSAULT\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Find closest cover to player for assault position\n\t_find_cover_closest_to_player()\n\n\n## Transition to RETREATING state with appropriate retreat mode.\nfunc _transition_to_retreating() -> void:\n\t_current_state = AIState.RETREATING\n\t# Enter alarm mode when retreating\n\t_in_alarm_mode = true\n\n\t# Determine retreat mode based on hits taken\n\tif _hits_taken_in_encounter == 0:\n\t\t_retreat_mode = RetreatMode.FULL_HP\n\t\t_retreat_turn_timer = 0.0\n\t\t_retreat_turning_to_cover = false\n\t\t_log_debug(\"Entering RETREATING state: FULL_HP mode (shoot while backing up)\")\n\telif _hits_taken_in_encounter == 1:\n\t\t_retreat_mode = RetreatMode.ONE_HIT\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t# Calculate arc spread: shots will be distributed across the arc\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: ONE_HIT mode (burst of %d shots)\" % _retreat_burst_remaining)\n\telse:\n\t\t_retreat_mode = RetreatMode.MULTIPLE_HITS\n\t\t# Multiple hits also gets burst fire (same as ONE_HIT)\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: MULTIPLE_HITS mode (burst of %d shots)\" % _retreat_burst_remaining)\n\n\t# Find cover position for retreating\n\t_find_cover_position()\n\n\n## Transition to SEARCHING state.\n## Activates the search zone and generates inspection points.\nfunc _transition_to_searching() -> void:\n\t_current_state = AIState.SEARCHING\n\t_search_timer = 0.0\n\t_inspection_wait_timer = 0.0\n\t_inspecting_point = false\n\t_current_inspection_index = 0\n\n\t# Activate search zone at last known player position\n\tif _last_known_player_position != Vector2.ZERO:\n\t\t_search_zone_active = true\n\t\t_log_debug(\"Activating search zone at %s (radius: %.1f)\" % [_last_known_player_position, SEARCH_ZONE_RADIUS])\n\t\t# Generate inspection points within the search zone\n\t\t_generate_inspection_points()\n\telse:\n\t\t# No last known position - fall back to pursuing\n\t\t_log_debug(\"No last known position, falling back to PURSUING\")\n\t\t_transition_to_pursuing()\n\n\n## Clear the search zone when player is found or search is complete.\nfunc _clear_search_zone() -> void:\n\t_search_zone_active = false\n\t_inspection_points.clear()\n\t_current_inspection_index = 0\n\t_inspecting_point = false\n\t_log_debug(\"Search zone cleared\")\n\n\n## Generate inspection points within the search zone.\n## Finds hiding spots behind covers and at corners within the search area.\nfunc _generate_inspection_points() -> void:\n\t_inspection_points.clear()\n\n\tif _last_known_player_position == Vector2.ZERO:\n\t\treturn\n\n\tvar search_center := _last_known_player_position\n\n\t# Use raycasts from the search center to find obstacles and generate inspection points\n\tfor i in range(INSPECTION_POINT_CHECK_COUNT):\n\t\tvar angle := (float(i) / INSPECTION_POINT_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\t# Cast ray from search center outward to find obstacles\n\t\tvar space_state := get_world_2d().direct_space_state\n\t\tvar query := PhysicsRayQueryParameters2D.new()\n\t\tquery.from = search_center\n\t\tquery.to = search_center + direction * INSPECTION_CHECK_DISTANCE\n\t\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\n\t\tvar result := space_state.intersect_ray(query)\n\n\t\tif not result.is_empty():\n\t\t\tvar collision_point: Vector2 = result[\"position\"]\n\t\t\tvar collision_normal: Vector2 = result[\"normal\"]\n\n\t\t\t# Generate inspection point behind the obstacle (from enemy's perspective)\n\t\t\t# This is where a player might hide\n\t\t\tvar inspection_pos := collision_point + collision_normal * 40.0\n\n\t\t\t# Only add if within search zone radius\n\t\t\tif inspection_pos.distance_to(search_center) <= SEARCH_ZONE_RADIUS:\n\t\t\t\t# Avoid duplicate or too-close points\n\t\t\t\tvar is_duplicate := false\n\t\t\t\tfor existing_point in _inspection_points:\n\t\t\t\t\tif inspection_pos.distance_to(existing_point) < 50.0:\n\t\t\t\t\t\tis_duplicate = true\n\t\t\t\t\t\tbreak\n\t\t\t\tif not is_duplicate:\n\t\t\t\t\t_inspection_points.append(inspection_pos)\n\n\t# Add corners of the search zone as additional inspection points\n\tvar corner_offsets := [\n\t\tVector2(SEARCH_ZONE_RADIUS * 0.7, SEARCH_ZONE_RADIUS * 0.7),\n\t\tVector2(-SEARCH_ZONE_RADIUS * 0.7, SEARCH_ZONE_RADIUS * 0.7),\n\t\tVector2(SEARCH_ZONE_RADIUS * 0.7, -SEARCH_ZONE_RADIUS * 0.7),\n\t\tVector2(-SEARCH_ZONE_RADIUS * 0.7, -SEARCH_ZONE_RADIUS * 0.7),\n\t]\n\n\tfor offset in corner_offsets:\n\t\tvar corner_point := search_center + offset\n\t\t# Only add corner if we can reach it (no obstacle blocking direct path)\n\t\tif _has_clear_path_to(corner_point):\n\t\t\tvar is_duplicate := false\n\t\t\tfor existing_point in _inspection_points:\n\t\t\t\tif corner_point.distance_to(existing_point) < 50.0:\n\t\t\t\t\tis_duplicate = true\n\t\t\t\t\tbreak\n\t\t\tif not is_duplicate:\n\t\t\t\t_inspection_points.append(corner_point)\n\n\t# Sort inspection points by distance from current position (closest first)\n\t_inspection_points.sort_custom(func(a: Vector2, b: Vector2) -> bool:\n\t\treturn global_position.distance_to(a) < global_position.distance_to(b)\n\t)\n\n\t_log_debug(\"Generated %d inspection points in search zone\" % _inspection_points.size())\n\n\n## Process SEARCHING state - investigate last-known player position and check hiding spots.\n## Enemy moves to last-known position, then checks each inspection point within the search zone.\n## Returns to IDLE when all points are checked or timeout expires.\nfunc _process_searching_state(delta: float) -> void:\n\t# If player is spotted during search, immediately transition to combat\n\tif _can_see_player:\n\t\t_log_debug(\"Player found during search, transitioning to COMBAT\")\n\t\t_clear_search_zone()\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Check for suppression - if under fire, need to take cover\n\tif _under_fire and enable_cover:\n\t\t_log_debug(\"Under fire during search, transitioning to RETREATING\")\n\t\t_clear_search_zone()\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Update search timer\n\t_search_timer += delta\n\n\t# Timeout - give up searching and return to patrol/guard\n\tif _search_timer >= SEARCH_MAX_DURATION:\n\t\t_log_debug(\"Search timeout reached, returning to IDLE\")\n\t\t_clear_search_zone()\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# If no inspection points left, search is complete\n\tif _inspection_points.is_empty() or _current_inspection_index >= _inspection_points.size():\n\t\t_log_debug(\"All inspection points checked, search zone cleared\")\n\t\t_clear_search_zone()\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# Get current inspection point target\n\tvar current_target := _inspection_points[_current_inspection_index]\n\tvar distance_to_target := global_position.distance_to(current_target)\n\n\t# Check if we're at the current inspection point\n\tif distance_to_target < 20.0:\n\t\tif not _inspecting_point:\n\t\t\t# Just arrived at inspection point - start looking around\n\t\t\t_inspecting_point = true\n\t\t\t_inspection_wait_timer = 0.0\n\t\t\t_log_debug(\"Inspecting point %d/%d at %s\" % [_current_inspection_index + 1, _inspection_points.size(), current_target])\n\n\t\t# Wait at the inspection point, looking around\n\t\t_inspection_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\t# Rotate while inspecting (looking around)\n\t\trotation += rotation_speed * delta * 0.5\n\n\t\tif _inspection_wait_timer >= INSPECTION_WAIT_DURATION:\n\t\t\t# Done inspecting this point, move to next\n\t\t\t_current_inspection_index += 1\n\t\t\t_inspecting_point = false\n\t\t\t_inspection_wait_timer = 0.0\n\t\treturn\n\n\t# Move toward current inspection point\n\tvar direction := (current_target - global_position).normalized()\n\n\t# Apply wall avoidance\n\tvar avoidance := _check_wall_ahead(direction)\n\tif avoidance != Vector2.ZERO:\n\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\tvelocity = direction * combat_move_speed * 0.8  # Slightly slower when searching\n\trotation = direction.angle()\n\n\n## Check if the enemy is visible from the player's position.\n## Uses raycasting from player to enemy to determine if there are obstacles blocking line of sight.\n## This is the inverse of _can_see_player - it checks if the PLAYER can see the ENEMY.\n## Checks multiple points on the enemy body (center and corners) to account for enemy size.\nfunc _is_visible_from_player() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check visibility to multiple points on the enemy body\n\t# This accounts for the enemy's size - corners can stick out from cover\n\tvar check_points := _get_enemy_check_points(global_position)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Get multiple check points on the enemy body for visibility testing.\n## Returns center and 4 corner points offset by the enemy's radius.\nfunc _get_enemy_check_points(center: Vector2) -> Array[Vector2]:\n\t# Enemy collision radius is 24, sprite is 48x48\n\t# Use a slightly smaller radius to avoid edge cases\n\tconst ENEMY_RADIUS: float = 22.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := ENEMY_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point is visible from the player's position.\nfunc _is_point_visible_from_player(point: Vector2) -> bool:\n\tif _player == null:\n\t\treturn false\n\n\tvar player_pos := _player.global_position\n\tvar distance := player_pos.distance_to(point)\n\n\t# Use direct space state to check line of sight from player to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = player_pos\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = []\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between player and point - point is visible\n\t\treturn true\n\telse:\n\t\t# Check if we hit an obstacle before reaching the point\n\t\tvar hit_position: Vector2 = result[\"position\"]\n\t\tvar distance_to_hit := player_pos.distance_to(hit_position)\n\n\t\t# If we hit something closer than the point, the point is hidden\n\t\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t\treturn false\n\t\telse:\n\t\t\treturn true\n\n\n## Check if a specific position would make the enemy visible from the player's position.\n## Checks all enemy body points (center and corners) to account for enemy size.\n## Used to validate cover positions before moving to them.\nfunc _is_position_visible_from_player(pos: Vector2) -> bool:\n\tif _player == null:\n\t\treturn true  # Assume visible if no player\n\n\t# Check visibility for all enemy body points at the given position\n\tvar check_points := _get_enemy_check_points(pos)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Check if a target position is visible from the enemy's perspective.\n## Uses raycast to verify there are no obstacles between enemy and the target position.\n## This is used to validate lead prediction targets - enemies should only aim at\n## positions they can actually see.\nfunc _is_position_visible_to_enemy(target_pos: Vector2) -> bool:\n\tvar distance := global_position.distance_to(target_pos)\n\n\t# Use direct space state to check line of sight from enemy to target\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = target_pos\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and target - position is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t# Hit obstacle before target - position is NOT visible\n\t\t_log_debug(\"Position %s blocked by obstacle at distance %.1f (target at %.1f)\" % [target_pos, distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Get multiple check points on the player's body for visibility testing.\n## Returns center and 4 corner points offset by the player's radius.\n## The player has a collision radius of 16 pixels (from Player.tscn).\nfunc _get_player_check_points(center: Vector2) -> Array[Vector2]:\n\t# Player collision radius is 16, sprite is 32x32\n\t# Use a slightly smaller radius to be conservative\n\tconst PLAYER_RADIUS: float = 14.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := PLAYER_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point on the player is visible from the enemy's position.\n## Uses direct space state query to check for obstacles blocking line of sight.\nfunc _is_player_point_visible_to_enemy(point: Vector2) -> bool:\n\tvar distance := global_position.distance_to(point)\n\n\t# Use direct space state to check line of sight from enemy to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and point - point is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the point\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\t# If we hit something before the point, the point is blocked\n\tif distance_to_hit < distance - 5.0:  # 5 pixel tolerance\n\t\treturn false\n\n\treturn true\n\n\n## Calculate what fraction of the player's body is visible to the enemy.\n## Returns a value from 0.0 (completely hidden) to 1.0 (fully visible).\n## Checks multiple points on the player's body (center + corners).\nfunc _calculate_player_visibility_ratio() -> float:\n\tif _player == null:\n\t\treturn 0.0\n\n\tvar check_points := _get_player_check_points(_player.global_position)\n\tvar visible_count := 0\n\n\tfor point in check_points:\n\t\tif _is_player_point_visible_to_enemy(point):\n\t\t\tvisible_count += 1\n\n\treturn float(visible_count) / float(check_points.size())\n\n\n## Check if the line of fire to the target position is clear of other enemies.\n## Returns true if no other enemies would be hit by a bullet traveling to the target.\nfunc _is_firing_line_clear_of_friendlies(target_position: Vector2) -> bool:\n\tif not enable_friendly_fire_avoidance:\n\t\treturn true\n\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if any enemies are in the firing line\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 2  # Only check enemies (layer 2)\n\tquery.exclude = [get_rid()]  # Exclude self using RID\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No enemies in the way\n\n\t# Check if the hit position is before the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 20.0:  # 20 pixel tolerance\n\t\t_log_debug(\"Friendly in firing line at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if a bullet fired at the target position would be blocked by cover/obstacles.\n## Returns true if the shot would likely hit the target, false if blocked by cover.\nfunc _is_shot_clear_of_cover(target_position: Vector2) -> bool:\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if obstacles block the shot\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No obstacles in the way\n\n\t# Check if the obstacle is before the target position\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t_log_debug(\"Shot blocked by cover at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if there's an obstacle immediately in front of the enemy that would block bullets.\n## This prevents shooting into walls that the enemy is flush against or very close to.\n## Uses a single raycast from enemy center to the bullet spawn position.\nfunc _is_bullet_spawn_clear(direction: Vector2) -> bool:\n\t# Fail-open: allow shooting if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn true\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn true\n\n\t# Check from enemy center to bullet spawn position plus a small buffer\n\tvar check_distance := bullet_spawn_offset + 5.0\n\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = global_position + direction * check_distance\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]\n\n\tvar result := space_state.intersect_ray(query)\n\tif not result.is_empty():\n\t\t_log_debug(\"Bullet spawn blocked: wall at distance %.1f\" % [\n\t\t\tglobal_position.distance_to(result[\"position\"])])\n\t\treturn false\n\n\treturn true\n\n\n## Find a sidestep direction that would lead to a clear shot position.\n## Checks perpendicular directions to the player and returns the first one\n## that would allow the bullet spawn point to be clear.\n## Returns Vector2.ZERO if no clear direction is found.\nfunc _find_sidestep_direction_for_clear_shot(direction_to_player: Vector2) -> Vector2:\n\t# Fail-safe: allow normal behavior if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn Vector2.ZERO\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn Vector2.ZERO\n\n\t# Check perpendicular directions (left and right of the player direction)\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Check both sidestep directions and pick the one that leads to clear shot faster\n\tvar check_distance := 50.0  # Check if moving 50 pixels in this direction would help\n\tvar bullet_check_distance := bullet_spawn_offset + 5.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:  # Try both sides\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\n\t\t# First check if we can actually move in this direction (no wall blocking movement)\n\t\tvar move_query := PhysicsRayQueryParameters2D.new()\n\t\tmove_query.from = global_position\n\t\tmove_query.to = global_position + sidestep_dir * 30.0\n\t\tmove_query.collision_mask = 4  # Only check obstacles\n\t\tmove_query.exclude = [get_rid()]\n\n\t\tvar move_result := space_state.intersect_ray(move_query)\n\t\tif not move_result.is_empty():\n\t\t\tcontinue  # Can't move this way, wall is blocking\n\n\t\t# Check if after sidestepping, we'd have a clear shot\n\t\tvar test_position: Vector2 = global_position + sidestep_dir * check_distance\n\t\tvar shot_query := PhysicsRayQueryParameters2D.new()\n\t\tshot_query.from = test_position\n\t\tshot_query.to = test_position + direction_to_player * bullet_check_distance\n\t\tshot_query.collision_mask = 4\n\t\tshot_query.exclude = [get_rid()]\n\n\t\tvar shot_result := space_state.intersect_ray(shot_query)\n\t\tif shot_result.is_empty():\n\t\t\t# Found a direction that leads to a clear shot\n\t\t\t_log_debug(\"Found sidestep direction: %s\" % sidestep_dir)\n\t\t\treturn sidestep_dir\n\n\treturn Vector2.ZERO  # No clear sidestep direction found\n\n\n## Check if the enemy should shoot at the current target.\n## Validates bullet spawn clearance, friendly fire avoidance, and cover blocking.\nfunc _should_shoot_at_target(target_position: Vector2) -> bool:\n\t# Check if the immediate path to bullet spawn is clear\n\t# This prevents shooting into walls the enemy is flush against\n\tvar direction := (target_position - global_position).normalized()\n\tif not _is_bullet_spawn_clear(direction):\n\t\treturn false\n\n\t# Check if friendlies are in the way\n\tif not _is_firing_line_clear_of_friendlies(target_position):\n\t\treturn false\n\n\t# Check if cover blocks the shot\n\tif not _is_shot_clear_of_cover(target_position):\n\t\treturn false\n\n\treturn true\n\n\n## Check if the player is \"close\" (within CLOSE_COMBAT_DISTANCE).\n## Used to determine if the enemy should engage directly or pursue.\nfunc _is_player_close() -> bool:\n\tif _player == null:\n\t\treturn false\n\treturn global_position.distance_to(_player.global_position) <= CLOSE_COMBAT_DISTANCE\n\n\n## Check if the enemy can hit the player from their current position.\n## Returns true if there's a clear line of fire to the player.\nfunc _can_hit_player_from_current_position() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check if we can see the player\n\tif not _can_see_player:\n\t\treturn false\n\n\t# Check if the shot would be blocked by cover\n\treturn _is_shot_clear_of_cover(_player.global_position)\n\n\n## Count the number of enemies currently in combat-related states.\n## Includes COMBAT, PURSUING, ASSAULT, IN_COVER (if can see player).\n## Used to determine if multi-enemy assault should be triggered.\nfunc _count_enemies_in_combat() -> int:\n\tvar count := 0\n\tvar enemies := get_tree().get_nodes_in_group(\"enemies\")\n\n\tfor enemy in enemies:\n\t\tif enemy == self:\n\t\t\tcontinue\n\t\tif not enemy.has_method(\"get_current_state\"):\n\t\t\tcontinue\n\n\t\tvar state: AIState = enemy.get_current_state()\n\t\t# Count enemies in combat-related states\n\t\tif state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\t\t# For IN_COVER, only count if they can see the player\n\t\t\tif state == AIState.IN_COVER:\n\t\t\t\tif enemy.has_method(\"is_in_combat_engagement\") and enemy.is_in_combat_engagement():\n\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tcount += 1\n\n\t# Count self if in a combat-related state\n\tif _current_state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\tcount += 1\n\n\treturn count\n\n\n## Check if this enemy is engaged in combat (can see player and in combat state).\nfunc is_in_combat_engagement() -> bool:\n\treturn _can_see_player and _current_state in [AIState.COMBAT, AIState.IN_COVER, AIState.ASSAULT]\n\n\n## Find cover position closer to the player for pursuit.\n## Used during PURSUING state to move cover-to-cover toward the player.\nfunc _find_pursuit_cover_toward_player() -> void:\n\tif _player == null:\n\t\t_has_pursuit_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For pursuit, we want cover that is:\n\t\t\t# 1. Closer to the player than we currently are\n\t\t\t# 2. Hidden from the player (or mostly hidden)\n\t\t\t# 3. Not too far from our current position\n\n\t\t\tvar my_distance_to_player := global_position.distance_to(player_pos)\n\t\t\tvar cover_distance_to_player := cover_pos.distance_to(player_pos)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to player\n\t\t\tif cover_distance_to_player >= my_distance_to_player:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if this position is hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Hidden from player (priority)\n\t\t\t# - Closer to player\n\t\t\t# - Not too far from current position\n\t\t\tvar hidden_score: float = 5.0 if is_hidden else 0.0\n\t\t\tvar approach_score: float = (my_distance_to_player - cover_distance_to_player) / CLOSE_COMBAT_DISTANCE\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = hidden_score + approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_pursuit_next_cover = best_cover\n\t\t_has_pursuit_cover = true\n\t\t_log_debug(\"Found pursuit cover at %s (score: %.2f)\" % [_pursuit_next_cover, best_score])\n\telse:\n\t\t_has_pursuit_cover = false\n\n\n## Find cover position closest to the player for assault positioning.\n## Used during ASSAULT state to take the nearest safe cover to the player.\nfunc _find_cover_closest_to_player() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_distance: float = INF\n\tvar found_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# Check if this position is hidden from player (safe cover)\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\tif is_hidden:\n\t\t\t\t# Calculate distance from this cover to the player\n\t\t\t\tvar distance_to_player := cover_pos.distance_to(player_pos)\n\n\t\t\t\t# We want the cover closest to the player\n\t\t\t\tif distance_to_player < best_distance:\n\t\t\t\t\tbest_distance = distance_to_player\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\t\tfound_cover = true\n\n\tif found_cover:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found assault cover at %s (distance to player: %.1f)\" % [_cover_position, best_distance])\n\telse:\n\t\t# Fall back to normal cover finding\n\t\t_find_cover_position()\n\n\n## Find a valid cover position relative to the player.\n## The cover position must be hidden from the player's line of sight.\nfunc _find_cover_position() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_hidden_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is on the opposite side of the obstacle from player\n\t\t\tvar direction_from_player := (collision_point - player_pos).normalized()\n\n\t\t\t# Position behind cover (offset from collision point along normal)\n\t\t\t# Offset must be large enough to hide the entire enemy body (radius ~24 pixels)\n\t\t\t# Using 35 pixels to provide some margin for the enemy's collision shape\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# First priority: Check if this position is actually hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Only consider hidden positions unless we have no choice\n\t\t\tif is_hidden or not found_hidden_cover:\n\t\t\t\t# Score based on:\n\t\t\t\t# 1. Whether position is hidden (highest priority)\n\t\t\t\t# 2. Distance from enemy (closer is better)\n\t\t\t\t# 3. Position relative to player (behind cover from player's view)\n\t\t\t\tvar hidden_score: float = 10.0 if is_hidden else 0.0  # Heavy weight for hidden positions\n\n\t\t\t\tvar distance_score := 1.0 - (global_position.distance_to(cover_pos) / COVER_CHECK_DISTANCE)\n\n\t\t\t\t# Check if this position is on the far side of obstacle from player\n\t\t\t\tvar cover_direction := (cover_pos - player_pos).normalized()\n\t\t\t\tvar dot_product := direction_from_player.dot(cover_direction)\n\t\t\t\tvar blocking_score: float = maxf(0.0, dot_product)\n\n\t\t\t\tvar total_score: float = hidden_score + distance_score * 0.3 + blocking_score * 0.7\n\n\t\t\t\t# If we find a hidden position, only accept other hidden positions\n\t\t\t\tif is_hidden and not found_hidden_cover:\n\t\t\t\t\tfound_hidden_cover = true\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\telif (is_hidden or not found_hidden_cover) and total_score > best_score:\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\n\tif best_score > 0:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found cover at: %s (hidden: %s)\" % [_cover_position, found_hidden_cover])\n\telse:\n\t\t_has_valid_cover = false\n\n\n## Calculate flank position based on player location.\nfunc _calculate_flank_position() -> void:\n\tif _player == null:\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar player_to_enemy := (global_position - player_pos).normalized()\n\n\t# Choose left or right flank based on current position\n\tvar flank_side := 1.0 if randf() > 0.5 else -1.0\n\tvar flank_direction := player_to_enemy.rotated(flank_angle * flank_side)\n\n\t_flank_target = player_pos + flank_direction * flank_distance\n\t_log_debug(\"Flank target: %s\" % _flank_target)\n\n\n## Check if there's a clear path (no obstacles) to the target position.\n## Uses a raycast to check for walls/obstacles between current position and target.\nfunc _has_clear_path_to(target: Vector2) -> bool:\n\tif _raycast == null:\n\t\treturn true  # Assume clear if no raycast available\n\n\tvar direction := (target - global_position).normalized()\n\tvar distance := global_position.distance_to(target)\n\n\t_raycast.target_position = direction * distance\n\t_raycast.force_raycast_update()\n\n\t# If we hit something, path is blocked\n\tif _raycast.is_colliding():\n\t\tvar collision_point := _raycast.get_collision_point()\n\t\tvar collision_distance := global_position.distance_to(collision_point)\n\t\t# Only consider it blocked if the collision is before the target\n\t\treturn collision_distance >= distance - 10.0\n\n\treturn true\n\n\n## Find cover position closer to the flank target.\n## Used during FLANKING state to move cover-to-cover toward the flank position.\nfunc _find_flank_cover_toward_target() -> void:\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction
[2026-01-18T02:54:00.489Z] [INFO]  := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For flanking, we want cover that is:\n\t\t\t# 1. Closer to the flank target than we currently are\n\t\t\t# 2. Not too far from our current position\n\t\t\t# 3. Reachable (has clear path)\n\n\t\t\tvar my_distance_to_target := global_position.distance_to(_flank_target)\n\t\t\tvar cover_distance_to_target := cover_pos.distance_to(_flank_target)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to flank target\n\t\t\tif cover_distance_to_target >= my_distance_to_target:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if we can reach this cover (has clear path)\n\t\t\tif not _has_clear_path_to(cover_pos):\n\t\t\t\t# Even if direct path is blocked, we might be able to reach\n\t\t\t\t# via another intermediate cover, but skip for now\n\t\t\t\tcontinue\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Closer to flank target (priority)\n\t\t\t# - Not too far from current position\n\t\t\tvar approach_score: float = (my_distance_to_target - cover_distance_to_target) / flank_distance\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_flank_next_cover = best_cover\n\t\t_has_flank_cover = true\n\t\t_log_debug(\"Found flank cover at %s (score: %.2f)\" % [_flank_next_cover, best_score])\n\telse:\n\t\t_has_flank_cover = false\n\n\n## Check if there's a wall ahead in the given direction and return avoidance direction.\n## Returns Vector2.ZERO if no wall detected, otherwise returns a vector to avoid the wall.\nfunc _check_wall_ahead(direction: Vector2) -> Vector2:\n\tif _wall_raycasts.is_empty():\n\t\treturn Vector2.ZERO\n\n\tvar avoidance := Vector2.ZERO\n\tvar perpendicular := Vector2(-direction.y, direction.x)  # 90 degrees rotation\n\n\t# Check center, left, and right raycasts\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar angle_offset := (i - 1) * 0.5  # -0.5, 0, 0.5 radians (~-28, 0, 28 degrees)\n\t\tvar check_direction := direction.rotated(angle_offset)\n\n\t\tvar raycast := _wall_raycasts[i]\n\t\traycast.target_position = check_direction * WALL_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\t# Calculate avoidance based on which raycast hit\n\t\t\tif i == 0:  # Left raycast hit\n\t\t\t\tavoidance += perpendicular  # Steer right\n\t\t\telif i == 1:  # Center raycast hit\n\t\t\t\tavoidance += perpendicular if randf() > 0.5 else -perpendicular  # Random steer\n\t\t\telif i == 2:  # Right raycast hit\n\t\t\t\tavoidance -= perpendicular  # Steer left\n\n\treturn avoidance.normalized() if avoidance.length() > 0 else Vector2.ZERO\n\n\n## Check if the player is visible using raycast.\n## If detection_range is 0 or negative, uses unlimited detection range (line-of-sight only).\n## This allows the enemy to see the player even outside the viewport if there's no obstacle.\n## Also updates the continuous visibility timer and visibility ratio for lead prediction control.\nfunc _check_player_visibility() -> void:\n\tvar was_visible := _can_see_player\n\t_can_see_player = false\n\t_player_visibility_ratio = 0.0\n\n\tif _player == null or not _raycast:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t# Check if player is within detection range (only if detection_range is positive)\n\t# If detection_range <= 0, detection is unlimited (line-of-sight only)\n\tif detection_range > 0 and distance_to_player > detection_range:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\t# Point raycast at player - use actual distance to player for the raycast length\n\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\tvar raycast_length := distance_to_player + 10.0  # Add small buffer to ensure we reach player\n\t_raycast.target_position = direction_to_player * raycast_length\n\t_raycast.force_raycast_update()\n\n\t# Check if raycast hit something\n\tif _raycast.is_colliding():\n\t\tvar collider := _raycast.get_collider()\n\t\t# If we hit the player, we can see them\n\t\tif collider == _player:\n\t\t\t_can_see_player = true\n\t\t# If we hit a wall/obstacle before the player, we can't see them\n\telse:\n\t\t# No collision between us and player - we have clear line of sight\n\t\t_can_see_player = true\n\n\t# Update continuous visibility timer and visibility ratio\n\tif _can_see_player:\n\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n\t\t# Calculate what fraction of the player's body is visible\n\t\t# This is used to determine if lead prediction should be enabled\n\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n\t\t# Update last known player position while we can see them\n\t\t_last_known_player_position = _player.global_position\n\t\t# Clear search zone when player is seen\n\t\tif _search_zone_active:\n\t\t\t_clear_search_zone()\n\telse:\n\t\t# Lost line of sight - reset the timer and visibility ratio\n\t\t_continuous_visibility_timer = 0.0\n\t\t_player_visibility_ratio = 0.0\n\t\t# If we just lost sight and were in combat, activate search zone\n\t\tif was_visible and _last_known_player_position != Vector2.ZERO:\n\t\t\t_log_debug(\"Player escaped from view at %s\" % _last_known_player_position)\n\n\n## Aim the enemy sprite/direction at the player using gradual rotation.\nfunc _aim_at_player() -> void:\n\tif _player == null:\n\t\treturn\n\tvar direction := (_player.global_position - global_position).normalized()\n\tvar target_angle := direction.angle()\n\n\t# Calculate the shortest rotation direction\n\tvar angle_diff := wrapf(target_angle - rotation, -PI, PI)\n\n\t# Get the delta time from the current physics process\n\tvar delta := get_physics_process_delta_time()\n\n\t# Apply gradual rotation based on rotation_speed\n\tif abs(angle_diff) <= rotation_speed * delta:\n\t\t# Close enough to snap to target\n\t\trotation = target_angle\n\telif angle_diff > 0:\n\t\trotation += rotation_speed * delta\n\telse:\n\t\trotation -= rotation_speed * delta\n\n\n## Shoot a bullet towards the player.\nfunc _shoot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\t# Check if we can shoot (have ammo and not reloading)\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Apply lead prediction if enabled\n\tif enable_lead_prediction:\n\t\ttarget_position = _calculate_lead_prediction()\n\n\t# Check if the shot should be taken (friendly fire and cover checks)\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Create bullet instance\n\tvar bullet := bullet_scene.instantiate()\n\n\t# Set bullet position with offset in shoot direction\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\n\t# Set bullet direction\n\tbullet.direction = direction\n\n\t# Set shooter ID to identify this enemy as the source\n\t# This prevents enemies from detecting their own bullets in the threat sphere\n\tbullet.shooter_id = get_instance_id()\n\n\t# Add bullet to the scene tree\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play shooting sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\n\t# Play shell casing sound with a small delay\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\t# Auto-reload when magazine is empty\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Play shell casing sound with a delay to simulate the casing hitting the ground.\nfunc _play_delayed_shell_sound() -> void:\n\tawait get_tree().create_timer(0.15).timeout\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_shell_rifle\"):\n\t\taudio_manager.play_shell_rifle(global_position)\n\n\n## Calculate lead prediction - aims where the player will be, not where they are.\n## Uses iterative approach for better accuracy with moving targets.\n## Only applies lead prediction if:\n## 1. The player has been continuously visible for at least lead_prediction_delay seconds\n## 2. At least lead_prediction_visibility_threshold of the player's body is visible\n## 3. The predicted position is also visible to the enemy (not behind cover)\n## This prevents enemies from \"knowing\" where the player will emerge from cover.\nfunc _calculate_lead_prediction() -> Vector2:\n\tif _player == null:\n\t\treturn global_position\n\n\tvar player_pos := _player.global_position\n\n\t# Only use lead prediction if the player has been continuously visible\n\t# for long enough. This prevents enemies from predicting player position\n\t# immediately when they emerge from cover.\n\tif _continuous_visibility_timer < lead_prediction_delay:\n\t\t_log_debug(\"Lead prediction disabled: visibility time %.2fs < %.2fs required\" % [_continuous_visibility_timer, lead_prediction_delay])\n\t\treturn player_pos\n\n\t# Only use lead prediction if enough of the player's body is visible.\n\t# This prevents pre-firing when the player is at the edge of cover with only\n\t# a small part of their body visible. The player must be significantly exposed\n\t# before the enemy can predict their movement.\n\tif _player_visibility_ratio < lead_prediction_visibility_threshold:\n\t\t_log_debug(\"Lead prediction disabled: visibility ratio %.2f < %.2f required (player at cover edge)\" % [_player_visibility_ratio, lead_prediction_visibility_threshold])\n\t\treturn player_pos\n\n\tvar player_velocity := Vector2.ZERO\n\n\t# Get player velocity if they are a CharacterBody2D\n\tif _player is CharacterBody2D:\n\t\tplayer_velocity = _player.velocity\n\n\t# If player is stationary, no need for prediction\n\tif player_velocity.length_squared() < 1.0:\n\t\treturn player_pos\n\n\t# Iterative lead prediction for better accuracy\n\t# Start with player's current position\n\tvar predicted_pos := player_pos\n\tvar distance := global_position.distance_to(predicted_pos)\n\n\t# Iterate 2-3 times for convergence\n\tfor i in range(3):\n\t\t# Time for bullet to reach the predicted position\n\t\tvar time_to_target := distance / bullet_speed\n\n\t\t# Predict where player will be at that time\n\t\tpredicted_pos = player_pos + player_velocity * time_to_target\n\n\t\t# Update distance for next iteration\n\t\tdistance = global_position.distance_to(predicted_pos)\n\n\t# CRITICAL: Validate that the predicted position is actually visible to the enemy.\n\t# If the predicted position is behind cover (e.g., player is running toward cover exit),\n\t# we should NOT aim there - it would feel like the enemy is \"cheating\" by knowing\n\t# where the player will emerge. Fall back to player's current visible position.\n\tif not _is_position_visible_to_enemy(predicted_pos):\n\t\t_log_debug(\"Lead prediction blocked: predicted position %s is not visible, using current position %s\" % [predicted_pos, player_pos])\n\t\treturn player_pos\n\n\t_log_debug(\"Lead prediction: player at %s moving %s, aiming at %s\" % [player_pos, player_velocity, predicted_pos])\n\n\treturn predicted_pos\n\n\n## Process patrol behavior - move between patrol points.\nfunc _process_patrol(delta: float) -> void:\n\tif _patrol_points.is_empty():\n\t\treturn\n\n\t# Handle waiting at patrol point\n\tif _is_waiting_at_patrol_point:\n\t\t_patrol_wait_timer += delta\n\t\tif _patrol_wait_timer >= patrol_wait_time:\n\t\t\t_is_waiting_at_patrol_point = false\n\t\t\t_patrol_wait_timer = 0.0\n\t\t\t_current_patrol_index = (_current_patrol_index + 1) % _patrol_points.size()\n\t\tvelocity = Vector2.ZERO\n\t\treturn\n\n\t# Move towards current patrol point\n\tvar target_point := _patrol_points[_current_patrol_index]\n\tvar direction := (target_point - global_position).normalized()\n\tvar distance := global_position.distance_to(target_point)\n\n\tif distance < 5.0:\n\t\t# Reached patrol point, start waiting\n\t\t_is_waiting_at_patrol_point = true\n\t\tvelocity = Vector2.ZERO\n\telse:\n\t\t# Check for walls and apply avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\t# Blend movement direction with avoidance\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * move_speed\n\t\t# Face movement direction when patrolling\n\t\trotation = direction.angle()\n\n\n## Process guard behavior - stand still and look around.\nfunc _process_guard(_delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\t# In guard mode, enemy doesn't move but can still aim at player when visible\n\n\n## Called when a bullet enters the threat sphere.\nfunc _on_threat_area_entered(area: Area2D) -> void:\n\t# Check if bullet has shooter_id property and if it's from this enemy\n\t# This prevents enemies from being suppressed by their own bullets\n\tif \"shooter_id\" in area and area.shooter_id == get_instance_id():\n\t\treturn  # Ignore own bullets\n\n\t_bullets_in_threat_sphere.append(area)\n\t# Set threat memory timer so enemy can react even after fast bullets exit\n\t# This allows the reaction delay to complete even if bullets pass through quickly\n\t_threat_memory_timer = THREAT_MEMORY_DURATION\n\t# Note: _under_fire is now set in _update_suppression after threat_reaction_delay\n\t# This gives the player more time before the enemy reacts to nearby gunfire\n\t_log_debug(\"Bullet entered threat sphere, starting reaction delay...\")\n\n\n## Called when a bullet exits the threat sphere.\nfunc _on_threat_area_exited(area: Area2D) -> void:\n\t_bullets_in_threat_sphere.erase(area)\n\n\n## Called when the enemy is hit (by bullet.gd).\nfunc on_hit() -> void:\n\tif not _is_alive:\n\t\treturn\n\n\thit.emit()\n\n\t# Track hits for retreat behavior\n\t_hits_taken_in_encounter += 1\n\t_log_debug(\"Hit taken! Total hits in encounter: %d\" % _hits_taken_in_encounter)\n\t_log_to_file(\"Hit taken, health: %d/%d\" % [_current_health - 1, _max_health])\n\n\t# Show hit flash effect\n\t_show_hit_flash()\n\n\t# Apply damage\n\t_current_health -= 1\n\n\t# Play appropriate hit sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif _current_health <= 0:\n\t\t# Play lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_lethal\"):\n\t\t\taudio_manager.play_hit_lethal(global_position)\n\t\t_on_death()\n\telse:\n\t\t# Play non-lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_non_lethal\"):\n\t\t\taudio_manager.play_hit_non_lethal(global_position)\n\t\t_update_health_visual()\n\n\n## Shows a brief flash effect when hit.\nfunc _show_hit_flash() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t_sprite.modulate = hit_flash_color\n\n\tawait get_tree().create_timer(hit_flash_duration).timeout\n\n\t# Restore color based on current health (if still alive)\n\tif _is_alive:\n\t\t_update_health_visual()\n\n\n## Updates the sprite color based on current health percentage.\nfunc _update_health_visual() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t# Interpolate color based on health percentage\n\tvar health_percent := _get_health_percent()\n\t_sprite.modulate = full_health_color.lerp(low_health_color, 1.0 - health_percent)\n\n\n## Returns the current health as a percentage (0.0 to 1.0).\nfunc _get_health_percent() -> float:\n\tif _max_health <= 0:\n\t\treturn 0.0\n\treturn float(_current_health) / float(_max_health)\n\n\n## Called when the enemy dies.\nfunc _on_death() -> void:\n\t_is_alive = false\n\t_log_to_file(\"Enemy died\")\n\tdied.emit()\n\n\tif destroy_on_death:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\tqueue_free()\n\telse:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\t_reset()\n\n\n## Resets the enemy to its initial state.\nfunc _reset() -> void:\n\tglobal_position = _initial_position\n\trotation = 0.0\n\t_current_patrol_index = 0\n\t_is_waiting_at_patrol_point = false\n\t_patrol_wait_timer = 0.0\n\t_current_state = AIState.IDLE\n\t_has_valid_cover = false\n\t_under_fire = false\n\t_suppression_timer = 0.0\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t_continuous_visibility_timer = 0.0\n\t_player_visibility_ratio = 0.0\n\t_threat_reaction_timer = 0.0\n\t_threat_reaction_delay_elapsed = false\n\t_threat_memory_timer = 0.0\n\t_bullets_in_threat_sphere.clear()\n\t# Reset retreat state variables\n\t_hits_taken_in_encounter = 0\n\t_retreat_mode = RetreatMode.FULL_HP\n\t_retreat_turn_timer = 0.0\n\t_retreat_turning_to_cover = false\n\t_retreat_burst_remaining = 0\n\t_retreat_burst_timer = 0.0\n\t_retreat_burst_complete = false\n\t_retreat_burst_angle_offset = 0.0\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\t# Reset combat state variables\n\t_combat_shoot_timer = 0.0\n\t_combat_shoot_duration = 2.5\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_approach_timer = 0.0\n\t# Reset pursuit state variables\n\t_pursuit_cover_wait_timer = 0.0\n\t_pursuit_next_cover = Vector2.ZERO\n\t_has_pursuit_cover = false\n\t# Reset assault state variables\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset flank state variables\n\t_flank_cover_wait_timer = 0.0\n\t_flank_next_cover = Vector2.ZERO\n\t_has_flank_cover = false\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_initialize_goap_state()\n\n\n## Log debug message if debug_logging is enabled.\nfunc _log_debug(message: String) -> void:\n\tif debug_logging:\n\t\tprint(\"[Enemy %s] %s\" % [name, message])\n\n\n## Log a message to the file logger (always logs, regardless of debug_logging setting).\n## Use for important events like spawning, dying, or critical state changes.\nfunc _log_to_file(message: String) -> void:\n\tif not is_inside_tree():\n\t\treturn\n\tvar file_logger: Node = get_node_or_null(\"/root/FileLogger\")\n\tif file_logger and file_logger.has_method(\"log_enemy\"):\n\t\tfile_logger.log_enemy(name, message)\n\n\n## Log spawn info (called via call_deferred to ensure FileLogger is loaded).\nfunc _log_spawn_info() -> void:\n\t_log_to_file(\"Enemy spawned at %s, health: %d, behavior: %s, player_found: %s\" % [\n\t\tglobal_position, _max_health, BehaviorMode.keys()[behavior_mode],\n\t\t\"yes\" if _player != null else \"no\"])\n\n\n## Get AI state name as a human-readable string.\nfunc _get_state_name(state: AIState) -> String:\n\tmatch state:\n\t\tAIState.IDLE:\n\t\t\treturn \"IDLE\"\n\t\tAIState.COMBAT:\n\t\t\treturn \"COMBAT\"\n\t\tAIState.SEEKING_COVER:\n\t\t\treturn \"SEEKING_COVER\"\n\t\tAIState.IN_COVER:\n\t\t\treturn \"IN_COVER\"\n\t\tAIState.FLANKING:\n\t\t\treturn \"FLANKING\"\n\t\tAIState.SUPPRESSED:\n\t\t\treturn \"SUPPRESSED\"\n\t\tAIState.RETREATING:\n\t\t\treturn \"RETREATING\"\n\t\tAIState.PURSUING:\n\t\t\treturn \"PURSUING\"\n\t\tAIState.ASSAULT:\n\t\t\treturn \"ASSAULT\"\n\t\tAIState.SEARCHING:\n\t\t\treturn \"SEARCHING\"\n\t\t_:\n\t\t\treturn \"UNKNOWN\"\n\n\n## Update the debug label with current AI state.\nfunc _update_debug_label() -> void:\n\tif _debug_label == null:\n\t\treturn\n\n\t_debug_label.visible = debug_label_enabled\n\tif not debug_label_enabled:\n\t\treturn\n\n\tvar state_text := _get_state_name(_current_state)\n\n\t# Add retreat mode info if retreating\n\tif _current_state == AIState.RETREATING:\n\t\tmatch _retreat_mode:\n\t\t\tRetreatMode.FULL_HP:\n\t\t\t\tstate_text += \"\\n(FULL_HP)\"\n\t\t\tRetreatMode.ONE_HIT:\n\t\t\t\tstate_text += \"\\n(ONE_HIT)\"\n\t\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t\tstate_text += \"\\n(MULTI_HITS)\"\n\n\t# Add assault timer info if in assault state\n\tif _current_state == AIState.ASSAULT:\n\t\tif _assault_ready:\n\t\t\tstate_text += \"\\n(RUSHING)\"\n\t\telse:\n\t\t\tvar time_left := ASSAULT_WAIT_DURATION - _assault_wait_timer\n\t\t\tstate_text += \"\\n(%.1fs)\" % time_left\n\n\t# Add combat phase info if in combat\n\tif _current_state == AIState.COMBAT:\n\t\tif _combat_exposed:\n\t\t\tvar time_left := _combat_shoot_duration - _combat_shoot_timer\n\t\t\tstate_text += \"\\n(EXPOSED %.1fs)\" % time_left\n\t\telif _seeking_clear_shot:\n\t\t\tvar time_left := CLEAR_SHOT_MAX_TIME - _clear_shot_timer\n\t\t\tstate_text += \"\\n(SEEK SHOT %.1fs)\" % time_left\n\t\telif _combat_approaching:\n\t\t\tstate_text += \"\\n(APPROACH)\"\n\n\t# Add pursuit timer info if pursuing and waiting at cover\n\tif _current_state == AIState.PURSUING:\n\t\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t\tvar time_left := PURSUIT_COVER_WAIT_DURATION - _pursuit_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_pursuit_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\n\t# Add flanking phase info if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_valid_cover and not _has_flank_cover:\n\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_flank_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\t\telse:\n\t\t\tstate_text += \"\\n(DIRECT)\"\n\n\t_debug_label.text = state_text\n\n\n## Get current AI state (for external access/debugging).\nfunc get_current_state() -> AIState:\n\treturn _current_state\n\n\n## Get GOAP world state (for GOAP planner).\nfunc get_goap_world_state() -> Dictionary:\n\treturn _goap_world_state.duplicate()\n\n\n## Check if enemy is currently under fire.\nfunc is_under_fire() -> bool:\n\treturn _under_fire\n\n\n## Check if enemy is in cover.\nfunc is_in_cover() -> bool:\n\treturn _current_state == AIState.IN_COVER or _current_state == AIState.SUPPRESSED\n\n\n## Get current ammo in magazine.\nfunc get_current_ammo() -> int:\n\treturn _current_ammo\n\n\n## Get reserve ammo.\nfunc get_reserve_ammo() -> int:\n\treturn _reserve_ammo\n\n\n## Get total ammo (current + reserve).\nfunc get_total_ammo() -> int:\n\treturn _current_ammo + _reserve_ammo\n\n\n## Check if enemy is currently reloading.\nfunc is_reloading() -> bool:\n\treturn _is_reloading\n\n\n## Check if enemy has any ammo left.\nfunc has_ammo() -> bool:\n\treturn _current_ammo > 0 or _reserve_ammo > 0\n\n\n## Get current player visibility ratio (for debugging).\n## Returns 0.0 if player is completely hidden, 1.0 if fully visible.\nfunc get_player_visibility_ratio() -> float:\n\treturn _player_visibility_ratio\n\n\n## Draw debug visualization when debug mode is enabled.\n## Shows: line to target (cover, clear shot, player), bullet spawn point status.\nfunc _draw() -> void:\n\tif not debug_label_enabled:\n\t\treturn\n\n\t# Colors for different debug elements\n\tvar color_to_cover := Color.CYAN  # Line to cover position\n\tvar color_to_player := Color.RED  # Line to player (when visible)\n\tvar color_clear_shot := Color.YELLOW  # Line to clear shot target\n\tvar color_pursuit := Color.ORANGE  # Line to pursuit cover\n\tvar color_flank := Color.MAGENTA  # Line to flank position\n\tvar color_bullet_spawn := Color.GREEN  # Bullet spawn point indicator\n\tvar color_blocked := Color.RED  # Blocked path indicator\n\n\t# Draw line to player if visible\n\tif _can_see_player and _player:\n\t\tvar to_player := _player.global_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_player, color_to_player, 1.5)\n\n\t\t# Draw bullet spawn point and check if blocked\n\t\tvar direction_to_player := to_player.normalized()\n\t\tvar spawn_point := direction_to_player * bullet_spawn_offset\n\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\tdraw_circle(spawn_point, 5.0, color_bullet_spawn)\n\t\telse:\n\t\t\t# Draw X for blocked spawn point\n\t\t\tdraw_line(spawn_point + Vector2(-5, -5), spawn_point + Vector2(5, 5), color_blocked, 2.0)\n\t\t\tdraw_line(spawn_point + Vector2(-5, 5), spawn_point + Vector2(5, -5), color_blocked, 2.0)\n\n\t# Draw line to cover position if we have one\n\tif _has_valid_cover:\n\t\tvar to_cover := _cover_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_cover, color_to_cover, 1.5)\n\t\t# Draw small circle at cover position\n\t\tdraw_circle(to_cover, 8.0, color_to_cover)\n\n\t# Draw line to clear shot target if seeking clear shot\n\tif _seeking_clear_shot and _clear_shot_target != Vector2.ZERO:\n\t\tvar to_target := _clear_shot_target - global_position\n\t\tdraw_line(Vector2.ZERO, to_target, color_clear_shot, 2.0)\n\t\t# Draw triangle at target position\n\t\tvar target_pos := to_target\n\t\tdraw_line(target_pos + Vector2(-6, 6), target_pos + Vector2(6, 6), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(6, 6), target_pos + Vector2(0, -8), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(0, -8), target_pos + Vector2(-6, 6), color_clear_shot, 2.0)\n\n\t# Draw line to pursuit cover if pursuing\n\tif _current_state == AIState.PURSUING and _has_pursuit_cover:\n\t\tvar to_pursuit := _pursuit_next_cover - global_position\n\t\tdraw_line(Vector2.ZERO, to_pursuit, color_pursuit, 2.0)\n\t\tdraw_circle(to_pursuit, 8.0, color_pursuit)\n\n\t# Draw line to flank target if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_flank_cover:\n\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n\t\telif _flank_target != Vector2.ZERO:\n\t\t\tvar to_flank := _flank_target - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n\t\t\t# Draw diamond at flank target\n\t\t\tvar flank_pos := to_flank\n\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)\n","structuredPatch":[{"oldStart":3313,"oldLines":6,"newStart":3313,"newLines":14,"lines":["     else:","       state_text += \"\\n(DIRECT)\""," ","+  # Add searching phase info if searching","+  if _current_state == AIState.SEARCHING:","+    var time_left := SEARCH_MAX_DURATION - _search_timer","+    if _inspecting_point:","+      state_text += \"\\n(INSPECT %d/%d)\" % [_current_inspection_index + 1, _inspection_points.size()]","+    else:","+      state_text += \"\\n(%d pts %.1fs)\" % [_inspection_points.size() - _current_inspection_index, time_left]","+","   _debug_label.text = state_text"," "," "]}],"userModified":false,"replaceAll":false}}
[2026-01-18T02:54:03.075Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_012k1Dqo5C3neE8Qr7UpiYUE",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me add debug visualization for the SEARCHING state to the _draw function:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 1050,
      "cache_read_input_tokens": 97844,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1050,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 4,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "241aacbd-3d5c-4e4c-aa48-126abaa7ea8e"
}
[2026-01-18T02:54:03.669Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_012k1Dqo5C3neE8Qr7UpiYUE",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_016FFifc3T6NbMaiBkhAmLsG",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "offset": 3380,
          "limit": 100
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 1050,
      "cache_read_input_tokens": 97844,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1050,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 4,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "3beb29b0-93aa-4ae1-976e-755ff6baac06"
}
[2026-01-18T02:54:03.713Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_016FFifc3T6NbMaiBkhAmLsG",
        "type": "tool_result",
        "content": "  3380‚Üífunc _draw() -> void:\n  3381‚Üí\tif not debug_label_enabled:\n  3382‚Üí\t\treturn\n  3383‚Üí\n  3384‚Üí\t# Colors for different debug elements\n  3385‚Üí\tvar color_to_cover := Color.CYAN  # Line to cover position\n  3386‚Üí\tvar color_to_player := Color.RED  # Line to player (when visible)\n  3387‚Üí\tvar color_clear_shot := Color.YELLOW  # Line to clear shot target\n  3388‚Üí\tvar color_pursuit := Color.ORANGE  # Line to pursuit cover\n  3389‚Üí\tvar color_flank := Color.MAGENTA  # Line to flank position\n  3390‚Üí\tvar color_bullet_spawn := Color.GREEN  # Bullet spawn point indicator\n  3391‚Üí\tvar color_blocked := Color.RED  # Blocked path indicator\n  3392‚Üí\n  3393‚Üí\t# Draw line to player if visible\n  3394‚Üí\tif _can_see_player and _player:\n  3395‚Üí\t\tvar to_player := _player.global_position - global_position\n  3396‚Üí\t\tdraw_line(Vector2.ZERO, to_player, color_to_player, 1.5)\n  3397‚Üí\n  3398‚Üí\t\t# Draw bullet spawn point and check if blocked\n  3399‚Üí\t\tvar direction_to_player := to_player.normalized()\n  3400‚Üí\t\tvar spawn_point := direction_to_player * bullet_spawn_offset\n  3401‚Üí\t\tif _is_bullet_spawn_clear(direction_to_player):\n  3402‚Üí\t\t\tdraw_circle(spawn_point, 5.0, color_bullet_spawn)\n  3403‚Üí\t\telse:\n  3404‚Üí\t\t\t# Draw X for blocked spawn point\n  3405‚Üí\t\t\tdraw_line(spawn_point + Vector2(-5, -5), spawn_point + Vector2(5, 5), color_blocked, 2.0)\n  3406‚Üí\t\t\tdraw_line(spawn_point + Vector2(-5, 5), spawn_point + Vector2(5, -5), color_blocked, 2.0)\n  3407‚Üí\n  3408‚Üí\t# Draw line to cover position if we have one\n  3409‚Üí\tif _has_valid_cover:\n  3410‚Üí\t\tvar to_cover := _cover_position - global_position\n  3411‚Üí\t\tdraw_line(Vector2.ZERO, to_cover, color_to_cover, 1.5)\n  3412‚Üí\t\t# Draw small circle at cover position\n  3413‚Üí\t\tdraw_circle(to_cover, 8.0, color_to_cover)\n  3414‚Üí\n  3415‚Üí\t# Draw line to clear shot target if seeking clear shot\n  3416‚Üí\tif _seeking_clear_shot and _clear_shot_target != Vector2.ZERO:\n  3417‚Üí\t\tvar to_target := _clear_shot_target - global_position\n  3418‚Üí\t\tdraw_line(Vector2.ZERO, to_target, color_clear_shot, 2.0)\n  3419‚Üí\t\t# Draw triangle at target position\n  3420‚Üí\t\tvar target_pos := to_target\n  3421‚Üí\t\tdraw_line(target_pos + Vector2(-6, 6), target_pos + Vector2(6, 6), color_clear_shot, 2.0)\n  3422‚Üí\t\tdraw_line(target_pos + Vector2(6, 6), target_pos + Vector2(0, -8), color_clear_shot, 2.0)\n  3423‚Üí\t\tdraw_line(target_pos + Vector2(0, -8), target_pos + Vector2(-6, 6), color_clear_shot, 2.0)\n  3424‚Üí\n  3425‚Üí\t# Draw line to pursuit cover if pursuing\n  3426‚Üí\tif _current_state == AIState.PURSUING and _has_pursuit_cover:\n  3427‚Üí\t\tvar to_pursuit := _pursuit_next_cover - global_position\n  3428‚Üí\t\tdraw_line(Vector2.ZERO, to_pursuit, color_pursuit, 2.0)\n  3429‚Üí\t\tdraw_circle(to_pursuit, 8.0, color_pursuit)\n  3430‚Üí\n  3431‚Üí\t# Draw line to flank target if flanking\n  3432‚Üí\tif _current_state == AIState.FLANKING:\n  3433‚Üí\t\tif _has_flank_cover:\n  3434‚Üí\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n  3435‚Üí\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n  3436‚Üí\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n  3437‚Üí\t\telif _flank_target != Vector2.ZERO:\n  3438‚Üí\t\t\tvar to_flank := _flank_target - global_position\n  3439‚Üí\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n  3440‚Üí\t\t\t# Draw diamond at flank target\n  3441‚Üí\t\t\tvar flank_pos := to_flank\n  3442‚Üí\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n  3443‚Üí\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n  3444‚Üí\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n  3445‚Üí\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)\n  3446‚Üí\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "c36d8128-7054-432a-b0f5-909ef4ed52a2",
  "tool_use_result": {
    "type": "text",
    "file": {
      "filePath": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
      "content": "func _draw() -> void:\n\tif not debug_label_enabled:\n\t\treturn\n\n\t# Colors for different debug elements\n\tvar color_to_cover := Color.CYAN  # Line to cover position\n\tvar color_to_player := Color.RED  # Line to player (when visible)\n\tvar color_clear_shot := Color.YELLOW  # Line to clear shot target\n\tvar color_pursuit := Color.ORANGE  # Line to pursuit cover\n\tvar color_flank := Color.MAGENTA  # Line to flank position\n\tvar color_bullet_spawn := Color.GREEN  # Bullet spawn point indicator\n\tvar color_blocked := Color.RED  # Blocked path indicator\n\n\t# Draw line to player if visible\n\tif _can_see_player and _player:\n\t\tvar to_player := _player.global_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_player, color_to_player, 1.5)\n\n\t\t# Draw bullet spawn point and check if blocked\n\t\tvar direction_to_player := to_player.normalized()\n\t\tvar spawn_point := direction_to_player * bullet_spawn_offset\n\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\tdraw_circle(spawn_point, 5.0, color_bullet_spawn)\n\t\telse:\n\t\t\t# Draw X for blocked spawn point\n\t\t\tdraw_line(spawn_point + Vector2(-5, -5), spawn_point + Vector2(5, 5), color_blocked, 2.0)\n\t\t\tdraw_line(spawn_point + Vector2(-5, 5), spawn_point + Vector2(5, -5), color_blocked, 2.0)\n\n\t# Draw line to cover position if we have one\n\tif _has_valid_cover:\n\t\tvar to_cover := _cover_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_cover, color_to_cover, 1.5)\n\t\t# Draw small circle at cover position\n\t\tdraw_circle(to_cover, 8.0, color_to_cover)\n\n\t# Draw line to clear shot target if seeking clear shot\n\tif _seeking_clear_shot and _clear_shot_target != Vector2.ZERO:\n\t\tvar to_target := _clear_shot_target - global_position\n\t\tdraw_line(Vector2.ZERO, to_target, color_clear_shot, 2.0)\n\t\t# Draw triangle at target position\n\t\tvar target_pos := to_target\n\t\tdraw_line(target_pos + Vector2(-6, 6), target_pos + Vector2(6, 6), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(6, 6), target_pos + Vector2(0, -8), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(0, -8), target_pos + Vector2(-6, 6), color_clear_shot, 2.0)\n\n\t# Draw line to pursuit cover if pursuing\n\tif _current_state == AIState.PURSUING and _has_pursuit_cover:\n\t\tvar to_pursuit := _pursuit_next_cover - global_position\n\t\tdraw_line(Vector2.ZERO, to_pursuit, color_pursuit, 2.0)\n\t\tdraw_circle(to_pursuit, 8.0, color_pursuit)\n\n\t# Draw line to flank target if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_flank_cover:\n\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n\t\telif _flank_target != Vector2.ZERO:\n\t\t\tvar to_flank := _flank_target - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n\t\t\t# Draw diamond at flank target\n\t\t\tvar flank_pos := to_flank\n\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)\n",
      "numLines": 67,
      "startLine": 3380,
      "totalLines": 3446
    }
  }
}
[2026-01-18T02:54:18.444Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01ABd19U7EaRmSJKQo9HBAyL",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01A9RkqLpxiNLt4eW2rDXiEy",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd",
          "old_string": "\t# Draw line to flank target if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_flank_cover:\n\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n\t\telif _flank_target != Vector2.ZERO:\n\t\t\tvar to_flank := _flank_target - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n\t\t\t# Draw diamond at flank target\n\t\t\tvar flank_pos := to_flank\n\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)",
          "new_string": "\t# Draw line to flank target if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_flank_cover:\n\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n\t\telif _flank_target != Vector2.ZERO:\n\t\t\tvar to_flank := _flank_target - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n\t\t\t# Draw diamond at flank target\n\t\t\tvar flank_pos := to_flank\n\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)\n\n\t# Draw search zone and inspection points if searching\n\tif _current_state == AIState.SEARCHING and _search_zone_active:\n\t\tvar color_search_zone := Color(1.0, 0.5, 0.0, 0.3)  # Orange semi-transparent\n\t\tvar color_inspection := Color.LIME_GREEN\n\t\tvar color_inspection_current := Color.WHITE\n\n\t\t# Draw circle representing search zone\n\t\tvar zone_center := _last_known_player_position - global_position\n\t\t# Draw search zone outline (multiple segments to form a circle)\n\t\tvar segments := 24\n\t\tfor i in range(segments):\n\t\t\tvar angle1 := (float(i) / segments) * TAU\n\t\t\tvar angle2 := (float(i + 1) / segments) * TAU\n\t\t\tvar p1 := zone_center + Vector2.from_angle(angle1) * SEARCH_ZONE_RADIUS\n\t\t\tvar p2 := zone_center + Vector2.from_angle(angle2) * SEARCH_ZONE_RADIUS\n\t\t\tdraw_line(p1, p2, color_search_zone, 2.0)\n\n\t\t# Draw last known position marker (X)\n\t\tdraw_line(zone_center + Vector2(-10, -10), zone_center + Vector2(10, 10), Color.RED, 2.0)\n\t\tdraw_line(zone_center + Vector2(-10, 10), zone_center + Vector2(10, -10), Color.RED, 2.0)\n\n\t\t# Draw all inspection points\n\t\tfor i in range(_inspection_points.size()):\n\t\t\tvar point_pos := _inspection_points[i] - global_position\n\t\t\tif i == _current_inspection_index:\n\t\t\t\t# Current target - highlight in white\n\t\t\t\tdraw_circle(point_pos, 10.0, color_inspection_current)\n\t\t\t\t# Draw line to current target\n\t\t\t\tdraw_line(Vector2.ZERO, point_pos, color_inspection_current, 2.0)\n\t\t\telif i < _current_inspection_index:\n\t\t\t\t# Already checked - small circle\n\t\t\t\tdraw_circle(point_pos, 4.0, Color(0.5, 0.5, 0.5))\n\t\t\telse:\n\t\t\t\t# Not yet checked - green circle\n\t\t\t\tdraw_circle(point_pos, 6.0, color_inspection)"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 1662,
      "cache_read_input_tokens": 98894,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1662,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 24,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "e6a13090-d9f3-4070-bbe8-37b8c73f1e95"
}
[2026-01-18T02:54:18.476Z] [INFO] {"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01A9RkqLpxiNLt4eW2rDXiEy","type":"tool_result","content":"The file /tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  3427‚Üí\t\tvar to_pursuit := _pursuit_next_cover - global_position\n  3428‚Üí\t\tdraw_line(Vector2.ZERO, to_pursuit, color_pursuit, 2.0)\n  3429‚Üí\t\tdraw_circle(to_pursuit, 8.0, color_pursuit)\n  3430‚Üí\n  3431‚Üí\t# Draw line to flank target if flanking\n  3432‚Üí\tif _current_state == AIState.FLANKING:\n  3433‚Üí\t\tif _has_flank_cover:\n  3434‚Üí\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n  3435‚Üí\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n  3436‚Üí\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n  3437‚Üí\t\telif _flank_target != Vector2.ZERO:\n  3438‚Üí\t\t\tvar to_flank := _flank_target - global_position\n  3439‚Üí\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n  3440‚Üí\t\t\t# Draw diamond at flank target\n  3441‚Üí\t\t\tvar flank_pos := to_flank\n  3442‚Üí\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n  3443‚Üí\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n  3444‚Üí\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n  3445‚Üí\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)\n  3446‚Üí\n  3447‚Üí\t# Draw search zone and inspection points if searching\n  3448‚Üí\tif _current_state == AIState.SEARCHING and _search_zone_active:\n  3449‚Üí\t\tvar color_search_zone := Color(1.0, 0.5, 0.0, 0.3)  # Orange semi-transparent\n  3450‚Üí\t\tvar color_inspection := Color.LIME_GREEN\n  3451‚Üí\t\tvar color_inspection_current := Color.WHITE\n  3452‚Üí\n  3453‚Üí\t\t# Draw circle representing search zone\n  3454‚Üí\t\tvar zone_center := _last_known_player_position - global_position\n  3455‚Üí\t\t# Draw search zone outline (multiple segments to form a circle)\n  3456‚Üí\t\tvar segments := 24\n  3457‚Üí\t\tfor i in range(segments):\n  3458‚Üí\t\t\tvar angle1 := (float(i) / segments) * TAU\n  3459‚Üí\t\t\tvar angle2 := (float(i + 1) / segments) * TAU\n  3460‚Üí\t\t\tvar p1 := zone_center + Vector2.from_angle(angle1) * SEARCH_ZONE_RADIUS\n  3461‚Üí\t\t\tvar p2 := zone_center + Vector2.from_angle(angle2) * SEARCH_ZONE_RADIUS\n  3462‚Üí\t\t\tdraw_line(p1, p2, color_search_zone, 2.0)\n  3463‚Üí\n  3464‚Üí\t\t# Draw last known position marker (X)\n  3465‚Üí\t\tdraw_line(zone_center + Vector2(-10, -10), zone_center + Vector2(10, 10), Color.RED, 2.0)\n  3466‚Üí\t\tdraw_line(zone_center + Vector2(-10, 10), zone_center + Vector2(10, -10), Color.RED, 2.0)\n  3467‚Üí\n  3468‚Üí\t\t# Draw all inspection points\n  3469‚Üí\t\tfor i in range(_inspection_points.size()):\n  3470‚Üí\t\t\tvar point_pos := _inspection_points[i] - global_position\n  3471‚Üí\t\t\tif i == _current_inspection_index:\n  3472‚Üí\t\t\t\t# Current target - highlight in white\n  3473‚Üí\t\t\t\tdraw_circle(point_pos, 10.0, color_inspection_current)\n  3474‚Üí\t\t\t\t# Draw line to current target\n  3475‚Üí\t\t\t\tdraw_line(Vector2.ZERO, point_pos, color_inspection_current, 2.0)\n  3476‚Üí\t\t\telif i < _current_inspection_index:\n  3477‚Üí\t\t\t\t# Already checked - small circle\n  3478‚Üí\t\t\t\tdraw_circle(point_pos, 4.0, Color(0.5, 0.5, 0.5))\n  3479‚Üí\t\t\telse:\n  3480‚Üí\t\t\t\t# Not yet checked - green circle\n  3481‚Üí\t\t\t\tdraw_circle(point_pos, 6.0, color_inspection)\n  3482‚Üí"}]},"parent_tool_use_id":null,"session_id":"797fbac8-f5e6-4339-8fd2-77453410db49","uuid":"085a5b6f-ef22-47aa-8ef5-6587d9f393e8","tool_use_result":{"filePath":"/tmp/gh-issue-solver-1768704499561/scripts/objects/enemy.gd","oldString":"\t# Draw line to flank target if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_flank_cover:\n\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n\t\telif _flank_target != Vector2.ZERO:\n\t\t\tvar to_flank := _flank_target - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n\t\t\t# Draw diamond at flank target\n\t\t\tvar flank_pos := to_flank\n\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)","newString":"\t# Draw line to flank target if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_flank_cover:\n\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n\t\telif _flank_target != Vector2.ZERO:\n\t\t\tvar to_flank := _flank_target - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n\t\t\t# Draw diamond at flank target\n\t\t\tvar flank_pos := to_flank\n\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)\n\n\t# Draw search zone and inspection points if searching\n\tif _current_state == AIState.SEARCHING and _search_zone_active:\n\t\tvar color_search_zone := Color(1.0, 0.5, 0.0, 0.3)  # Orange semi-transparent\n\t\tvar color_inspection := Color.LIME_GREEN\n\t\tvar color_inspection_current := Color.WHITE\n\n\t\t# Draw circle representing search zone\n\t\tvar zone_center := _last_known_player_position - global_position\n\t\t# Draw search zone outline (multiple segments to form a circle)\n\t\tvar segments := 24\n\t\tfor i in range(segments):\n\t\t\tvar angle1 := (float(i) / segments) * TAU\n\t\t\tvar angle2 := (float(i + 1) / segments) * TAU\n\t\t\tvar p1 := zone_center + Vector2.from_angle(angle1) * SEARCH_ZONE_RADIUS\n\t\t\tvar p2 := zone_center + Vector2.from_angle(angle2) * SEARCH_ZONE_RADIUS\n\t\t\tdraw_line(p1, p2, color_search_zone, 2.0)\n\n\t\t# Draw last known position marker (X)\n\t\tdraw_line(zone_center + Vector2(-10, -10), zone_center + Vector2(10, 10), Color.RED, 2.0)\n\t\tdraw_line(zone_center + Vector2(-10, 10), zone_center + Vector2(10, -10), Color.RED, 2.0)\n\n\t\t# Draw all inspection points\n\t\tfor i in range(_inspection_points.size()):\n\t\t\tvar point_pos := _inspection_points[i] - global_position\n\t\t\tif i == _current_inspection_index:\n\t\t\t\t# Current target - highlight in white\n\t\t\t\tdraw_circle(point_pos, 10.0, color_inspection_current)\n\t\t\t\t# Draw line to current target\n\t\t\t\tdraw_line(Vector2.ZERO, point_pos, color_inspection_current, 2.0)\n\t\t\telif i < _current_inspection_index:\n\t\t\t\t# Already checked - small circle\n\t\t\t\tdraw_circle(point_pos, 4.0, Color(0.5, 0.5, 0.5))\n\t\t\telse:\n\t\t\t\t# Not yet checked - green circle\n\t\t\t\tdraw_circle(point_pos, 6.0, color_inspection)","originalFile":"extends CharacterBody2D\n## Enemy AI with tactical behaviors including patrol, guard, cover, and flanking.\n##\n## Supports multiple behavior modes:\n## - PATROL: Moves between patrol points\n## - GUARD: Stands in place watching for the player\n##\n## Tactical features:\n## - Uses cover when under fire (suppression)\n## - Attempts to flank the player from the sides\n## - Coordinates with other enemies (optional)\n## - GOAP foundation for goal-oriented planning\n\n## AI States for tactical behavior.\nenum AIState {\n\tIDLE,       ## Default idle state (patrol or guard)\n\tCOMBAT,     ## Actively engaging the player (coming out of cover, shooting 2-3s, returning)\n\tSEEKING_COVER,  ## Moving to cover position\n\tIN_COVER,   ## Taking cover from player fire\n\tFLANKING,   ## Attempting to flank the player\n\tSUPPRESSED, ## Under fire, staying in cover\n\tRETREATING, ## Retreating to cover while possibly shooting\n\tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n\tASSAULT,    ## Coordinated multi-enemy assault (rush player after 5s wait)\n\tSEARCHING   ## Searching for player at last-known-position zone\n}\n\n## Retreat behavior modes based on damage taken.\nenum RetreatMode {\n\tFULL_HP,        ## No damage - retreat backwards while shooting, periodically turn to cover\n\tONE_HIT,        ## One hit taken - quick burst then retreat without shooting\n\tMULTIPLE_HITS   ## Multiple hits - quick burst then retreat without shooting (same as ONE_HIT)\n}\n\n## Behavior modes for the enemy.\nenum BehaviorMode {\n\tPATROL,  ## Moves between patrol points\n\tGUARD    ## Stands in one place\n}\n\n## Current behavior mode.\n@export var behavior_mode: BehaviorMode = BehaviorMode.GUARD\n\n## Maximum movement speed in pixels per second.\n@export var move_speed: float = 220.0\n\n## Combat movement speed (faster when flanking/seeking cover).\n@export var combat_move_speed: float = 320.0\n\n## Rotation speed in radians per second for gradual turning.\n## Default is 15 rad/sec for challenging but fair combat.\n@export var rotation_speed: float = 15.0\n\n## Detection range for spotting the player.\n## Set to 0 or negative to allow unlimited detection range (line-of-sight only).\n## This allows enemies to see the player even outside the viewport if no obstacles block view.\n@export var detection_range: float = 0.0\n\n## Time between shots in seconds.\n## Default matches assault rifle fire rate (10 shots/second = 0.1s cooldown).\n@export var shoot_cooldown: float = 0.1\n\n## Bullet scene to instantiate when shooting.\n@export var bullet_scene: PackedScene\n\n## Offset from enemy center for bullet spawn position.\n@export var bullet_spawn_offset: float = 30.0\n\n## Patrol points as offsets from the initial position.\n## Only used when behavior_mode is PATROL.\n@export var patrol_offsets: Array[Vector2] = [Vector2(100, 0), Vector2(-100, 0)]\n\n## Wait time at each patrol point in seconds.\n@export var patrol_wait_time: float = 1.5\n\n## Color when at full health.\n@export var full_health_color: Color = Color(0.9, 0.2, 0.2, 1.0)\n\n## Color when at low health (interpolates based on health percentage).\n@export var low_health_color: Color = Color(0.3, 0.1, 0.1, 1.0)\n\n## Color to flash when hit.\n@export var hit_flash_color: Color = Color(1.0, 1.0, 1.0, 1.0)\n\n## Duration of hit flash effect in seconds.\n@export var hit_flash_duration: float = 0.1\n\n## Whether to destroy the enemy after death.\n@export var destroy_on_death: bool = false\n\n## Delay before respawning or destroying (in seconds).\n@export var respawn_delay: float = 2.0\n\n## Minimum random health.\n@export var min_health: int = 2\n\n## Maximum random health.\n@export var max_health: int = 4\n\n## Threat sphere radius - bullets within this radius trigger suppression.\n@export var threat_sphere_radius: float = 100.0\n\n## Time to stay suppressed after bullets leave threat sphere.\n@export var suppression_cooldown: float = 2.0\n\n## Delay (in seconds) before reacting to bullets in the threat sphere.\n## This prevents instant reactions to nearby gunfire, giving the player more time.\n@export var threat_reaction_delay: float = 0.2\n\n## Flank angle from player's facing direction (radians).\n@export var flank_angle: float = PI / 3.0  # 60 degrees\n\n## Distance to maintain while flanking.\n@export var flank_distance: float = 200.0\n\n## Enable/disable flanking behavior.\n@export var enable_flanking: bool = true\n\n## Enable/disable cover behavior.\n@export var enable_cover: bool = true\n\n## Enable/disable debug logging.\n@export var debug_logging: bool = false\n\n## Enable/disable debug label above enemy showing current AI state.\n@export var debug_label_enabled: bool = false\n\n## Enable/disable friendly fire avoidance (don't shoot if other enemies are in the way).\n@export var enable_friendly_fire_avoidance: bool = true\n\n## Enable/disable lead prediction (shooting ahead of moving targets).\n@export var enable_lead_prediction: bool = true\n\n## Bullet speed for lead prediction calculation.\n## Should match the actual bullet speed (default is 2500 for assault rifle).\n@export var bullet_speed: float = 2500.0\n\n## Ammunition system - magazine size (bullets per magazine).\n@export var magazine_size: int = 30\n\n## Ammunition system - number of magazines the enemy carries.\n@export var total_magazines: int = 5\n\n## Ammunition system - time to reload in seconds.\n@export var reload_time: float = 3.0\n\n## Delay (in seconds) between spotting player and starting to shoot.\n## Gives player a brief reaction time when entering enemy line of sight.\n## This delay \"recharges\" each time the player breaks direct contact with the enemy.\n@export var detection_delay: float = 0.2\n\n## Minimum time (in seconds) the player must be continuously visible before\n## lead prediction is enabled. This prevents enemies from predicting player\n## position immediately when they emerge from cover.\n@export var lead_prediction_delay: float = 0.3\n\n## Minimum visibility ratio (0.0 to 1.0) of player body that must be visible\n## before lead prediction is enabled. At 1.0, the player's entire body must be\n## visible. At 0.5, at least half of the check points must be visible.\n## This prevents pre-firing at players who are at cover edges.\n@export var lead_prediction_visibility_threshold: float = 0.6\n\n## Signal emitted when the enemy is hit.\nsignal hit\n\n## Signal emitted when the enemy dies.\nsignal died\n\n## Signal emitted when AI state changes.\nsignal state_changed(new_state: AIState)\n\n## Signal emitted when ammunition changes.\nsignal ammo_changed(current_ammo: int, reserve_ammo: int)\n\n## Signal emitted when reloading starts.\nsignal reload_started\n\n## Signal emitted when reloading finishes.\nsignal reload_finished\n\n## Signal emitted when all ammunition is depleted.\nsignal ammo_depleted\n\n## Reference to the sprite for color changes.\n@onready var _sprite: Sprite2D = $Sprite2D\n\n## RayCast2D for line of sight detection.\n@onready var _raycast: RayCast2D = $RayCast2D\n\n## Debug label for showing current AI state above the enemy.\n@onready var _debug_label: Label = $DebugLabel\n\n## Wall detection raycasts for obstacle avoidance (created at runtime).\nvar _wall_raycasts: Array[RayCast2D] = []\n\n## Distance to check for walls ahead.\nconst WALL_CHECK_DISTANCE: float = 40.0\n\n## Number of raycasts for wall detection (spread around the enemy).\nconst WALL_CHECK_COUNT: int = 3\n\n## Cover detection raycasts (created at runtime).\nvar _cover_raycasts: Array[RayCast2D] = []\n\n## Number of raycasts for cover detection.\nconst COVER_CHECK_COUNT: int = 16\n\n## Distance to check for cover.\nconst COVER_CHECK_DISTANCE: float = 300.0\n\n## Current health of the enemy.\nvar _current_health: int = 0\n\n## Maximum health of the enemy (set at spawn).\nvar _max_health: int = 0\n\n## Whether the enemy is alive.\nvar _is_alive: bool = true\n\n## Reference to the player (found at runtime).\nvar _player: Node2D = null\n\n## Time since last shot.\nvar _shoot_timer: float = 0.0\n\n## Current ammo in the magazine.\nvar _current_ammo: int = 0\n\n## Reserve ammo (ammo in remaining magazines).\nvar _reserve_ammo: int = 0\n\n## Whether the enemy is currently reloading.\nvar _is_reloading: bool = false\n\n## Timer for reload progress.\nvar _reload_timer: float = 0.0\n\n## Patrol state variables.\nvar _patrol_points: Array[Vector2] = []\nvar _current_patrol_index: int = 0\nvar _is_waiting_at_patrol_point: bool = false\nvar _patrol_wait_timer: float = 0.0\nvar _initial_position: Vector2\n\n## Whether the enemy can currently see the player.\nvar _can_see_player: bool = false\n\n## Current AI state.\nvar _current_state: AIState = AIState.IDLE\n\n## Current cover position (if any).\nvar _cover_position: Vector2 = Vector2.ZERO\n\n## Is currently in a valid cover position.\nvar _has_valid_cover: bool = false\n\n## Timer for suppression cooldown.\nvar _suppression_timer: float = 0.0\n\n## Whether enemy is currently under fire (bullets in threat sphere).\nvar _under_fire: bool = false\n\n## Flank target position.\nvar _flank_target: Vector2 = Vector2.ZERO\n\n## Threat sphere Area2D for detecting nearby bullets.\nvar _threat_sphere: Area2D = null\n\n## Bullets currently in threat sphere.\nvar _bullets_in_threat_sphere: Array = []\n\n## Timer for threat reaction delay - time since first bullet entered threat sphere.\nvar _threat_reaction_timer: float = 0.0\n\n## Whether the threat reaction delay has elapsed (enemy can react to bullets).\nvar _threat_reaction_delay_elapsed: bool = false\n\n## Memory of bullets that have passed through the threat sphere recently.\n## This allows the enemy to react even after fast-moving bullets have exited.\nvar _threat_memory_timer: float = 0.0\n\n## Duration to remember that a bullet passed through the threat sphere.\n## This should be longer than the reaction delay to ensure enemies can complete\n## their reaction even after bullets have passed through quickly.\nconst THREAT_MEMORY_DURATION: float = 0.5\n\n## Current retreat mode determined by damage taken.\nvar _retreat_mode: RetreatMode = RetreatMode.FULL_HP\n\n## Number of hits taken during the current retreat/combat encounter.\n## Resets when enemy enters IDLE state or finishes retreating.\nvar _hits_taken_in_encounter: int = 0\n\n## Timer for periodic turning to cover during FULL_HP retreat.\nvar _retreat_turn_timer: float = 0.0\n\n## Duration to face cover during FULL_HP retreat turn (seconds).\nconst RETREAT_TURN_DURATION: float = 0.8\n\n## Interval between turns toward cover in FULL_HP retreat (seconds).\nconst RETREAT_TURN_INTERVAL: float = 1.5\n\n## Whether currently in the \"turn to cover\" phase of FULL_HP retreat.\nvar _retreat_turning_to_cover: bool = false\n\n## Burst fire counter for ONE_HIT retreat mode.\nvar _retreat_burst_remaining: int = 0\n\n## Timer for burst fire cooldown in ONE_HIT retreat.\nvar _retreat_burst_timer: float = 0.0\n\n## Fast cooldown between burst shots (seconds).\nconst RETREAT_BURST_COOLDOWN: float = 0.06\n\n## Whether burst fire phase is complete in ONE_HIT retreat.\nvar _retreat_burst_complete: bool = false\n\n## Accuracy reduction during retreat (multiplier for inaccuracy angle spread).\nconst RETREAT_INACCURACY_SPREAD: float = 0.15\n\n## Arc spread for ONE_HIT burst fire (radians, total spread).\nconst RETREAT_BURST_ARC: float = 0.4\n\n## Current angle offset within burst arc.\nvar _retreat_burst_angle_offset: float = 0.0\n\n## Whether enemy is in \"alarm\" mode (was suppressed/retreating and hasn't calmed down).\n## This persists until the enemy reaches safety in cover or returns to idle.\nvar _in_alarm_mode: bool = false\n\n## Whether the enemy needs to fire a cover burst (when leaving cover while in alarm).\nvar _cover_burst_pending: bool = false\n\n## --- Combat Cover Cycling (come out, shoot 2-3s, go back) ---\n## Timer for how long the enemy has been shooting while out of cover.\nvar _combat_shoot_timer: float = 0.0\n\n## Duration to shoot while out of cover (2-3 seconds, randomized).\nvar _combat_shoot_duration: float = 2.5\n\n## Whether the enemy is currently in the \"exposed shooting\" phase of combat.\nvar _combat_exposed: bool = false\n\n## Whether the enemy is in the \"approaching player\" phase of combat.\n## In this phase, the enemy moves toward the player to get into direct contact.\nvar _combat_approaching: bool = false\n\n## Timer for the approach phase of combat.\nvar _combat_approach_timer: float = 0.0\n\n## Maximum time to spend approaching player before starting to shoot (seconds).\nconst COMBAT_APPROACH_MAX_TIME: float = 2.0\n\n## Distance at which enemy is considered \"close enough\" to start shooting phase.\nconst COMBAT_DIRECT_CONTACT_DISTANCE: float = 250.0\n\n## --- Pursuit State (cover-to-cover movement) ---\n## Timer for waiting at cover during pursuit.\nvar _pursuit_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during pursuit (1-2 seconds, reduced for faster pursuit).\nconst PURSUIT_COVER_WAIT_DURATION: float = 1.5\n\n## Current pursuit target cover position.\nvar _pursuit_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid pursuit cover target.\nvar _has_pursuit_cover: bool = false\n\n## --- Flanking State (cover-to-cover movement toward flank target) ---\n## Timer for waiting at cover during flanking.\nvar _flank_cover_wait_timer: float = 0.0\n\n## Duration to wait at each cover during flanking (seconds).\nconst FLANK_COVER_WAIT_DURATION: float = 0.8\n\n## Current flank cover position to move to.\nvar _flank_next_cover: Vector2 = Vector2.ZERO\n\n## Whether the enemy has a valid flank cover target.\nvar _has_flank_cover: bool = false\n\n## --- Assault State (coordinated multi-enemy rush) ---\n## Timer for assault wait period (5 seconds before rushing).\nvar _assault_wait_timer: float = 0.0\n\n## Duration to wait at cover before assault (5 seconds).\nconst ASSAULT_WAIT_DURATION: float = 5.0\n\n## Whether the assault wait period is complete.\nvar _assault_ready: bool = false\n\n## Whether this enemy is currently participating in an assault.\nvar _in_assault: bool = false\n\n## Distance threshold for \"close\" vs \"far\" from player.\n## Used to determine if enemy can engage from current position or needs to pursue.\nconst CLOSE_COMBAT_DISTANCE: float = 400.0\n\n## GOAP world state for goal-oriented planning.\nvar _goap_world_state: Dictionary = {}\n\n## --- Search/Investigation State (for when player escapes from view) ---\n## Last known position where the player was seen before escaping view.\nvar _last_known_player_position: Vector2 = Vector2.ZERO\n\n## Whether a search zone is currently active.\nvar _search_zone_active: bool = false\n\n## Radius of the potential player zone (area where player might be hiding).\nconst SEARCH_ZONE_RADIUS: float = 200.0\n\n## Timer for search timeout - enemy gives up searching after this time.\nvar _search_timer: float = 0.0\n\n## Maximum time to spend searching before giving up (seconds).\nconst SEARCH_MAX_DURATION: float = 15.0\n\n## Inspection points within the search zone (hiding spots behind covers and corners).\nvar _inspection_points: Array[Vector2] = []\n\n## Index of current inspection point being checked.\nvar _current_inspection_index: int = 0\n\n## Timer for waiting at each inspection point (looking around).\nvar _inspection_wait_timer: float = 0.0\n\n## Duration to wait at each inspection point (seconds).\nconst INSPECTION_WAIT_DURATION: float = 1.5\n\n## Whether currently waiting at an inspection point.\nvar _inspecting_point: bool = false\n\n## Number of raycasts for detecting inspection points (corners/hiding spots).\nconst INSPECTION_POINT_CHECK_COUNT: int = 24\n\n## Distance to check for inspection points from search zone center.\nconst INSPECTION_CHECK_DISTANCE: float = 250.0\n\n## Detection delay timer - tracks time since entering combat.\nvar _detection_timer: float = 0.0\n\n## Whether the detection delay has elapsed.\nvar _detection_delay_elapsed: bool = false\n\n## Continuous visibility timer - tracks how long the player has been continuously visible.\n## Resets when line of sight is lost.\nvar _continuous_visibility_timer: float = 0.0\n\n## Current visibility ratio of the player (0.0 to 1.0).\n## Represents what fraction of the player's body is visible to the enemy.\n## Used to determine if lead prediction should be enabled.\nvar _player_visibility_ratio: float = 0.0\n\n## --- Clear Shot Movement (move out from cover to get clear shot) ---\n## Target position to move to for getting a clear shot.\nvar _clear_shot_target: Vector2 = Vector2.ZERO\n\n## Whether we're currently moving to find a clear shot position.\nvar _seeking_clear_shot: bool = false\n\n## Timer for how long we've been trying to find a clear shot.\nvar _clear_shot_timer: float = 0.0\n\n## Maximum time to spend finding a clear shot before giving up (seconds).\nconst CLEAR_SHOT_MAX_TIME: float = 3.0\n\n## Distance to move when exiting cover to find a clear shot.\nconst CLEAR_SHOT_EXIT_DISTANCE: float = 60.0\n\n\n\nfunc _ready() -> void:\n\t_initial_position = global_position\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_setup_patrol_points()\n\t_find_player()\n\t_setup_wall_detection()\n\t_setup_cover_detection()\n\t_setup_threat_sphere()\n\t_initialize_goap_state()\n\t_connect_debug_mode_signal()\n\t_update_debug_label()\n\n\t# Log that this enemy is ready (use call_deferred to ensure FileLogger is loaded)\n\tcall_deferred(\"_log_spawn_info\")\n\n\t# Preload bullet scene if not set in inspector\n\tif bullet_scene == null:\n\t\tbullet_scene = preload(\"res://scenes/projectiles/Bullet.tscn\")\n\n\n## Initialize health with random value between min and max.\nfunc _initialize_health() -> void:\n\t_max_health = randi_range(min_health, max_health)\n\t_current_health = _max_health\n\t_is_alive = true\n\n\n## Initialize ammunition with full magazine and reserve ammo.\nfunc _initialize_ammo() -> void:\n\t_current_ammo = magazine_size\n\t# Reserve ammo is (total_magazines - 1) * magazine_size since one magazine is loaded\n\t_reserve_ammo = (total_magazines - 1) * magazine_size\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\n## Setup patrol points based on patrol offsets from initial position.\nfunc _setup_patrol_points() -> void:\n\t_patrol_points.clear()\n\t_patrol_points.append(_initial_position)\n\tfor offset in patrol_offsets:\n\t\t_patrol_points.append(_initial_position + offset)\n\n\n## Setup wall detection raycasts for obstacle avoidance.\nfunc _setup_wall_detection() -> void:\n\t# Create multiple raycasts spread in front of the enemy\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_wall_raycasts.append(raycast)\n\n\n## Setup cover detection raycasts for finding cover positions.\nfunc _setup_cover_detection() -> void:\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar raycast := RayCast2D.new()\n\t\traycast.enabled = true\n\t\traycast.collision_mask = 4  # Only detect obstacles (layer 3)\n\t\traycast.exclude_parent = true\n\t\tadd_child(raycast)\n\t\t_cover_raycasts.append(raycast)\n\n\n## Setup threat sphere for detecting nearby bullets.\nfunc _setup_threat_sphere() -> void:\n\t_threat_sphere = Area2D.new()\n\t_threat_sphere.name = \"ThreatSphere\"\n\t_threat_sphere.collision_layer = 0\n\t_threat_sphere.collision_mask = 16  # Detect projectiles (layer 5)\n\n\tvar collision_shape := CollisionShape2D.new()\n\tvar circle_shape := CircleShape2D.new()\n\tcircle_shape.radius = threat_sphere_radius\n\tcollision_shape.shape = circle_shape\n\t_threat_sphere.add_child(collision_shape)\n\n\tadd_child(_threat_sphere)\n\n\t# Connect signals\n\t_threat_sphere.area_entered.connect(_on_threat_area_entered)\n\t_threat_sphere.area_exited.connect(_on_threat_area_exited)\n\n\n## Initialize GOAP world state.\nfunc _initialize_goap_state() -> void:\n\t_goap_world_state = {\n\t\t\"player_visible\": false,\n\t\t\"has_cover\": false,\n\t\t\"in_cover\": false,\n\t\t\"under_fire\": false,\n\t\t\"health_low\": false,\n\t\t\"can_flank\": false,\n\t\t\"at_flank_position\": false,\n\t\t\"is_retreating\": false,\n\t\t\"hits_taken\": 0,\n\t\t\"is_pursuing\": false,\n\t\t\"is_assaulting\": false,\n\t\t\"can_hit_from_cover\": false,\n\t\t\"player_close\": false,\n\t\t\"enemies_in_combat\": 0,\n\t\t\"has_search_zone\": false,\n\t\t\"search_zone_cleared\": false,\n\t\t\"inspection_points_remaining\": 0,\n\t\t\"is_searching\": false\n\t}\n\n\n## Connect to GameManager's debug mode signal for F7 toggle.\nfunc _connect_debug_mode_signal() -> void:\n\tvar game_manager: Node = get_node_or_null(\"/root/GameManager\")\n\tif game_manager:\n\t\t# Connect to debug mode toggle signal\n\t\tif game_manager.has_signal(\"debug_mode_toggled\"):\n\t\t\tgame_manager.debug_mode_toggled.connect(_on_debug_mode_toggled)\n\t\t# Sync with current debug mode state\n\t\tif game_manager.has_method(\"is_debug_mode_enabled\"):\n\t\t\tdebug_label_enabled = game_manager.is_debug_mode_enabled()\n\n\n## Called when debug mode is toggled via F7 key.\nfunc _on_debug_mode_toggled(enabled: bool) -> void:\n\tdebug_label_enabled = enabled\n\t_update_debug_label()\n\n\n## Find the player node in the scene tree.\nfunc _find_player() -> void:\n\t# Try to find the player by group first\n\tvar players := get_tree().get_nodes_in_group(\"player\")\n\tif players.size() > 0:\n\t\t_player = players[0]\n\t\treturn\n\n\t# Fallback: search for player by node name or type\n\tvar root := get_tree().current_scene\n\tif root:\n\t\t_player = _find_player_recursive(root)\n\n\n## Recursively search for a player node.\nfunc _find_player_recursive(node: Node) -> Node2D:\n\tif node.name == \"Player\" and node is Node2D:\n\t\treturn node\n\tfor child in node.get_children():\n\t\tvar result := _find_player_recursive(child)\n\t\tif result:\n\t\t\treturn result\n\treturn null\n\n\nfunc _physics_process(delta: float) -> void:\n\tif not _is_alive:\n\t\treturn\n\n\t# Update shoot cooldown timer\n\t_shoot_timer += delta\n\n\t# Update reload timer\n\t_update_reload(delta)\n\n\t# Check for player visibility and try to find player if not found\n\tif _player == null:\n\t\t_find_player()\n\n\t_check_player_visibility()\n\t_update_goap_state()\n\t_update_suppression(delta)\n\n\t# Process AI state machine\n\t_process_ai_state(delta)\n\n\t# Update debug label if enabled\n\t_update_debug_label()\n\n\t# Request redraw for debug visualization\n\tif debug_label_enabled:\n\t\tqueue_redraw()\n\n\tmove_and_slide()\n\n\n## Update GOAP world state based on current conditions.\nfunc _update_goap_state() -> void:\n\t_goap_world_state[\"player_visible\"] = _can_see_player\n\t_goap_world_state[\"under_fire\"] = _under_fire\n\t_goap_world_state[\"health_low\"] = _get_health_percent() < 0.5\n\t_goap_world_state[\"in_cover\"] = _current_state == AIState.IN_COVER\n\t_goap_world_state[\"has_cover\"] = _has_valid_cover\n\t_goap_world_state[\"is_retreating\"] = _current_state == AIState.RETREATING\n\t_goap_world_state[\"hits_taken\"] = _hits_taken_in_encounter\n\t_goap_world_state[\"is_pursuing\"] = _current_state == AIState.PURSUING\n\t_goap_world_state[\"is_assaulting\"] = _current_state == AIState.ASSAULT\n\t_goap_world_state[\"player_close\"] = _is_player_close()\n\t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n\t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()\n\t_goap_world_state[\"has_search_zone\"] = _search_zone_active\n\t_goap_world_state[\"search_zone_cleared\"] = not _search_zone_active and _last_known_player_position != Vector2.ZERO\n\t_goap_world_state[\"inspection_points_remaining\"] = _inspection_points.size() - _current_inspection_index\n\t_goap_world_state[\"is_searching\"] = _current_state == AIState.SEARCHING\n\n\n## Update suppression state.\nfunc _update_suppression(delta: float) -> void:\n\t# Clean up destroyed bullets from tracking\n\t_bullets_in_threat_sphere = _bullets_in_threat_sphere.filter(func(b): return is_instance_valid(b))\n\n\t# Determine if there's an active threat (bullets in sphere OR recent threat memory)\n\tvar has_active_threat := not _bullets_in_threat_sphere.is_empty() or _threat_memory_timer > 0.0\n\n\tif not has_active_threat:\n\t\tif _under_fire:\n\t\t\t_suppression_timer += delta\n\t\t\tif _suppression_timer >= suppression_cooldown:\n\t\t\t\t_under_fire = false\n\t\t\t\t_suppression_timer = 0.0\n\t\t\t\t_log_debug(\"Suppression ended\")\n\t\t# Reset threat reaction timer when no bullets are in threat sphere and no threat memory\n\
[2026-01-18T02:54:18.479Z] [INFO] t\t_threat_reaction_timer = 0.0\n\t\t_threat_reaction_delay_elapsed = false\n\telse:\n\t\t# Decrement threat memory timer if no bullets currently in sphere\n\t\tif _bullets_in_threat_sphere.is_empty() and _threat_memory_timer > 0.0:\n\t\t\t_threat_memory_timer -= delta\n\n\t\t# Update threat reaction timer\n\t\tif not _threat_reaction_delay_elapsed:\n\t\t\t_threat_reaction_timer += delta\n\t\t\tif _threat_reaction_timer >= threat_reaction_delay:\n\t\t\t\t_threat_reaction_delay_elapsed = true\n\t\t\t\t_log_debug(\"Threat reaction delay elapsed, now reacting to bullets\")\n\n\t\t# Only set under_fire after the reaction delay has elapsed\n\t\tif _threat_reaction_delay_elapsed:\n\t\t\t_under_fire = true\n\t\t\t_suppression_timer = 0.0\n\n\n## Update reload state.\nfunc _update_reload(delta: float) -> void:\n\tif not _is_reloading:\n\t\treturn\n\n\t_reload_timer += delta\n\tif _reload_timer >= reload_time:\n\t\t_finish_reload()\n\n\n## Start reloading the weapon.\nfunc _start_reload() -> void:\n\t# Can't reload if already reloading or no reserve ammo\n\tif _is_reloading or _reserve_ammo <= 0:\n\t\treturn\n\n\t_is_reloading = true\n\t_reload_timer = 0.0\n\treload_started.emit()\n\t_log_debug(\"Reloading... (%d reserve ammo)\" % _reserve_ammo)\n\n\n## Finish the reload process.\nfunc _finish_reload() -> void:\n\t_is_reloading = false\n\t_reload_timer = 0.0\n\n\t# Calculate how many rounds to load\n\tvar ammo_needed := magazine_size - _current_ammo\n\tvar ammo_to_load := mini(ammo_needed, _reserve_ammo)\n\n\t_reserve_ammo -= ammo_to_load\n\t_current_ammo += ammo_to_load\n\n\treload_finished.emit()\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\t_log_debug(\"Reload complete. Magazine: %d/%d, Reserve: %d\" % [_current_ammo, magazine_size, _reserve_ammo])\n\n\n## Check if the enemy can shoot (has ammo and not reloading).\nfunc _can_shoot() -> bool:\n\t# Can't shoot if reloading\n\tif _is_reloading:\n\t\treturn false\n\n\t# Can't shoot if no ammo in magazine\n\tif _current_ammo <= 0:\n\t\t# Try to start reload if we have reserve ammo\n\t\tif _reserve_ammo > 0:\n\t\t\t_start_reload()\n\t\telse:\n\t\t\t# No ammo at all - emit depleted signal once\n\t\t\tif not _goap_world_state.get(\"ammo_depleted\", false):\n\t\t\t\t_goap_world_state[\"ammo_depleted\"] = true\n\t\t\t\tammo_depleted.emit()\n\t\t\t\t_log_debug(\"All ammunition depleted!\")\n\t\treturn false\n\n\treturn true\n\n\n## Process the AI state machine.\nfunc _process_ai_state(delta: float) -> void:\n\tvar previous_state := _current_state\n\n\t# State transitions based on conditions\n\tmatch _current_state:\n\t\tAIState.IDLE:\n\t\t\t_process_idle_state(delta)\n\t\tAIState.COMBAT:\n\t\t\t_process_combat_state(delta)\n\t\tAIState.SEEKING_COVER:\n\t\t\t_process_seeking_cover_state(delta)\n\t\tAIState.IN_COVER:\n\t\t\t_process_in_cover_state(delta)\n\t\tAIState.FLANKING:\n\t\t\t_process_flanking_state(delta)\n\t\tAIState.SUPPRESSED:\n\t\t\t_process_suppressed_state(delta)\n\t\tAIState.RETREATING:\n\t\t\t_process_retreating_state(delta)\n\t\tAIState.PURSUING:\n\t\t\t_process_pursuing_state(delta)\n\t\tAIState.ASSAULT:\n\t\t\t_process_assault_state(delta)\n\t\tAIState.SEARCHING:\n\t\t\t_process_searching_state(delta)\n\n\tif previous_state != _current_state:\n\t\tstate_changed.emit(_current_state)\n\t\t_log_debug(\"State changed: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\t\t# Also log to file for exported build debugging\n\t\t_log_to_file(\"State: %s -> %s\" % [AIState.keys()[previous_state], AIState.keys()[_current_state]])\n\n\n## Process IDLE state - patrol or guard behavior.\nfunc _process_idle_state(delta: float) -> void:\n\t# Transition to combat if player is visible\n\tif _can_see_player and _player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Execute idle behavior\n\tmatch behavior_mode:\n\t\tBehaviorMode.PATROL:\n\t\t\t_process_patrol(delta)\n\t\tBehaviorMode.GUARD:\n\t\t\t_process_guard(delta)\n\n\n## Process COMBAT state - approach player for direct contact, shoot for 2-3 seconds, return to cover.\n## Implements the combat cycling behavior: exit cover -> exposed shooting -> return to cover.\n## Phase 0 (seeking clear shot): If bullet spawn blocked, move out from cover to find clear shot.\n## Phase 1 (approaching): Move toward player to get into direct contact range.\n## Phase 2 (exposed): Stand and shoot for 2-3 seconds.\n## Phase 3: Return to cover via SEEKING_COVER state.\nfunc _process_combat_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies in combat (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can't see player, transition to SEARCHING to investigate last-known position\n\tif not _can_see_player:\n\t\t_combat_exposed = false\n\t\t_combat_approaching = false\n\t\t_seeking_clear_shot = false\n\t\t_log_debug(\"Lost sight of player in COMBAT, transitioning to SEARCHING\")\n\t\t_transition_to_searching()\n\t\treturn\n\n\t# Update detection delay timer\n\tif not _detection_delay_elapsed:\n\t\t_detection_timer += delta\n\t\tif _detection_timer >= detection_delay:\n\t\t\t_detection_delay_elapsed = true\n\n\t# If we don't have cover, find some first (needed for returning later)\n\tif not _has_valid_cover and enable_cover:\n\t\t_find_cover_position()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found cover at %s for combat cycling\" % _cover_position)\n\n\t# Check player distance for approach/exposed phase decisions\n\tvar distance_to_player := INF\n\tif _player:\n\t\tdistance_to_player = global_position.distance_to(_player.global_position)\n\n\t# Check if we have a clear shot (no wall blocking bullet spawn)\n\tvar direction_to_player := Vector2.ZERO\n\tvar has_clear_shot := true\n\tif _player:\n\t\tdirection_to_player = (_player.global_position - global_position).normalized()\n\t\thas_clear_shot = _is_bullet_spawn_clear(direction_to_player)\n\n\t# If already exposed (shooting phase), handle shooting and timer\n\tif _combat_exposed:\n\t\t_combat_shoot_timer += delta\n\n\t\t# Check if exposure time is complete - go back to cover\n\t\tif _combat_shoot_timer >= _combat_shoot_duration and _has_valid_cover:\n\t\t\t_log_debug(\"Combat exposure time complete (%.1fs), returning to cover\" % _combat_shoot_duration)\n\t\t\t_combat_exposed = false\n\t\t\t_combat_approaching = false\n\t\t\t_combat_shoot_timer = 0.0\n\t\t\t_transition_to_seeking_cover()\n\t\t\treturn\n\n\t\t# Check if we still have a clear shot - if not, move sideways to find one\n\t\tif _player and not has_clear_shot:\n\t\t\t# Bullet spawn is blocked - move sideways to find a clear shot position\n\t\t\tvar sidestep_dir := _find_sidestep_direction_for_clear_shot(direction_to_player)\n\t\t\tif sidestep_dir != Vector2.ZERO:\n\t\t\t\tvelocity = sidestep_dir * combat_move_speed * 0.7\n\t\t\t\trotation = direction_to_player.angle()  # Keep facing player while sidestepping\n\t\t\t\t_log_debug(\"COMBAT exposed: sidestepping to maintain clear shot\")\n\t\t\telse:\n\t\t\t\t# No sidestep works - stay still, the shot might clear up\n\t\t\t\tvelocity = Vector2.ZERO\n\t\t\treturn\n\n\t\t# In exposed phase with clear shot, stand still and shoot\n\t\tvelocity = Vector2.ZERO\n\n\t\t# Aim and shoot at player (only shoot after detection delay)\n\t\tif _player:\n\t\t\t_aim_at_player()\n\t\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot()\n\t\t\t\t_shoot_timer = 0.0\n\t\treturn\n\n\t# --- CLEAR SHOT SEEKING PHASE ---\n\t# If bullet spawn is blocked and we're not already exposed, we need to move out from cover\n\tif not has_clear_shot and _player:\n\t\t# Start seeking clear shot if not already doing so\n\t\tif not _seeking_clear_shot:\n\t\t\t_seeking_clear_shot = true\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Calculate target position: move perpendicular to player direction (around cover edge)\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\t_log_debug(\"COMBAT: bullet spawn blocked, seeking clear shot at %s\" % _clear_shot_target)\n\n\t\t_clear_shot_timer += delta\n\n\t\t# Check if we've exceeded the max time trying to find a clear shot\n\t\tif _clear_shot_timer >= CLEAR_SHOT_MAX_TIME:\n\t\t\t_log_debug(\"COMBAT: clear shot timeout, trying flanking\")\n\t\t\t_seeking_clear_shot = false\n\t\t\t_clear_shot_timer = 0.0\n\t\t\t# Try flanking to get around the obstacle\n\t\t\tif enable_flanking:\n\t\t\t\t_transition_to_flanking()\n\t\t\telse:\n\t\t\t\t_transition_to_pursuing()\n\t\t\treturn\n\n\t\t# Move toward the clear shot target position\n\t\tvar distance_to_target := global_position.distance_to(_clear_shot_target)\n\t\tif distance_to_target > 15.0:\n\t\t\tvar move_direction := (_clear_shot_target - global_position).normalized()\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed\n\t\t\trotation = direction_to_player.angle()  # Keep facing player\n\n\t\t\t# Check if the new position now has a clear shot\n\t\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\t\t_log_debug(\"COMBAT: found clear shot position while moving\")\n\t\t\t\t_seeking_clear_shot = false\n\t\t\t\t_clear_shot_timer = 0.0\n\t\t\t\t# Continue to exposed phase check below\n\t\t\telse:\n\t\t\t\treturn  # Keep moving toward target\n\t\telse:\n\t\t\t# Reached target but still no clear shot - recalculate target\n\t\t\t_log_debug(\"COMBAT: reached target but no clear shot, recalculating\")\n\t\t\t_clear_shot_target = _calculate_clear_shot_exit_position(direction_to_player)\n\t\t\treturn\n\n\t# Reset seeking state if we now have a clear shot\n\tif _seeking_clear_shot and has_clear_shot:\n\t\t_log_debug(\"COMBAT: clear shot acquired\")\n\t\t_seeking_clear_shot = false\n\t\t_clear_shot_timer = 0.0\n\n\t# Determine if we should be in approach phase or exposed shooting phase\n\tvar in_direct_contact := distance_to_player <= COMBAT_DIRECT_CONTACT_DISTANCE\n\n\t# Enter exposed phase if we have a clear shot and are either close enough or have approached long enough\n\tif has_clear_shot and (in_direct_contact or _combat_approach_timer >= COMBAT_APPROACH_MAX_TIME):\n\t\t# Close enough AND have clear shot - start exposed shooting phase\n\t\t_combat_exposed = true\n\t\t_combat_approaching = false\n\t\t_combat_shoot_timer = 0.0\n\t\t_combat_approach_timer = 0.0\n\t\t# Randomize exposure duration between 2-3 seconds\n\t\t_combat_shoot_duration = randf_range(2.0, 3.0)\n\t\t_log_debug(\"COMBAT exposed phase started (distance: %.0f), will shoot for %.1fs\" % [distance_to_player, _combat_shoot_duration])\n\t\treturn\n\n\t# Need to approach player - move toward them\n\tif not _combat_approaching:\n\t\t_combat_approaching = true\n\t\t_combat_approach_timer = 0.0\n\t\t_log_debug(\"COMBAT approach phase started, moving toward player\")\n\n\t_combat_approach_timer += delta\n\n\t# Move toward player while approaching\n\tif _player:\n\t\tvar move_direction := direction_to_player\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = move_direction * combat_move_speed\n\t\trotation = direction_to_player.angle()  # Always face player\n\n\t\t# Can shoot while approaching (only after detection delay and if have clear shot)\n\t\tif has_clear_shot and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\n## Calculate a target position to exit cover and get a clear shot.\n## Returns a position that should allow the bullet spawn point to be unobstructed.\nfunc _calculate_clear_shot_exit_position(direction_to_player: Vector2) -> Vector2:\n\t# Calculate perpendicular directions to the player\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Try both perpendicular directions and pick the one that's more likely to work\n\t# Also blend with forward movement toward player to help navigate around cover\n\tvar best_position := global_position\n\tvar best_score := -1.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\t\t# Blend sidestep with forward movement for better cover navigation\n\t\tvar exit_dir: Vector2 = (sidestep_dir * 0.7 + direction_to_player * 0.3).normalized()\n\t\tvar test_position: Vector2 = global_position + exit_dir * CLEAR_SHOT_EXIT_DISTANCE\n\n\t\t# Score this position based on:\n\t\t# 1. Does it have a clear path? (no walls in the way)\n\t\t# 2. Would the bullet spawn be clear from there?\n\t\tvar score: float = 0.0\n\n\t\t# Check if we can move to this position\n\t\tif _has_clear_path_to(test_position):\n\t\t\tscore += 1.0\n\n\t\t# Check if bullet spawn would be clear from this position\n\t\t# This is a rough estimate - we check from the test position toward player\n\t\tvar world_2d := get_world_2d()\n\t\tif world_2d != null:\n\t\t\tvar space_state := world_2d.direct_space_state\n\t\t\tif space_state != null:\n\t\t\t\tvar check_distance := bullet_spawn_offset + 5.0\n\t\t\t\tvar query := PhysicsRayQueryParameters2D.new()\n\t\t\t\tquery.from = test_position\n\t\t\t\tquery.to = test_position + direction_to_player * check_distance\n\t\t\t\tquery.collision_mask = 4  # Only check obstacles\n\t\t\t\tquery.exclude = [get_rid()]\n\t\t\t\tvar result := space_state.intersect_ray(query)\n\t\t\t\tif result.is_empty():\n\t\t\t\t\tscore += 2.0  # Higher score for clear bullet spawn\n\n\t\tif score > best_score:\n\t\t\tbest_score = score\n\t\t\tbest_position = test_position\n\n\t# If no good position found, just move forward toward player\n\tif best_score < 0.5:\n\t\tbest_position = global_position + direction_to_player * CLEAR_SHOT_EXIT_DISTANCE\n\n\treturn best_position\n\n\n## Process SEEKING_COVER state - moving to cover position.\nfunc _process_seeking_cover_state(_delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, stay in combat\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're already hidden from the player (the main goal)\n\tif not _is_visible_from_player():\n\t\t_transition_to_in_cover()\n\t\t_log_debug(\"Hidden from player, entering cover state\")\n\t\treturn\n\n\t# Move towards cover\n\tvar direction := (_cover_position - global_position).normalized()\n\tvar distance := global_position.distance_to(_cover_position)\n\n\tif distance < 10.0:\n\t\t# Reached the cover position, but still visible - try to find better cover\n\t\tif _is_visible_from_player():\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\t# No better cover found, stay in combat\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\n\t# Apply wall avoidance\n\tvar avoidance := _check_wall_ahead(direction)\n\tif avoidance != Vector2.ZERO:\n\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\tvelocity = direction * combat_move_speed\n\trotation = direction.angle()\n\n\t# Can still shoot while moving to cover (only after detection delay)\n\tif _can_see_player and _player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t_aim_at_player()\n\t\t_shoot()\n\t\t_shoot_timer = 0.0\n\n\n## Process IN_COVER state - taking cover from enemy fire.\n## Decides next action based on:\n## 1. If under fire -> suppressed\n## 2. If player is close (can exit cover for direct contact) -> COMBAT\n## 3. If player is far but can hit from current position -> COMBAT (stay and shoot)\n## 4. If player is far and can't hit -> PURSUING (move cover-to-cover)\nfunc _process_in_cover_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# If still under fire, stay suppressed\n\tif _under_fire:\n\t\t_transition_to_suppressed()\n\t\treturn\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover\n\tif _is_visible_from_player():\n\t\t# If in alarm mode and can see player, fire a burst before escaping\n\t\tif _in_alarm_mode and _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"IN_COVER alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay in cover while firing burst\n\n\t\t# Burst complete or not in alarm mode, seek new cover\n\t\t_log_debug(\"Player flanked our cover position, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# Decision making based on player distance and visibility\n\tif _player:\n\t\tvar player_close := _is_player_close()\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\n\t\tif _can_see_player:\n\t\t\tif player_close:\n\t\t\t\t# Player is close - engage in combat (come out, shoot, go back)\n\t\t\t\t_log_debug(\"Player is close, transitioning to COMBAT\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\t# Player is far\n\t\t\t\tif can_hit:\n\t\t\t\t\t# Can hit from current position - come out and shoot\n\t\t\t\t\t# (Don't pursue, just transition to combat which will handle the cycling)\n\t\t\t\t\t_log_debug(\"Player is far but can hit from here, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\telse:\n\t\t\t\t\t# Can't hit from here - need to pursue (move cover-to-cover)\n\t\t\t\t\t_log_debug(\"Player is far and can't hit, transitioning to PURSUING\")\n\t\t\t\t\t_transition_to_pursuing()\n\t\t\t\t\treturn\n\n\t# If not under fire and can see player, engage (only shoot after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If player is no longer visible and not under fire, try pursuing\n\tif not _can_see_player and not _under_fire:\n\t\t_log_debug(\"Lost sight of player from cover, transitioning to PURSUING\")\n\t\t_transition_to_pursuing()\n\n\n## Process FLANKING state - attempting to flank the player using cover-to-cover movement.\n## Uses intermediate cover positions to navigate around obstacles instead of walking\n## directly toward the flank target.\nfunc _process_flanking_state(delta: float) -> void:\n\t# If under fire, retreat with shooting behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# If can see player, engage in combat\n\tif _can_see_player:\n\t\t_transition_to_combat()\n\t\treturn\n\n\tif _player == null:\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# Recalculate flank position (player may have moved)\n\t_calculate_flank_position()\n\n\tvar distance_to_flank := global_position.distance_to(_flank_target)\n\n\t# Check if we've reached the flank target\n\tif distance_to_flank < 30.0:\n\t\t_log_debug(\"Reached flank position, engaging\")\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Check if we have direct line of sight to flank target (no obstacles)\n\tif _has_clear_path_to(_flank_target):\n\t\t# Direct path is clear - move directly toward flank target\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\t_has_flank_cover = false\n\t\treturn\n\n\t# Path is blocked - use cover-to-cover movement\n\n\t# If we're at a cover position, wait briefly before moving to next\n\tif _has_valid_cover and not _has_flank_cover:\n\t\t_flank_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _flank_cover_wait_timer >= FLANK_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover toward flank target\n\t\t\t_find_flank_cover_toward_target()\n\t\t\tif not _has_flank_cover:\n\t\t\t\t_log_debug(\"No flank cover found, attempting direct movement\")\n\t\t\t\t# No cover found - try direct movement with enhanced wall avoidance\n\t\t\t\tvar direction := (_flank_target - global_position).normalized()\n\t\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\t\tvelocity = direction * combat_move_speed\n\t\t\t\trotation = direction.angle()\n\t\t\t\t# Invalidate current cover to trigger new search next frame\n\t\t\t\t_has_valid_cover = false\n\t\treturn\n\n\t# If we have a flank cover target, move toward it\n\tif _has_flank_cover:\n\t\tvar direction := (_flank_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_flank_next_cover)\n\n\t\t# Check if we've reached the flank cover\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached flank cover at distance %.1f\" % distance)\n\t\t\t_has_flank_cover = false\n\t\t\t_flank_cover_wait_timer = 0.0\n\t\t\t_cover_position = _flank_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no flank cover target - find initial flank cover\n\t_find_flank_cover_toward_target()\n\tif not _has_flank_cover:\n\t\t# Can't find cover, try direct movement with wall avoidance\n\t\tvar direction := (_flank_target - global_position).normalized()\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\n\n## Process SUPPRESSED state - staying in cover under fire.\nfunc _process_suppressed_state(delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\n\t# Check if player has flanked us - if we're now visible from player's position,\n\t# we need to find new cover even while suppressed\n\tif _is_visible_from_player():\n\t\t# In suppressed state we're always in alarm mode - fire a burst before escaping if we can see player\n\t\tif _can_see_player and _player:\n\t\t\tif not _cover_burst_pending:\n\t\t\t\t# Start the cover burst\n\t\t\t\t_cover_burst_pending = true\n\t\t\t\t_retreat_burst_remaining = randi_range(2, 4)\n\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t\t\t_log_debug(\"SUPPRESSED alarm: starting burst before escaping (%d shots)\" % _retreat_burst_remaining)\n\n\t\t\t# Fire the burst\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_timer += delta\n\t\t\t\tif _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t\t\t_aim_at_player()\n\t\t\t\t\t_shoot_burst_shot()\n\t\t\t\t\t_retreat_burst_remaining -= 1\n\t\t\t\t\t_retreat_burst_timer = 0.0\n\t\t\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0\n\t\t\t\treturn  # Stay suppressed while firing burst\n\n\t\t# Burst complete or can't see player, seek new cover\n\t\t_log_debug(\"Player flanked our cover position while suppressed, seeking new cover\")\n\t\t_has_valid_cover = false  # Invalidate current cover\n\t\t_cover_burst_pending = false\n\t\t_transition_to_seeking_cover()\n\t\treturn\n\n\t# Can still shoot while suppressed (only after detection delay)\n\tif _can_see_player and _player:\n\t\t_aim_at_player()\n\t\tif _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t# If no longer under fire, exit suppression\n\tif not _under_fire:\n\t\t_transition_to_in_cover()\n\n\n## Process RETREATING state - moving to cover with behavior based on damage taken.\nfunc _process_retreating_state(delta: float) -> void:\n\tif not _has_valid_cover:\n\t\t# Try to find cover\n\t\t_find_cover_position()\n\t\tif not _has_valid_cover:\n\t\t\t# No cover found, transition to combat or suppressed\n\t\t\tif _under_fire:\n\t\t\t\t_transition_to_suppressed()\n\t\t\telse:\n\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we've reached cover and are hidden from player\n\tif not _is_visible_from_player():\n\t\t_log_debug(\"Reached cover during retreat\")\n\t\t# Reset encounter hits when successfully reaching cover\n\t\t_hits_taken_in_encounter = 0\n\t\t_transition_to_in_cover()\n\t\treturn\n\n\t# Calculate direction to cover\n\tvar direction_to_cover := (_cover_position - global_position).normalized()\n\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\n\t# Check if reached cover position\n\tif distance_to_cover < 10.0:\n\t\tif _is_visible_from_player():\n\t\t\t# Still visible, find better cover\n\t\t\t_has_valid_cover = false\n\t\t\t_find_cover_position()\n\t\t\tif not _has_valid_cover:\n\t\t\t\tif _under_fire:\n\t\t\t\t\t_transition_to_suppressed()\n\t\t\t\telse:\n\t\t\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Apply retreat behavior based on mode\n\tmatch _retreat_mode:\n\t\tRetreatMode.FULL_HP:\n\t\t\t_process_retreat_full_hp(delta, direction_to_cover)\n\t\tRetreatMode.ONE_HIT:\n\t\t\t_process_retreat_one_hit(delta, direction_to_cover)\n\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t_process_retreat_multiple_hits(delta, direction_to_cover)\n\n\n## Process FULL_HP retreat: walk backwards facing player, shoot with reduced accuracy,\n## periodically turn toward cover.\nfunc _process_retreat_full_hp(delta: float, direction_to_cover: Vector2) -> void:\n\t_retreat_turn_timer += delta\n\n\tif _retreat_turning_to_cover:\n\t\t# Turning to face cover, don't shoot\n\t\tif _retreat_turn_timer >= RETREAT_TURN_DURATION:\n\t\t\t_retreat_turning_to_cover = false\n\t\t\t_retreat_turn_timer = 0.0\n\n\t\t# Face cover and move toward it\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\telse:\n\t\t# Face player and back up (walk backwards)\n\t\tif _retreat_turn_timer >= RETREAT_TURN_INTERVAL:\n\t\t\t_retreat_turning_to_cover = true\n\t\t\t_retreat_turn_timer = 0.0\n\t\t\t_log_debug(\"FULL_HP retreat: turning to check cover\")\n\n\t\tif _player:\n\t\t\t# Face the player\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\t_aim_at_player()\n\n\t\t\t# Move backwards (opposite of player direction = toward cover generally)\n\t\t\t# Use the negative of the direction we're facing for \"backing up\"\n\t\t\tvar move_direction := -direction_to_player\n\n\t\t\t# Apply wall avoidance\n\t\t\tvar avoidance := _check_wall_ahead(move_direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tmove_direction = (move_direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\t\tvelocity = move_direction * combat_move_speed * 0.7  # Slower when backing up\n\n\t\t\t# Shoot with reduced accuracy (only after detection delay)\n\t\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t\t_shoot_with_inaccuracy()\n\t\t\t\t_shoot_timer = 0.0\n\n\n## Process ONE_HIT retreat: quick burst of 2-4 shots in an arc while turning, then face cover.\nfunc _process_retreat_one_hit(delta: float, direction_to_cover: Vector2) -> void:\n\tif not _retreat_burst_complete:\n\t\t# During burst phase\n\t\t_retreat_burst_timer += delta\n\n\t\tif _player and _retreat_burst_remaining > 0 and _retreat_burst_timer >= RETREAT_BURST_COOLDOWN:\n\t\t\t# Fire a burst shot with arc spread\n\t\t\t_shoot_burst_shot()\n\t\t\t_retreat_burst_remaining -= 1\n\t\t\t_retreat_burst_timer = 0.0\n\n\t\t\t# Progress through the arc\n\t\t\tif _retreat_burst_remaining > 0:\n\t\t\t\t_retreat_burst_angle_offset += RETREAT_BURST_ARC / 3.0  # Spread across 4 shots max\n\n\t\t# Gradually turn from player to cover during burst\n\t\tif _player:\n\t\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\t\tvar target_angle: float\n\n\t\t\t# Interpolate rotation from player direction to cover direction\n\t\t\tvar burst_progress := 1.0 - (float(_retreat_burst_remaining) / 4.0)\n\t\t\tvar player_angle := direction_to_player.angle()\n\t\t\tvar cover_angle := direction_to_cover.angle()\n\t\t\ttarget_angle = lerp_angle(player_angle, cover_angle, burst_progress * 0.7)\n\t\t\trotation = target_angle\n\n\t\t# Move toward cover (slower during burst)\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed * 0.5\n\n\t\t# Check if burst is complete\n\t\tif _retreat_burst_remaining <= 0:\n\t\t\t_retreat_burst_complete = true\n\t\t\t_log_debug(\"ONE_HIT retreat: burst complete, now running to cover\")\n\telse:\n\t\t# After burst, run to cover without shooting\n\t\trotation = direction_to_cover.angle()\n\t\tvar avoidance := _check_wall_ahead(direction_to_cover)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_cover = (direction_to_cover * 0.5 + avoidance * 0.5).normalized()\n\t\tvelocity = direction_to_cover * combat_move_speed\n\n\n## Process MULTIPLE_HITS retreat: quick burst of 2-4 shots then run to cover (same as ONE_HIT).\nfunc _process_retreat_multiple_hits(delta: float, direction_to_cover: Vector2) -> void:\n\t# Same behavior as ONE_HIT - quick burst then escape\n\t_process_retreat_one_hit(delta, direction_to_cover)\n\n\n## Process PURSUING state - move cover-to-cover toward player.\n## Enemy moves between covers, waiting 1-2 seconds at each cover,\n## until they can see and hit the player.\nfunc _process_pursuing_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover:\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if multiple enemies are in combat - transition to assault state\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat >= 2:\n\t\t_log_debug(\"Multiple enemies detected during pursuit (%d), transitioning to ASSAULT\" % enemies_in_combat)\n\t\t_transition_to_assault()\n\t\treturn\n\n\t# If can see player and can hit them from current position, engage\n\tif _can_see_player and _player:\n\t\tvar can_hit := _can_hit_player_from_current_position()\n\t\tif can_hit:\n\t\t\t_log_debug(\"Can see and hit player from pursuit, transitioning to COMBAT\")\n\t\t\t_has_pursuit_cover = false\n\t\t\t_transition_to_combat()\n\t\t\treturn\n\n\t# Check if we're waiting at cover\n\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t# Currently at cover, wait for 1-2 seconds before moving to next cover\n\t\t_pursuit_cover_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\tif _pursuit_cover_wait_timer >= PURSUIT_COVER_WAIT_DURATION:\n\t\t\t# Done waiting, find next cover closer to player\n\t\t\t_log_debug(\"Pursuit wait complete, finding next cover\")\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_find_pursuit_cover_toward_player()\n\t\t\tif _has_pursuit_cover:\n\t\t\t\t_log_debug(\"Found pursuit cover at %s\" % _pursuit_next_cover)\n\t\t\telse:\n\t\t\t\t# No pursuit cover found - fallback behavior\n\t\t\t\t_log_debug(\"No pursuit cover found, checking fallback options\")\n\t\t\t\t# If we can now see the player, engage directly\n\t\t\t\tif _can_see_player:\n\t\t\t\t\t_log_debug(\"Can see player, transitioning to COMBAT\")\n\t\t\t\t\t_transition_to_combat()\n\t\t\t\t\treturn\n\t\t\t\t# Try flanking\n\t\t\t\tif enable_flanking and _player:\n\t\t\t\t\t_log_debug(\"Attempting flanking maneuver\")\n\t\t\t\t\t_transition_to_flanking()\n\t\t\t\t\treturn\n\t\t\t\t# Last resort: move directly toward player\n\t\t\t\t_log_debug(\"No cover options, moving directly toward player\")\n\t\t\t\t_transition_to_combat()\n\t\t\t\treturn\n\t\treturn\n\n\t# If we have a pursuit cover target, move toward it\n\tif _has_pursuit_cover:\n\t\tvar direction := (_pursuit_next_cover - global_position).normalized()\n\t\tvar distance := global_position.distance_to(_pursuit_next_cover)\n\n\t\t# Check if we've reached the pursuit cover\n\t\t# Note: We only check distance here, NOT visibility from player.\n\t\t# If we checked visibility, the enemy would immediately consider themselves\n\t\t# \"at cover\" even before moving, since they start hidden from player.\n\t\tif distance < 15.0:\n\t\t\t_log_debug(\"Reached pursuit cover at distance %.1f\" % distance)\n\t\t\t_has_pursuit_cover = false\n\t\t\t_pursuit_cover_wait_timer = 0.0\n\t\t\t_cover_position = _pursuit_next_cover\n\t\t\t_has_valid_cover = true\n\t\t\t# Start waiting at this cover\n\t\t\treturn\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * combat_move_speed\n\t\trotation = direction.angle()\n\t\treturn\n\n\t# No cover and no pursuit target - find initial pursuit cover\n\t_find_pursuit_cover_toward_player()\n\tif not _has_pursuit_cover:\n\t\t# Can't find cover to pursue, try flanking or combat\n\t\tif enable_flanking and _player:\n\t\t\t_transition_to_flanking()\n\t\telse:\n\t\t\t_transition_to_combat()\n\n\n## Process ASSAULT state - coordinated multi-enemy rush.\n## Wait at cover for 5 seconds, then all enemies rush the player simultaneously.\nfunc _process_assault_state(delta: float) -> void:\n\t# Check for suppression - transition to retreating behavior\n\tif _under_fire and enable_cover and not _assault_ready:\n\t\t_in_assault = false\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Check if we're the only enemy left in assault - switch back to combat\n\tvar enemies_in_combat := _count_enemies_in_combat()\n\tif enemies_in_combat < 2 and not _assault_ready:\n\t\t_log_debug(\"Not enough enemies for assault, switching to COMBAT\")\n\t\t_in_assault = false\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Find closest cover to player if we don't have one\n\tif not _has_valid_cover:\n\t\t_find_cover_closest_to_player()\n\t\tif _has_valid_cover:\n\t\t\t_log_debug(\"Found assault cover at %s\" % _cover_position)\n\n\t# Move to cover position first\n\tif _has_valid_cover and not _in_assault:\n\t\tvar distance_to_cover := global_position.distance_to(_cover_position)\n\t\tif distance_to_cover > 15.0 and _is_visible_from_player():\n\t\t\t# Still need to reach cover\n\t\t\tvar direction := (_cover_position - global_position).normalized()\n\t\t\tvar avoidance := _check_wall_ahead(direction)\n\t\t\tif avoidance != Vector2.ZERO:\n\t\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\t\t\tvelocity = direction * combat_move_speed\n\t\t\trotation = direction.angle()\n\t\t\treturn\n\n\t# At cover, wait for assault timer\n\tif not _assault_ready:\n\t\tvelocity = Vector2.ZERO\n\t\t_assault_wait_timer += delta\n\n\t\t# Check if all assault enemies are ready (synchronized assault)\n\t\tif _assault_wait_timer >= ASSAULT_WAIT_DURATION:\n\t\t\t# Check if situation has changed - player might have moved\n\t\t\tif _player and _is_player_close():\n\t\t\t\t_assault_ready = true\n\t\t\t\t_in_assault = true\n\t\t\t\t_log_debug(\"ASSAULT ready - rushing player!\")\n\t\t\telse:\n\t\t\t\t# Player moved away, reset timer and check if we should pursue\n\t\t\t\t_log_debug(\"Player moved away during assault wait, resetting\")\n\t\t\t\t_assault_wait_timer = 0.0\n\t\t\t\t_in_assault = false\n\t\t\t\t_transition_to_pursuing()\n\t\t\t\treturn\n\t\treturn\n\n\t# Assault phase - rush the player while shooting\n\tif _assault_ready and _player:\n\t\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\t\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t\t# Apply wall avoidance\n\t\tvar avoidance := _check_wall_ahead(direction_to_player)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\tdirection_to_player = (direction_to_player * 0.5 + avoidance * 0.5).normalized()\n\n\t\t# Rush at full speed\n\t\tvelocity = direction_to_player * combat_move_speed\n\t\trotation = direction_to_player.angle()\n\n\t\t# Update detection delay timer\n\t\tif not _detection_delay_elapsed:\n\t\t\t_detection_timer += delta\n\t\t\tif _detection_timer >= detection_delay:\n\t\t\t\t_detection_delay_elapsed = true\n\n\t\t# Shoot while rushing (only after detection delay)\n\t\tif _can_see_player and _detection_delay_elapsed and _shoot_timer >= shoot_cooldown:\n\t\t\t_aim_at_player()\n\t\t\t_shoot()\n\t\t\t_shoot_timer = 0.0\n\n\t\t# If very close to player, stay in combat\n\t\tif distance_to_player < 50.0:\n\t\t\t_log_debug(\"Assault complete - reached player\")\n\t\t\t_assault_ready = false\n\t\t\t_in_assault = false\n\t\t\t_transition_to_combat()\n\n\n## Shoot with reduced accuracy for retreat mode.\nfunc _shoot_with_inaccuracy() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Check if the shot should be taken\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Add inaccuracy spread\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD, RETREAT_INACCURACY_SPREAD)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the inaccurate shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Inaccurate shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Shoot a burst shot with arc spread for ONE_HIT retreat.\nfunc _shoot_burst_shot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Apply arc offset for burst spread\n\tdirection = direction.rotated(_retreat_burst_angle_offset)\n\n\t# Also add some random inaccuracy on top of the arc\n\tvar inaccuracy_angle := randf_range(-RETREAT_INACCURACY_SPREAD * 0.5, RETREAT_INACCURACY_SPREAD * 0.5)\n\tdirection = direction.rotated(inaccuracy_angle)\n\n\t# Check if the burst shot direction would hit a wall\n\tif not _is_bullet_spawn_clear(direction):\n\t\t_log_debug(\"Burst shot blocked: wall in path after rotation\")\n\t\treturn\n\n\t# Create and fire bullet\n\tvar bullet := bullet_scene.instantiate()\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\tbullet.direction = direction\n\tbullet.shooter_id = get_instance_id()\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play sounds\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Transition to IDLE state.\nfunc _transition_to_idle() -> void:\n\t_current_state = AIState.IDLE\n\t# Reset encounter hit tracking when returning to idle\n\t_hits_taken_in_encounter = 0\n\t# Reset alarm mode when returning to idle\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\n\n## Transition to COMBAT state.\nfunc _transition_to_combat() -> void:\n\t_current_state = AIState.COMBAT\n\t# Reset detection delay timer when entering combat\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Reset combat phase variables\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_shoot_timer = 0.0\n\t_combat_approach_timer = 0.0\n\t# Reset clear shot seeking variables\n\t_seeking_clear_shot = false\n\t_clear_shot_timer = 0.0\n\t_clear_shot_target = Vector2.ZERO\n\n\n## Transition to SEEKING_COVER state.\nfunc _transition_to_seeking_cover() -> void:\n\t_current_state = AIState.SEEKING_COVER\n\t_find_cover_position()\n\n\n## Transition to IN_COVER state.\nfunc _transition_to_in_cover() -> void:\n\t_current_state = AIState.IN_COVER\n\n\n## Transition to FLANKING state.\nfunc _transition_to_flanking() -> void:\n\t_current_state = AIState.FLANKING\n\t_calculate_flank_position()\n\t_flank_cover_wait_timer = 0.0\n\t_has_flank_cover = false\n\t_has_valid_cover = false\n\n\n## Transition to SUPPRESSED state.\nfunc _transition_to_suppressed() -> void:\n\t_current_state = AIState.SUPPRESSED\n\t# Enter alarm mode when suppressed\n\t_in_alarm_mode = true\n\n\n## Transition to PURSUING state.\nfunc _transition_to_pursuing() -> void:\n\t_current_state = AIState.PURSUING\n\t_pursuit_cover_wait_timer = 0.0\n\t_has_pursuit_cover = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\n\n## Transition to ASSAULT state.\nfunc _transition_to_assault() -> void:\n\t_current_state = AIState.ASSAULT\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset detection delay for new engagement\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t# Find closest cover to player for assault position\n\t_find_cover_closest_to_player()\n\n\n## Transition to RETREATING state with appropriate retreat mode.\nfunc _transition_to_retreating() -> void:\n\t_current_state = AIState.RETREATING\n\t# Enter alarm mode when retreating\n\t_in_alarm_mode = true\n\n\t# Determine retreat mode based on hits taken\n\tif _hits_taken_in_encounter == 0:\n\t\t_retreat_mode = RetreatMode.FULL_HP\n\t\t_retreat_turn_timer = 0.0\n\t\t_retreat_turning_to_cover = false\n\t\t_log_debug(\"Entering RETREATING state: FULL_HP mode (shoot while backing up)\")\n\telif _hits_taken_in_encounter == 1:\n\t\t_retreat_mode = RetreatMode.ONE_HIT\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t# Calculate arc spread: shots will be distributed across the arc\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: ONE_HIT mode (burst of %d shots)\" % _retreat_burst_remaining)\n\telse:\n\t\t_retreat_mode = RetreatMode.MULTIPLE_HITS\n\t\t# Multiple hits also gets burst fire (same as ONE_HIT)\n\t\t_retreat_burst_remaining = randi_range(2, 4)  # Random 2-4 bullets\n\t\t_retreat_burst_timer = 0.0\n\t\t_retreat_burst_complete = false\n\t\t_retreat_burst_angle_offset = -RETREAT_BURST_ARC / 2.0\n\t\t_log_debug(\"Entering RETREATING state: MULTIPLE_HITS mode (burst of %d shots)\" % _retreat_burst_remaining)\n\n\t# Find cover position for retreating\n\t_find_cover_position()\n\n\n## Transition to SEARCHING state.\n## Activates the search zone and generates inspection points.\nfunc _transition_to_searching() -> void:\n\t_current_state = AIState.SEARCHING\n\t_search_timer = 0.0\n\t_inspection_wait_timer = 0.0\n\t_inspecting_point = false\n\t_current_inspection_index = 0\n\n\t# Activate search zone at last known player position\n\tif _last_known_player_position != Vector2.ZERO:\n\t\t_search_zone_active = true\n\t\t_log_debug(\"Activating search zone at %s (radius: %.1f)\" % [_last_known_player_position, SEARCH_ZONE_RADIUS])\n\t\t# Generate inspection points within the search zone\n\t\t_generate_inspection_points()\n\telse:\n\t\t# No last known position - fall back to pursuing\n\t\t_log_debug(\"No last known position, falling back to PURSUING\")\n\t\t_transition_to_pursuing()\n\n\n## Clear the search zone when player is found or search is complete.\nfunc _clear_search_zone() -> void:\n\t_search_zone_active = false\n\t_inspection_points.clear()\n\t_current_inspection_index = 0\n\t_inspecting_point = false\n\t_log_debug(\"Search zone cleared\")\n\n\n## Generate inspection points within the search zone.\n## Finds hiding spots behind covers and at corners within the search area.\nfunc _generate_inspection_points() -> void:\n\t_inspection_points.clear()\n\n\tif _last_known_player_position == Vector2.ZERO:\n\t\treturn\n\n\tvar search_center := _last_known_player_position\n\n\t# Use raycasts from the search center to find obstacles and generate inspection points\n\tfor i in range(INSPECTION_POINT_CHECK_COUNT):\n\t\tvar angle := (float(i) / INSPECTION_POINT_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\t# Cast ray from search center outward to find obstacles\n\t\tvar space_state := get_world_2d().direct_space_state\n\t\tvar query := PhysicsRayQueryParameters2D.new()\n\t\tquery.from = search_center\n\t\tquery.to = search_center + direction * INSPECTION_CHECK_DISTANCE\n\t\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\n\t\tvar result := space_state.intersect_ray(query)\n\n\t\tif not result.is_empty():\n\t\t\tvar collision_point: Vector2 = result[\"position\"]\n\t\t\tvar collision_normal: Vector2 = result[\"normal\"]\n\n\t\t\t# Generate inspection point behind the obstacle (from enemy's perspective)\n\t\t\t# This is where a player might hide\n\t\t\tvar inspection_pos := collision_point + collision_normal * 40.0\n\n\t\t\t# Only add if within search zone radius\n\t\t\tif inspection_pos.distance_to(search_center) <= SEARCH_ZONE_RADIUS:\n\t\t\t\t# Avoid duplicate or too-close points\n\t\t\t\tvar is_duplicate := false\n\t\t\t\tfor existing_point in _inspection_points:\n\t\t\t\t\tif inspection_pos.distance_to(existing_point) < 50.0:\n\t\t\t\t\t\tis_duplicate = true\n\t\t\t\t\t\tbreak\n\t\t\t\tif not is_duplicate:\n\t\t\t\t\t_inspection_points.append(inspection_pos)\n\n\t# Add corners of the search zone as additional inspection points\n\tvar corner_offsets := [\n\t\tVector2(SEARCH_ZONE_RADIUS * 0.7, SEARCH_ZONE_RADIUS * 0.7),\n\t\tVector2(-SEARCH_ZONE_RADIUS * 0.7, SEARCH_ZONE_RADIUS * 0.7),\n\t\tVector2(SEARCH_ZONE_RADIUS * 0.7, -SEARCH_ZONE_RADIUS * 0.7),\n\t\tVector2(-SEARCH_ZONE_RADIUS * 0.7, -SEARCH_ZONE_RADIUS * 0.7),\n\t]\n\n\tfor offset in corner_offsets:\n\t\tvar corner_point := search_center + offset\n\t\t# Only add corner if we can reach it (no obstacle blocking direct path)\n\t\tif _has_clear_path_to(corner_point):\n\t\t\tvar is_duplicate := false\n\t\t\tfor existing_point in _inspection_points:\n\t\t\t\tif corner_point.distance_to(existing_point) < 50.0:\n\t\t\t\t\tis_duplicate = true\n\t\t\t\t\tbreak\n\t\t\tif not is_duplicate:\n\t\t\t\t_inspection_points.append(corner_point)\n\n\t# Sort inspection points by distance from current position (closest first)\n\t_inspection_points.sort_custom(func(a: Vector2, b: Vector2) -> bool:\n\t\treturn global_position.distance_to(a) < global_position.distance_to(b)\n\t)\n\n\t_log_debug(\"Generated %d inspection points in search zone\" % _inspection_points.size())\n\n\n## Process SEARCHING state - investigate last-known player position and check hiding spots.\n## Enemy moves to last-known position, then checks each inspection point within the search zone.\n## Returns to IDLE when all points are checked or timeout expires.\nfunc _process_searching_state(delta: float) -> void:\n\t# If player is spotted during search, immediately transition to combat\n\tif _can_see_player:\n\t\t_log_debug(\"Player found during search, transitioning to COMBAT\")\n\t\t_clear_search_zone()\n\t\t_transition_to_combat()\n\t\treturn\n\n\t# Check for suppression - if under fire, need to take cover\n\tif _under_fire and enable_cover:\n\t\t_log_debug(\"Under fire during search, transitioning to RETREATING\")\n\t\t_clear_search_zone()\n\t\t_transition_to_retreating()\n\t\treturn\n\n\t# Update search timer\n\t_search_timer += delta\n\n\t# Timeout - give up searching and return to patrol/guard\n\tif _search_timer >= SEARCH_MAX_DURATION:\n\t\t_log_debug(\"Search timeout reached, returning to IDLE\")\n\t\t_clear_search_zone()\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# If no inspection points left, search is complete\n\tif _inspection_points.is_empty() or _current_inspection_index >= _inspection_points.size():\n\t\t_log_debug(\"All inspection points checked, search zone cleared\")\n\t\t_clear_search_zone()\n\t\t_transition_to_idle()\n\t\treturn\n\n\t# Get current inspection point target\n\tvar current_target := _inspection_points[_current_inspection_index]\n\tvar distance_to_target := global_position.distance_to(current_target)\n\n\t# Check if we're at the current inspection point\n\tif distance_to_target < 20.0:\n\t\tif not _inspecting_point:\n\t\t\t# Just arrived at inspection point - start looking around\n\t\t\t_inspecting_point = true\n\t\t\t_inspection_wait_timer = 0.0\n\t\t\t_log_debug(\"Inspecting point %d/%d at %s\" % [_current_inspection_index + 1, _inspection_points.size(), current_target])\n\n\t\t# Wait at the inspection point, looking around\n\t\t_inspection_wait_timer += delta\n\t\tvelocity = Vector2.ZERO\n\n\t\t# Rotate while inspecting (looking around)\n\t\trotation += rotation_speed * delta * 0.5\n\n\t\tif _inspection_wait_timer >= INSPECTION_WAIT_DURATION:\n\t\t\t# Done inspecting this point, move to next\n\t\t\t_current_inspection_index += 1\n\t\t\t_inspecting_point = false\n\t\t\t_inspection_wait_timer = 0.0\n\t\treturn\n\n\t# Move toward current inspection point\n\tvar direction := (current_target - global_position).normalized()\n\n\t# Apply wall avoidance\n\tvar avoidance := _check_wall_ahead(direction)\n\tif avoidance != Vector2.ZERO:\n\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\tvelocity = direction * combat_move_speed * 0.8  # Slightly slower when searching\n\trotation = direction.angle()\n\n\n## Check if the enemy is visible from the player's position.\n## Uses raycasting from player to enemy to determine if there are obstacles blocking line of sight.\n## This is the inverse of _can_see_player - it checks if the PLAYER can see the ENEMY.\n## Checks multiple points on the enemy body (center and corners) to account for enemy size.\nfunc _is_visible_from_player() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check visibility to multiple points on the enemy body\n\t# This accounts for the enemy's size - corners can stick out from cover\n\tvar check_points := _get_enemy_check_points(global_position)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Get multiple check points on the enemy body for visibility testing.\n## Returns center and 4 corner points offset by the enemy's radius.\nfunc _get_enemy_check_points(center: Vector2) -> Array[Vector2]:\n\t# Enemy collision radius is 24, sprite is 48x48\n\t# Use a slightly smaller radius to avoid edge cases\n\tconst ENEMY_RADIUS: float = 22.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := ENEMY_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point is visible from the player's position.\nfunc _is_point_visible_from_player(point: Vector2) -> bool:\n\tif _player == null:\n\t\treturn false\n\n\tvar player_pos := _player.global_position\n\tvar distance := player_pos.distance_to(point)\n\n\t# Use direct space state to check line of sight from player to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = player_pos\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = []\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between player and point - point is visible\n\t\treturn true\n\telse:\n\t\t# Check if we hit an obstacle before reaching the point\n\t\tvar hit_position: Vector2 = result[\"position\"]\n\t\tvar distance_to_hit := player_pos.distance_to(hit_position)\n\n\t\t# If we hit something closer than the point, the point is hidden\n\t\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t\treturn false\n\t\telse:\n\t\t\treturn true\n\n\n## Check if a specific position would make the enemy visible from the player's position.\n## Checks all enemy body points (center and corners) to account for enemy size.\n## Used to validate cover positions before moving to them.\nfunc _is_position_visible_from_player(pos: Vector2) -> bool:\n\tif _player == null:\n\t\treturn true  # Assume visible if no player\n\n\t# Check visibility for all enemy body points at the given position\n\tvar check_points := _get_enemy_check_points(pos)\n\n\tfor point in check_points:\n\t\tif _is_point_visible_from_player(point):\n\t\t\treturn true\n\n\treturn false\n\n\n## Check if a target position is visible from the enemy's perspective.\n## Uses raycast to verify there are no obstacles between enemy and the target position.\n## This is used to validate lead prediction targets - enemies should only aim at\n## positions they can actually see.\nfunc _is_position_visible_to_enemy(target_pos: Vector2) -> bool:\n\tvar distance := global_position.distance_to(target_pos)\n\n\t# Use direct space state to check line of sight from enemy to target\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = target_pos\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and target - position is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t# Hit obstacle before target - position is NOT visible\n\t\t_log_debug(\"Position %s blocked by obstacle at distance %.1f (target at %.1f)\" % [target_pos, distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Get multiple check points on the player's body for visibility testing.\n## Returns center and 4 corner points offset by the player's radius.\n## The player has a collision radius of 16 pixels (from Player.tscn).\nfunc _get_player_check_points(center: Vector2) -> Array[Vector2]:\n\t# Player collision radius is 16, sprite is 32x32\n\t# Use a slightly smaller radius to be conservative\n\tconst PLAYER_RADIUS: float = 14.0\n\n\tvar points: Array[Vector2] = []\n\tpoints.append(center)  # Center point\n\n\t# 4 corner points (diagonal directions)\n\tvar diagonal_offset := PLAYER_RADIUS * 0.707  # cos(45¬∞) ‚âà 0.707\n\tpoints.append(center + Vector2(diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, diagonal_offset))\n\tpoints.append(center + Vector2(diagonal_offset, -diagonal_offset))\n\tpoints.append(center + Vector2(-diagonal_offset, -diagonal_offset))\n\n\treturn points\n\n\n## Check if a single point on the player is visible from the enemy's position.\n## Uses direct space state query to check for obstacles blocking line of sight.\nfunc _is_player_point_visible_to_enemy(point: Vector2) -> bool:\n\tvar distance := global_position.distance_to(point)\n\n\t# Use direct space state to check line of sight from enemy to point\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = point\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]  # Exclude self\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\t# No obstacle between enemy and point - point is visible\n\t\treturn true\n\n\t# Check if we hit an obstacle before reaching the point\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\t# If we hit something before the point, the point is blocked\n\tif distance_to_hit < distance - 5.0:  # 5 pixel tolerance\n\t\treturn false\n\n\treturn true\n\n\n## Calculate what fraction of the player's body is visible to the enemy.\n## Returns a value from 0.0 (completely hidden) to 1.0 (fully visible).\n## Checks multiple points on the player's body (center + corners).\nfunc _calculate_player_visibility_ratio() -> float:\n\tif _player == null:\n\t\treturn 0.0\n\n\tvar check_points := _get_player_check_points(_player.global_position)\n\tvar visible_count := 0\n\n\tfor point in check_points:\n\t\tif _is_player_point_visible_to_enemy(point):\n\t\t\tvisible_count += 1\n\n\treturn float(visible_count) / float(check_points.size())\n\n\n## Check if the line of fire to the target position is clear of other enemies.\n## Returns true if no other enemies would be hit by a bullet traveling to the target.\nfunc _is_firing_line_clear_of_friendlies(target_position: Vector2) -> bool:\n\tif not enable_friendly_fire_avoidance:\n\t\treturn true\n\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if any enemies are in the firing line\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 2  # Only check enemies (layer 2)\n\tquery.exclude = [get_rid()]  # Exclude self using RID\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No enemies in the way\n\n\t# Check if the hit position is before the target\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 20.0:  # 20 pixel tolerance\n\t\t_log_debug(\"Friendly in firing line at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if a bullet fired at the target position would be blocked by cover/obstacles.\n## Returns true if the shot would likely hit the target, false if blocked by cover.\nfunc _is_shot_clear_of_cover(target_position: Vector2) -> bool:\n\tvar direction := (target_position - global_position).normalized()\n\tvar distance := global_position.distance_to(target_position)\n\n\t# Use direct space state to check if obstacles block the shot\n\tvar space_state := get_world_2d().direct_space_state\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position + direction * bullet_spawn_offset  # Start from bullet spawn point\n\tquery.to = target_position\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\n\tvar result := space_state.intersect_ray(query)\n\n\tif result.is_empty():\n\t\treturn true  # No obstacles in the way\n\n\t# Check if the obstacle is before the target position\n\tvar hit_position: Vector2 = result[\"position\"]\n\tvar distance_to_hit := global_position.distance_to(hit_position)\n\n\tif distance_to_hit < distance - 10.0:  # 10 pixel tolerance\n\t\t_log_debug(\"Shot blocked by cover at distance %0.1f (target at %0.1f)\" % [distance_to_hit, distance])\n\t\treturn false\n\n\treturn true\n\n\n## Check if there's an obstacle immediately in front of the enemy that would block bullets.\n## This prevents shooting into walls that the enemy is flush against or very close to.\n## Uses a single raycast from enemy center to the bullet spawn position.\nfunc _is_bullet_spawn_clear(direction: Vector2) -> bool:\n\t# Fail-open: allow shooting if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn true\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn true\n\n\t# Check from enemy center to bullet spawn position plus a small buffer\n\tvar check_distance := bullet_spawn_offset + 5.0\n\n\tvar query := PhysicsRayQueryParameters2D.new()\n\tquery.from = global_position\n\tquery.to = global_position + direction * check_distance\n\tquery.collision_mask = 4  # Only check obstacles (layer 3)\n\tquery.exclude = [get_rid()]\n\n\tvar result := space_state.intersect_ray(query)\n\tif not result.is_empty():\n\t\t_log_debug(\"Bullet spawn blocked: wall at distance %.1f\" % [\n\t\t\tglobal_position.distance_to(result[\"position\"])])\n\t\treturn false\n\n\treturn true\n\n\n## Find a sidestep direction that would lead to a clear shot position.\n## Checks perpendicular directions to the player and returns the first one\n## that would allow the bullet spawn point to be clear.\n## Returns Vector2.ZERO if no clear direction is found.\nfunc _find_sidestep_direction_for_clear_shot(direction_to_player: Vector2) -> Vector2:\n\t# Fail-safe: allow normal behavior if physics is not ready\n\tvar world_2d := get_world_2d()\n\tif world_2d == null:\n\t\treturn Vector2.ZERO\n\tvar space_state := world_2d.direct_space_state\n\tif space_state == null:\n\t\treturn Vector2.ZERO\n\n\t# Check perpendicular directions (left and right of the player direction)\n\tvar perpendicular := Vector2(-direction_to_player.y, direction_to_player.x)\n\n\t# Check both sidestep directions and pick the one that leads to clear shot faster\n\tvar check_distance := 50.0  # Check if moving 50 pixels in this direction would help\n\tvar bullet_check_distance := bullet_spawn_offset + 5.0\n\n\tfor side_multiplier: float in [1.0, -1.0]:  # Try both sides\n\t\tvar sidestep_dir: Vector2 = perpendicular * side_multiplier\n\n\t\t# First check if we can actually move in this direction (no wall blocking movement)\n\t\tvar move_query := PhysicsRayQueryParameters2D.new()\n\t\tmove_query.from = global_position\n\t\tmove_query.to = global_position + sidestep_dir * 30.0\n\t\tmove_query.collision_mask = 4  # Only check obstacles\n\t\tmove_query.exclude = [get_rid()]\n\n\t\tvar move_result := space_state.intersect_ray(move_query)\n\t\tif not move_result.is_empty():\n\t\t\tcontinue  # Can't move this way, wall is blocking\n\n\t\t# Check if after sidestepping, we'd have a clear shot\n\t\tvar test_position: Vector2 = global_position + sidestep_dir * check_distance\n\t\tvar shot_query := PhysicsRayQueryParameters2D.new()\n\t\tshot_query.from = test_position\n\t\tshot_query.to = test_position + direction_to_player * bullet_check_distance\n\t\tshot_query.collision_mask = 4\n\t\tshot_query.exclude = [get_rid()]\n\n\t\tvar shot_result := space_state.intersect_ray(shot_query)\n\t\tif shot_result.is_empty():\n\t\t\t# Found a direction that leads to a clear shot\n\t\t\t_log_debug(\"Found sidestep direction: %s\" % sidestep_dir)\n\t\t\treturn sidestep_dir\n\n\treturn Vector2.ZERO  # No clear sidestep direction found\n\n\n## Check if the enemy should shoot at the current target.\n## Validates bullet spawn c
[2026-01-18T02:54:18.484Z] [INFO] learance, friendly fire avoidance, and cover blocking.\nfunc _should_shoot_at_target(target_position: Vector2) -> bool:\n\t# Check if the immediate path to bullet spawn is clear\n\t# This prevents shooting into walls the enemy is flush against\n\tvar direction := (target_position - global_position).normalized()\n\tif not _is_bullet_spawn_clear(direction):\n\t\treturn false\n\n\t# Check if friendlies are in the way\n\tif not _is_firing_line_clear_of_friendlies(target_position):\n\t\treturn false\n\n\t# Check if cover blocks the shot\n\tif not _is_shot_clear_of_cover(target_position):\n\t\treturn false\n\n\treturn true\n\n\n## Check if the player is \"close\" (within CLOSE_COMBAT_DISTANCE).\n## Used to determine if the enemy should engage directly or pursue.\nfunc _is_player_close() -> bool:\n\tif _player == null:\n\t\treturn false\n\treturn global_position.distance_to(_player.global_position) <= CLOSE_COMBAT_DISTANCE\n\n\n## Check if the enemy can hit the player from their current position.\n## Returns true if there's a clear line of fire to the player.\nfunc _can_hit_player_from_current_position() -> bool:\n\tif _player == null:\n\t\treturn false\n\n\t# Check if we can see the player\n\tif not _can_see_player:\n\t\treturn false\n\n\t# Check if the shot would be blocked by cover\n\treturn _is_shot_clear_of_cover(_player.global_position)\n\n\n## Count the number of enemies currently in combat-related states.\n## Includes COMBAT, PURSUING, ASSAULT, IN_COVER (if can see player).\n## Used to determine if multi-enemy assault should be triggered.\nfunc _count_enemies_in_combat() -> int:\n\tvar count := 0\n\tvar enemies := get_tree().get_nodes_in_group(\"enemies\")\n\n\tfor enemy in enemies:\n\t\tif enemy == self:\n\t\t\tcontinue\n\t\tif not enemy.has_method(\"get_current_state\"):\n\t\t\tcontinue\n\n\t\tvar state: AIState = enemy.get_current_state()\n\t\t# Count enemies in combat-related states\n\t\tif state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\t\t# For IN_COVER, only count if they can see the player\n\t\t\tif state == AIState.IN_COVER:\n\t\t\t\tif enemy.has_method(\"is_in_combat_engagement\") and enemy.is_in_combat_engagement():\n\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tcount += 1\n\n\t# Count self if in a combat-related state\n\tif _current_state in [AIState.COMBAT, AIState.ASSAULT, AIState.IN_COVER, AIState.SEEKING_COVER, AIState.PURSUING]:\n\t\tcount += 1\n\n\treturn count\n\n\n## Check if this enemy is engaged in combat (can see player and in combat state).\nfunc is_in_combat_engagement() -> bool:\n\treturn _can_see_player and _current_state in [AIState.COMBAT, AIState.IN_COVER, AIState.ASSAULT]\n\n\n## Find cover position closer to the player for pursuit.\n## Used during PURSUING state to move cover-to-cover toward the player.\nfunc _find_pursuit_cover_toward_player() -> void:\n\tif _player == null:\n\t\t_has_pursuit_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For pursuit, we want cover that is:\n\t\t\t# 1. Closer to the player than we currently are\n\t\t\t# 2. Hidden from the player (or mostly hidden)\n\t\t\t# 3. Not too far from our current position\n\n\t\t\tvar my_distance_to_player := global_position.distance_to(player_pos)\n\t\t\tvar cover_distance_to_player := cover_pos.distance_to(player_pos)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to player\n\t\t\tif cover_distance_to_player >= my_distance_to_player:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if this position is hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Hidden from player (priority)\n\t\t\t# - Closer to player\n\t\t\t# - Not too far from current position\n\t\t\tvar hidden_score: float = 5.0 if is_hidden else 0.0\n\t\t\tvar approach_score: float = (my_distance_to_player - cover_distance_to_player) / CLOSE_COMBAT_DISTANCE\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = hidden_score + approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_pursuit_next_cover = best_cover\n\t\t_has_pursuit_cover = true\n\t\t_log_debug(\"Found pursuit cover at %s (score: %.2f)\" % [_pursuit_next_cover, best_score])\n\telse:\n\t\t_has_pursuit_cover = false\n\n\n## Find cover position closest to the player for assault positioning.\n## Used during ASSAULT state to take the nearest safe cover to the player.\nfunc _find_cover_closest_to_player() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_distance: float = INF\n\tvar found_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# Check if this position is hidden from player (safe cover)\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\tif is_hidden:\n\t\t\t\t# Calculate distance from this cover to the player\n\t\t\t\tvar distance_to_player := cover_pos.distance_to(player_pos)\n\n\t\t\t\t# We want the cover closest to the player\n\t\t\t\tif distance_to_player < best_distance:\n\t\t\t\t\tbest_distance = distance_to_player\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\t\tfound_cover = true\n\n\tif found_cover:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found assault cover at %s (distance to player: %.1f)\" % [_cover_position, best_distance])\n\telse:\n\t\t# Fall back to normal cover finding\n\t\t_find_cover_position()\n\n\n## Find a valid cover position relative to the player.\n## The cover position must be hidden from the player's line of sight.\nfunc _find_cover_position() -> void:\n\tif _player == null:\n\t\t_has_valid_cover = false\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_hidden_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is on the opposite side of the obstacle from player\n\t\t\tvar direction_from_player := (collision_point - player_pos).normalized()\n\n\t\t\t# Position behind cover (offset from collision point along normal)\n\t\t\t# Offset must be large enough to hide the entire enemy body (radius ~24 pixels)\n\t\t\t# Using 35 pixels to provide some margin for the enemy's collision shape\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# First priority: Check if this position is actually hidden from player\n\t\t\tvar is_hidden := not _is_position_visible_from_player(cover_pos)\n\n\t\t\t# Only consider hidden positions unless we have no choice\n\t\t\tif is_hidden or not found_hidden_cover:\n\t\t\t\t# Score based on:\n\t\t\t\t# 1. Whether position is hidden (highest priority)\n\t\t\t\t# 2. Distance from enemy (closer is better)\n\t\t\t\t# 3. Position relative to player (behind cover from player's view)\n\t\t\t\tvar hidden_score: float = 10.0 if is_hidden else 0.0  # Heavy weight for hidden positions\n\n\t\t\t\tvar distance_score := 1.0 - (global_position.distance_to(cover_pos) / COVER_CHECK_DISTANCE)\n\n\t\t\t\t# Check if this position is on the far side of obstacle from player\n\t\t\t\tvar cover_direction := (cover_pos - player_pos).normalized()\n\t\t\t\tvar dot_product := direction_from_player.dot(cover_direction)\n\t\t\t\tvar blocking_score: float = maxf(0.0, dot_product)\n\n\t\t\t\tvar total_score: float = hidden_score + distance_score * 0.3 + blocking_score * 0.7\n\n\t\t\t\t# If we find a hidden position, only accept other hidden positions\n\t\t\t\tif is_hidden and not found_hidden_cover:\n\t\t\t\t\tfound_hidden_cover = true\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\t\t\t\telif (is_hidden or not found_hidden_cover) and total_score > best_score:\n\t\t\t\t\tbest_score = total_score\n\t\t\t\t\tbest_cover = cover_pos\n\n\tif best_score > 0:\n\t\t_cover_position = best_cover\n\t\t_has_valid_cover = true\n\t\t_log_debug(\"Found cover at: %s (hidden: %s)\" % [_cover_position, found_hidden_cover])\n\telse:\n\t\t_has_valid_cover = false\n\n\n## Calculate flank position based on player location.\nfunc _calculate_flank_position() -> void:\n\tif _player == null:\n\t\treturn\n\n\tvar player_pos := _player.global_position\n\tvar player_to_enemy := (global_position - player_pos).normalized()\n\n\t# Choose left or right flank based on current position\n\tvar flank_side := 1.0 if randf() > 0.5 else -1.0\n\tvar flank_direction := player_to_enemy.rotated(flank_angle * flank_side)\n\n\t_flank_target = player_pos + flank_direction * flank_distance\n\t_log_debug(\"Flank target: %s\" % _flank_target)\n\n\n## Check if there's a clear path (no obstacles) to the target position.\n## Uses a raycast to check for walls/obstacles between current position and target.\nfunc _has_clear_path_to(target: Vector2) -> bool:\n\tif _raycast == null:\n\t\treturn true  # Assume clear if no raycast available\n\n\tvar direction := (target - global_position).normalized()\n\tvar distance := global_position.distance_to(target)\n\n\t_raycast.target_position = direction * distance\n\t_raycast.force_raycast_update()\n\n\t# If we hit something, path is blocked\n\tif _raycast.is_colliding():\n\t\tvar collision_point := _raycast.get_collision_point()\n\t\tvar collision_distance := global_position.distance_to(collision_point)\n\t\t# Only consider it blocked if the collision is before the target\n\t\treturn collision_distance >= distance - 10.0\n\n\treturn true\n\n\n## Find cover position closer to the flank target.\n## Used during FLANKING state to move cover-to-cover toward the flank position.\nfunc _find_flank_cover_toward_target() -> void:\n\tvar best_cover: Vector2 = Vector2.ZERO\n\tvar best_score: float = -INF\n\tvar found_valid_cover: bool = false\n\n\t# Cast rays in all directions to find obstacles\n\tfor i in range(COVER_CHECK_COUNT):\n\t\tvar angle := (float(i) / COVER_CHECK_COUNT) * TAU\n\t\tvar direction := Vector2.from_angle(angle)\n\n\t\tvar raycast := _cover_raycasts[i]\n\t\traycast.target_position = direction * COVER_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\tvar collision_point := raycast.get_collision_point()\n\t\t\tvar collision_normal := raycast.get_collision_normal()\n\n\t\t\t# Cover position is offset from collision point along normal\n\t\t\tvar cover_pos := collision_point + collision_normal * 35.0\n\n\t\t\t# For flanking, we want cover that is:\n\t\t\t# 1. Closer to the flank target than we currently are\n\t\t\t# 2. Not too far from our current position\n\t\t\t# 3. Reachable (has clear path)\n\n\t\t\tvar my_distance_to_target := global_position.distance_to(_flank_target)\n\t\t\tvar cover_distance_to_target := cover_pos.distance_to(_flank_target)\n\t\t\tvar cover_distance_from_me := global_position.distance_to(cover_pos)\n\n\t\t\t# Skip covers that don't bring us closer to flank target\n\t\t\tif cover_distance_to_target >= my_distance_to_target:\n\t\t\t\tcontinue\n\n\t\t\t# Skip covers that are too close to current position (would cause looping)\n\t\t\t# Must be at least 30 pixels away to be a meaningful movement\n\t\t\tif cover_distance_from_me < 30.0:\n\t\t\t\tcontinue\n\n\t\t\t# Check if we can reach this cover (has clear path)\n\t\t\tif not _has_clear_path_to(cover_pos):\n\t\t\t\t# Even if direct path is blocked, we might be able to reach\n\t\t\t\t# via another intermediate cover, but skip for now\n\t\t\t\tcontinue\n\n\t\t\t# Score calculation:\n\t\t\t# Higher score for positions that are:\n\t\t\t# - Closer to flank target (priority)\n\t\t\t# - Not too far from current position\n\t\t\tvar approach_score: float = (my_distance_to_target - cover_distance_to_target) / flank_distance\n\t\t\tvar distance_penalty: float = cover_distance_from_me / COVER_CHECK_DISTANCE\n\n\t\t\tvar total_score: float = approach_score * 2.0 - distance_penalty\n\n\t\t\tif total_score > best_score:\n\t\t\t\tbest_score = total_score\n\t\t\t\tbest_cover = cover_pos\n\t\t\t\tfound_valid_cover = true\n\n\tif found_valid_cover:\n\t\t_flank_next_cover = best_cover\n\t\t_has_flank_cover = true\n\t\t_log_debug(\"Found flank cover at %s (score: %.2f)\" % [_flank_next_cover, best_score])\n\telse:\n\t\t_has_flank_cover = false\n\n\n## Check if there's a wall ahead in the given direction and return avoidance direction.\n## Returns Vector2.ZERO if no wall detected, otherwise returns a vector to avoid the wall.\nfunc _check_wall_ahead(direction: Vector2) -> Vector2:\n\tif _wall_raycasts.is_empty():\n\t\treturn Vector2.ZERO\n\n\tvar avoidance := Vector2.ZERO\n\tvar perpendicular := Vector2(-direction.y, direction.x)  # 90 degrees rotation\n\n\t# Check center, left, and right raycasts\n\tfor i in range(WALL_CHECK_COUNT):\n\t\tvar angle_offset := (i - 1) * 0.5  # -0.5, 0, 0.5 radians (~-28, 0, 28 degrees)\n\t\tvar check_direction := direction.rotated(angle_offset)\n\n\t\tvar raycast := _wall_raycasts[i]\n\t\traycast.target_position = check_direction * WALL_CHECK_DISTANCE\n\t\traycast.force_raycast_update()\n\n\t\tif raycast.is_colliding():\n\t\t\t# Calculate avoidance based on which raycast hit\n\t\t\tif i == 0:  # Left raycast hit\n\t\t\t\tavoidance += perpendicular  # Steer right\n\t\t\telif i == 1:  # Center raycast hit\n\t\t\t\tavoidance += perpendicular if randf() > 0.5 else -perpendicular  # Random steer\n\t\t\telif i == 2:  # Right raycast hit\n\t\t\t\tavoidance -= perpendicular  # Steer left\n\n\treturn avoidance.normalized() if avoidance.length() > 0 else Vector2.ZERO\n\n\n## Check if the player is visible using raycast.\n## If detection_range is 0 or negative, uses unlimited detection range (line-of-sight only).\n## This allows the enemy to see the player even outside the viewport if there's no obstacle.\n## Also updates the continuous visibility timer and visibility ratio for lead prediction control.\nfunc _check_player_visibility() -> void:\n\tvar was_visible := _can_see_player\n\t_can_see_player = false\n\t_player_visibility_ratio = 0.0\n\n\tif _player == null or not _raycast:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\tvar distance_to_player := global_position.distance_to(_player.global_position)\n\n\t# Check if player is within detection range (only if detection_range is positive)\n\t# If detection_range <= 0, detection is unlimited (line-of-sight only)\n\tif detection_range > 0 and distance_to_player > detection_range:\n\t\t_continuous_visibility_timer = 0.0\n\t\treturn\n\n\t# Point raycast at player - use actual distance to player for the raycast length\n\tvar direction_to_player := (_player.global_position - global_position).normalized()\n\tvar raycast_length := distance_to_player + 10.0  # Add small buffer to ensure we reach player\n\t_raycast.target_position = direction_to_player * raycast_length\n\t_raycast.force_raycast_update()\n\n\t# Check if raycast hit something\n\tif _raycast.is_colliding():\n\t\tvar collider := _raycast.get_collider()\n\t\t# If we hit the player, we can see them\n\t\tif collider == _player:\n\t\t\t_can_see_player = true\n\t\t# If we hit a wall/obstacle before the player, we can't see them\n\telse:\n\t\t# No collision between us and player - we have clear line of sight\n\t\t_can_see_player = true\n\n\t# Update continuous visibility timer and visibility ratio\n\tif _can_see_player:\n\t\t_continuous_visibility_timer += get_physics_process_delta_time()\n\t\t# Calculate what fraction of the player's body is visible\n\t\t# This is used to determine if lead prediction should be enabled\n\t\t_player_visibility_ratio = _calculate_player_visibility_ratio()\n\t\t# Update last known player position while we can see them\n\t\t_last_known_player_position = _player.global_position\n\t\t# Clear search zone when player is seen\n\t\tif _search_zone_active:\n\t\t\t_clear_search_zone()\n\telse:\n\t\t# Lost line of sight - reset the timer and visibility ratio\n\t\t_continuous_visibility_timer = 0.0\n\t\t_player_visibility_ratio = 0.0\n\t\t# If we just lost sight and were in combat, activate search zone\n\t\tif was_visible and _last_known_player_position != Vector2.ZERO:\n\t\t\t_log_debug(\"Player escaped from view at %s\" % _last_known_player_position)\n\n\n## Aim the enemy sprite/direction at the player using gradual rotation.\nfunc _aim_at_player() -> void:\n\tif _player == null:\n\t\treturn\n\tvar direction := (_player.global_position - global_position).normalized()\n\tvar target_angle := direction.angle()\n\n\t# Calculate the shortest rotation direction\n\tvar angle_diff := wrapf(target_angle - rotation, -PI, PI)\n\n\t# Get the delta time from the current physics process\n\tvar delta := get_physics_process_delta_time()\n\n\t# Apply gradual rotation based on rotation_speed\n\tif abs(angle_diff) <= rotation_speed * delta:\n\t\t# Close enough to snap to target\n\t\trotation = target_angle\n\telif angle_diff > 0:\n\t\trotation += rotation_speed * delta\n\telse:\n\t\trotation -= rotation_speed * delta\n\n\n## Shoot a bullet towards the player.\nfunc _shoot() -> void:\n\tif bullet_scene == null or _player == null:\n\t\treturn\n\n\t# Check if we can shoot (have ammo and not reloading)\n\tif not _can_shoot():\n\t\treturn\n\n\tvar target_position := _player.global_position\n\n\t# Apply lead prediction if enabled\n\tif enable_lead_prediction:\n\t\ttarget_position = _calculate_lead_prediction()\n\n\t# Check if the shot should be taken (friendly fire and cover checks)\n\tif not _should_shoot_at_target(target_position):\n\t\treturn\n\n\tvar direction := (target_position - global_position).normalized()\n\n\t# Create bullet instance\n\tvar bullet := bullet_scene.instantiate()\n\n\t# Set bullet position with offset in shoot direction\n\tbullet.global_position = global_position + direction * bullet_spawn_offset\n\n\t# Set bullet direction\n\tbullet.direction = direction\n\n\t# Set shooter ID to identify this enemy as the source\n\t# This prevents enemies from detecting their own bullets in the threat sphere\n\tbullet.shooter_id = get_instance_id()\n\n\t# Add bullet to the scene tree\n\tget_tree().current_scene.add_child(bullet)\n\n\t# Play shooting sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_m16_shot\"):\n\t\taudio_manager.play_m16_shot(global_position)\n\n\t# Play shell casing sound with a small delay\n\t_play_delayed_shell_sound()\n\n\t# Consume ammo\n\t_current_ammo -= 1\n\tammo_changed.emit(_current_ammo, _reserve_ammo)\n\n\t# Auto-reload when magazine is empty\n\tif _current_ammo <= 0 and _reserve_ammo > 0:\n\t\t_start_reload()\n\n\n## Play shell casing sound with a delay to simulate the casing hitting the ground.\nfunc _play_delayed_shell_sound() -> void:\n\tawait get_tree().create_timer(0.15).timeout\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif audio_manager and audio_manager.has_method(\"play_shell_rifle\"):\n\t\taudio_manager.play_shell_rifle(global_position)\n\n\n## Calculate lead prediction - aims where the player will be, not where they are.\n## Uses iterative approach for better accuracy with moving targets.\n## Only applies lead prediction if:\n## 1. The player has been continuously visible for at least lead_prediction_delay seconds\n## 2. At least lead_prediction_visibility_threshold of the player's body is visible\n## 3. The predicted position is also visible to the enemy (not behind cover)\n## This prevents enemies from \"knowing\" where the player will emerge from cover.\nfunc _calculate_lead_prediction() -> Vector2:\n\tif _player == null:\n\t\treturn global_position\n\n\tvar player_pos := _player.global_position\n\n\t# Only use lead prediction if the player has been continuously visible\n\t# for long enough. This prevents enemies from predicting player position\n\t# immediately when they emerge from cover.\n\tif _continuous_visibility_timer < lead_prediction_delay:\n\t\t_log_debug(\"Lead prediction disabled: visibility time %.2fs < %.2fs required\" % [_continuous_visibility_timer, lead_prediction_delay])\n\t\treturn player_pos\n\n\t# Only use lead prediction if enough of the player's body is visible.\n\t# This prevents pre-firing when the player is at the edge of cover with only\n\t# a small part of their body visible. The player must be significantly exposed\n\t# before the enemy can predict their movement.\n\tif _player_visibility_ratio < lead_prediction_visibility_threshold:\n\t\t_log_debug(\"Lead prediction disabled: visibility ratio %.2f < %.2f required (player at cover edge)\" % [_player_visibility_ratio, lead_prediction_visibility_threshold])\n\t\treturn player_pos\n\n\tvar player_velocity := Vector2.ZERO\n\n\t# Get player velocity if they are a CharacterBody2D\n\tif _player is CharacterBody2D:\n\t\tplayer_velocity = _player.velocity\n\n\t# If player is stationary, no need for prediction\n\tif player_velocity.length_squared() < 1.0:\n\t\treturn player_pos\n\n\t# Iterative lead prediction for better accuracy\n\t# Start with player's current position\n\tvar predicted_pos := player_pos\n\tvar distance := global_position.distance_to(predicted_pos)\n\n\t# Iterate 2-3 times for convergence\n\tfor i in range(3):\n\t\t# Time for bullet to reach the predicted position\n\t\tvar time_to_target := distance / bullet_speed\n\n\t\t# Predict where player will be at that time\n\t\tpredicted_pos = player_pos + player_velocity * time_to_target\n\n\t\t# Update distance for next iteration\n\t\tdistance = global_position.distance_to(predicted_pos)\n\n\t# CRITICAL: Validate that the predicted position is actually visible to the enemy.\n\t# If the predicted position is behind cover (e.g., player is running toward cover exit),\n\t# we should NOT aim there - it would feel like the enemy is \"cheating\" by knowing\n\t# where the player will emerge. Fall back to player's current visible position.\n\tif not _is_position_visible_to_enemy(predicted_pos):\n\t\t_log_debug(\"Lead prediction blocked: predicted position %s is not visible, using current position %s\" % [predicted_pos, player_pos])\n\t\treturn player_pos\n\n\t_log_debug(\"Lead prediction: player at %s moving %s, aiming at %s\" % [player_pos, player_velocity, predicted_pos])\n\n\treturn predicted_pos\n\n\n## Process patrol behavior - move between patrol points.\nfunc _process_patrol(delta: float) -> void:\n\tif _patrol_points.is_empty():\n\t\treturn\n\n\t# Handle waiting at patrol point\n\tif _is_waiting_at_patrol_point:\n\t\t_patrol_wait_timer += delta\n\t\tif _patrol_wait_timer >= patrol_wait_time:\n\t\t\t_is_waiting_at_patrol_point = false\n\t\t\t_patrol_wait_timer = 0.0\n\t\t\t_current_patrol_index = (_current_patrol_index + 1) % _patrol_points.size()\n\t\tvelocity = Vector2.ZERO\n\t\treturn\n\n\t# Move towards current patrol point\n\tvar target_point := _patrol_points[_current_patrol_index]\n\tvar direction := (target_point - global_position).normalized()\n\tvar distance := global_position.distance_to(target_point)\n\n\tif distance < 5.0:\n\t\t# Reached patrol point, start waiting\n\t\t_is_waiting_at_patrol_point = true\n\t\tvelocity = Vector2.ZERO\n\telse:\n\t\t# Check for walls and apply avoidance\n\t\tvar avoidance := _check_wall_ahead(direction)\n\t\tif avoidance != Vector2.ZERO:\n\t\t\t# Blend movement direction with avoidance\n\t\t\tdirection = (direction * 0.5 + avoidance * 0.5).normalized()\n\n\t\tvelocity = direction * move_speed\n\t\t# Face movement direction when patrolling\n\t\trotation = direction.angle()\n\n\n## Process guard behavior - stand still and look around.\nfunc _process_guard(_delta: float) -> void:\n\tvelocity = Vector2.ZERO\n\t# In guard mode, enemy doesn't move but can still aim at player when visible\n\n\n## Called when a bullet enters the threat sphere.\nfunc _on_threat_area_entered(area: Area2D) -> void:\n\t# Check if bullet has shooter_id property and if it's from this enemy\n\t# This prevents enemies from being suppressed by their own bullets\n\tif \"shooter_id\" in area and area.shooter_id == get_instance_id():\n\t\treturn  # Ignore own bullets\n\n\t_bullets_in_threat_sphere.append(area)\n\t# Set threat memory timer so enemy can react even after fast bullets exit\n\t# This allows the reaction delay to complete even if bullets pass through quickly\n\t_threat_memory_timer = THREAT_MEMORY_DURATION\n\t# Note: _under_fire is now set in _update_suppression after threat_reaction_delay\n\t# This gives the player more time before the enemy reacts to nearby gunfire\n\t_log_debug(\"Bullet entered threat sphere, starting reaction delay...\")\n\n\n## Called when a bullet exits the threat sphere.\nfunc _on_threat_area_exited(area: Area2D) -> void:\n\t_bullets_in_threat_sphere.erase(area)\n\n\n## Called when the enemy is hit (by bullet.gd).\nfunc on_hit() -> void:\n\tif not _is_alive:\n\t\treturn\n\n\thit.emit()\n\n\t# Track hits for retreat behavior\n\t_hits_taken_in_encounter += 1\n\t_log_debug(\"Hit taken! Total hits in encounter: %d\" % _hits_taken_in_encounter)\n\t_log_to_file(\"Hit taken, health: %d/%d\" % [_current_health - 1, _max_health])\n\n\t# Show hit flash effect\n\t_show_hit_flash()\n\n\t# Apply damage\n\t_current_health -= 1\n\n\t# Play appropriate hit sound\n\tvar audio_manager: Node = get_node_or_null(\"/root/AudioManager\")\n\tif _current_health <= 0:\n\t\t# Play lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_lethal\"):\n\t\t\taudio_manager.play_hit_lethal(global_position)\n\t\t_on_death()\n\telse:\n\t\t# Play non-lethal hit sound\n\t\tif audio_manager and audio_manager.has_method(\"play_hit_non_lethal\"):\n\t\t\taudio_manager.play_hit_non_lethal(global_position)\n\t\t_update_health_visual()\n\n\n## Shows a brief flash effect when hit.\nfunc _show_hit_flash() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t_sprite.modulate = hit_flash_color\n\n\tawait get_tree().create_timer(hit_flash_duration).timeout\n\n\t# Restore color based on current health (if still alive)\n\tif _is_alive:\n\t\t_update_health_visual()\n\n\n## Updates the sprite color based on current health percentage.\nfunc _update_health_visual() -> void:\n\tif not _sprite:\n\t\treturn\n\n\t# Interpolate color based on health percentage\n\tvar health_percent := _get_health_percent()\n\t_sprite.modulate = full_health_color.lerp(low_health_color, 1.0 - health_percent)\n\n\n## Returns the current health as a percentage (0.0 to 1.0).\nfunc _get_health_percent() -> float:\n\tif _max_health <= 0:\n\t\treturn 0.0\n\treturn float(_current_health) / float(_max_health)\n\n\n## Called when the enemy dies.\nfunc _on_death() -> void:\n\t_is_alive = false\n\t_log_to_file(\"Enemy died\")\n\tdied.emit()\n\n\tif destroy_on_death:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\tqueue_free()\n\telse:\n\t\tawait get_tree().create_timer(respawn_delay).timeout\n\t\t_reset()\n\n\n## Resets the enemy to its initial state.\nfunc _reset() -> void:\n\tglobal_position = _initial_position\n\trotation = 0.0\n\t_current_patrol_index = 0\n\t_is_waiting_at_patrol_point = false\n\t_patrol_wait_timer = 0.0\n\t_current_state = AIState.IDLE\n\t_has_valid_cover = false\n\t_under_fire = false\n\t_suppression_timer = 0.0\n\t_detection_timer = 0.0\n\t_detection_delay_elapsed = false\n\t_continuous_visibility_timer = 0.0\n\t_player_visibility_ratio = 0.0\n\t_threat_reaction_timer = 0.0\n\t_threat_reaction_delay_elapsed = false\n\t_threat_memory_timer = 0.0\n\t_bullets_in_threat_sphere.clear()\n\t# Reset retreat state variables\n\t_hits_taken_in_encounter = 0\n\t_retreat_mode = RetreatMode.FULL_HP\n\t_retreat_turn_timer = 0.0\n\t_retreat_turning_to_cover = false\n\t_retreat_burst_remaining = 0\n\t_retreat_burst_timer = 0.0\n\t_retreat_burst_complete = false\n\t_retreat_burst_angle_offset = 0.0\n\t_in_alarm_mode = false\n\t_cover_burst_pending = false\n\t# Reset combat state variables\n\t_combat_shoot_timer = 0.0\n\t_combat_shoot_duration = 2.5\n\t_combat_exposed = false\n\t_combat_approaching = false\n\t_combat_approach_timer = 0.0\n\t# Reset pursuit state variables\n\t_pursuit_cover_wait_timer = 0.0\n\t_pursuit_next_cover = Vector2.ZERO\n\t_has_pursuit_cover = false\n\t# Reset assault state variables\n\t_assault_wait_timer = 0.0\n\t_assault_ready = false\n\t_in_assault = false\n\t# Reset flank state variables\n\t_flank_cover_wait_timer = 0.0\n\t_flank_next_cover = Vector2.ZERO\n\t_has_flank_cover = false\n\t_initialize_health()\n\t_initialize_ammo()\n\t_update_health_visual()\n\t_initialize_goap_state()\n\n\n## Log debug message if debug_logging is enabled.\nfunc _log_debug(message: String) -> void:\n\tif debug_logging:\n\t\tprint(\"[Enemy %s] %s\" % [name, message])\n\n\n## Log a message to the file logger (always logs, regardless of debug_logging setting).\n## Use for important events like spawning, dying, or critical state changes.\nfunc _log_to_file(message: String) -> void:\n\tif not is_inside_tree():\n\t\treturn\n\tvar file_logger: Node = get_node_or_null(\"/root/FileLogger\")\n\tif file_logger and file_logger.has_method(\"log_enemy\"):\n\t\tfile_logger.log_enemy(name, message)\n\n\n## Log spawn info (called via call_deferred to ensure FileLogger is loaded).\nfunc _log_spawn_info() -> void:\n\t_log_to_file(\"Enemy spawned at %s, health: %d, behavior: %s, player_found: %s\" % [\n\t\tglobal_position, _max_health, BehaviorMode.keys()[behavior_mode],\n\t\t\"yes\" if _player != null else \"no\"])\n\n\n## Get AI state name as a human-readable string.\nfunc _get_state_name(state: AIState) -> String:\n\tmatch state:\n\t\tAIState.IDLE:\n\t\t\treturn \"IDLE\"\n\t\tAIState.COMBAT:\n\t\t\treturn \"COMBAT\"\n\t\tAIState.SEEKING_COVER:\n\t\t\treturn \"SEEKING_COVER\"\n\t\tAIState.IN_COVER:\n\t\t\treturn \"IN_COVER\"\n\t\tAIState.FLANKING:\n\t\t\treturn \"FLANKING\"\n\t\tAIState.SUPPRESSED:\n\t\t\treturn \"SUPPRESSED\"\n\t\tAIState.RETREATING:\n\t\t\treturn \"RETREATING\"\n\t\tAIState.PURSUING:\n\t\t\treturn \"PURSUING\"\n\t\tAIState.ASSAULT:\n\t\t\treturn \"ASSAULT\"\n\t\tAIState.SEARCHING:\n\t\t\treturn \"SEARCHING\"\n\t\t_:\n\t\t\treturn \"UNKNOWN\"\n\n\n## Update the debug label with current AI state.\nfunc _update_debug_label() -> void:\n\tif _debug_label == null:\n\t\treturn\n\n\t_debug_label.vis
[2026-01-18T02:54:18.495Z] [INFO] ible = debug_label_enabled\n\tif not debug_label_enabled:\n\t\treturn\n\n\tvar state_text := _get_state_name(_current_state)\n\n\t# Add retreat mode info if retreating\n\tif _current_state == AIState.RETREATING:\n\t\tmatch _retreat_mode:\n\t\t\tRetreatMode.FULL_HP:\n\t\t\t\tstate_text += \"\\n(FULL_HP)\"\n\t\t\tRetreatMode.ONE_HIT:\n\t\t\t\tstate_text += \"\\n(ONE_HIT)\"\n\t\t\tRetreatMode.MULTIPLE_HITS:\n\t\t\t\tstate_text += \"\\n(MULTI_HITS)\"\n\n\t# Add assault timer info if in assault state\n\tif _current_state == AIState.ASSAULT:\n\t\tif _assault_ready:\n\t\t\tstate_text += \"\\n(RUSHING)\"\n\t\telse:\n\t\t\tvar time_left := ASSAULT_WAIT_DURATION - _assault_wait_timer\n\t\t\tstate_text += \"\\n(%.1fs)\" % time_left\n\n\t# Add combat phase info if in combat\n\tif _current_state == AIState.COMBAT:\n\t\tif _combat_exposed:\n\t\t\tvar time_left := _combat_shoot_duration - _combat_shoot_timer\n\t\t\tstate_text += \"\\n(EXPOSED %.1fs)\" % time_left\n\t\telif _seeking_clear_shot:\n\t\t\tvar time_left := CLEAR_SHOT_MAX_TIME - _clear_shot_timer\n\t\t\tstate_text += \"\\n(SEEK SHOT %.1fs)\" % time_left\n\t\telif _combat_approaching:\n\t\t\tstate_text += \"\\n(APPROACH)\"\n\n\t# Add pursuit timer info if pursuing and waiting at cover\n\tif _current_state == AIState.PURSUING:\n\t\tif _has_valid_cover and not _has_pursuit_cover:\n\t\t\tvar time_left := PURSUIT_COVER_WAIT_DURATION - _pursuit_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_pursuit_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\n\t# Add flanking phase info if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_valid_cover and not _has_flank_cover:\n\t\t\tvar time_left := FLANK_COVER_WAIT_DURATION - _flank_cover_wait_timer\n\t\t\tstate_text += \"\\n(WAIT %.1fs)\" % time_left\n\t\telif _has_flank_cover:\n\t\t\tstate_text += \"\\n(MOVING)\"\n\t\telse:\n\t\t\tstate_text += \"\\n(DIRECT)\"\n\n\t# Add searching phase info if searching\n\tif _current_state == AIState.S
[2026-01-18T02:54:18.497Z] [INFO] EARCHING:\n\t\tvar time_left := SEARCH_MAX_DURATION - _search_timer\n\t\tif _inspecting_point:\n\t\t\tstate_text += \"\\n(INSPECT %d/%d)\" % [_current_inspection_index + 1, _inspection_points.size()]\n\t\telse:\n\t\t\tstate_text += \"\\n(%d pts %.1fs)\" % [_inspection_points.size() - _current_inspection_index, time_left]\n\n\t_debug_label.text = state_text\n\n\n## Get current AI state (for external access/debugging).\nfunc get_current_state() -> AIState:\n\treturn _current_state\n\n\n## Get GOAP world state (for GOAP planner).\nfunc get_goap_world_state() -> Dictionary:\n\treturn _goap_world_state.duplicate()\n\n\n## Check if enemy is currently under fire.\nfunc is_under_fire() -> bool:\n\treturn _under_fire\n\n\n## Check if enemy is in cover.\nfunc is_in_cover() -> bool:\n\treturn _current_state == AIState.IN_COVER or _current_state == AIState.SUPPRESSED\n\n\n## Get current ammo in magazine.\nfunc get_current_ammo() -> int:\n\treturn _current_ammo\n\n\n## Get reserve ammo.\nfunc get_reserve_ammo() -> int:\n\treturn _reserve_ammo\n\n\n## Get total ammo (current + reserve).\nfunc get_total_ammo() -> int:\n\treturn _current_ammo + _reserve_ammo\n\n\n## Check if enemy is currently reloading.\nfunc is_reloading() -> bool:\n\treturn _is_reloading\n\n\n## Check if enemy has any ammo left.\nfunc has_ammo() -> bool:\n\treturn _current_ammo > 0 or _reserve_ammo > 0\n\n\n## Get current player visibility ratio (for debugging).\n## Returns 0.0 if player is completely hidden, 1.0 if fully visible.\nfunc get_player_visibility_ratio() -> float:\n\treturn _player_visibility_ratio\n\n\n## Draw debug visualization when debug mode is enabled.\n## Shows: line to target (cover, clear shot, player), bullet spawn point status.\nfunc _draw() -> void:\n\tif not debug_label_enabled:\n\t\treturn\n\n\t# Colors for different debug elements\n\tvar color_to_cover := Color.CYAN  # Line to cover position\n\tvar color_to_player := Color.RED  # Line to player (when visible)\n\tvar color_clear_shot := Color.YELLOW  # Line to clear shot target\n\tvar color_pursuit := Color.ORANGE  # Line to pursuit cover\n\tvar color_flank := Color.MAGENTA  # Line to flank position\n\tvar color_bullet_spawn := Color.GREEN  # Bullet spawn point indicator\n\tvar color_blocked := Color.RED  # Blocked path indicator\n\n\t# Draw line to player if visible\n\tif _can_see_player and _player:\n\t\tvar to_player := _player.global_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_player, color_to_player, 1.5)\n\n\t\t# Draw bullet spawn point and check if blocked\n\t\tvar direction_to_player := to_player.normalized()\n\t\tvar spawn_point := direction_to_player * bullet_spawn_offset\n\t\tif _is_bullet_spawn_clear(direction_to_player):\n\t\t\tdraw_circle(spawn_point, 5.0, color_bullet_spawn)\n\t\telse:\n\t\t\t# Draw X for blocked spawn point\n\t\t\tdraw_line(spawn_point + Vector2(-5, -5), spawn_point + Vector2(5, 5), color_blocked, 2.0)\n\t\t\tdraw_line(spawn_point + Vector2(-5, 5), spawn_point + Vector2(5, -5), color_blocked, 2.0)\n\n\t# Draw line to cover position if we have one\n\tif _has_valid_cover:\n\t\tvar to_cover := _cover_position - global_position\n\t\tdraw_line(Vector2.ZERO, to_cover, color_to_cover, 1.5)\n\t\t# Draw small circle at cover position\n\t\tdraw_circle(to_cover, 8.0, color_to_cover)\n\n\t# Draw line to clear shot target if seeking clear shot\n\tif _seeking_clear_shot and _clear_shot_target != Vector2.ZERO:\n\t\tvar to_target := _clear_shot_target - global_position\n\t\tdraw_line(Vector2.ZERO, to_target, color_clear_shot, 2.0)\n\t\t# Draw triangle at target position\n\t\tvar target_pos := to_target\n\t\tdraw_line(target_pos + Vector2(-6, 6), target_pos + Vector2(6, 6), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(6, 6), target_pos + Vector2(0, -8), color_clear_shot, 2.0)\n\t\tdraw_line(target_pos + Vector2(0, -8), target_pos + Vector2(-6, 6), color_clear_shot, 2.0)\n\n\t# Draw line to pursuit cover if pursuing\n\tif _current_state == AIState.PURSUING and _has_pursuit_cover:\n\t\tvar to_pursuit := _pursuit_next_cover - global_position\n\t\tdraw_line(Vector2.ZERO, to_pursuit, color_pursuit, 2.0)\n\t\tdraw_circle(to_pursuit, 8.0, color_pursuit)\n\n\t# Draw line to flank target if flanking\n\tif _current_state == AIState.FLANKING:\n\t\tif _has_flank_cover:\n\t\t\tvar to_flank_cover := _flank_next_cover - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank_cover, color_flank, 2.0)\n\t\t\tdraw_circle(to_flank_cover, 8.0, color_flank)\n\t\telif _flank_target != Vector2.ZERO:\n\t\t\tvar to_flank := _flank_target - global_position\n\t\t\tdraw_line(Vector2.ZERO, to_flank, color_flank, 1.5)\n\t\t\t# Draw diamond at flank target\n\t\t\tvar flank_pos := to_flank\n\t\t\tdraw_line(flank_pos + Vector2(0, -8), flank_pos + Vector2(8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)\n\t\t\tdraw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)\n","structuredPatch":[{"oldStart":3443,"oldLines":3,"newStart":3443,"newLines":39,"lines":["       draw_line(flank_pos + Vector2(8, 0), flank_pos + Vector2(0, 8), color_flank, 2.0)","       draw_line(flank_pos + Vector2(0, 8), flank_pos + Vector2(-8, 0), color_flank, 2.0)","       draw_line(flank_pos + Vector2(-8, 0), flank_pos + Vector2(0, -8), color_flank, 2.0)","+","+  # Draw search zone and inspection points if searching","+  if _current_state == AIState.SEARCHING and _search_zone_active:","+    var color_search_zone := Color(1.0, 0.5, 0.0, 0.3)  # Orange semi-transparent","+    var color_inspection := Color.LIME_GREEN","+    var color_inspection_current := Color.WHITE","+","+    # Draw circle representing search zone","+    var zone_center := _last_known_player_position - global_position","+    # Draw search zone outline (multiple segments to form a circle)","+    var segments := 24","+    for i in range(segments):","+      var angle1 := (float(i) / segments) * TAU","+      var angle2 := (float(i + 1) / segments) * TAU","+      var p1 := zone_center + Vector2.from_angle(angle1) * SEARCH_ZONE_RADIUS","+      var p2 := zone_center + Vector2.from_angle(angle2) * SEARCH_ZONE_RADIUS","+      draw_line(p1, p2, color_search_zone, 2.0)","+","+    # Draw last known position marker (X)","+    draw_line(zone_center + Vector2(-10, -10), zone_center + Vector2(10, 10), Color.RED, 2.0)","+    draw_line(zone_center + Vector2(-10, 10), zone_center + Vector2(10, -10), Color.RED, 2.0)","+","+    # Draw all inspection points","+    for i in range(_inspection_points.size()):","+      var point_pos := _inspection_points[i] - global_position","+      if i == _current_inspection_index:","+        # Current target - highlight in white","+        draw_circle(point_pos, 10.0, color_inspection_current)","+        # Draw line to current target","+        draw_line(Vector2.ZERO, point_pos, color_inspection_current, 2.0)","+      elif i < _current_inspection_index:","+        # Already checked - small circle","+        draw_circle(point_pos, 4.0, Color(0.5, 0.5, 0.5))","+      else:","+        # Not yet checked - green circle","+        draw_circle(point_pos, 6.0, color_inspection)"]}],"userModified":false,"replaceAll":false}}
[2026-01-18T02:54:21.468Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_017GvH29Zto8DkRLB71bJdBM",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me update the todos and update the GOAP action file to add a new search action:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 2676,
      "cache_read_input_tokens": 100556,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 2676,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 4,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "5dec0ee1-3b2d-45f7-8165-4133b5d4fe1f"
}
[2026-01-18T02:54:27.699Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_017GvH29Zto8DkRLB71bJdBM",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01FjEBiSC86UyGFBp1pGN1N9",
        "name": "TodoWrite",
        "input": {
          "todos": [
            {
              "content": "Read and analyze issue #103 requirements",
              "status": "completed",
              "activeForm": "Reading issue requirements"
            },
            {
              "content": "Explore existing AI/GOAP system architecture",
              "status": "completed",
              "activeForm": "Exploring AI/GOAP system architecture"
            },
            {
              "content": "Create case study directory structure",
              "status": "completed",
              "activeForm": "Creating case study directory structure"
            },
            {
              "content": "Research GOAP and AI search patterns online",
              "status": "completed",
              "activeForm": "Researching GOAP and AI search patterns"
            },
            {
              "content": "Document timeline and sequence of events",
              "status": "completed",
              "activeForm": "Documenting timeline and events"
            },
            {
              "content": "Identify root causes and propose solutions",
              "status": "completed",
              "activeForm": "Identifying root causes and solutions"
            },
            {
              "content": "Implement enemy search behavior with last-known-position",
              "status": "completed",
              "activeForm": "Implementing enemy search behavior"
            },
            {
              "content": "Add inspection points system for corners and hiding spots",
              "status": "completed",
              "activeForm": "Adding inspection points system"
            },
            {
              "content": "Update GOAP actions for search behavior",
              "status": "in_progress",
              "activeForm": "Updating GOAP actions"
            },
            {
              "content": "Test and verify implementation",
              "status": "pending",
              "activeForm": "Testing implementation"
            },
            {
              "content": "Update PR description and finalize",
              "status": "pending",
              "activeForm": "Updating PR and finalizing"
            }
          ]
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 2676,
      "cache_read_input_tokens": 100556,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 2676,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 4,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "bbe6e7e7-541e-4f23-a975-23bcc529ebc8"
}
[2026-01-18T02:54:27.710Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_017GvH29Zto8DkRLB71bJdBM",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01S39UNxY7K5CTc6T5qWhFZG",
        "name": "Read",
        "input": {
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/ai/enemy_actions.gd"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 2676,
      "cache_read_input_tokens": 100556,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 2676,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 4,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "7d278d4e-3932-48d3-a1d4-f38732d7af2e"
}
[2026-01-18T02:54:27.731Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01FjEBiSC86UyGFBp1pGN1N9",
        "type": "tool_result",
        "content": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "87e5b596-4466-49b4-ade5-a45ade3ba53f",
  "tool_use_result": {
    "oldTodos": [
      {
        "content": "Read and analyze issue #103 requirements",
        "status": "completed",
        "activeForm": "Reading issue requirements"
      },
      {
        "content": "Explore existing AI/GOAP system architecture",
        "status": "completed",
        "activeForm": "Exploring AI/GOAP system architecture"
      },
      {
        "content": "Create case study directory structure",
        "status": "completed",
        "activeForm": "Creating case study directory structure"
      },
      {
        "content": "Research GOAP and AI search patterns online",
        "status": "completed",
        "activeForm": "Researching GOAP and AI search patterns"
      },
      {
        "content": "Document timeline and sequence of events",
        "status": "completed",
        "activeForm": "Documenting timeline and events"
      },
      {
        "content": "Identify root causes and propose solutions",
        "status": "completed",
        "activeForm": "Identifying root causes and solutions"
      },
      {
        "content": "Implement enemy search behavior with last-known-position",
        "status": "in_progress",
        "activeForm": "Implementing enemy search behavior"
      },
      {
        "content": "Add inspection points system for corners and hiding spots",
        "status": "pending",
        "activeForm": "Adding inspection points system"
      },
      {
        "content": "Test and verify implementation",
        "status": "pending",
        "activeForm": "Testing implementation"
      },
      {
        "content": "Update PR description and finalize",
        "status": "pending",
        "activeForm": "Updating PR and finalizing"
      }
    ],
    "newTodos": [
      {
        "content": "Read and analyze issue #103 requirements",
        "status": "completed",
        "activeForm": "Reading issue requirements"
      },
      {
        "content": "Explore existing AI/GOAP system architecture",
        "status": "completed",
        "activeForm": "Exploring AI/GOAP system architecture"
      },
      {
        "content": "Create case study directory structure",
        "status": "completed",
        "activeForm": "Creating case study directory structure"
      },
      {
        "content": "Research GOAP and AI search patterns online",
        "status": "completed",
        "activeForm": "Researching GOAP and AI search patterns"
      },
      {
        "content": "Document timeline and sequence of events",
        "status": "completed",
        "activeForm": "Documenting timeline and events"
      },
      {
        "content": "Identify root causes and propose solutions",
        "status": "completed",
        "activeForm": "Identifying root causes and solutions"
      },
      {
        "content": "Implement enemy search behavior with last-known-position",
        "status": "completed",
        "activeForm": "Implementing enemy search behavior"
      },
      {
        "content": "Add inspection points system for corners and hiding spots",
        "status": "completed",
        "activeForm": "Adding inspection points system"
      },
      {
        "content": "Update GOAP actions for search behavior",
        "status": "in_progress",
        "activeForm": "Updating GOAP actions"
      },
      {
        "content": "Test and verify implementation",
        "status": "pending",
        "activeForm": "Testing implementation"
      },
      {
        "content": "Update PR description and finalize",
        "status": "pending",
        "activeForm": "Updating PR and finalizing"
      }
    ]
  }
}
[2026-01-18T02:54:27.752Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01S39UNxY7K5CTc6T5qWhFZG",
        "type": "tool_result",
        "content": "     1‚Üíclass_name EnemyActions\n     2‚Üíextends RefCounted\n     3‚Üí## Collection of GOAP actions for enemy AI.\n     4‚Üí##\n     5‚Üí## These actions define what enemies can do to achieve their goals.\n     6‚Üí## Each action has preconditions, effects, and costs that the\n     7‚Üí## GOAP planner uses to find optimal action sequences.\n     8‚Üí\n     9‚Üí\n    10‚Üí## Action to find and move to cover.\n    11‚Üíclass SeekCoverAction extends GOAPAction:\n    12‚Üí\tfunc _init() -> void:\n    13‚Üí\t\tsuper._init(\"seek_cover\", 2.0)\n    14‚Üí\t\tpreconditions = {\n    15‚Üí\t\t\t\"has_cover\": true,\n    16‚Üí\t\t\t\"in_cover\": false\n    17‚Üí\t\t}\n    18‚Üí\t\teffects = {\n    19‚Üí\t\t\t\"in_cover\": true,\n    20‚Üí\t\t\t\"under_fire\": false\n    21‚Üí\t\t}\n    22‚Üí\n    23‚Üí\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n    24‚Üí\t\t# Higher cost if we're actively engaging\n    25‚Üí\t\tif world_state.get(\"player_visible\", false):\n    26‚Üí\t\t\treturn 3.0\n    27‚Üí\t\treturn 2.0\n    28‚Üí\n    29‚Üí\n    30‚Üí## Action to engage the player in combat.\n    31‚Üíclass EngagePlayerAction extends GOAPAction:\n    32‚Üí\tfunc _init() -> void:\n    33‚Üí\t\tsuper._init(\"engage_player\", 1.0)\n    34‚Üí\t\tpreconditions = {\n    35‚Üí\t\t\t\"player_visible\": true\n    36‚Üí\t\t}\n    37‚Üí\t\teffects = {\n    38‚Üí\t\t\t\"player_engaged\": true\n    39‚Üí\t\t}\n    40‚Üí\n    41‚Üí\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n    42‚Üí\t\t# Lower cost if we have advantage (in cover, not under fire)\n    43‚Üí\t\tif world_state.get(\"in_cover\", false):\n    44‚Üí\t\t\treturn 0.5\n    45‚Üí\t\tif world_state.get(\"under_fire\", false):\n    46‚Üí\t\t\treturn 2.0\n    47‚Üí\t\treturn 1.0\n    48‚Üí\n    49‚Üí\n    50‚Üí## Action to flank the player.\n    51‚Üíclass FlankPlayerAction extends GOAPAction:\n    52‚Üí\tfunc _init() -> void:\n    53‚Üí\t\tsuper._init(\"flank_player\", 3.0)\n    54‚Üí\t\tpreconditions = {\n    55‚Üí\t\t\t\"player_visible\": false,\n    56‚Üí\t\t\t\"under_fire\": false\n    57‚Üí\t\t}\n    58‚Üí\t\teffects = {\n    59‚Üí\t\t\t\"at_flank_position\": true,\n    60‚Üí\t\t\t\"player_visible\": true\n    61‚Üí\t\t}\n    62‚Üí\n    63‚Üí\n    64‚Üí## Action to patrol the area.\n    65‚Üíclass PatrolAction extends GOAPAction:\n    66‚Üí\tfunc _init() -> void:\n    67‚Üí\t\tsuper._init(\"patrol\", 1.0)\n    68‚Üí\t\tpreconditions = {\n    69‚Üí\t\t\t\"player_visible\": false,\n    70‚Üí\t\t\t\"under_fire\": false\n    71‚Üí\t\t}\n    72‚Üí\t\teffects = {\n    73‚Üí\t\t\t\"area_patrolled\": true\n    74‚Üí\t\t}\n    75‚Üí\n    76‚Üí\n    77‚Üí## Action to stay suppressed (wait for fire to stop).\n    78‚Üíclass StaySuppressedAction extends GOAPAction:\n    79‚Üí\tfunc _init() -> void:\n    80‚Üí\t\tsuper._init(\"stay_suppressed\", 0.5)\n    81‚Üí\t\tpreconditions = {\n    82‚Üí\t\t\t\"under_fire\": true,\n    83‚Üí\t\t\t\"in_cover\": true\n    84‚Üí\t\t}\n    85‚Üí\t\teffects = {\n    86‚Üí\t\t\t\"waiting_for_safe\": true\n    87‚Üí\t\t}\n    88‚Üí\n    89‚Üí\n    90‚Üí## Action to return fire while suppressed.\n    91‚Üíclass ReturnFireAction extends GOAPAction:\n    92‚Üí\tfunc _init() -> void:\n    93‚Üí\t\tsuper._init(\"return_fire\", 1.5)\n    94‚Üí\t\tpreconditions = {\n    95‚Üí\t\t\t\"player_visible\": true,\n    96‚Üí\t\t\t\"in_cover\": true\n    97‚Üí\t\t}\n    98‚Üí\t\teffects = {\n    99‚Üí\t\t\t\"player_engaged\": true\n   100‚Üí\t\t}\n   101‚Üí\n   102‚Üí\n   103‚Üí## Action to find cover (search for cover positions).\n   104‚Üíclass FindCoverAction extends GOAPAction:\n   105‚Üí\tfunc _init() -> void:\n   106‚Üí\t\tsuper._init(\"find_cover\", 0.5)\n   107‚Üí\t\tpreconditions = {\n   108‚Üí\t\t\t\"has_cover\": false\n   109‚Üí\t\t}\n   110‚Üí\t\teffects = {\n   111‚Üí\t\t\t\"has_cover\": true\n   112‚Üí\t\t}\n   113‚Üí\n   114‚Üí\n   115‚Üí## Action to retreat when health is low.\n   116‚Üíclass RetreatAction extends GOAPAction:\n   117‚Üí\tfunc _init() -> void:\n   118‚Üí\t\tsuper._init(\"retreat\", 4.0)\n   119‚Üí\t\tpreconditions = {\n   120‚Üí\t\t\t\"health_low\": true\n   121‚Üí\t\t}\n   122‚Üí\t\teffects = {\n   123‚Üí\t\t\t\"in_cover\": true,\n   124‚Üí\t\t\t\"retreated\": true\n   125‚Üí\t\t}\n   126‚Üí\n   127‚Üí\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n   128‚Üí\t\t# Very high priority if under fire with low health\n   129‚Üí\t\tif world_state.get(\"under_fire\", false):\n   130‚Üí\t\t\treturn 1.0\n   131‚Üí\t\treturn 4.0\n   132‚Üí\n   133‚Üí\n   134‚Üí## Action to retreat with fire when under suppression (tactical retreat).\n   135‚Üí## Cost varies based on number of hits taken during encounter.\n   136‚Üíclass RetreatWithFireAction extends GOAPAction:\n   137‚Üí\tfunc _init() -> void:\n   138‚Üí\t\tsuper._init(\"retreat_with_fire\", 1.5)\n   139‚Üí\t\tpreconditions = {\n   140‚Üí\t\t\t\"under_fire\": true\n   141‚Üí\t\t}\n   142‚Üí\t\teffects = {\n   143‚Üí\t\t\t\"in_cover\": true,\n   144‚Üí\t\t\t\"is_retreating\": true\n   145‚Üí\t\t}\n   146‚Üí\n   147‚Üí\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n   148‚Üí\t\t# Cost is lower (higher priority) when under fire\n   149‚Üí\t\t# Priority also depends on hits taken\n   150‚Üí\t\tvar hits: int = world_state.get(\"hits_taken\", 0)\n   151‚Üí\t\tif hits == 0:\n   152‚Üí\t\t\t# Full HP - can afford to fight while retreating\n   153‚Üí\t\t\treturn 1.0\n   154‚Üí\t\telif hits == 1:\n   155‚Üí\t\t\t# One hit - quick burst then escape\n   156‚Üí\t\t\treturn 0.8\n   157‚Üí\t\telse:\n   158‚Üí\t\t\t# Multiple hits - just run!\n   159‚Üí\t\t\treturn 0.5\n   160‚Üí\n   161‚Üí\n   162‚Üí## Action to pursue the player by moving cover-to-cover.\n   163‚Üí## Used when enemy is far from player and can't hit them from current position.\n   164‚Üíclass PursuePlayerAction extends GOAPAction:\n   165‚Üí\tfunc _init() -> void:\n   166‚Üí\t\tsuper._init(\"pursue_player\", 2.5)\n   167‚Üí\t\tpreconditions = {\n   168‚Üí\t\t\t\"player_visible\": false,\n   169‚Üí\t\t\t\"player_close\": false\n   170‚Üí\t\t}\n   171‚Üí\t\teffects = {\n   172‚Üí\t\t\t\"is_pursuing\": true,\n   173‚Üí\t\t\t\"player_close\": true\n   174‚Üí\t\t}\n   175‚Üí\n   176‚Üí\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n   177‚Üí\t\t# Lower cost if we can't hit from current position\n   178‚Üí\t\tif not world_state.get(\"can_hit_from_cover\", false):\n   179‚Üí\t\t\treturn 1.5\n   180‚Üí\t\treturn 3.0\n   181‚Üí\n   182‚Üí\n   183‚Üí## Action to initiate coordinated assault when multiple enemies are in combat.\n   184‚Üí## All enemies rush the player simultaneously after a 5 second wait.\n   185‚Üíclass AssaultPlayerAction extends GOAPAction:\n   186‚Üí\tfunc _init() -> void:\n   187‚Üí\t\tsuper._init(\"assault_player\", 1.0)\n   188‚Üí\t\tpreconditions = {\n   189‚Üí\t\t\t\"player_visible\": true\n   190‚Üí\t\t}\n   191‚Üí\t\teffects = {\n   192‚Üí\t\t\t\"is_assaulting\": true,\n   193‚Üí\t\t\t\"player_engaged\": true\n   194‚Üí\t\t}\n   195‚Üí\n   196‚Üí\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n   197‚Üí\t\t# Only low cost if multiple enemies are in combat\n   198‚Üí\t\tvar enemies_count: int = world_state.get(\"enemies_in_combat\", 0)\n   199‚Üí\t\tif enemies_count >= 2:\n   200‚Üí\t\t\treturn 0.5  # High priority for coordinated attack\n   201‚Üí\t\treturn 5.0  # Very high cost if alone (prefer other actions)\n   202‚Üí\n   203‚Üí\n   204‚Üí## Create and return all enemy actions.\n   205‚Üístatic func create_all_actions() -> Array[GOAPAction]:\n   206‚Üí\tvar actions: Array[GOAPAction] = []\n   207‚Üí\tactions.append(SeekCoverAction.new())\n   208‚Üí\tactions.append(EngagePlayerAction.new())\n   209‚Üí\tactions.append(FlankPlayerAction.new())\n   210‚Üí\tactions.append(PatrolAction.new())\n   211‚Üí\tactions.append(StaySuppressedAction.new())\n   212‚Üí\tactions.append(ReturnFireAction.new())\n   213‚Üí\tactions.append(FindCoverAction.new())\n   214‚Üí\tactions.append(RetreatAction.new())\n   215‚Üí\tactions.append(RetreatWithFireAction.new())\n   216‚Üí\tactions.append(PursuePlayerAction.new())\n   217‚Üí\tactions.append(AssaultPlayerAction.new())\n   218‚Üí\treturn actions\n   219‚Üí\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "fb6951c3-976b-4d79-baba-e9d7b7bb61bd",
  "tool_use_result": {
    "type": "text",
    "file": {
      "filePath": "/tmp/gh-issue-solver-1768704499561/scripts/ai/enemy_actions.gd",
      "content": "class_name EnemyActions\nextends RefCounted\n## Collection of GOAP actions for enemy AI.\n##\n## These actions define what enemies can do to achieve their goals.\n## Each action has preconditions, effects, and costs that the\n## GOAP planner uses to find optimal action sequences.\n\n\n## Action to find and move to cover.\nclass SeekCoverAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"seek_cover\", 2.0)\n\t\tpreconditions = {\n\t\t\t\"has_cover\": true,\n\t\t\t\"in_cover\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"in_cover\": true,\n\t\t\t\"under_fire\": false\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Higher cost if we're actively engaging\n\t\tif world_state.get(\"player_visible\", false):\n\t\t\treturn 3.0\n\t\treturn 2.0\n\n\n## Action to engage the player in combat.\nclass EngagePlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"engage_player\", 1.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"player_engaged\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Lower cost if we have advantage (in cover, not under fire)\n\t\tif world_state.get(\"in_cover\", false):\n\t\t\treturn 0.5\n\t\tif world_state.get(\"under_fire\", false):\n\t\t\treturn 2.0\n\t\treturn 1.0\n\n\n## Action to flank the player.\nclass FlankPlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"flank_player\", 3.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": false,\n\t\t\t\"under_fire\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"at_flank_position\": true,\n\t\t\t\"player_visible\": true\n\t\t}\n\n\n## Action to patrol the area.\nclass PatrolAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"patrol\", 1.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": false,\n\t\t\t\"under_fire\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"area_patrolled\": true\n\t\t}\n\n\n## Action to stay suppressed (wait for fire to stop).\nclass StaySuppressedAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"stay_suppressed\", 0.5)\n\t\tpreconditions = {\n\t\t\t\"under_fire\": true,\n\t\t\t\"in_cover\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"waiting_for_safe\": true\n\t\t}\n\n\n## Action to return fire while suppressed.\nclass ReturnFireAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"return_fire\", 1.5)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": true,\n\t\t\t\"in_cover\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"player_engaged\": true\n\t\t}\n\n\n## Action to find cover (search for cover positions).\nclass FindCoverAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"find_cover\", 0.5)\n\t\tpreconditions = {\n\t\t\t\"has_cover\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"has_cover\": true\n\t\t}\n\n\n## Action to retreat when health is low.\nclass RetreatAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"retreat\", 4.0)\n\t\tpreconditions = {\n\t\t\t\"health_low\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"in_cover\": true,\n\t\t\t\"retreated\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Very high priority if under fire with low health\n\t\tif world_state.get(\"under_fire\", false):\n\t\t\treturn 1.0\n\t\treturn 4.0\n\n\n## Action to retreat with fire when under suppression (tactical retreat).\n## Cost varies based on number of hits taken during encounter.\nclass RetreatWithFireAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"retreat_with_fire\", 1.5)\n\t\tpreconditions = {\n\t\t\t\"under_fire\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"in_cover\": true,\n\t\t\t\"is_retreating\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Cost is lower (higher priority) when under fire\n\t\t# Priority also depends on hits taken\n\t\tvar hits: int = world_state.get(\"hits_taken\", 0)\n\t\tif hits == 0:\n\t\t\t# Full HP - can afford to fight while retreating\n\t\t\treturn 1.0\n\t\telif hits == 1:\n\t\t\t# One hit - quick burst then escape\n\t\t\treturn 0.8\n\t\telse:\n\t\t\t# Multiple hits - just run!\n\t\t\treturn 0.5\n\n\n## Action to pursue the player by moving cover-to-cover.\n## Used when enemy is far from player and can't hit them from current position.\nclass PursuePlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"pursue_player\", 2.5)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": false,\n\t\t\t\"player_close\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"is_pursuing\": true,\n\t\t\t\"player_close\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Lower cost if we can't hit from current position\n\t\tif not world_state.get(\"can_hit_from_cover\", false):\n\t\t\treturn 1.5\n\t\treturn 3.0\n\n\n## Action to initiate coordinated assault when multiple enemies are in combat.\n## All enemies rush the player simultaneously after a 5 second wait.\nclass AssaultPlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"assault_player\", 1.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"is_assaulting\": true,\n\t\t\t\"player_engaged\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Only low cost if multiple enemies are in combat\n\t\tvar enemies_count: int = world_state.get(\"enemies_in_combat\", 0)\n\t\tif enemies_count >= 2:\n\t\t\treturn 0.5  # High priority for coordinated attack\n\t\treturn 5.0  # Very high cost if alone (prefer other actions)\n\n\n## Create and return all enemy actions.\nstatic func create_all_actions() -> Array[GOAPAction]:\n\tvar actions: Array[GOAPAction] = []\n\tactions.append(SeekCoverAction.new())\n\tactions.append(EngagePlayerAction.new())\n\tactions.append(FlankPlayerAction.new())\n\tactions.append(PatrolAction.new())\n\tactions.append(StaySuppressedAction.new())\n\tactions.append(ReturnFireAction.new())\n\tactions.append(FindCoverAction.new())\n\tactions.append(RetreatAction.new())\n\tactions.append(RetreatWithFireAction.new())\n\tactions.append(PursuePlayerAction.new())\n\tactions.append(AssaultPlayerAction.new())\n\treturn actions\n",
      "numLines": 219,
      "startLine": 1,
      "totalLines": 219
    }
  }
}
[2026-01-18T02:54:30.684Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01GoV7LyE7EHQWaYChWvQu8K",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me add the SearchArea GOAP action:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 3167,
      "cache_read_input_tokens": 103232,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 3167,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 4,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "d2b53f30-cd47-4849-b46b-2bdef214003b"
}
[2026-01-18T02:54:40.725Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01GoV7LyE7EHQWaYChWvQu8K",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_018WWdcUt8ZC6rPzaCzZhNdJ",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/ai/enemy_actions.gd",
          "old_string": "## Action to initiate coordinated assault when multiple enemies are in combat.\n## All enemies rush the player simultaneously after a 5 second wait.\nclass AssaultPlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"assault_player\", 1.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"is_assaulting\": true,\n\t\t\t\"player_engaged\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Only low cost if multiple enemies are in combat\n\t\tvar enemies_count: int = world_state.get(\"enemies_in_combat\", 0)\n\t\tif enemies_count >= 2:\n\t\t\treturn 0.5  # High priority for coordinated attack\n\t\treturn 5.0  # Very high cost if alone (prefer other actions)\n\n\n## Create and return all enemy actions.",
          "new_string": "## Action to initiate coordinated assault when multiple enemies are in combat.\n## All enemies rush the player simultaneously after a 5 second wait.\nclass AssaultPlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"assault_player\", 1.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"is_assaulting\": true,\n\t\t\t\"player_engaged\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Only low cost if multiple enemies are in combat\n\t\tvar enemies_count: int = world_state.get(\"enemies_in_combat\", 0)\n\t\tif enemies_count >= 2:\n\t\t\treturn 0.5  # High priority for coordinated attack\n\t\treturn 5.0  # Very high cost if alone (prefer other actions)\n\n\n## Action to search for player at last-known position.\n## Used when player escapes from view - enemy investigates the area\n## where player was last seen and checks nearby hiding spots.\nclass SearchAreaAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"search_area\", 2.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": false,\n\t\t\t\"has_search_zone\": true,\n\t\t\t\"search_zone_cleared\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"is_searching\": true,\n\t\t\t\"search_zone_cleared\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Lower cost if not under fire (safer to search)\n\t\tif world_state.get(\"under_fire\", false):\n\t\t\treturn 4.0  # High cost if under fire - prioritize cover\n\t\t# Higher priority if we have a search zone to check\n\t\tif world_state.get(\"has_search_zone\", false):\n\t\t\treturn 1.5\n\t\treturn 3.0\n\n\n## Action to inspect a specific hiding spot.\n## Used during search to check behind covers and at corners.\nclass InspectHidingSpotAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"inspect_hiding_spot\", 0.5)\n\t\tpreconditions = {\n\t\t\t\"is_searching\": true,\n\t\t\t\"inspection_points_remaining\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"hiding_spot_checked\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Cost based on remaining points - more points = lower average cost per point\n\t\tvar remaining: int = world_state.get(\"inspection_points_remaining\", 0)\n\t\tif remaining > 0:\n\t\t\treturn 0.5\n\t\treturn 1.0\n\n\n## Create and return all enemy actions."
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 3167,
      "cache_read_input_tokens": 103232,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 3167,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 4,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "b1e008be-e1dc-4dc9-8c85-42731316a337"
}
[2026-01-18T02:54:40.753Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_018WWdcUt8ZC6rPzaCzZhNdJ",
        "type": "tool_result",
        "content": "The file /tmp/gh-issue-solver-1768704499561/scripts/ai/enemy_actions.gd has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   179‚Üí\t\t\treturn 1.5\n   180‚Üí\t\treturn 3.0\n   181‚Üí\n   182‚Üí\n   183‚Üí## Action to initiate coordinated assault when multiple enemies are in combat.\n   184‚Üí## All enemies rush the player simultaneously after a 5 second wait.\n   185‚Üíclass AssaultPlayerAction extends GOAPAction:\n   186‚Üí\tfunc _init() -> void:\n   187‚Üí\t\tsuper._init(\"assault_player\", 1.0)\n   188‚Üí\t\tpreconditions = {\n   189‚Üí\t\t\t\"player_visible\": true\n   190‚Üí\t\t}\n   191‚Üí\t\teffects = {\n   192‚Üí\t\t\t\"is_assaulting\": true,\n   193‚Üí\t\t\t\"player_engaged\": true\n   194‚Üí\t\t}\n   195‚Üí\n   196‚Üí\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n   197‚Üí\t\t# Only low cost if multiple enemies are in combat\n   198‚Üí\t\tvar enemies_count: int = world_state.get(\"enemies_in_combat\", 0)\n   199‚Üí\t\tif enemies_count >= 2:\n   200‚Üí\t\t\treturn 0.5  # High priority for coordinated attack\n   201‚Üí\t\treturn 5.0  # Very high cost if alone (prefer other actions)\n   202‚Üí\n   203‚Üí\n   204‚Üí## Action to search for player at last-known position.\n   205‚Üí## Used when player escapes from view - enemy investigates the area\n   206‚Üí## where player was last seen and checks nearby hiding spots.\n   207‚Üíclass SearchAreaAction extends GOAPAction:\n   208‚Üí\tfunc _init() -> void:\n   209‚Üí\t\tsuper._init(\"search_area\", 2.0)\n   210‚Üí\t\tpreconditions = {\n   211‚Üí\t\t\t\"player_visible\": false,\n   212‚Üí\t\t\t\"has_search_zone\": true,\n   213‚Üí\t\t\t\"search_zone_cleared\": false\n   214‚Üí\t\t}\n   215‚Üí\t\teffects = {\n   216‚Üí\t\t\t\"is_searching\": true,\n   217‚Üí\t\t\t\"search_zone_cleared\": true\n   218‚Üí\t\t}\n   219‚Üí\n   220‚Üí\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n   221‚Üí\t\t# Lower cost if not under fire (safer to search)\n   222‚Üí\t\tif world_state.get(\"under_fire\", false):\n   223‚Üí\t\t\treturn 4.0  # High cost if under fire - prioritize cover\n   224‚Üí\t\t# Higher priority if we have a search zone to check\n   225‚Üí\t\tif world_state.get(\"has_search_zone\", false):\n   226‚Üí\t\t\treturn 1.5\n   227‚Üí\t\treturn 3.0\n   228‚Üí\n   229‚Üí\n   230‚Üí## Action to inspect a specific hiding spot.\n   231‚Üí## Used during search to check behind covers and at corners.\n   232‚Üíclass InspectHidingSpotAction extends GOAPAction:\n   233‚Üí\tfunc _init() -> void:\n   234‚Üí\t\tsuper._init(\"inspect_hiding_spot\", 0.5)\n   235‚Üí\t\tpreconditions = {\n   236‚Üí\t\t\t\"is_searching\": true,\n   237‚Üí\t\t\t\"inspection_points_remaining\": true\n   238‚Üí\t\t}\n   239‚Üí\t\teffects = {\n   240‚Üí\t\t\t\"hiding_spot_checked\": true\n   241‚Üí\t\t}\n   242‚Üí\n   243‚Üí\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n   244‚Üí\t\t# Cost based on remaining points - more points = lower average cost per point\n   245‚Üí\t\tvar remaining: int = world_state.get(\"inspection_points_remaining\", 0)\n   246‚Üí\t\tif remaining > 0:\n   247‚Üí\t\t\treturn 0.5\n   248‚Üí\t\treturn 1.0\n   249‚Üí\n   250‚Üí\n   251‚Üí## Create and return all enemy actions.\n   252‚Üístatic func create_all_actions() -> Array[GOAPAction]:\n   253‚Üí\tvar actions: Array[GOAPAction] = []\n   254‚Üí\tactions.append(SeekCoverAction.new())\n   255‚Üí\tactions.append(EngagePlayerAction.new())"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "1c9b0d7c-9138-4ab9-9872-72b869482f34",
  "tool_use_result": {
    "filePath": "/tmp/gh-issue-solver-1768704499561/scripts/ai/enemy_actions.gd",
    "oldString": "## Action to initiate coordinated assault when multiple enemies are in combat.\n## All enemies rush the player simultaneously after a 5 second wait.\nclass AssaultPlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"assault_player\", 1.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"is_assaulting\": true,\n\t\t\t\"player_engaged\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Only low cost if multiple enemies are in combat\n\t\tvar enemies_count: int = world_state.get(\"enemies_in_combat\", 0)\n\t\tif enemies_count >= 2:\n\t\t\treturn 0.5  # High priority for coordinated attack\n\t\treturn 5.0  # Very high cost if alone (prefer other actions)\n\n\n## Create and return all enemy actions.",
    "newString": "## Action to initiate coordinated assault when multiple enemies are in combat.\n## All enemies rush the player simultaneously after a 5 second wait.\nclass AssaultPlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"assault_player\", 1.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"is_assaulting\": true,\n\t\t\t\"player_engaged\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Only low cost if multiple enemies are in combat\n\t\tvar enemies_count: int = world_state.get(\"enemies_in_combat\", 0)\n\t\tif enemies_count >= 2:\n\t\t\treturn 0.5  # High priority for coordinated attack\n\t\treturn 5.0  # Very high cost if alone (prefer other actions)\n\n\n## Action to search for player at last-known position.\n## Used when player escapes from view - enemy investigates the area\n## where player was last seen and checks nearby hiding spots.\nclass SearchAreaAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"search_area\", 2.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": false,\n\t\t\t\"has_search_zone\": true,\n\t\t\t\"search_zone_cleared\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"is_searching\": true,\n\t\t\t\"search_zone_cleared\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Lower cost if not under fire (safer to search)\n\t\tif world_state.get(\"under_fire\", false):\n\t\t\treturn 4.0  # High cost if under fire - prioritize cover\n\t\t# Higher priority if we have a search zone to check\n\t\tif world_state.get(\"has_search_zone\", false):\n\t\t\treturn 1.5\n\t\treturn 3.0\n\n\n## Action to inspect a specific hiding spot.\n## Used during search to check behind covers and at corners.\nclass InspectHidingSpotAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"inspect_hiding_spot\", 0.5)\n\t\tpreconditions = {\n\t\t\t\"is_searching\": true,\n\t\t\t\"inspection_points_remaining\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"hiding_spot_checked\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Cost based on remaining points - more points = lower average cost per point\n\t\tvar remaining: int = world_state.get(\"inspection_points_remaining\", 0)\n\t\tif remaining > 0:\n\t\t\treturn 0.5\n\t\treturn 1.0\n\n\n## Create and return all enemy actions.",
    "originalFile": "class_name EnemyActions\nextends RefCounted\n## Collection of GOAP actions for enemy AI.\n##\n## These actions define what enemies can do to achieve their goals.\n## Each action has preconditions, effects, and costs that the\n## GOAP planner uses to find optimal action sequences.\n\n\n## Action to find and move to cover.\nclass SeekCoverAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"seek_cover\", 2.0)\n\t\tpreconditions = {\n\t\t\t\"has_cover\": true,\n\t\t\t\"in_cover\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"in_cover\": true,\n\t\t\t\"under_fire\": false\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Higher cost if we're actively engaging\n\t\tif world_state.get(\"player_visible\", false):\n\t\t\treturn 3.0\n\t\treturn 2.0\n\n\n## Action to engage the player in combat.\nclass EngagePlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"engage_player\", 1.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"player_engaged\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Lower cost if we have advantage (in cover, not under fire)\n\t\tif world_state.get(\"in_cover\", false):\n\t\t\treturn 0.5\n\t\tif world_state.get(\"under_fire\", false):\n\t\t\treturn 2.0\n\t\treturn 1.0\n\n\n## Action to flank the player.\nclass FlankPlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"flank_player\", 3.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": false,\n\t\t\t\"under_fire\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"at_flank_position\": true,\n\t\t\t\"player_visible\": true\n\t\t}\n\n\n## Action to patrol the area.\nclass PatrolAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"patrol\", 1.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": false,\n\t\t\t\"under_fire\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"area_patrolled\": true\n\t\t}\n\n\n## Action to stay suppressed (wait for fire to stop).\nclass StaySuppressedAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"stay_suppressed\", 0.5)\n\t\tpreconditions = {\n\t\t\t\"under_fire\": true,\n\t\t\t\"in_cover\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"waiting_for_safe\": true\n\t\t}\n\n\n## Action to return fire while suppressed.\nclass ReturnFireAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"return_fire\", 1.5)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": true,\n\t\t\t\"in_cover\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"player_engaged\": true\n\t\t}\n\n\n## Action to find cover (search for cover positions).\nclass FindCoverAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"find_cover\", 0.5)\n\t\tpreconditions = {\n\t\t\t\"has_cover\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"has_cover\": true\n\t\t}\n\n\n## Action to retreat when health is low.\nclass RetreatAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"retreat\", 4.0)\n\t\tpreconditions = {\n\t\t\t\"health_low\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"in_cover\": true,\n\t\t\t\"retreated\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Very high priority if under fire with low health\n\t\tif world_state.get(\"under_fire\", false):\n\t\t\treturn 1.0\n\t\treturn 4.0\n\n\n## Action to retreat with fire when under suppression (tactical retreat).\n## Cost varies based on number of hits taken during encounter.\nclass RetreatWithFireAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"retreat_with_fire\", 1.5)\n\t\tpreconditions = {\n\t\t\t\"under_fire\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"in_cover\": true,\n\t\t\t\"is_retreating\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Cost is lower (higher priority) when under fire\n\t\t# Priority also depends on hits taken\n\t\tvar hits: int = world_state.get(\"hits_taken\", 0)\n\t\tif hits == 0:\n\t\t\t# Full HP - can afford to fight while retreating\n\t\t\treturn 1.0\n\t\telif hits == 1:\n\t\t\t# One hit - quick burst then escape\n\t\t\treturn 0.8\n\t\telse:\n\t\t\t# Multiple hits - just run!\n\t\t\treturn 0.5\n\n\n## Action to pursue the player by moving cover-to-cover.\n## Used when enemy is far from player and can't hit them from current position.\nclass PursuePlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"pursue_player\", 2.5)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": false,\n\t\t\t\"player_close\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"is_pursuing\": true,\n\t\t\t\"player_close\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Lower cost if we can't hit from current position\n\t\tif not world_state.get(\"can_hit_from_cover\", false):\n\t\t\treturn 1.5\n\t\treturn 3.0\n\n\n## Action to initiate coordinated assault when multiple enemies are in combat.\n## All enemies rush the player simultaneously after a 5 second wait.\nclass AssaultPlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"assault_player\", 1.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"is_assaulting\": true,\n\t\t\t\"player_engaged\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Only low cost if multiple enemies are in combat\n\t\tvar enemies_count: int = world_state.get(\"enemies_in_combat\", 0)\n\t\tif enemies_count >= 2:\n\t\t\treturn 0.5  # High priority for coordinated attack\n\t\treturn 5.0  # Very high cost if alone (prefer other actions)\n\n\n## Create and return all enemy actions.\nstatic func create_all_actions() -> Array[GOAPAction]:\n\tvar actions: Array[GOAPAction] = []\n\tactions.append(SeekCoverAction.new())\n\tactions.append(EngagePlayerAction.new())\n\tactions.append(FlankPlayerAction.new())\n\tactions.append(PatrolAction.new())\n\tactions.append(StaySuppressedAction.new())\n\tactions.append(ReturnFireAction.new())\n\tactions.append(FindCoverAction.new())\n\tactions.append(RetreatAction.new())\n\tactions.append(RetreatWithFireAction.new())\n\tactions.append(PursuePlayerAction.new())\n\tactions.append(AssaultPlayerAction.new())\n\treturn actions\n",
    "structuredPatch": [
      {
        "oldStart": 201,
        "oldLines": 6,
        "newStart": 201,
        "newLines": 53,
        "lines": [
          "     return 5.0  # Very high cost if alone (prefer other actions)",
          " ",
          " ",
          "+## Action to search for player at last-known position.",
          "+## Used when player escapes from view - enemy investigates the area",
          "+## where player was last seen and checks nearby hiding spots.",
          "+class SearchAreaAction extends GOAPAction:",
          "+  func _init() -> void:",
          "+    super._init(\"search_area\", 2.0)",
          "+    preconditions = {",
          "+      \"player_visible\": false,",
          "+      \"has_search_zone\": true,",
          "+      \"search_zone_cleared\": false",
          "+    }",
          "+    effects = {",
          "+      \"is_searching\": true,",
          "+      \"search_zone_cleared\": true",
          "+    }",
          "+",
          "+  func get_cost(_agent: Node, world_state: Dictionary) -> float:",
          "+    # Lower cost if not under fire (safer to search)",
          "+    if world_state.get(\"under_fire\", false):",
          "+      return 4.0  # High cost if under fire - prioritize cover",
          "+    # Higher priority if we have a search zone to check",
          "+    if world_state.get(\"has_search_zone\", false):",
          "+      return 1.5",
          "+    return 3.0",
          "+",
          "+",
          "+## Action to inspect a specific hiding spot.",
          "+## Used during search to check behind covers and at corners.",
          "+class InspectHidingSpotAction extends GOAPAction:",
          "+  func _init() -> void:",
          "+    super._init(\"inspect_hiding_spot\", 0.5)",
          "+    preconditions = {",
          "+      \"is_searching\": true,",
          "+      \"inspection_points_remaining\": true",
          "+    }",
          "+    effects = {",
          "+      \"hiding_spot_checked\": true",
          "+    }",
          "+",
          "+  func get_cost(_agent: Node, world_state: Dictionary) -> float:",
          "+    # Cost based on remaining points - more points = lower average cost per point",
          "+    var remaining: int = world_state.get(\"inspection_points_remaining\", 0)",
          "+    if remaining > 0:",
          "+      return 0.5",
          "+    return 1.0",
          "+",
          "+",
          " ## Create and return all enemy actions.",
          " static func create_all_actions() -> Array[GOAPAction]:",
          "   var actions: Array[GOAPAction] = []"
        ]
      }
    ],
    "userModified": false,
    "replaceAll": false
  }
}
[2026-01-18T02:54:46.716Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_014JTF13v5D9Mmi2Ut5oQaHa",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_018BSyYJwK1XCH7x1hBb9BZ1",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1768704499561/scripts/ai/enemy_actions.gd",
          "old_string": "## Create and return all enemy actions.\nstatic func create_all_actions() -> Array[GOAPAction]:\n\tvar actions: Array[GOAPAction] = []\n\tactions.append(SeekCoverAction.new())\n\tactions.append(EngagePlayerAction.new())\n\tactions.append(FlankPlayerAction.new())\n\tactions.append(PatrolAction.new())\n\tactions.append(StaySuppressedAction.new())\n\tactions.append(ReturnFireAction.new())\n\tactions.append(FindCoverAction.new())\n\tactions.append(RetreatAction.new())\n\tactions.append(RetreatWithFireAction.new())\n\tactions.append(PursuePlayerAction.new())\n\tactions.append(AssaultPlayerAction.new())\n\treturn actions",
          "new_string": "## Create and return all enemy actions.\nstatic func create_all_actions() -> Array[GOAPAction]:\n\tvar actions: Array[GOAPAction] = []\n\tactions.append(SeekCoverAction.new())\n\tactions.append(EngagePlayerAction.new())\n\tactions.append(FlankPlayerAction.new())\n\tactions.append(PatrolAction.new())\n\tactions.append(StaySuppressedAction.new())\n\tactions.append(ReturnFireAction.new())\n\tactions.append(FindCoverAction.new())\n\tactions.append(RetreatAction.new())\n\tactions.append(RetreatWithFireAction.new())\n\tactions.append(PursuePlayerAction.new())\n\tactions.append(AssaultPlayerAction.new())\n\tactions.append(SearchAreaAction.new())\n\tactions.append(InspectHidingSpotAction.new())\n\treturn actions"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 2071,
      "cache_read_input_tokens": 106399,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 2071,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 25,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "d225db0d-2731-4157-b8c5-576ad5eb83ba"
}
[2026-01-18T02:54:46.754Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_018BSyYJwK1XCH7x1hBb9BZ1",
        "type": "tool_result",
        "content": "The file /tmp/gh-issue-solver-1768704499561/scripts/ai/enemy_actions.gd has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   247‚Üí\t\t\treturn 0.5\n   248‚Üí\t\treturn 1.0\n   249‚Üí\n   250‚Üí\n   251‚Üí## Create and return all enemy actions.\n   252‚Üístatic func create_all_actions() -> Array[GOAPAction]:\n   253‚Üí\tvar actions: Array[GOAPAction] = []\n   254‚Üí\tactions.append(SeekCoverAction.new())\n   255‚Üí\tactions.append(EngagePlayerAction.new())\n   256‚Üí\tactions.append(FlankPlayerAction.new())\n   257‚Üí\tactions.append(PatrolAction.new())\n   258‚Üí\tactions.append(StaySuppressedAction.new())\n   259‚Üí\tactions.append(ReturnFireAction.new())\n   260‚Üí\tactions.append(FindCoverAction.new())\n   261‚Üí\tactions.append(RetreatAction.new())\n   262‚Üí\tactions.append(RetreatWithFireAction.new())\n   263‚Üí\tactions.append(PursuePlayerAction.new())\n   264‚Üí\tactions.append(AssaultPlayerAction.new())\n   265‚Üí\tactions.append(SearchAreaAction.new())\n   266‚Üí\tactions.append(InspectHidingSpotAction.new())\n   267‚Üí\treturn actions\n   268‚Üí"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "0c1f5785-33c9-4bd4-9656-aaf0d3d62037",
  "tool_use_result": {
    "filePath": "/tmp/gh-issue-solver-1768704499561/scripts/ai/enemy_actions.gd",
    "oldString": "## Create and return all enemy actions.\nstatic func create_all_actions() -> Array[GOAPAction]:\n\tvar actions: Array[GOAPAction] = []\n\tactions.append(SeekCoverAction.new())\n\tactions.append(EngagePlayerAction.new())\n\tactions.append(FlankPlayerAction.new())\n\tactions.append(PatrolAction.new())\n\tactions.append(StaySuppressedAction.new())\n\tactions.append(ReturnFireAction.new())\n\tactions.append(FindCoverAction.new())\n\tactions.append(RetreatAction.new())\n\tactions.append(RetreatWithFireAction.new())\n\tactions.append(PursuePlayerAction.new())\n\tactions.append(AssaultPlayerAction.new())\n\treturn actions",
    "newString": "## Create and return all enemy actions.\nstatic func create_all_actions() -> Array[GOAPAction]:\n\tvar actions: Array[GOAPAction] = []\n\tactions.append(SeekCoverAction.new())\n\tactions.append(EngagePlayerAction.new())\n\tactions.append(FlankPlayerAction.new())\n\tactions.append(PatrolAction.new())\n\tactions.append(StaySuppressedAction.new())\n\tactions.append(ReturnFireAction.new())\n\tactions.append(FindCoverAction.new())\n\tactions.append(RetreatAction.new())\n\tactions.append(RetreatWithFireAction.new())\n\tactions.append(PursuePlayerAction.new())\n\tactions.append(AssaultPlayerAction.new())\n\tactions.append(SearchAreaAction.new())\n\tactions.append(InspectHidingSpotAction.new())\n\treturn actions",
    "originalFile": "class_name EnemyActions\nextends RefCounted\n## Collection of GOAP actions for enemy AI.\n##\n## These actions define what enemies can do to achieve their goals.\n## Each action has preconditions, effects, and costs that the\n## GOAP planner uses to find optimal action sequences.\n\n\n## Action to find and move to cover.\nclass SeekCoverAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"seek_cover\", 2.0)\n\t\tpreconditions = {\n\t\t\t\"has_cover\": true,\n\t\t\t\"in_cover\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"in_cover\": true,\n\t\t\t\"under_fire\": false\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Higher cost if we're actively engaging\n\t\tif world_state.get(\"player_visible\", false):\n\t\t\treturn 3.0\n\t\treturn 2.0\n\n\n## Action to engage the player in combat.\nclass EngagePlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"engage_player\", 1.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"player_engaged\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Lower cost if we have advantage (in cover, not under fire)\n\t\tif world_state.get(\"in_cover\", false):\n\t\t\treturn 0.5\n\t\tif world_state.get(\"under_fire\", false):\n\t\t\treturn 2.0\n\t\treturn 1.0\n\n\n## Action to flank the player.\nclass FlankPlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"flank_player\", 3.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": false,\n\t\t\t\"under_fire\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"at_flank_position\": true,\n\t\t\t\"player_visible\": true\n\t\t}\n\n\n## Action to patrol the area.\nclass PatrolAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"patrol\", 1.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": false,\n\t\t\t\"under_fire\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"area_patrolled\": true\n\t\t}\n\n\n## Action to stay suppressed (wait for fire to stop).\nclass StaySuppressedAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"stay_suppressed\", 0.5)\n\t\tpreconditions = {\n\t\t\t\"under_fire\": true,\n\t\t\t\"in_cover\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"waiting_for_safe\": true\n\t\t}\n\n\n## Action to return fire while suppressed.\nclass ReturnFireAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"return_fire\", 1.5)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": true,\n\t\t\t\"in_cover\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"player_engaged\": true\n\t\t}\n\n\n## Action to find cover (search for cover positions).\nclass FindCoverAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"find_cover\", 0.5)\n\t\tpreconditions = {\n\t\t\t\"has_cover\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"has_cover\": true\n\t\t}\n\n\n## Action to retreat when health is low.\nclass RetreatAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"retreat\", 4.0)\n\t\tpreconditions = {\n\t\t\t\"health_low\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"in_cover\": true,\n\t\t\t\"retreated\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Very high priority if under fire with low health\n\t\tif world_state.get(\"under_fire\", false):\n\t\t\treturn 1.0\n\t\treturn 4.0\n\n\n## Action to retreat with fire when under suppression (tactical retreat).\n## Cost varies based on number of hits taken during encounter.\nclass RetreatWithFireAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"retreat_with_fire\", 1.5)\n\t\tpreconditions = {\n\t\t\t\"under_fire\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"in_cover\": true,\n\t\t\t\"is_retreating\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Cost is lower (higher priority) when under fire\n\t\t# Priority also depends on hits taken\n\t\tvar hits: int = world_state.get(\"hits_taken\", 0)\n\t\tif hits == 0:\n\t\t\t# Full HP - can afford to fight while retreating\n\t\t\treturn 1.0\n\t\telif hits == 1:\n\t\t\t# One hit - quick burst then escape\n\t\t\treturn 0.8\n\t\telse:\n\t\t\t# Multiple hits - just run!\n\t\t\treturn 0.5\n\n\n## Action to pursue the player by moving cover-to-cover.\n## Used when enemy is far from player and can't hit them from current position.\nclass PursuePlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"pursue_player\", 2.5)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": false,\n\t\t\t\"player_close\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"is_pursuing\": true,\n\t\t\t\"player_close\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Lower cost if we can't hit from current position\n\t\tif not world_state.get(\"can_hit_from_cover\", false):\n\t\t\treturn 1.5\n\t\treturn 3.0\n\n\n## Action to initiate coordinated assault when multiple enemies are in combat.\n## All enemies rush the player simultaneously after a 5 second wait.\nclass AssaultPlayerAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"assault_player\", 1.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"is_assaulting\": true,\n\t\t\t\"player_engaged\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Only low cost if multiple enemies are in combat\n\t\tvar enemies_count: int = world_state.get(\"enemies_in_combat\", 0)\n\t\tif enemies_count >= 2:\n\t\t\treturn 0.5  # High priority for coordinated attack\n\t\treturn 5.0  # Very high cost if alone (prefer other actions)\n\n\n## Action to search for player at last-known position.\n## Used when player escapes from view - enemy investigates the area\n## where player was last seen and checks nearby hiding spots.\nclass SearchAreaAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"search_area\", 2.0)\n\t\tpreconditions = {\n\t\t\t\"player_visible\": false,\n\t\t\t\"has_search_zone\": true,\n\t\t\t\"search_zone_cleared\": false\n\t\t}\n\t\teffects = {\n\t\t\t\"is_searching\": true,\n\t\t\t\"search_zone_cleared\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Lower cost if not under fire (safer to search)\n\t\tif world_state.get(\"under_fire\", false):\n\t\t\treturn 4.0  # High cost if under fire - prioritize cover\n\t\t# Higher priority if we have a search zone to check\n\t\tif world_state.get(\"has_search_zone\", false):\n\t\t\treturn 1.5\n\t\treturn 3.0\n\n\n## Action to inspect a specific hiding spot.\n## Used during search to check behind covers and at corners.\nclass InspectHidingSpotAction extends GOAPAction:\n\tfunc _init() -> void:\n\t\tsuper._init(\"inspect_hiding_spot\", 0.5)\n\t\tpreconditions = {\n\t\t\t\"is_searching\": true,\n\t\t\t\"inspection_points_remaining\": true\n\t\t}\n\t\teffects = {\n\t\t\t\"hiding_spot_checked\": true\n\t\t}\n\n\tfunc get_cost(_agent: Node, world_state: Dictionary) -> float:\n\t\t# Cost based on remaining points - more points = lower average cost per point\n\t\tvar remaining: int = world_state.get(\"inspection_points_remaining\", 0)\n\t\tif remaining > 0:\n\t\t\treturn 0.5\n\t\treturn 1.0\n\n\n## Create and return all enemy actions.\nstatic func create_all_actions() -> Array[GOAPAction]:\n\tvar actions: Array[GOAPAction] = []\n\tactions.append(SeekCoverAction.new())\n\tactions.append(EngagePlayerAction.new())\n\tactions.append(FlankPlayerAction.new())\n\tactions.append(PatrolAction.new())\n\tactions.append(StaySuppressedAction.new())\n\tactions.append(ReturnFireAction.new())\n\tactions.append(FindCoverAction.new())\n\tactions.append(RetreatAction.new())\n\tactions.append(RetreatWithFireAction.new())\n\tactions.append(PursuePlayerAction.new())\n\tactions.append(AssaultPlayerAction.new())\n\treturn actions\n",
    "structuredPatch": [
      {
        "oldStart": 262,
        "oldLines": 4,
        "newStart": 262,
        "newLines": 6,
        "lines": [
          "   actions.append(RetreatWithFireAction.new())",
          "   actions.append(PursuePlayerAction.new())",
          "   actions.append(AssaultPlayerAction.new())",
          "+  actions.append(SearchAreaAction.new())",
          "+  actions.append(InspectHidingSpotAction.new())",
          "   return actions"
        ]
      }
    ],
    "userModified": false,
    "replaceAll": false
  }
}
[2026-01-18T02:54:49.414Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_018ZpbU4w63tipEZ4j2srQKr",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me update the case study document with the final implementation details:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 911,
      "cache_read_input_tokens": 108470,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 911,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 4,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "8190e4fa-91a4-4a60-92e8-d78e75c1dfbb"
}
[2026-01-18T02:55:05.217Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_018ZpbU4w63tipEZ4j2srQKr",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01NZhHo4tpGZ6D8Z5WWhvkQU",
        "name": "Edit",
        "input": {
          "replace_all": false,
          "file_path": "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-103/README.md",
          "old_string": "## Success Criteria\n\n1. Enemy remembers where player was last seen\n2. Enemy moves to that location after losing sight\n3. Enemy checks nearby hiding spots methodically\n4. Enemy returns to patrol/guard after zone is cleared\n5. All existing functionality preserved (shooting, cover, etc.)",
          "new_string": "## Success Criteria\n\n1. Enemy remembers where player was last seen\n2. Enemy moves to that location after losing sight\n3. Enemy checks nearby hiding spots methodically\n4. Enemy returns to patrol/guard after zone is cleared\n5. All existing functionality preserved (shooting, cover, etc.)\n\n---\n\n## Implementation Summary\n\n### Files Modified\n\n1. **`scripts/objects/enemy.gd`**\n   - Added `SEARCHING` state to `AIState` enum\n   - Added search zone variables (`_last_known_player_position`, `_search_zone_active`, etc.)\n   - Added inspection point variables and constants\n   - Updated `_initialize_goap_state()` with search-related world state\n   - Updated `_update_goap_state()` to track search status\n   - Updated `_process_ai_state()` to handle SEARCHING state\n   - Updated `_check_player_visibility()` to track last known position\n   - Changed COMBAT->PURSUING transition to COMBAT->SEARCHING\n   - Added `_transition_to_searching()` function\n   - Added `_clear_search_zone()` function\n   - Added `_generate_inspection_points()` function\n   - Added `_process_searching_state()` function\n   - Updated `_get_state_name()` to include SEARCHING\n   - Updated `_update_debug_label()` for search state info\n   - Updated `_draw()` for search zone visualization\n\n2. **`scripts/ai/enemy_actions.gd`**\n   - Added `SearchAreaAction` class\n   - Added `InspectHidingSpotAction` class\n   - Updated `create_all_actions()` to include new actions\n\n### New Constants Added\n\n```gdscript\nconst SEARCH_ZONE_RADIUS: float = 200.0\nconst SEARCH_MAX_DURATION: float = 15.0\nconst INSPECTION_WAIT_DURATION: float = 1.5\nconst INSPECTION_POINT_CHECK_COUNT: int = 24\nconst INSPECTION_CHECK_DISTANCE: float = 250.0\n```\n\n### Behavior Flow\n\n```\nPlayer Visible (COMBAT)\n    ‚Üì Player escapes view\nStore last_known_player_position\n    ‚Üì\nTransition to SEARCHING\n    ‚Üì\nGenerate inspection points (behind obstacles + corners)\n    ‚Üì\nMove to first inspection point\n    ‚Üì\nWait and look around (1.5s)\n    ‚Üì\nMove to next inspection point (repeat until all checked)\n    ‚Üì\nSearch complete OR timeout (15s)\n    ‚Üì\nReturn to IDLE (patrol/guard)\n\nAt any point during search:\n- If player spotted ‚Üí COMBAT\n- If under fire ‚Üí RETREATING\n```\n\n### Debug Visualization\n\nWhen `debug_label_enabled` is true (toggle with F7 in-game):\n- Orange circle: Search zone boundary\n- Red X: Last known player position\n- Green circles: Unchecked inspection points\n- White circle: Current target inspection point\n- Gray circles: Already checked inspection points\n- White line: Path to current inspection point"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 911,
      "cache_read_input_tokens": 108470,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 911,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 4,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "7c324ba5-9693-437a-ad45-d0df650aa70e"
}
[2026-01-18T02:55:05.257Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01NZhHo4tpGZ6D8Z5WWhvkQU",
        "type": "tool_result",
        "content": "The file /tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-103/README.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   193‚Üí   - Break line of sight with enemy\n   194‚Üí   - Observe enemy search behavior\n   195‚Üí   - Verify zone is cleared or player found\n   196‚Üí\n   197‚Üí## Success Criteria\n   198‚Üí\n   199‚Üí1. Enemy remembers where player was last seen\n   200‚Üí2. Enemy moves to that location after losing sight\n   201‚Üí3. Enemy checks nearby hiding spots methodically\n   202‚Üí4. Enemy returns to patrol/guard after zone is cleared\n   203‚Üí5. All existing functionality preserved (shooting, cover, etc.)\n   204‚Üí\n   205‚Üí---\n   206‚Üí\n   207‚Üí## Implementation Summary\n   208‚Üí\n   209‚Üí### Files Modified\n   210‚Üí\n   211‚Üí1. **`scripts/objects/enemy.gd`**\n   212‚Üí   - Added `SEARCHING` state to `AIState` enum\n   213‚Üí   - Added search zone variables (`_last_known_player_position`, `_search_zone_active`, etc.)\n   214‚Üí   - Added inspection point variables and constants\n   215‚Üí   - Updated `_initialize_goap_state()` with search-related world state\n   216‚Üí   - Updated `_update_goap_state()` to track search status\n   217‚Üí   - Updated `_process_ai_state()` to handle SEARCHING state\n   218‚Üí   - Updated `_check_player_visibility()` to track last known position\n   219‚Üí   - Changed COMBAT->PURSUING transition to COMBAT->SEARCHING\n   220‚Üí   - Added `_transition_to_searching()` function\n   221‚Üí   - Added `_clear_search_zone()` function\n   222‚Üí   - Added `_generate_inspection_points()` function\n   223‚Üí   - Added `_process_searching_state()` function\n   224‚Üí   - Updated `_get_state_name()` to include SEARCHING\n   225‚Üí   - Updated `_update_debug_label()` for search state info\n   226‚Üí   - Updated `_draw()` for search zone visualization\n   227‚Üí\n   228‚Üí2. **`scripts/ai/enemy_actions.gd`**\n   229‚Üí   - Added `SearchAreaAction` class\n   230‚Üí   - Added `InspectHidingSpotAction` class\n   231‚Üí   - Updated `create_all_actions()` to include new actions\n   232‚Üí\n   233‚Üí### New Constants Added\n   234‚Üí\n   235‚Üí```gdscript\n   236‚Üíconst SEARCH_ZONE_RADIUS: float = 200.0\n   237‚Üíconst SEARCH_MAX_DURATION: float = 15.0\n   238‚Üíconst INSPECTION_WAIT_DURATION: float = 1.5\n   239‚Üíconst INSPECTION_POINT_CHECK_COUNT: int = 24\n   240‚Üíconst INSPECTION_CHECK_DISTANCE: float = 250.0\n   241‚Üí```\n   242‚Üí\n   243‚Üí### Behavior Flow\n   244‚Üí\n   245‚Üí```\n   246‚ÜíPlayer Visible (COMBAT)\n   247‚Üí    ‚Üì Player escapes view\n   248‚ÜíStore last_known_player_position\n   249‚Üí    ‚Üì\n   250‚ÜíTransition to SEARCHING\n   251‚Üí    ‚Üì\n   252‚ÜíGenerate inspection points (behind obstacles + corners)\n   253‚Üí    ‚Üì\n   254‚ÜíMove to first inspection point\n   255‚Üí    ‚Üì\n   256‚ÜíWait and look around (1.5s)\n   257‚Üí    ‚Üì\n   258‚ÜíMove to next inspection point (repeat until all checked)\n   259‚Üí    ‚Üì\n   260‚ÜíSearch complete OR timeout (15s)\n   261‚Üí    ‚Üì\n   262‚ÜíReturn to IDLE (patrol/guard)\n   263‚Üí\n   264‚ÜíAt any point during search:\n   265‚Üí- If player spotted ‚Üí COMBAT\n   266‚Üí- If under fire ‚Üí RETREATING\n   267‚Üí```\n   268‚Üí\n   269‚Üí### Debug Visualization\n   270‚Üí\n   271‚ÜíWhen `debug_label_enabled` is true (toggle with F7 in-game):\n   272‚Üí- Orange circle: Search zone boundary\n   273‚Üí- Red X: Last known player position\n   274‚Üí- Green circles: Unchecked inspection points\n   275‚Üí- White circle: Current target inspection point\n   276‚Üí- Gray circles: Already checked inspection points\n   277‚Üí- White line: Path to current inspection point\n   278‚Üí"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "565853e7-bb86-4a35-ac47-874aea9ecd63",
  "tool_use_result": {
    "filePath": "/tmp/gh-issue-solver-1768704499561/docs/case-studies/issue-103/README.md",
    "oldString": "## Success Criteria\n\n1. Enemy remembers where player was last seen\n2. Enemy moves to that location after losing sight\n3. Enemy checks nearby hiding spots methodically\n4. Enemy returns to patrol/guard after zone is cleared\n5. All existing functionality preserved (shooting, cover, etc.)",
    "newString": "## Success Criteria\n\n1. Enemy remembers where player was last seen\n2. Enemy moves to that location after losing sight\n3. Enemy checks nearby hiding spots methodically\n4. Enemy returns to patrol/guard after zone is cleared\n5. All existing functionality preserved (shooting, cover, etc.)\n\n---\n\n## Implementation Summary\n\n### Files Modified\n\n1. **`scripts/objects/enemy.gd`**\n   - Added `SEARCHING` state to `AIState` enum\n   - Added search zone variables (`_last_known_player_position`, `_search_zone_active`, etc.)\n   - Added inspection point variables and constants\n   - Updated `_initialize_goap_state()` with search-related world state\n   - Updated `_update_goap_state()` to track search status\n   - Updated `_process_ai_state()` to handle SEARCHING state\n   - Updated `_check_player_visibility()` to track last known position\n   - Changed COMBAT->PURSUING transition to COMBAT->SEARCHING\n   - Added `_transition_to_searching()` function\n   - Added `_clear_search_zone()` function\n   - Added `_generate_inspection_points()` function\n   - Added `_process_searching_state()` function\n   - Updated `_get_state_name()` to include SEARCHING\n   - Updated `_update_debug_label()` for search state info\n   - Updated `_draw()` for search zone visualization\n\n2. **`scripts/ai/enemy_actions.gd`**\n   - Added `SearchAreaAction` class\n   - Added `InspectHidingSpotAction` class\n   - Updated `create_all_actions()` to include new actions\n\n### New Constants Added\n\n```gdscript\nconst SEARCH_ZONE_RADIUS: float = 200.0\nconst SEARCH_MAX_DURATION: float = 15.0\nconst INSPECTION_WAIT_DURATION: float = 1.5\nconst INSPECTION_POINT_CHECK_COUNT: int = 24\nconst INSPECTION_CHECK_DISTANCE: float = 250.0\n```\n\n### Behavior Flow\n\n```\nPlayer Visible (COMBAT)\n    ‚Üì Player escapes view\nStore last_known_player_position\n    ‚Üì\nTransition to SEARCHING\n    ‚Üì\nGenerate inspection points (behind obstacles + corners)\n    ‚Üì\nMove to first inspection point\n    ‚Üì\nWait and look around (1.5s)\n    ‚Üì\nMove to next inspection point (repeat until all checked)\n    ‚Üì\nSearch complete OR timeout (15s)\n    ‚Üì\nReturn to IDLE (patrol/guard)\n\nAt any point during search:\n- If player spotted ‚Üí COMBAT\n- If under fire ‚Üí RETREATING\n```\n\n### Debug Visualization\n\nWhen `debug_label_enabled` is true (toggle with F7 in-game):\n- Orange circle: Search zone boundary\n- Red X: Last known player position\n- Green circles: Unchecked inspection points\n- White circle: Current target inspection point\n- Gray circles: Already checked inspection points\n- White line: Path to current inspection point",
    "originalFile": "# Case Study: Issue #103 - Improve Enemy Movement System\n\n## Issue Summary\n\n**Original Request (Russian):**\n> –ü–æ—Å–ª–µ –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è –∏–≥—Ä–æ–∫–∞ –∏–∑ –ø–æ–ª—è –∑—Ä–µ–Ω–∏—è –≤—Ä–∞–≥–∞ –æ–Ω –¥–æ–ª–∂–µ–Ω —Å—á–∏—Ç–∞—Ç—å –Ω–µ–±–æ–ª—å—à—É—é –Ω–µ–≤–∏–¥–∏–º—É—é –∑–æ–Ω—É, –≤ –∫–æ—Ç–æ—Ä–æ–π —Å–∫—Ä—ã–ª—Å—è –∏–≥—Ä–æ–∫ - –∑–æ–Ω–æ–π –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞. –≤—Ä–∞–≥ –¥–æ–ª–∂–µ–Ω —Å—Ç—Ä–æ–∏—Ç—å –ø–æ–ª–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç –¥–æ —ç—Ç–æ–π –∑–æ–Ω—ã –∏ –∑–∞—Ç–µ–º –æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å –µ—ë.\n> –∑–∞ –≤—Å–µ–º–∏ —É–∫—Ä—ã—Ç–∏—è–º–∏ –∏ –≤ —É–≥–ª–∞—Ö –∫–æ–º–Ω–∞—Ç –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–≤–∏–¥–∏–º—ã–µ —Ç–æ—á–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤—Ä–∞–≥ –¥–æ–ª–∂–µ–Ω –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–µ–∂–¥–µ, —á–µ–º –¥–≤–∏–≥–∞—Ç—å—Å—è –¥–∞–ª—å—à–µ, –µ—Å–ª–∏ —ç—Ç–∏ —Ç–æ—á–∫–∏ –≤ –∑–æ–Ω–µ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞. –∫–æ–≥–¥–∞ –≤—Å–µ —Ç–æ—á–∫–∏ —É –∑–æ–Ω–µ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞ –ø—Ä–æ–≤–µ—Ä–µ–Ω—ã - –∑–æ–Ω–∞ —Å—á–∏—Ç–∞–µ—Ç—Å—è –∑–æ–Ω–æ–π –±–µ–∑ –∏–≥—Ä–æ–∫–∞.\n> –ø—Ä–∏ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–∏ —Å –∏–≥—Ä–æ–∫–æ–º –∑–æ–Ω—ã –æ–±–Ω—É–ª—è—é—Ç—Å—è.\n\n**Translation:**\n> After the player disappears from the enemy's field of view, the enemy should consider a small invisible zone where the player hid as a \"potential player zone\". The enemy should build a full route to this zone and then inspect it.\n> Behind all covers and in room corners there should be invisible inspection points that the enemy must check before moving further, if these points are in the potential player zone. When all points in the potential player zone are checked - the zone is considered a \"no player zone\".\n> Upon encountering the player, the zones reset.\n\n## Timeline of Events\n\n### Current Codebase State (Pre-Issue)\n\nThe existing AI system in `scripts/objects/enemy.gd` has several states:\n- `IDLE` - Patrol or guard behavior\n- `COMBAT` - Actively engaging player\n- `SEEKING_COVER` - Moving to cover position\n- `IN_COVER` - Taking cover from player fire\n- `FLANKING` - Attempting to flank the player\n- `SUPPRESSED` - Under fire, staying in cover\n- `RETREATING` - Retreating to cover while possibly shooting\n- `PURSUING` - Moving cover-to-cover toward player\n- `ASSAULT` - Coordinated multi-enemy rush\n\n### Problem Identification\n\nWhen the player escapes from the enemy's line of sight:\n\n1. **Current Behavior (Line 803-809 in enemy.gd):**\n   ```gdscript\n   # If can't see player, pursue them (move cover-to-cover toward player)\n   if not _can_see_player:\n       _log_debug(\"Lost sight of player in COMBAT, transitioning to PURSUING\")\n       _transition_to_pursuing()\n   ```\n\n2. **PURSUING State Behavior:**\n   - Moves cover-to-cover toward player's **current position**\n   - Does NOT remember where the player was last seen\n   - Does NOT search the area methodically\n   - Simply tries to find a path to the player\n\n3. **Missing Features:**\n   - No \"last known position\" memory\n   - No \"potential player zone\" concept\n   - No inspection point system\n   - No methodical search pattern\n\n## Root Cause Analysis\n\n### Architecture Gap\n\nThe GOAP system (`scripts/ai/goap_planner.gd` and `scripts/ai/goap_action.gd`) provides the planning framework, but the `enemy_actions.gd` lacks:\n\n1. **SearchZoneAction** - Action to investigate a last-known-position area\n2. **InspectPointAction** - Action to check specific hiding spots\n3. **World State Variables** for tracking:\n   - `last_known_player_position`\n   - `search_zone_active`\n   - `inspection_points_remaining`\n\n### Behavioral Gap\n\nThe state machine transitions directly from `COMBAT` ‚Üí `PURSUING` when line of sight is lost, without:\n1. Recording where the player was last seen\n2. Defining a search zone around that position\n3. Identifying nearby hiding spots to check\n\n## Proposed Solution\n\n### 1. Add New AI State: SEARCHING\n\nA new state between PURSUING and IDLE that implements:\n- Move to last known player position\n- Define a circular \"potential player zone\" around it\n- Identify inspection points (corners, behind covers) within the zone\n- Visit and \"inspect\" each point (brief pause + looking around)\n- Mark zone as cleared when all points checked\n\n### 2. Add Inspection Point System\n\nCreate invisible \"InspectionPoint\" markers that can be:\n- Automatically generated from level geometry (wall corners)\n- Manually placed by level designers (behind covers)\n- Detected via raycast from wall collision points\n\n### 3. Extend GOAP Actions\n\nAdd new actions to `enemy_actions.gd`:\n- `SearchAreaAction` - Move to and investigate last-known-position\n- `InspectHidingSpotAction` - Check a specific inspection point\n- `ClearSearchZoneAction` - Mark zone as cleared\n\n### 4. State Flow\n\n```\nPlayer Visible ‚Üí COMBAT ‚Üí Player Escapes ‚Üí SEARCHING (new) ‚Üí Zone Cleared ‚Üí IDLE/PATROL\n                                            ‚Üì\n                                      Player Found ‚Üí COMBAT\n```\n\n## Implementation Details\n\n### New Variables for Enemy\n\n```gdscript\n## Last known position where player was seen\nvar _last_known_player_position: Vector2 = Vector2.ZERO\n\n## Whether a search zone is active\nvar _search_zone_active: bool = false\n\n## Radius of the potential player zone\nvar _search_zone_radius: float = 200.0\n\n## Inspection points within the search zone\nvar _inspection_points: Array[Vector2] = []\n\n## Index of current inspection point being checked\nvar _current_inspection_index: int = 0\n```\n\n### New GOAP World State\n\n```gdscript\n\"has_search_zone\": false,\n\"search_zone_cleared\": false,\n\"inspection_points_remaining\": 0\n```\n\n## Research References\n\n### Industry Best Practices\n\n1. **F.E.A.R. (2005)** - Pioneered GOAP for enemy AI\n   - Uses ~70 goals and ~120 actions\n   - Maintains \"last known position\" for search behavior\n   - Source: [Building the AI of F.E.A.R. with Goal Oriented Action Planning](https://www.gamedeveloper.com/design/building-the-ai-of-f-e-a-r-with-goal-oriented-action-planning)\n\n2. **Splinter Cell: Blacklist** - Dynamic search patterns\n   - Guards don't drop alert after searching\n   - Modified patrol routes after alerts\n   - Source: [What's the right AI for a stealth game?](https://www.neogaf.com/threads/whats-the-right-ai-for-a-stealth-game.1011199/)\n\n3. **Third Eye Crime** - Occupancy maps\n   - Uses probability-based knowledge representation\n   - More realistic pursuit and search behavior\n   - Source: [Dynamic Guard Patrol in Stealth Games](https://ojs.aaai.org/index.php/AIIDE/article/download/7425/7308/10903)\n\n### Common Patterns\n\n1. **Last Known Position (LKP)**\n   - Store position where player was last seen\n   - Move to LKP before searching\n   - Define search area around LKP\n\n2. **Investigation Points**\n   - Pre-defined or dynamically generated\n   - Located at corners, behind objects\n   - Priority-ordered by proximity to LKP\n\n3. **Alert Decay**\n   - Gradual return to patrol after search\n   - Modified patrol patterns post-alert\n   - Memory of previous encounters\n\n## Files to Modify\n\n1. `scripts/objects/enemy.gd` - Add SEARCHING state and related logic\n2. `scripts/ai/enemy_actions.gd` - Add new GOAP actions\n3. `scripts/ai/goap_action.gd` - No changes needed (base class sufficient)\n4. `scripts/ai/goap_planner.gd` - No changes needed (planner sufficient)\n5. Level scenes - Optionally add InspectionPoint nodes\n\n## Testing Strategy\n\n1. **Unit Tests**\n   - Test inspection point generation from geometry\n   - Test search zone activation/deactivation\n   - Test transition from COMBAT ‚Üí SEARCHING\n\n2. **Integration Tests**\n   - Verify enemy moves to last known position\n   - Verify inspection points are checked\n   - Verify zone is cleared after full search\n\n3. **Manual Testing**\n   - Break line of sight with enemy\n   - Observe enemy search behavior\n   - Verify zone is cleared or player found\n\n## Success Criteria\n\n1. Enemy remembers where player was last seen\n2. Enemy moves to that location after losing sight\n3. Enemy checks nearby hiding spots methodically\n4. Enemy returns to patrol/guard after zone is cleared\n5. All existing functionality preserved (shooting, cover, etc.)\n",
    "structuredPatch": [
      {
        "oldStart": 201,
        "oldLines": 3,
        "newStart": 201,
        "newLines": 77,
        "lines": [
          " 3. Enemy checks nearby hiding spots methodically",
          " 4. Enemy returns to patrol/guard after zone is cleared",
          " 5. All existing functionality preserved (shooting, cover, etc.)",
          "+",
          "+---",
          "+",
          "+## Implementation Summary",
          "+",
          "+### Files Modified",
          "+",
          "+1. **`scripts/objects/enemy.gd`**",
          "+   - Added `SEARCHING` state to `AIState` enum",
          "+   - Added search zone variables (`_last_known_player_position`, `_search_zone_active`, etc.)",
          "+   - Added inspection point variables and constants",
          "+   - Updated `_initialize_goap_state()` with search-related world state",
          "+   - Updated `_update_goap_state()` to track search status",
          "+   - Updated `_process_ai_state()` to handle SEARCHING state",
          "+   - Updated `_check_player_visibility()` to track last known position",
          "+   - Changed COMBAT->PURSUING transition to COMBAT->SEARCHING",
          "+   - Added `_transition_to_searching()` function",
          "+   - Added `_clear_search_zone()` function",
          "+   - Added `_generate_inspection_points()` function",
          "+   - Added `_process_searching_state()` function",
          "+   - Updated `_get_state_name()` to include SEARCHING",
          "+   - Updated `_update_debug_label()` for search state info",
          "+   - Updated `_draw()` for search zone visualization",
          "+",
          "+2. **`scripts/ai/enemy_actions.gd`**",
          "+   - Added `SearchAreaAction` class",
          "+   - Added `InspectHidingSpotAction` class",
          "+   - Updated `create_all_actions()` to include new actions",
          "+",
          "+### New Constants Added",
          "+",
          "+```gdscript",
          "+const SEARCH_ZONE_RADIUS: float = 200.0",
          "+const SEARCH_MAX_DURATION: float = 15.0",
          "+const INSPECTION_WAIT_DURATION: float = 1.5",
          "+const INSPECTION_POINT_CHECK_COUNT: int = 24",
          "+const INSPECTION_CHECK_DISTANCE: float = 250.0",
          "+```",
          "+",
          "+### Behavior Flow",
          "+",
          "+```",
          "+Player Visible (COMBAT)",
          "+    ‚Üì Player escapes view",
          "+Store last_known_player_position",
          "+    ‚Üì",
          "+Transition to SEARCHING",
          "+    ‚Üì",
          "+Generate inspection points (behind obstacles + corners)",
          "+    ‚Üì",
          "+Move to first inspection point",
          "+    ‚Üì",
          "+Wait and look around (1.5s)",
          "+    ‚Üì",
          "+Move to next inspection point (repeat until all checked)",
          "+    ‚Üì",
          "+Search complete OR timeout (15s)",
          "+    ‚Üì",
          "+Return to IDLE (patrol/guard)",
          "+",
          "+At any point during search:",
          "+- If player spotted ‚Üí COMBAT",
          "+- If under fire ‚Üí RETREATING",
          "+```",
          "+",
          "+### Debug Visualization",
          "+",
          "+When `debug_label_enabled` is true (toggle with F7 in-game):",
          "+- Orange circle: Search zone boundary",
          "+- Red X: Last known player position",
          "+- Green circles: Unchecked inspection points",
          "+- White circle: Current target inspection point",
          "+- Gray circles: Already checked inspection points",
          "+- White line: Path to current inspection point"
        ]
      }
    ],
    "userModified": false,
    "replaceAll": false
  }
}
[2026-01-18T02:55:08.105Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01VpEdpV56Bf5pAszJohjPQR",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me commit the changes and update the PR. Let me first check the git status:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 2032,
      "cache_read_input_tokens": 109381,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 2032,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "94c9d33b-4690-4531-8bab-2309f39e96df"
}
[2026-01-18T02:55:13.466Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01VpEdpV56Bf5pAszJohjPQR",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01WbDfCdFCXqPCBgujXGx2ro",
        "name": "TodoWrite",
        "input": {
          "todos": [
            {
              "content": "Read and analyze issue #103 requirements",
              "status": "completed",
              "activeForm": "Reading issue requirements"
            },
            {
              "content": "Explore existing AI/GOAP system architecture",
              "status": "completed",
              "activeForm": "Exploring AI/GOAP system architecture"
            },
            {
              "content": "Create case study directory structure",
              "status": "completed",
              "activeForm": "Creating case study directory structure"
            },
            {
              "content": "Research GOAP and AI search patterns online",
              "status": "completed",
              "activeForm": "Researching GOAP and AI search patterns"
            },
            {
              "content": "Document timeline and sequence of events",
              "status": "completed",
              "activeForm": "Documenting timeline and events"
            },
            {
              "content": "Identify root causes and propose solutions",
              "status": "completed",
              "activeForm": "Identifying root causes and solutions"
            },
            {
              "content": "Implement enemy search behavior with last-known-position",
              "status": "completed",
              "activeForm": "Implementing enemy search behavior"
            },
            {
              "content": "Add inspection points system for corners and hiding spots",
              "status": "completed",
              "activeForm": "Adding inspection points system"
            },
            {
              "content": "Update GOAP actions for search behavior",
              "status": "completed",
              "activeForm": "Updating GOAP actions"
            },
            {
              "content": "Test and verify implementation",
              "status": "in_progress",
              "activeForm": "Testing implementation"
            },
            {
              "content": "Update PR description and finalize",
              "status": "pending",
              "activeForm": "Updating PR and finalizing"
            }
          ]
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 2032,
      "cache_read_input_tokens": 109381,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 2032,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "3f396e42-f317-458e-8470-30f7abfb2e0c"
}
[2026-01-18T02:55:13.847Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01VpEdpV56Bf5pAszJohjPQR",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01RczMRdueMaeTivCdZz9MPK",
        "name": "Bash",
        "input": {
          "command": "git status",
          "description": "Check git status"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 2032,
      "cache_read_input_tokens": 109381,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 2032,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "cac881cb-3bba-423d-a1c0-80baf40448a3"
}
[2026-01-18T02:55:13.898Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01WbDfCdFCXqPCBgujXGx2ro",
        "type": "tool_result",
        "content": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "903e7c30-9e81-4c57-aa18-3f88899809e1",
  "tool_use_result": {
    "oldTodos": [
      {
        "content": "Read and analyze issue #103 requirements",
        "status": "completed",
        "activeForm": "Reading issue requirements"
      },
      {
        "content": "Explore existing AI/GOAP system architecture",
        "status": "completed",
        "activeForm": "Exploring AI/GOAP system architecture"
      },
      {
        "content": "Create case study directory structure",
        "status": "completed",
        "activeForm": "Creating case study directory structure"
      },
      {
        "content": "Research GOAP and AI search patterns online",
        "status": "completed",
        "activeForm": "Researching GOAP and AI search patterns"
      },
      {
        "content": "Document timeline and sequence of events",
        "status": "completed",
        "activeForm": "Documenting timeline and events"
      },
      {
        "content": "Identify root causes and propose solutions",
        "status": "completed",
        "activeForm": "Identifying root causes and solutions"
      },
      {
        "content": "Implement enemy search behavior with last-known-position",
        "status": "completed",
        "activeForm": "Implementing enemy search behavior"
      },
      {
        "content": "Add inspection points system for corners and hiding spots",
        "status": "completed",
        "activeForm": "Adding inspection points system"
      },
      {
        "content": "Update GOAP actions for search behavior",
        "status": "in_progress",
        "activeForm": "Updating GOAP actions"
      },
      {
        "content": "Test and verify implementation",
        "status": "pending",
        "activeForm": "Testing implementation"
      },
      {
        "content": "Update PR description and finalize",
        "status": "pending",
        "activeForm": "Updating PR and finalizing"
      }
    ],
    "newTodos": [
      {
        "content": "Read and analyze issue #103 requirements",
        "status": "completed",
        "activeForm": "Reading issue requirements"
      },
      {
        "content": "Explore existing AI/GOAP system architecture",
        "status": "completed",
        "activeForm": "Exploring AI/GOAP system architecture"
      },
      {
        "content": "Create case study directory structure",
        "status": "completed",
        "activeForm": "Creating case study directory structure"
      },
      {
        "content": "Research GOAP and AI search patterns online",
        "status": "completed",
        "activeForm": "Researching GOAP and AI search patterns"
      },
      {
        "content": "Document timeline and sequence of events",
        "status": "completed",
        "activeForm": "Documenting timeline and events"
      },
      {
        "content": "Identify root causes and propose solutions",
        "status": "completed",
        "activeForm": "Identifying root causes and solutions"
      },
      {
        "content": "Implement enemy search behavior with last-known-position",
        "status": "completed",
        "activeForm": "Implementing enemy search behavior"
      },
      {
        "content": "Add inspection points system for corners and hiding spots",
        "status": "completed",
        "activeForm": "Adding inspection points system"
      },
      {
        "content": "Update GOAP actions for search behavior",
        "status": "completed",
        "activeForm": "Updating GOAP actions"
      },
      {
        "content": "Test and verify implementation",
        "status": "in_progress",
        "activeForm": "Testing implementation"
      },
      {
        "content": "Update PR description and finalize",
        "status": "pending",
        "activeForm": "Updating PR and finalizing"
      }
    ]
  }
}
[2026-01-18T02:55:13.994Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01RczMRdueMaeTivCdZz9MPK",
        "type": "tool_result",
        "content": "On branch issue-103-a8cadd220202\nYour branch is up to date with 'origin/issue-103-a8cadd220202'.\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   scripts/ai/enemy_actions.gd\n\tmodified:   scripts/objects/enemy.gd\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tdocs/case-studies/issue-103/\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "d7e473f0-897d-4fce-9a61-33527788e3c7",
  "tool_use_result": {
    "stdout": "On branch issue-103-a8cadd220202\nYour branch is up to date with 'origin/issue-103-a8cadd220202'.\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   scripts/ai/enemy_actions.gd\n\tmodified:   scripts/objects/enemy.gd\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tdocs/case-studies/issue-103/\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-01-18T02:55:16.934Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_015wVkQMoki24DkiRxHTZgXc",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01MfH6iNieMYWimZxd5CqLkt",
        "name": "Bash",
        "input": {
          "command": "git diff scripts/objects/enemy.gd | head -100",
          "description": "View changes to enemy.gd"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 729,
      "cache_read_input_tokens": 111413,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 729,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 25,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "0172ca45-f665-44a4-9415-dadb05945038"
}
[2026-01-18T02:55:17.847Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_015wVkQMoki24DkiRxHTZgXc",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_014Cs2BuBTvegT5CRbhEqChn",
        "name": "Bash",
        "input": {
          "command": "git log --oneline -5",
          "description": "View recent commit history"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 729,
      "cache_read_input_tokens": 111413,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 729,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 25,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "e1aacc94-5ebd-484c-9636-c60cfe652b3a"
}
[2026-01-18T02:55:17.996Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_014Cs2BuBTvegT5CRbhEqChn",
        "type": "tool_result",
        "content": "5904996 Initial commit with task details\n9e7af85 Merge pull request #102 from konard/issue-100-12a42823264e\nef2d70e Revert \"Initial commit with task details\"\n2bf79e4 Add CI test logs to case study documentation\n8a85c07 Fix floating-point precision issue in duration boundary test",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "74a16a9d-830c-4f4c-ab86-cbca131da81b",
  "tool_use_result": {
    "stdout": "5904996 Initial commit with task details\n9e7af85 Merge pull request #102 from konard/issue-100-12a42823264e\nef2d70e Revert \"Initial commit with task details\"\n2bf79e4 Add CI test logs to case study documentation\n8a85c07 Fix floating-point precision issue in duration boundary test",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-01-18T02:55:18.014Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01MfH6iNieMYWimZxd5CqLkt",
        "type": "tool_result",
        "content": "diff --git a/scripts/objects/enemy.gd b/scripts/objects/enemy.gd\nindex e37cfff..3c8ce18 100644\n--- a/scripts/objects/enemy.gd\n+++ b/scripts/objects/enemy.gd\n@@ -21,7 +21,8 @@ enum AIState {\n \tSUPPRESSED, ## Under fire, staying in cover\n \tRETREATING, ## Retreating to cover while possibly shooting\n \tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n-\tASSAULT     ## Coordinated multi-enemy assault (rush player after 5s wait)\n+\tASSAULT,    ## Coordinated multi-enemy assault (rush player after 5s wait)\n+\tSEARCHING   ## Searching for player at last-known-position zone\n }\n \n ## Retreat behavior modes based on damage taken.\n@@ -399,6 +400,43 @@ const CLOSE_COMBAT_DISTANCE: float = 400.0\n ## GOAP world state for goal-oriented planning.\n var _goap_world_state: Dictionary = {}\n \n+## --- Search/Investigation State (for when player escapes from view) ---\n+## Last known position where the player was seen before escaping view.\n+var _last_known_player_position: Vector2 = Vector2.ZERO\n+\n+## Whether a search zone is currently active.\n+var _search_zone_active: bool = false\n+\n+## Radius of the potential player zone (area where player might be hiding).\n+const SEARCH_ZONE_RADIUS: float = 200.0\n+\n+## Timer for search timeout - enemy gives up searching after this time.\n+var _search_timer: float = 0.0\n+\n+## Maximum time to spend searching before giving up (seconds).\n+const SEARCH_MAX_DURATION: float = 15.0\n+\n+## Inspection points within the search zone (hiding spots behind covers and corners).\n+var _inspection_points: Array[Vector2] = []\n+\n+## Index of current inspection point being checked.\n+var _current_inspection_index: int = 0\n+\n+## Timer for waiting at each inspection point (looking around).\n+var _inspection_wait_timer: float = 0.0\n+\n+## Duration to wait at each inspection point (seconds).\n+const INSPECTION_WAIT_DURATION: float = 1.5\n+\n+## Whether currently waiting at an inspection point.\n+var _inspecting_point: bool = false\n+\n+## Number of raycasts for detecting inspection points (corners/hiding spots).\n+const INSPECTION_POINT_CHECK_COUNT: int = 24\n+\n+## Distance to check for inspection points from search zone center.\n+const INSPECTION_CHECK_DISTANCE: float = 250.0\n+\n ## Detection delay timer - tracks time since entering combat.\n var _detection_timer: float = 0.0\n \n@@ -537,7 +575,11 @@ func _initialize_goap_state() -> void:\n \t\t\"is_assaulting\": false,\n \t\t\"can_hit_from_cover\": false,\n \t\t\"player_close\": false,\n-\t\t\"enemies_in_combat\": 0\n+\t\t\"enemies_in_combat\": 0,\n+\t\t\"has_search_zone\": false,\n+\t\t\"search_zone_cleared\": false,\n+\t\t\"inspection_points_remaining\": 0,\n+\t\t\"is_searching\": false\n \t}\n \n \n@@ -629,6 +671,10 @@ func _update_goap_state() -> void:\n \t_goap_world_state[\"player_close\"] = _is_player_close()\n \t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n \t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()\n+\t_goap_world_state[\"has_search_zone\"] = _search_zone_active\n+\t_goap_world_state[\"search_zone_cleared\"] = not _search_zone_active and _last_known_player_position != Vector2.ZERO\n+\t_goap_world_state[\"inspection_points_remaining\"] = _inspection_points.size() - _current_inspection_index\n+\t_goap_world_state[\"is_searching\"] = _current_state == AIState.SEARCHING\n \n \n ## Update suppression state.\n@@ -752,6 +798,8 @@ func _process_ai_state(delta: float) -> void:\n \t\t\t_process_pursuing_state(delta)\n \t\tAIState.ASSAULT:\n \t\t\t_process_assault_state(delta)\n+\t\tAIState.SEARCHING:\n+\t\t\t_process_searching_state(delta)\n \n \tif previous_state != _current_state:\n \t\tstate_changed.emit(_current_state)\n@@ -800,13 +848,13 @@ func _process_combat_state(delta: float) -> void:\n \t\t_transition_to_assault()\n \t\treturn\n \n-\t# If can't see player, pursue them (move cover-to-cover toward player)\n+\t# If can't see player, transition to SEARCHING to investigate last-known position\n \tif not _can_see_player:\n \t\t_combat_exposed = false\n \t\t_combat_approaching = false",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "8fb3a671-8807-44e3-be13-9d453e19bbe6",
  "tool_use_result": {
    "stdout": "diff --git a/scripts/objects/enemy.gd b/scripts/objects/enemy.gd\nindex e37cfff..3c8ce18 100644\n--- a/scripts/objects/enemy.gd\n+++ b/scripts/objects/enemy.gd\n@@ -21,7 +21,8 @@ enum AIState {\n \tSUPPRESSED, ## Under fire, staying in cover\n \tRETREATING, ## Retreating to cover while possibly shooting\n \tPURSUING,   ## Moving cover-to-cover toward player (when far and can't hit)\n-\tASSAULT     ## Coordinated multi-enemy assault (rush player after 5s wait)\n+\tASSAULT,    ## Coordinated multi-enemy assault (rush player after 5s wait)\n+\tSEARCHING   ## Searching for player at last-known-position zone\n }\n \n ## Retreat behavior modes based on damage taken.\n@@ -399,6 +400,43 @@ const CLOSE_COMBAT_DISTANCE: float = 400.0\n ## GOAP world state for goal-oriented planning.\n var _goap_world_state: Dictionary = {}\n \n+## --- Search/Investigation State (for when player escapes from view) ---\n+## Last known position where the player was seen before escaping view.\n+var _last_known_player_position: Vector2 = Vector2.ZERO\n+\n+## Whether a search zone is currently active.\n+var _search_zone_active: bool = false\n+\n+## Radius of the potential player zone (area where player might be hiding).\n+const SEARCH_ZONE_RADIUS: float = 200.0\n+\n+## Timer for search timeout - enemy gives up searching after this time.\n+var _search_timer: float = 0.0\n+\n+## Maximum time to spend searching before giving up (seconds).\n+const SEARCH_MAX_DURATION: float = 15.0\n+\n+## Inspection points within the search zone (hiding spots behind covers and corners).\n+var _inspection_points: Array[Vector2] = []\n+\n+## Index of current inspection point being checked.\n+var _current_inspection_index: int = 0\n+\n+## Timer for waiting at each inspection point (looking around).\n+var _inspection_wait_timer: float = 0.0\n+\n+## Duration to wait at each inspection point (seconds).\n+const INSPECTION_WAIT_DURATION: float = 1.5\n+\n+## Whether currently waiting at an inspection point.\n+var _inspecting_point: bool = false\n+\n+## Number of raycasts for detecting inspection points (corners/hiding spots).\n+const INSPECTION_POINT_CHECK_COUNT: int = 24\n+\n+## Distance to check for inspection points from search zone center.\n+const INSPECTION_CHECK_DISTANCE: float = 250.0\n+\n ## Detection delay timer - tracks time since entering combat.\n var _detection_timer: float = 0.0\n \n@@ -537,7 +575,11 @@ func _initialize_goap_state() -> void:\n \t\t\"is_assaulting\": false,\n \t\t\"can_hit_from_cover\": false,\n \t\t\"player_close\": false,\n-\t\t\"enemies_in_combat\": 0\n+\t\t\"enemies_in_combat\": 0,\n+\t\t\"has_search_zone\": false,\n+\t\t\"search_zone_cleared\": false,\n+\t\t\"inspection_points_remaining\": 0,\n+\t\t\"is_searching\": false\n \t}\n \n \n@@ -629,6 +671,10 @@ func _update_goap_state() -> void:\n \t_goap_world_state[\"player_close\"] = _is_player_close()\n \t_goap_world_state[\"can_hit_from_cover\"] = _can_hit_player_from_current_position()\n \t_goap_world_state[\"enemies_in_combat\"] = _count_enemies_in_combat()\n+\t_goap_world_state[\"has_search_zone\"] = _search_zone_active\n+\t_goap_world_state[\"search_zone_cleared\"] = not _search_zone_active and _last_known_player_position != Vector2.ZERO\n+\t_goap_world_state[\"inspection_points_remaining\"] = _inspection_points.size() - _current_inspection_index\n+\t_goap_world_state[\"is_searching\"] = _current_state == AIState.SEARCHING\n \n \n ## Update suppression state.\n@@ -752,6 +798,8 @@ func _process_ai_state(delta: float) -> void:\n \t\t\t_process_pursuing_state(delta)\n \t\tAIState.ASSAULT:\n \t\t\t_process_assault_state(delta)\n+\t\tAIState.SEARCHING:\n+\t\t\t_process_searching_state(delta)\n \n \tif previous_state != _current_state:\n \t\tstate_changed.emit(_current_state)\n@@ -800,13 +848,13 @@ func _process_combat_state(delta: float) -> void:\n \t\t_transition_to_assault()\n \t\treturn\n \n-\t# If can't see player, pursue them (move cover-to-cover toward player)\n+\t# If can't see player, transition to SEARCHING to investigate last-known position\n \tif not _can_see_player:\n \t\t_combat_exposed = false\n \t\t_combat_approaching = false",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-01-18T02:55:20.790Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01Hjx5pC67tjZtygPdjEakkU",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Let me commit the implementation:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 116,
      "cache_creation_input_tokens": 1512,
      "cache_read_input_tokens": 112142,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1512,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 3,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "c644b648-e2f4-4749-abf0-48fe3fe66ee9"
}
[2026-01-18T02:55:26.321Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01Hjx5pC67tjZtygPdjEakkU",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01A4D9PMYzuW5bckeuDfcU4u",
        "name": "Bash",
        "input": {
          "command": "git add scripts/objects/enemy.gd scripts/ai/enemy_actions.gd docs/case-studies/issue-103/ && git commit -m \"$(cat <<'EOF'\nAdd SEARCHING state for enemy AI search behavior\n\nImplements issue #103 - enemy now searches for player at last-known position\nwhen player escapes from view.\n\nNew features:\n- SEARCHING AI state for methodical area investigation\n- Last-known-position tracking during player visibility\n- Automatic inspection point generation from obstacles/corners\n- Search zone visualization (debug mode, toggle with F7)\n- New GOAP actions: SearchAreaAction, InspectHidingSpotAction\n\nBehavior flow:\n- When player escapes view during combat, enemy transitions to SEARCHING\n- Enemy moves to inspection points within search zone (200 pixel radius)\n- Enemy waits 1.5s at each point, looking around\n- After all points checked or 15s timeout, returns to IDLE\n- If player spotted during search, immediately returns to COMBAT\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n)\"",
          "description": "Commit the implementation"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 116,
      "cache_creation_input_tokens": 1512,
      "cache_read_input_tokens": 112142,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 1512,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 3,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "afac59a6-61eb-413a-bbef-9fb5a97412a9"
}
[2026-01-18T02:55:27.415Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01A4D9PMYzuW5bckeuDfcU4u",
        "type": "tool_result",
        "content": "[issue-103-a8cadd220202 8e924fb] Add SEARCHING state for enemy AI search behavior\n 3 files changed, 607 insertions(+), 5 deletions(-)\n create mode 100644 docs/case-studies/issue-103/README.md",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "d1779dec-970f-46c2-bd63-cbb0d8297125",
  "tool_use_result": {
    "stdout": "[issue-103-a8cadd220202 8e924fb] Add SEARCHING state for enemy AI search behavior\n 3 files changed, 607 insertions(+), 5 deletions(-)\n create mode 100644 docs/case-studies/issue-103/README.md",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-01-18T02:55:30.354Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01LxJadZ9gxnjXU8Qsudeheq",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_012nCdH8XmN4fUD3CZTjNJqc",
        "name": "Bash",
        "input": {
          "command": "git push origin issue-103-a8cadd220202",
          "description": "Push changes to remote"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 534,
      "cache_read_input_tokens": 113654,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 534,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 25,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "0cf8be4d-a1c0-4893-ba4b-92c793534372"
}
[2026-01-18T02:55:31.923Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_012nCdH8XmN4fUD3CZTjNJqc",
        "type": "tool_result",
        "content": "To https://github.com/konard/Jhon-Crow-godot-topdown-MVP.git\n   5904996..8e924fb  issue-103-a8cadd220202 -> issue-103-a8cadd220202",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "0a142aa2-1664-4a2c-9639-86898488eafa",
  "tool_use_result": {
    "stdout": "To https://github.com/konard/Jhon-Crow-godot-topdown-MVP.git\n   5904996..8e924fb  issue-103-a8cadd220202 -> issue-103-a8cadd220202",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-01-18T02:55:34.476Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01VSnrNCLBHWDcxfMMyh7Jsb",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me update the PR description and check the existing PR:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 155,
      "cache_read_input_tokens": 114188,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 155,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 4,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "2dfc7381-231a-4120-8fcc-aef3b0597c70"
}
[2026-01-18T02:55:35.588Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01VSnrNCLBHWDcxfMMyh7Jsb",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01Cjz3EYvFgkKvDmovuqZVB9",
        "name": "Bash",
        "input": {
          "command": "gh pr view 104 --repo Jhon-Crow/godot-topdown-MVP --json title,body,state",
          "description": "Get existing PR details"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 155,
      "cache_read_input_tokens": 114188,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 155,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 4,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "16159263-a1e4-4918-8a54-b7fe00b43104"
}
[2026-01-18T02:55:37.061Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01Cjz3EYvFgkKvDmovuqZVB9",
        "type": "tool_result",
        "content": "{\"body\":\"## ü§ñ AI-Powered Solution Draft\\n\\nThis pull request is being automatically generated to solve issue Jhon-Crow/godot-topdown-MVP#103.\\n\\n### üìã Issue Reference\\nFixes Jhon-Crow/godot-topdown-MVP#103\\n\\n### üöß Status\\n**Work in Progress** - The AI assistant is currently analyzing and implementing the solution draft.\\n\\n### üìù Implementation Details\\n_Details will be added as the solution draft is developed..._\\n\\n---\\n*This PR was created automatically by the AI issue solver*\",\"state\":\"OPEN\",\"title\":\"[WIP] —É–ª—É—á—à–∏—Ç—å —Å–∏—Å—Ç–µ–º—É –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è\"}",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "752e1960-44a8-4c2d-bf9f-95153e813ac2",
  "tool_use_result": {
    "stdout": "{\"body\":\"## ü§ñ AI-Powered Solution Draft\\n\\nThis pull request is being automatically generated to solve issue Jhon-Crow/godot-topdown-MVP#103.\\n\\n### üìã Issue Reference\\nFixes Jhon-Crow/godot-topdown-MVP#103\\n\\n### üöß Status\\n**Work in Progress** - The AI assistant is currently analyzing and implementing the solution draft.\\n\\n### üìù Implementation Details\\n_Details will be added as the solution draft is developed..._\\n\\n---\\n*This PR was created automatically by the AI issue solver*\",\"state\":\"OPEN\",\"title\":\"[WIP] —É–ª—É—á—à–∏—Ç—å —Å–∏—Å—Ç–µ–º—É –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è\"}",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-01-18T02:55:48.458Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01NgmBSQySQpzs7PM5rpM6HS",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01CoGf8t5aWXiEWbEBEdqR8L",
        "name": "Bash",
        "input": {
          "command": "gh pr edit 104 --repo Jhon-Crow/godot-topdown-MVP --title \"Add enemy search behavior when player escapes from view\" --body \"$(cat <<'EOF'\n## Summary\n- Implements enemy search behavior when player escapes from view\n- Enemy now tracks and investigates last-known player position\n- Adds inspection point system for checking hiding spots\n\n## Implementation Details\n\n### New AI State: SEARCHING\nWhen the player breaks line of sight during combat, the enemy no longer simply pursues. Instead:\n\n1. **Last Known Position Tracking**: Enemy remembers where the player was last seen\n2. **Search Zone Activation**: A 200-pixel radius search zone is created around that position\n3. **Inspection Points**: Enemy automatically generates points to check:\n   - Behind nearby obstacles (covers, walls)\n   - At corners of the search zone\n4. **Methodical Search**: Enemy visits each inspection point, waiting 1.5s at each to \"look around\"\n5. **Search Completion**: After all points checked or 15s timeout, enemy returns to IDLE\n\n### Files Changed\n- `scripts/objects/enemy.gd` - Added SEARCHING state and all related logic\n- `scripts/ai/enemy_actions.gd` - Added SearchAreaAction and InspectHidingSpotAction\n- `docs/case-studies/issue-103/README.md` - Case study documentation\n\n### Debug Visualization\nPress F7 in-game to toggle debug mode:\n- Orange circle: Search zone boundary\n- Red X: Last known player position\n- Green circles: Unchecked inspection points\n- White circle/line: Current target point\n- Gray circles: Already checked points\n\n## Test plan\n- [ ] Engage enemy in combat, then break line of sight\n- [ ] Verify enemy transitions to SEARCHING state\n- [ ] Verify enemy checks inspection points methodically\n- [ ] Verify enemy returns to combat if player spotted during search\n- [ ] Verify enemy returns to IDLE after search completes\n\n## References\nBased on research of industry-standard AI patterns:\n- F.E.A.R. GOAP implementation\n- Splinter Cell: Blacklist search behaviors\n- Third Eye Crime occupancy maps\n\nFixes #103\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\nEOF\n)\"",
          "description": "Update PR title and description"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 300,
      "cache_read_input_tokens": 114343,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 300,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 24,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "8793c48c-198d-4b70-8a84-8d4225412d6a"
}
[2026-01-18T02:55:51.052Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01CoGf8t5aWXiEWbEBEdqR8L",
        "type": "tool_result",
        "content": "https://github.com/Jhon-Crow/godot-topdown-MVP/pull/104",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "a7bd4ea1-54e4-45fb-ae1a-88bdebfc0a71",
  "tool_use_result": {
    "stdout": "https://github.com/Jhon-Crow/godot-topdown-MVP/pull/104",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-01-18T02:55:53.638Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01EiXLepjhVQXZ18uW8CgMZ4",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me check if there are any CI runs and update my todo list:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 643,
      "cache_read_input_tokens": 114643,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 643,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 5,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "0b3c4702-28f0-46fe-8e6f-f2e09d211545"
}
[2026-01-18T02:55:55.021Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01EiXLepjhVQXZ18uW8CgMZ4",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01UnsccTjMfo88Si5U39FtvY",
        "name": "Bash",
        "input": {
          "command": "gh run list --repo konard/Jhon-Crow-godot-topdown-MVP --branch issue-103-a8cadd220202 --limit 3 --json databaseId,conclusion,createdAt,headSha",
          "description": "List recent CI runs"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 643,
      "cache_read_input_tokens": 114643,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 643,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 5,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "0a156dee-6a67-442d-962a-e5baae0a3953"
}
[2026-01-18T02:55:56.571Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01UnsccTjMfo88Si5U39FtvY",
        "type": "tool_result",
        "content": "[{\"conclusion\":\"\",\"createdAt\":\"2026-01-18T02:55:33Z\",\"databaseId\":21104925786,\"headSha\":\"8e924fb86503da3d955b8c84e8e4655c80cd8a9f\"},{\"conclusion\":\"\",\"createdAt\":\"2026-01-18T02:55:33Z\",\"databaseId\":21104925789,\"headSha\":\"8e924fb86503da3d955b8c84e8e4655c80cd8a9f\"},{\"conclusion\":\"success\",\"createdAt\":\"2026-01-18T02:48:27Z\",\"databaseId\":21104811233,\"headSha\":\"5904996dc6b9bfe4c3ea8494cd184758b82d361d\"}]",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "2b1e248a-bf9f-497a-8d3d-ba189acd7e46",
  "tool_use_result": {
    "stdout": "[{\"conclusion\":\"\",\"createdAt\":\"2026-01-18T02:55:33Z\",\"databaseId\":21104925786,\"headSha\":\"8e924fb86503da3d955b8c84e8e4655c80cd8a9f\"},{\"conclusion\":\"\",\"createdAt\":\"2026-01-18T02:55:33Z\",\"databaseId\":21104925789,\"headSha\":\"8e924fb86503da3d955b8c84e8e4655c80cd8a9f\"},{\"conclusion\":\"success\",\"createdAt\":\"2026-01-18T02:48:27Z\",\"databaseId\":21104811233,\"headSha\":\"5904996dc6b9bfe4c3ea8494cd184758b82d361d\"}]",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-01-18T02:55:59.195Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01S6HyT4ec2k9fhiHdHfbztf",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "The CI is running. Let me wait for it to complete:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 607,
      "cache_read_input_tokens": 115286,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 607,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "a8860628-d482-432d-9af9-fcfef2046280"
}
[2026-01-18T02:56:00.114Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01S6HyT4ec2k9fhiHdHfbztf",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01MJ3xr9peGqS6WYJfH4R7dj",
        "name": "Bash",
        "input": {
          "command": "sleep 30 && gh run list --repo konard/Jhon-Crow-godot-topdown-MVP --branch issue-103-a8cadd220202 --limit 3 --json databaseId,conclusion,createdAt,headSha",
          "description": "Wait and check CI status"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 607,
      "cache_read_input_tokens": 115286,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 607,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "1a5671b5-8bea-4d93-ae52-24862151a50e"
}
[2026-01-18T02:56:32.135Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01MJ3xr9peGqS6WYJfH4R7dj",
        "type": "tool_result",
        "content": "[{\"conclusion\":\"\",\"createdAt\":\"2026-01-18T02:55:33Z\",\"databaseId\":21104925786,\"headSha\":\"8e924fb86503da3d955b8c84e8e4655c80cd8a9f\"},{\"conclusion\":\"success\",\"createdAt\":\"2026-01-18T02:55:33Z\",\"databaseId\":21104925789,\"headSha\":\"8e924fb86503da3d955b8c84e8e4655c80cd8a9f\"},{\"conclusion\":\"success\",\"createdAt\":\"2026-01-18T02:48:27Z\",\"databaseId\":21104811233,\"headSha\":\"5904996dc6b9bfe4c3ea8494cd184758b82d361d\"}]",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "46805d99-7ded-4421-a7da-067635485b52",
  "tool_use_result": {
    "stdout": "[{\"conclusion\":\"\",\"createdAt\":\"2026-01-18T02:55:33Z\",\"databaseId\":21104925786,\"headSha\":\"8e924fb86503da3d955b8c84e8e4655c80cd8a9f\"},{\"conclusion\":\"success\",\"createdAt\":\"2026-01-18T02:55:33Z\",\"databaseId\":21104925789,\"headSha\":\"8e924fb86503da3d955b8c84e8e4655c80cd8a9f\"},{\"conclusion\":\"success\",\"createdAt\":\"2026-01-18T02:48:27Z\",\"databaseId\":21104811233,\"headSha\":\"5904996dc6b9bfe4c3ea8494cd184758b82d361d\"}]",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-01-18T02:56:35.227Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01E8xvEkqCgZm1T4rQnyAY4y",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "One is passing, one is still running. Let me wait a bit more:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 344,
      "cache_read_input_tokens": 115893,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 344,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "dff23d8b-f77f-45cf-9b11-b87f46bf858e"
}
[2026-01-18T02:56:36.058Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01E8xvEkqCgZm1T4rQnyAY4y",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01NDUeTyBfeu5he8reHgrdEd",
        "name": "Bash",
        "input": {
          "command": "sleep 30 && gh run list --repo konard/Jhon-Crow-godot-topdown-MVP --branch issue-103-a8cadd220202 --limit 3 --json databaseId,conclusion,createdAt,headSha",
          "description": "Wait and check CI status again"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 344,
      "cache_read_input_tokens": 115893,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 344,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "378f3ae7-72db-4595-8a58-752c0494b4fe"
}
[2026-01-18T02:57:06.904Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01NDUeTyBfeu5he8reHgrdEd",
        "type": "tool_result",
        "content": "[{\"conclusion\":\"success\",\"createdAt\":\"2026-01-18T02:55:33Z\",\"databaseId\":21104925789,\"headSha\":\"8e924fb86503da3d955b8c84e8e4655c80cd8a9f\"},{\"conclusion\":\"success\",\"createdAt\":\"2026-01-18T02:55:33Z\",\"databaseId\":21104925786,\"headSha\":\"8e924fb86503da3d955b8c84e8e4655c80cd8a9f\"},{\"conclusion\":\"success\",\"createdAt\":\"2026-01-18T02:48:27Z\",\"databaseId\":21104811233,\"headSha\":\"5904996dc6b9bfe4c3ea8494cd184758b82d361d\"}]",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "b5c23f3e-7ea0-4c03-ad20-4049bc08cc28",
  "tool_use_result": {
    "stdout": "[{\"conclusion\":\"success\",\"createdAt\":\"2026-01-18T02:55:33Z\",\"databaseId\":21104925789,\"headSha\":\"8e924fb86503da3d955b8c84e8e4655c80cd8a9f\"},{\"conclusion\":\"success\",\"createdAt\":\"2026-01-18T02:55:33Z\",\"databaseId\":21104925786,\"headSha\":\"8e924fb86503da3d955b8c84e8e4655c80cd8a9f\"},{\"conclusion\":\"success\",\"createdAt\":\"2026-01-18T02:48:27Z\",\"databaseId\":21104811233,\"headSha\":\"5904996dc6b9bfe4c3ea8494cd184758b82d361d\"}]",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-01-18T02:57:09.913Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_017jSqa6vi2XqmmmF9S6SUYW",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "All CI checks are passing. Let me mark the PR as ready for review:"
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 349,
      "cache_read_input_tokens": 116237,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 349,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "7c65ff08-0ce8-486a-8d38-a7f34d38c34c"
}
[2026-01-18T02:57:10.575Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_017jSqa6vi2XqmmmF9S6SUYW",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01CxerZNYuUG56cYQMVpc3B7",
        "name": "Bash",
        "input": {
          "command": "gh pr ready 104 --repo Jhon-Crow/godot-topdown-MVP",
          "description": "Mark PR as ready for review"
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 349,
      "cache_read_input_tokens": 116237,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 349,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "a1d4a615-8f91-408a-9e0e-c27e9c2cbf75"
}
[2026-01-18T02:57:12.635Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01CxerZNYuUG56cYQMVpc3B7",
        "type": "tool_result",
        "content": "‚úì Pull request Jhon-Crow/godot-topdown-MVP#104 is marked as \"ready for review\"",
        "is_error": false
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "4774d2ac-f9a5-443c-9a66-4324f67b86e1",
  "tool_use_result": {
    "stdout": "‚úì Pull request Jhon-Crow/godot-topdown-MVP#104 is marked as \"ready for review\"",
    "stderr": "",
    "interrupted": false,
    "isImage": false
  }
}
[2026-01-18T02:57:18.372Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01M1rSqEucCj5RoZ2omC8Qyj",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01R5yd1WqxZqXkxSRMYS3rr3",
        "name": "TodoWrite",
        "input": {
          "todos": [
            {
              "content": "Read and analyze issue #103 requirements",
              "status": "completed",
              "activeForm": "Reading issue requirements"
            },
            {
              "content": "Explore existing AI/GOAP system architecture",
              "status": "completed",
              "activeForm": "Exploring AI/GOAP system architecture"
            },
            {
              "content": "Create case study directory structure",
              "status": "completed",
              "activeForm": "Creating case study directory structure"
            },
            {
              "content": "Research GOAP and AI search patterns online",
              "status": "completed",
              "activeForm": "Researching GOAP and AI search patterns"
            },
            {
              "content": "Document timeline and sequence of events",
              "status": "completed",
              "activeForm": "Documenting timeline and events"
            },
            {
              "content": "Identify root causes and propose solutions",
              "status": "completed",
              "activeForm": "Identifying root causes and solutions"
            },
            {
              "content": "Implement enemy search behavior with last-known-position",
              "status": "completed",
              "activeForm": "Implementing enemy search behavior"
            },
            {
              "content": "Add inspection points system for corners and hiding spots",
              "status": "completed",
              "activeForm": "Adding inspection points system"
            },
            {
              "content": "Update GOAP actions for search behavior",
              "status": "completed",
              "activeForm": "Updating GOAP actions"
            },
            {
              "content": "Test and verify implementation",
              "status": "completed",
              "activeForm": "Testing implementation"
            },
            {
              "content": "Update PR description and finalize",
              "status": "completed",
              "activeForm": "Updating PR and finalizing"
            }
          ]
        }
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 154,
      "cache_read_input_tokens": 116586,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 154,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 25,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "0d0d147e-5e6c-40a1-8922-7173f62fc1c0"
}
[2026-01-18T02:57:18.398Z] [INFO] {
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01R5yd1WqxZqXkxSRMYS3rr3",
        "type": "tool_result",
        "content": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"
      }
    ]
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "b8fe8693-3553-40f0-9cd2-f4c829ae52c3",
  "tool_use_result": {
    "oldTodos": [
      {
        "content": "Read and analyze issue #103 requirements",
        "status": "completed",
        "activeForm": "Reading issue requirements"
      },
      {
        "content": "Explore existing AI/GOAP system architecture",
        "status": "completed",
        "activeForm": "Exploring AI/GOAP system architecture"
      },
      {
        "content": "Create case study directory structure",
        "status": "completed",
        "activeForm": "Creating case study directory structure"
      },
      {
        "content": "Research GOAP and AI search patterns online",
        "status": "completed",
        "activeForm": "Researching GOAP and AI search patterns"
      },
      {
        "content": "Document timeline and sequence of events",
        "status": "completed",
        "activeForm": "Documenting timeline and events"
      },
      {
        "content": "Identify root causes and propose solutions",
        "status": "completed",
        "activeForm": "Identifying root causes and solutions"
      },
      {
        "content": "Implement enemy search behavior with last-known-position",
        "status": "completed",
        "activeForm": "Implementing enemy search behavior"
      },
      {
        "content": "Add inspection points system for corners and hiding spots",
        "status": "completed",
        "activeForm": "Adding inspection points system"
      },
      {
        "content": "Update GOAP actions for search behavior",
        "status": "completed",
        "activeForm": "Updating GOAP actions"
      },
      {
        "content": "Test and verify implementation",
        "status": "in_progress",
        "activeForm": "Testing implementation"
      },
      {
        "content": "Update PR description and finalize",
        "status": "pending",
        "activeForm": "Updating PR and finalizing"
      }
    ],
    "newTodos": [
      {
        "content": "Read and analyze issue #103 requirements",
        "status": "completed",
        "activeForm": "Reading issue requirements"
      },
      {
        "content": "Explore existing AI/GOAP system architecture",
        "status": "completed",
        "activeForm": "Exploring AI/GOAP system architecture"
      },
      {
        "content": "Create case study directory structure",
        "status": "completed",
        "activeForm": "Creating case study directory structure"
      },
      {
        "content": "Research GOAP and AI search patterns online",
        "status": "completed",
        "activeForm": "Researching GOAP and AI search patterns"
      },
      {
        "content": "Document timeline and sequence of events",
        "status": "completed",
        "activeForm": "Documenting timeline and events"
      },
      {
        "content": "Identify root causes and propose solutions",
        "status": "completed",
        "activeForm": "Identifying root causes and solutions"
      },
      {
        "content": "Implement enemy search behavior with last-known-position",
        "status": "completed",
        "activeForm": "Implementing enemy search behavior"
      },
      {
        "content": "Add inspection points system for corners and hiding spots",
        "status": "completed",
        "activeForm": "Adding inspection points system"
      },
      {
        "content": "Update GOAP actions for search behavior",
        "status": "completed",
        "activeForm": "Updating GOAP actions"
      },
      {
        "content": "Test and verify implementation",
        "status": "completed",
        "activeForm": "Testing implementation"
      },
      {
        "content": "Update PR description and finalize",
        "status": "completed",
        "activeForm": "Updating PR and finalizing"
      }
    ]
  }
}
[2026-01-18T02:57:27.150Z] [INFO] {
  "type": "assistant",
  "message": {
    "model": "claude-opus-4-5-20251101",
    "id": "msg_01TzjXigdea6NLSY5snD8w5m",
    "type": "message",
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "I have successfully implemented the requested feature. Here's a summary of what was accomplished:\n\n## Summary\n\nI've implemented the enemy search behavior system for issue #103. The solution addresses the original request (in Russian) which asked for:\n\n1. **Last-known-position tracking**: When the player disappears from the enemy's view, the enemy now remembers where they were last seen\n\n2. **Potential player zone**: A search zone (200 pixel radius) is created around the last-known position\n\n3. **Inspection points**: The system automatically generates inspection points:\n   - Behind obstacles within the search zone (using raycasts)\n   - At corners of the search zone\n   - These represent potential hiding spots\n\n4. **Methodical search behavior**: The enemy:\n   - Moves to each inspection point in order\n   - Waits 1.5 seconds at each point while \"looking around\" (rotating)\n   - Marks points as checked\n   - Continues until all points are verified or a 15-second timeout occurs\n\n5. **Zone clearing**: When all inspection points are checked, the zone is considered cleared and the enemy returns to IDLE (patrol/guard behavior)\n\n6. **Combat re-engagement**: If the player is spotted during the search, the enemy immediately transitions back to COMBAT\n\n### Technical Implementation\n\n- Added new `SEARCHING` AI state to the enemy state machine\n- Added `SearchAreaAction` and `InspectHidingSpotAction` GOAP actions\n- Extended the GOAP world state with search-related variables\n- Added debug visualization (orange search zone circle, inspection point markers)\n- Created comprehensive case study documentation\n\n### Pull Request\n\nThe PR is ready for review at: https://github.com/Jhon-Crow/godot-topdown-MVP/pull/104\n\nAll CI checks are passing."
      }
    ],
    "stop_reason": null,
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1,
      "cache_creation_input_tokens": 437,
      "cache_read_input_tokens": 116740,
      "cache_creation": {
        "ephemeral_5m_input_tokens": 437,
        "ephemeral_1h_input_tokens": 0
      },
      "output_tokens": 1,
      "service_tier": "standard"
    },
    "context_management": null
  },
  "parent_tool_use_id": null,
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "uuid": "7d617082-5ff2-48d7-a510-8678f55b440f"
}
[2026-01-18T02:57:27.182Z] [INFO] {
  "type": "result",
  "subtype": "success",
  "is_error": false,
  "duration_ms": 522958,
  "duration_api_ms": 471741,
  "num_turns": 68,
  "result": "I have successfully implemented the requested feature. Here's a summary of what was accomplished:\n\n## Summary\n\nI've implemented the enemy search behavior system for issue #103. The solution addresses the original request (in Russian) which asked for:\n\n1. **Last-known-position tracking**: When the player disappears from the enemy's view, the enemy now remembers where they were last seen\n\n2. **Potential player zone**: A search zone (200 pixel radius) is created around the last-known position\n\n3. **Inspection points**: The system automatically generates inspection points:\n   - Behind obstacles within the search zone (using raycasts)\n   - At corners of the search zone\n   - These represent potential hiding spots\n\n4. **Methodical search behavior**: The enemy:\n   - Moves to each inspection point in order\n   - Waits 1.5 seconds at each point while \"looking around\" (rotating)\n   - Marks points as checked\n   - Continues until all points are verified or a 15-second timeout occurs\n\n5. **Zone clearing**: When all inspection points are checked, the zone is considered cleared and the enemy returns to IDLE (patrol/guard behavior)\n\n6. **Combat re-engagement**: If the player is spotted during the search, the enemy immediately transitions back to COMBAT\n\n### Technical Implementation\n\n- Added new `SEARCHING` AI state to the enemy state machine\n- Added `SearchAreaAction` and `InspectHidingSpotAction` GOAP actions\n- Extended the GOAP world state with search-related variables\n- Added debug visualization (orange search zone circle, inspection point markers)\n- Created comprehensive case study documentation\n\n### Pull Request\n\nThe PR is ready for review at: https://github.com/Jhon-Crow/godot-topdown-MVP/pull/104\n\nAll CI checks are passing.",
  "session_id": "797fbac8-f5e6-4339-8fd2-77453410db49",
  "total_cost_usd": 4.495610750000001,
  "usage": {
    "input_tokens": 1180,
    "cache_creation_input_tokens": 192408,
    "cache_read_input_tokens": 4726741,
    "output_tokens": 22098,
    "server_tool_use": {
      "web_search_requests": 0,
      "web_fetch_requests": 0
    },
    "service_tier": "standard",
    "cache_creation": {
      "ephemeral_1h_input_tokens": 0,
      "ephemeral_5m_input_tokens": 192408
    }
  },
  "modelUsage": {
    "claude-haiku-4-5-20251001": {
      "inputTokens": 69574,
      "outputTokens": 1035,
      "cacheReadInputTokens": 0,
      "cacheCreationInputTokens": 0,
      "webSearchRequests": 0,
      "costUSD": 0.07474900000000001,
      "contextWindow": 200000,
      "maxOutputTokens": 64000
    },
    "claude-opus-4-5-20251101": {
      "inputTokens": 5722,
      "outputTokens": 24040,
      "cacheReadInputTokens": 4726741,
      "cacheCreationInputTokens": 225261,
      "webSearchRequests": 2,
      "costUSD": 4.420861750000001,
      "contextWindow": 200000,
      "maxOutputTokens": 64000
    }
  },
  "permission_denials": [],
  "uuid": "a652c699-369c-4e53-a6ea-02197dac9839"
}
[2026-01-18T02:57:27.183Z] [INFO] üí∞ Anthropic official cost captured: $4.495611
[2026-01-18T02:57:27.633Z] [INFO] 

‚úÖ Claude command completed
[2026-01-18T02:57:27.634Z] [INFO] üìä Total messages: 0, Tool uses: 0
[2026-01-18T02:57:27.766Z] [INFO] 
üí∞ Token Usage Summary:
[2026-01-18T02:57:27.767Z] [INFO] 
   üìä Claude Opus 4.5:
[2026-01-18T02:57:27.767Z] [INFO]       Model ID: claude-opus-4-5-20251101
[2026-01-18T02:57:27.767Z] [INFO]       Provider: Anthropic
[2026-01-18T02:57:27.768Z] [INFO]       Context window: 200 000 tokens
[2026-01-18T02:57:27.768Z] [INFO]       Max output: 64 000 tokens
[2026-01-18T02:57:27.768Z] [INFO]       Input modalities: text, image, pdf
[2026-01-18T02:57:27.768Z] [INFO]       Output modalities: text
[2026-01-18T02:57:27.768Z] [INFO]       Knowledge cutoff: 2025-03-31
[2026-01-18T02:57:27.768Z] [INFO]       Released: 2025-11-01
[2026-01-18T02:57:27.768Z] [INFO]       Capabilities: Attachments, Reasoning, Temperature, Tool calls
[2026-01-18T02:57:27.769Z] [INFO]       Open weights: No
[2026-01-18T02:57:27.769Z] [INFO] 
[2026-01-18T02:57:27.769Z] [INFO]       Usage:
[2026-01-18T02:57:27.769Z] [INFO]         Input tokens: 3 966
[2026-01-18T02:57:27.770Z] [INFO]         Cache creation tokens: 412 891
[2026-01-18T02:57:27.770Z] [INFO]         Cache read tokens: 8 390 189
[2026-01-18T02:57:27.770Z] [INFO]         Output tokens: 665
[2026-01-18T02:57:27.770Z] [INFO] 
[2026-01-18T02:57:27.770Z] [INFO]       Cost Calculation (USD):
[2026-01-18T02:57:27.770Z] [INFO]         Input: 3 966 tokens √ó $5/M = $0.019830
[2026-01-18T02:57:27.770Z] [INFO]         Cache write: 412 891 tokens √ó $6.25/M = $2.580569
[2026-01-18T02:57:27.770Z] [INFO]         Cache read: 8 390 189 tokens √ó $0.5/M = $4.195094
[2026-01-18T02:57:27.770Z] [INFO]         Output: 665 tokens √ó $25/M = $0.016625
[2026-01-18T02:57:27.770Z] [INFO]         ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
[2026-01-18T02:57:27.771Z] [INFO]         Total: $6.812118
[2026-01-18T02:57:27.771Z] [INFO] 
      üìä Token Budget Statistics:
[2026-01-18T02:57:27.771Z] [INFO]         Context window:
[2026-01-18T02:57:27.772Z] [INFO]           Used: 8 807 046 tokens
[2026-01-18T02:57:27.772Z] [INFO]           Limit: 200 000 tokens
[2026-01-18T02:57:27.773Z] [INFO]           Ratio: 44.0352 (4403.52%)
[2026-01-18T02:57:27.773Z] [INFO]         Output tokens:
[2026-01-18T02:57:27.773Z] [INFO]           Used: 665 tokens
[2026-01-18T02:57:27.773Z] [INFO]           Limit: 64 000 tokens
[2026-01-18T02:57:27.773Z] [INFO]           Ratio: 0.0104 (1.04%)
[2026-01-18T02:57:27.773Z] [INFO]         Total session tokens: 417 522
[2026-01-18T02:57:27.773Z] [INFO] 
   üí∞ Cost estimation:
[2026-01-18T02:57:27.774Z] [INFO]       Public pricing estimate: $6.812118 USD
[2026-01-18T02:57:27.774Z] [INFO]       Calculated by Anthropic: $4.495611 USD
[2026-01-18T02:57:27.774Z] [INFO]       Difference:              $-2.316507 (-34.01%)
[2026-01-18T02:57:27.774Z] [INFO]       Total tokens: 417 522
[2026-01-18T02:57:27.774Z] [INFO] 
üí° To continue this session in Claude Code interactive mode:

[2026-01-18T02:57:27.775Z] [INFO]    (cd "/tmp/gh-issue-solver-1768704499561" && claude --resume 797fbac8-f5e6-4339-8fd2-77453410db49 --model opus)

[2026-01-18T02:57:27.775Z] [INFO] 
üîç Checking for uncommitted changes...
[2026-01-18T02:57:27.812Z] [INFO] ‚úÖ No uncommitted changes found
[2026-01-18T02:57:27.848Z] [INFO] üîÑ Cleanup:                  Reverting CLAUDE.md commit
[2026-01-18T02:57:27.848Z] [INFO]    Using saved commit hash: 5904996...
[2026-01-18T02:57:27.848Z] [INFO]    Checking if CLAUDE.md was modified since initial commit...
[2026-01-18T02:57:27.886Z] [INFO]    No modifications detected, using standard git revert...
[2026-01-18T02:57:27.926Z] [INFO] üì¶ Committed:                CLAUDE.md revert
[2026-01-18T02:57:28.714Z] [INFO] üì§ Pushed:                   CLAUDE.md revert to GitHub
[2026-01-18T02:57:28.715Z] [INFO] 
=== Session Summary ===
[2026-01-18T02:57:28.716Z] [INFO] ‚úÖ Session ID: 797fbac8-f5e6-4339-8fd2-77453410db49
[2026-01-18T02:57:28.716Z] [INFO] ‚úÖ Complete log file: /home/hive/797fbac8-f5e6-4339-8fd2-77453410db49.log
[2026-01-18T02:57:28.716Z] [INFO] 
[2026-01-18T02:57:28.716Z] [INFO] üí° To continue this session in Claude Code interactive mode:
[2026-01-18T02:57:28.717Z] [INFO] 
[2026-01-18T02:57:28.717Z] [INFO]    (cd "/tmp/gh-issue-solver-1768704499561" && claude --resume 797fbac8-f5e6-4339-8fd2-77453410db49 --model opus)
[2026-01-18T02:57:28.717Z] [INFO] 
[2026-01-18T02:57:28.718Z] [INFO] 
üîç Searching for created pull requests or comments...
[2026-01-18T02:57:29.122Z] [INFO] 
üîç Checking for pull requests from branch issue-103-a8cadd220202...
[2026-01-18T02:57:29.555Z] [INFO]   ‚úÖ Found pull request #104: "Add enemy search behavior when player escapes from view"
[2026-01-18T02:57:30.068Z] [INFO]   ‚úÖ PR body already contains issue reference
[2026-01-18T02:57:30.069Z] [INFO]   ‚úÖ PR is already ready for review
[2026-01-18T02:57:30.069Z] [INFO] 
üìé Uploading solution draft log to Pull Request...
[2026-01-18T02:57:30.152Z] [INFO]   üí∞ Calculated cost: $6.812118
